[
  {
    "function_name": "btrfs_update_commit_device_bytes_used",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6712-6734",
    "snippet": "void btrfs_update_commit_device_bytes_used(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_transaction *transaction)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_device *dev;\n\tint i;\n\n\tif (list_empty(&transaction->pending_chunks))\n\t\treturn;\n\n\t/* In order to kick the device replace finish process */\n\tlock_chunks(root);\n\tlist_for_each_entry(em, &transaction->pending_chunks, list) {\n\t\tmap = (struct map_lookup *)em->bdev;\n\n\t\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t\tdev = map->stripes[i].dev;\n\t\t\tdev->commit_bytes_used = dev->bytes_used;\n\t\t}\n\t}\n\tunlock_chunks(root);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_chunks",
          "args": [
            "root"
          ],
          "line": 6733
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "536-539",
          "snippet": "static inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "em",
            "&transaction->pending_chunks",
            "list"
          ],
          "line": 6725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&transaction->pending_chunks"
          ],
          "line": 6720
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_update_commit_device_bytes_used(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_transaction *transaction)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_device *dev;\n\tint i;\n\n\tif (list_empty(&transaction->pending_chunks))\n\t\treturn;\n\n\t/* In order to kick the device replace finish process */\n\tlock_chunks(root);\n\tlist_for_each_entry(em, &transaction->pending_chunks, list) {\n\t\tmap = (struct map_lookup *)em->bdev;\n\n\t\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t\tdev = map->stripes[i].dev;\n\t\t\tdev->commit_bytes_used = dev->bytes_used;\n\t\t}\n\t}\n\tunlock_chunks(root);\n}"
  },
  {
    "function_name": "btrfs_update_commit_device_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6692-6709",
    "snippet": "void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *curr, *next;\n\n\tif (list_empty(&fs_devices->resized_devices))\n\t\treturn;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlock_chunks(fs_info->dev_root);\n\tlist_for_each_entry_safe(curr, next, &fs_devices->resized_devices,\n\t\t\t\t resized_list) {\n\t\tlist_del_init(&curr->resized_list);\n\t\tcurr->commit_total_bytes = curr->disk_total_bytes;\n\t}\n\tunlock_chunks(fs_info->dev_root);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 6708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_chunks",
          "args": [
            "fs_info->dev_root"
          ],
          "line": 6707
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "536-539",
          "snippet": "static inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&curr->resized_list"
          ],
          "line": 6704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "curr",
            "next",
            "&fs_devices->resized_devices",
            "resized_list"
          ],
          "line": 6702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 6700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fs_devices->resized_devices"
          ],
          "line": 6697
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *curr, *next;\n\n\tif (list_empty(&fs_devices->resized_devices))\n\t\treturn;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlock_chunks(fs_info->dev_root);\n\tlist_for_each_entry_safe(curr, next, &fs_devices->resized_devices,\n\t\t\t\t resized_list) {\n\t\tlist_del_init(&curr->resized_list);\n\t\tcurr->commit_total_bytes = curr->disk_total_bytes;\n\t}\n\tunlock_chunks(fs_info->dev_root);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n}"
  },
  {
    "function_name": "btrfs_scratch_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6670-6686",
    "snippet": "int btrfs_scratch_superblock(struct btrfs_device *device)\n{\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\n\tbh = btrfs_read_dev_super(device->bdev);\n\tif (!bh)\n\t\treturn -EINVAL;\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\n\tmemset(&disk_super->magic, 0, sizeof(disk_super->magic));\n\tset_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 6683
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 6682
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 6681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&disk_super->magic",
            "0",
            "sizeof(disk_super->magic)"
          ],
          "line": 6680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_dev_super",
          "args": [
            "device->bdev"
          ],
          "line": 6675
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_dev_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3084-3124",
          "snippet": "struct buffer_head *btrfs_read_dev_super(struct block_device *bdev)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *latest = NULL;\n\tstruct btrfs_super_block *super;\n\tint i;\n\tu64 transid = 0;\n\tu64 bytenr;\n\n\t/* we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tfor (i = 0; i < 1; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t\t\t\ti_size_read(bdev->bd_inode))\n\t\t\tbreak;\n\t\tbh = __bread(bdev, bytenr / 4096,\n\t\t\t\t\tBTRFS_SUPER_INFO_SIZE);\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tsuper = (struct btrfs_super_block *)bh->b_data;\n\t\tif (btrfs_super_bytenr(super) != bytenr ||\n\t\t    btrfs_super_magic(super) != BTRFS_MAGIC) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!latest || btrfs_super_generation(super) > transid) {\n\t\t\tbrelse(latest);\n\t\t\tlatest = bh;\n\t\t\ttransid = btrfs_super_generation(super);\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n\treturn latest;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstruct buffer_head *btrfs_read_dev_super(struct block_device *bdev)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *latest = NULL;\n\tstruct btrfs_super_block *super;\n\tint i;\n\tu64 transid = 0;\n\tu64 bytenr;\n\n\t/* we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tfor (i = 0; i < 1; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t\t\t\ti_size_read(bdev->bd_inode))\n\t\t\tbreak;\n\t\tbh = __bread(bdev, bytenr / 4096,\n\t\t\t\t\tBTRFS_SUPER_INFO_SIZE);\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tsuper = (struct btrfs_super_block *)bh->b_data;\n\t\tif (btrfs_super_bytenr(super) != bytenr ||\n\t\t    btrfs_super_magic(super) != BTRFS_MAGIC) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!latest || btrfs_super_generation(super) > transid) {\n\t\t\tbrelse(latest);\n\t\t\tlatest = bh;\n\t\t\ttransid = btrfs_super_generation(super);\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n\treturn latest;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_scratch_superblock(struct btrfs_device *device)\n{\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\n\tbh = btrfs_read_dev_super(device->bdev);\n\tif (!bh)\n\t\treturn -EINVAL;\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\n\tmemset(&disk_super->magic, 0, sizeof(disk_super->magic));\n\tset_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_get_dev_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6635-6668",
    "snippet": "int btrfs_get_dev_stats(struct btrfs_root *root,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tint i;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(root->fs_info, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tif (!dev) {\n\t\tbtrfs_warn(root->fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(root->fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_dev_stat_read",
          "args": [
            "dev",
            "i"
          ],
          "line": 6663
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_read_and_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "502-511",
          "snippet": "static inline int btrfs_dev_stat_read_and_reset(struct btrfs_device *dev,\n\t\t\t\t\t\tint index)\n{\n\tint ret;\n\n\tret = atomic_xchg(dev->dev_stat_values + index, 0);\n\tsmp_mb__before_atomic();\n\tatomic_inc(&dev->dev_stats_ccnt);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline int btrfs_dev_stat_read_and_reset(struct btrfs_device *dev,\n\t\t\t\t\t\tint index)\n{\n\tint ret;\n\n\tret = atomic_xchg(dev->dev_stat_values + index, 0);\n\tsmp_mb__before_atomic();\n\tatomic_inc(&dev->dev_stats_ccnt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_reset",
          "args": [
            "dev",
            "i"
          ],
          "line": 6658
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "521-525",
          "snippet": "static inline void btrfs_dev_stat_reset(struct btrfs_device *dev,\n\t\t\t\t\tint index)\n{\n\tbtrfs_dev_stat_set(dev, index, 0);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void btrfs_dev_stat_reset(struct btrfs_device *dev,\n\t\t\t\t\tint index)\n{\n\tbtrfs_dev_stat_set(dev, index, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"get dev_stats failed, not yet valid\""
          ],
          "line": 6650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"get dev_stats failed, device not found\""
          ],
          "line": 6647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 6644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_device",
          "args": [
            "root->fs_info",
            "stats->devid",
            "NULL",
            "NULL"
          ],
          "line": 6643
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5918-5936",
          "snippet": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 6642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_get_dev_stats(struct btrfs_root *root,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tint i;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(root->fs_info, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tif (!dev) {\n\t\tbtrfs_warn(root->fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(root->fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_dev_stat_print_on_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6615-6633",
    "snippet": "static void btrfs_dev_stat_print_on_load(struct btrfs_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\tif (btrfs_dev_stat_read(dev, i) != 0)\n\t\t\tbreak;\n\tif (i == BTRFS_DEV_STAT_VALUES_MAX)\n\t\treturn; /* all values == 0, suppress message */\n\n\tprintk_in_rcu(KERN_INFO \"BTRFS: \"\n\t\t   \"bdev %s errs: wr %u, rd %u, flush %u, corrupt %u, gen %u\\n\",\n\t       rcu_str_deref(dev->name),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_WRITE_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_READ_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_FLUSH_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_GENERATION_ERRS));\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "KERN_INFO \"BTRFS: \"\n\t\t   \"bdev %s errs: wr %u, rd %u, flush %u, corrupt %u, gen %u\\n\"",
            "rcu_str_deref(dev->name)",
            "btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_WRITE_ERRS)",
            "btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_READ_ERRS)",
            "btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_FLUSH_ERRS)",
            "btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS)",
            "btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_GENERATION_ERRS)"
          ],
          "line": 6625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_read",
          "args": [
            "dev",
            "BTRFS_DEV_STAT_GENERATION_ERRS"
          ],
          "line": 6632
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_read_and_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "502-511",
          "snippet": "static inline int btrfs_dev_stat_read_and_reset(struct btrfs_device *dev,\n\t\t\t\t\t\tint index)\n{\n\tint ret;\n\n\tret = atomic_xchg(dev->dev_stat_values + index, 0);\n\tsmp_mb__before_atomic();\n\tatomic_inc(&dev->dev_stats_ccnt);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline int btrfs_dev_stat_read_and_reset(struct btrfs_device *dev,\n\t\t\t\t\t\tint index)\n{\n\tint ret;\n\n\tret = atomic_xchg(dev->dev_stat_values + index, 0);\n\tsmp_mb__before_atomic();\n\tatomic_inc(&dev->dev_stats_ccnt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "dev->name"
          ],
          "line": 6627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\tif (btrfs_dev_stat_read(dev, i) != 0)\n\t\t\tbreak;\n\tif (i == BTRFS_DEV_STAT_VALUES_MAX)\n\t\treturn; /* all values == 0, suppress message */\n\n\tprintk_in_rcu(KERN_INFO \"BTRFS: \"\n\t\t   \"bdev %s errs: wr %u, rd %u, flush %u, corrupt %u, gen %u\\n\",\n\t       rcu_str_deref(dev->name),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_WRITE_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_READ_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_FLUSH_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_GENERATION_ERRS));\n}"
  },
  {
    "function_name": "btrfs_dev_stat_print_on_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6601-6613",
    "snippet": "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev)\n{\n\tif (!dev->dev_stats_valid)\n\t\treturn;\n\tprintk_ratelimited_in_rcu(KERN_ERR \"BTRFS: \"\n\t\t\t   \"bdev %s errs: wr %u, rd %u, flush %u, corrupt %u, gen %u\\n\",\n\t\t\t   rcu_str_deref(dev->name),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_WRITE_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_READ_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_FLUSH_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_GENERATION_ERRS));\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited_in_rcu",
          "args": [
            "KERN_ERR \"BTRFS: \"\n\t\t\t   \"bdev %s errs: wr %u, rd %u, flush %u, corrupt %u, gen %u\\n\"",
            "rcu_str_deref(dev->name)",
            "btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_WRITE_ERRS)",
            "btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_READ_ERRS)",
            "btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_FLUSH_ERRS)",
            "btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS)",
            "btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_GENERATION_ERRS)"
          ],
          "line": 6605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_read",
          "args": [
            "dev",
            "BTRFS_DEV_STAT_GENERATION_ERRS"
          ],
          "line": 6612
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_read_and_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "502-511",
          "snippet": "static inline int btrfs_dev_stat_read_and_reset(struct btrfs_device *dev,\n\t\t\t\t\t\tint index)\n{\n\tint ret;\n\n\tret = atomic_xchg(dev->dev_stat_values + index, 0);\n\tsmp_mb__before_atomic();\n\tatomic_inc(&dev->dev_stats_ccnt);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline int btrfs_dev_stat_read_and_reset(struct btrfs_device *dev,\n\t\t\t\t\t\tint index)\n{\n\tint ret;\n\n\tret = atomic_xchg(dev->dev_stat_values + index, 0);\n\tsmp_mb__before_atomic();\n\tatomic_inc(&dev->dev_stats_ccnt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "dev->name"
          ],
          "line": 6607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev)\n{\n\tif (!dev->dev_stats_valid)\n\t\treturn;\n\tprintk_ratelimited_in_rcu(KERN_ERR \"BTRFS: \"\n\t\t\t   \"bdev %s errs: wr %u, rd %u, flush %u, corrupt %u, gen %u\\n\",\n\t\t\t   rcu_str_deref(dev->name),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_WRITE_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_READ_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_FLUSH_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_GENERATION_ERRS));\n}"
  },
  {
    "function_name": "btrfs_dev_stat_inc_and_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6595-6599",
    "snippet": "void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_dev_stat_print_on_error",
          "args": [
            "dev"
          ],
          "line": 6598
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_print_on_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6601-6613",
          "snippet": "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev)\n{\n\tif (!dev->dev_stats_valid)\n\t\treturn;\n\tprintk_ratelimited_in_rcu(KERN_ERR \"BTRFS: \"\n\t\t\t   \"bdev %s errs: wr %u, rd %u, flush %u, corrupt %u, gen %u\\n\",\n\t\t\t   rcu_str_deref(dev->name),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_WRITE_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_READ_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_FLUSH_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_GENERATION_ERRS));\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev)\n{\n\tif (!dev->dev_stats_valid)\n\t\treturn;\n\tprintk_ratelimited_in_rcu(KERN_ERR \"BTRFS: \"\n\t\t\t   \"bdev %s errs: wr %u, rd %u, flush %u, corrupt %u, gen %u\\n\",\n\t\t\t   rcu_str_deref(dev->name),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_WRITE_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_READ_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_FLUSH_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_GENERATION_ERRS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_inc",
          "args": [
            "dev",
            "index"
          ],
          "line": 6597
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_inc_and_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6595-6599",
          "snippet": "void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}"
  },
  {
    "function_name": "btrfs_run_dev_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6571-6593",
    "snippet": "int btrfs_run_dev_stats(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tint stats_cnt;\n\tint ret = 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tif (!device->dev_stats_valid || !btrfs_dev_stats_dirty(device))\n\t\t\tcontinue;\n\n\t\tstats_cnt = atomic_read(&device->dev_stats_ccnt);\n\t\tret = update_dev_stat_item(trans, dev_root, device);\n\t\tif (!ret)\n\t\t\tatomic_sub(stats_cnt, &device->dev_stats_ccnt);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 6590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_sub",
          "args": [
            "stats_cnt",
            "&device->dev_stats_ccnt"
          ],
          "line": 6588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_dev_stat_item",
          "args": [
            "trans",
            "dev_root",
            "device"
          ],
          "line": 6586
        },
        "resolved": true,
        "details": {
          "function_name": "update_dev_stat_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6505-6566",
          "snippet": "static int update_dev_stat_item(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *dev_root,\n\t\t\t\tstruct btrfs_device *device)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dev_stats_item *ptr;\n\tint ret;\n\tint i;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_STATS_KEY;\n\tkey.offset = device->devid;\n\n\tpath = btrfs_alloc_path();\n\tBUG_ON(!path);\n\tret = btrfs_search_slot(trans, dev_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: \"\n\t\t\t\"error %d while searching for dev_stats item for device %s!\\n\",\n\t\t\t      ret, rcu_str_deref(device->name));\n\t\tgoto out;\n\t}\n\n\tif (ret == 0 &&\n\t    btrfs_item_size_nr(path->nodes[0], path->slots[0]) < sizeof(*ptr)) {\n\t\t/* need to delete old one and insert a new one */\n\t\tret = btrfs_del_item(trans, dev_root, path);\n\t\tif (ret != 0) {\n\t\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\"delete too small dev_stats item for device %s failed %d!\\n\",\n\t\t\t\t      rcu_str_deref(device->name), ret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = 1;\n\t}\n\n\tif (ret == 1) {\n\t\t/* need to insert a new item */\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, dev_root, path,\n\t\t\t\t\t      &key, sizeof(*ptr));\n\t\tif (ret < 0) {\n\t\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\t  \"insert dev_stats item for device %s failed %d!\\n\",\n\t\t\t\t      rcu_str_deref(device->name), ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\teb = path->nodes[0];\n\tptr = btrfs_item_ptr(eb, path->slots[0], struct btrfs_dev_stats_item);\n\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\tbtrfs_set_dev_stats_value(eb, ptr, i,\n\t\t\t\t\t  btrfs_dev_stat_read(device, i));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int update_dev_stat_item(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *dev_root,\n\t\t\t\tstruct btrfs_device *device)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dev_stats_item *ptr;\n\tint ret;\n\tint i;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_STATS_KEY;\n\tkey.offset = device->devid;\n\n\tpath = btrfs_alloc_path();\n\tBUG_ON(!path);\n\tret = btrfs_search_slot(trans, dev_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: \"\n\t\t\t\"error %d while searching for dev_stats item for device %s!\\n\",\n\t\t\t      ret, rcu_str_deref(device->name));\n\t\tgoto out;\n\t}\n\n\tif (ret == 0 &&\n\t    btrfs_item_size_nr(path->nodes[0], path->slots[0]) < sizeof(*ptr)) {\n\t\t/* need to delete old one and insert a new one */\n\t\tret = btrfs_del_item(trans, dev_root, path);\n\t\tif (ret != 0) {\n\t\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\"delete too small dev_stats item for device %s failed %d!\\n\",\n\t\t\t\t      rcu_str_deref(device->name), ret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = 1;\n\t}\n\n\tif (ret == 1) {\n\t\t/* need to insert a new item */\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, dev_root, path,\n\t\t\t\t\t      &key, sizeof(*ptr));\n\t\tif (ret < 0) {\n\t\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\t  \"insert dev_stats item for device %s failed %d!\\n\",\n\t\t\t\t      rcu_str_deref(device->name), ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\teb = path->nodes[0];\n\tptr = btrfs_item_ptr(eb, path->slots[0], struct btrfs_dev_stats_item);\n\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\tbtrfs_set_dev_stats_value(eb, ptr, i,\n\t\t\t\t\t  btrfs_dev_stat_read(device, i));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&device->dev_stats_ccnt"
          ],
          "line": 6585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stats_dirty",
          "args": [
            "device"
          ],
          "line": 6582
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stats_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "483-486",
          "snippet": "static inline int btrfs_dev_stats_dirty(struct btrfs_device *dev)\n{\n\treturn atomic_read(&dev->dev_stats_ccnt);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline int btrfs_dev_stats_dirty(struct btrfs_device *dev)\n{\n\treturn atomic_read(&dev->dev_stats_ccnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "&fs_devices->devices",
            "dev_list"
          ],
          "line": 6581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 6580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_run_dev_stats(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tint stats_cnt;\n\tint ret = 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tif (!device->dev_stats_valid || !btrfs_dev_stats_dirty(device))\n\t\t\tcontinue;\n\n\t\tstats_cnt = atomic_read(&device->dev_stats_ccnt);\n\t\tret = update_dev_stat_item(trans, dev_root, device);\n\t\tif (!ret)\n\t\t\tatomic_sub(stats_cnt, &device->dev_stats_ccnt);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "update_dev_stat_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6505-6566",
    "snippet": "static int update_dev_stat_item(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *dev_root,\n\t\t\t\tstruct btrfs_device *device)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dev_stats_item *ptr;\n\tint ret;\n\tint i;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_STATS_KEY;\n\tkey.offset = device->devid;\n\n\tpath = btrfs_alloc_path();\n\tBUG_ON(!path);\n\tret = btrfs_search_slot(trans, dev_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: \"\n\t\t\t\"error %d while searching for dev_stats item for device %s!\\n\",\n\t\t\t      ret, rcu_str_deref(device->name));\n\t\tgoto out;\n\t}\n\n\tif (ret == 0 &&\n\t    btrfs_item_size_nr(path->nodes[0], path->slots[0]) < sizeof(*ptr)) {\n\t\t/* need to delete old one and insert a new one */\n\t\tret = btrfs_del_item(trans, dev_root, path);\n\t\tif (ret != 0) {\n\t\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\"delete too small dev_stats item for device %s failed %d!\\n\",\n\t\t\t\t      rcu_str_deref(device->name), ret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = 1;\n\t}\n\n\tif (ret == 1) {\n\t\t/* need to insert a new item */\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, dev_root, path,\n\t\t\t\t\t      &key, sizeof(*ptr));\n\t\tif (ret < 0) {\n\t\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\t  \"insert dev_stats item for device %s failed %d!\\n\",\n\t\t\t\t      rcu_str_deref(device->name), ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\teb = path->nodes[0];\n\tptr = btrfs_item_ptr(eb, path->slots[0], struct btrfs_dev_stats_item);\n\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\tbtrfs_set_dev_stats_value(eb, ptr, i,\n\t\t\t\t\t  btrfs_dev_stat_read(device, i));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 6564
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "eb"
          ],
          "line": 6561
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_stats_value",
          "args": [
            "eb",
            "ptr",
            "i",
            "btrfs_dev_stat_read(device, i)"
          ],
          "line": 6559
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_dev_stats_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3176-3184",
          "snippet": "static inline void btrfs_set_dev_stats_value(struct extent_buffer *eb,\n\t\t\t\t\t     struct btrfs_dev_stats_item *ptr,\n\t\t\t\t\t     int index, u64 val)\n{\n\twrite_extent_buffer(eb, &val,\n\t\t\t    offsetof(struct btrfs_dev_stats_item, values) +\n\t\t\t     ((unsigned long)ptr) + (index * sizeof(u64)),\n\t\t\t    sizeof(val));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_dev_stats_value(struct extent_buffer *eb,\n\t\t\t\t\t     struct btrfs_dev_stats_item *ptr,\n\t\t\t\t\t     int index, u64 val)\n{\n\twrite_extent_buffer(eb, &val,\n\t\t\t    offsetof(struct btrfs_dev_stats_item, values) +\n\t\t\t     ((unsigned long)ptr) + (index * sizeof(u64)),\n\t\t\t    sizeof(val));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_read",
          "args": [
            "device",
            "i"
          ],
          "line": 6560
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_read_and_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "502-511",
          "snippet": "static inline int btrfs_dev_stat_read_and_reset(struct btrfs_device *dev,\n\t\t\t\t\t\tint index)\n{\n\tint ret;\n\n\tret = atomic_xchg(dev->dev_stat_values + index, 0);\n\tsmp_mb__before_atomic();\n\tatomic_inc(&dev->dev_stats_ccnt);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline int btrfs_dev_stat_read_and_reset(struct btrfs_device *dev,\n\t\t\t\t\t\tint index)\n{\n\tint ret;\n\n\tret = atomic_xchg(dev->dev_stat_values + index, 0);\n\tsmp_mb__before_atomic();\n\tatomic_inc(&dev->dev_stats_ccnt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "path->slots[0]",
            "structbtrfs_dev_stats_item"
          ],
          "line": 6557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "KERN_WARNING \"BTRFS: \"\n\t\t\t\t\t  \"insert dev_stats item for device %s failed %d!\\n\"",
            "rcu_str_deref(device->name)",
            "ret"
          ],
          "line": 6549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "device->name"
          ],
          "line": 6551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "dev_root",
            "path",
            "&key",
            "sizeof(*ptr)"
          ],
          "line": 6546
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 6545
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "KERN_WARNING \"BTRFS: \"\n\t\t\t\t\"delete too small dev_stats item for device %s failed %d!\\n\"",
            "rcu_str_deref(device->name)",
            "ret"
          ],
          "line": 6535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "device->name"
          ],
          "line": 6537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "trans",
            "dev_root",
            "path"
          ],
          "line": 6533
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]"
          ],
          "line": 6531
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "KERN_WARNING \"BTRFS: \"\n\t\t\t\"error %d while searching for dev_stats item for device %s!\\n\"",
            "ret",
            "rcu_str_deref(device->name)"
          ],
          "line": 6524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "device->name"
          ],
          "line": 6526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "dev_root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 6522
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!path"
          ],
          "line": 6521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 6520
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int update_dev_stat_item(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *dev_root,\n\t\t\t\tstruct btrfs_device *device)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dev_stats_item *ptr;\n\tint ret;\n\tint i;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_STATS_KEY;\n\tkey.offset = device->devid;\n\n\tpath = btrfs_alloc_path();\n\tBUG_ON(!path);\n\tret = btrfs_search_slot(trans, dev_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: \"\n\t\t\t\"error %d while searching for dev_stats item for device %s!\\n\",\n\t\t\t      ret, rcu_str_deref(device->name));\n\t\tgoto out;\n\t}\n\n\tif (ret == 0 &&\n\t    btrfs_item_size_nr(path->nodes[0], path->slots[0]) < sizeof(*ptr)) {\n\t\t/* need to delete old one and insert a new one */\n\t\tret = btrfs_del_item(trans, dev_root, path);\n\t\tif (ret != 0) {\n\t\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\"delete too small dev_stats item for device %s failed %d!\\n\",\n\t\t\t\t      rcu_str_deref(device->name), ret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = 1;\n\t}\n\n\tif (ret == 1) {\n\t\t/* need to insert a new item */\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, dev_root, path,\n\t\t\t\t\t      &key, sizeof(*ptr));\n\t\tif (ret < 0) {\n\t\t\tprintk_in_rcu(KERN_WARNING \"BTRFS: \"\n\t\t\t\t\t  \"insert dev_stats item for device %s failed %d!\\n\",\n\t\t\t\t      rcu_str_deref(device->name), ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\teb = path->nodes[0];\n\tptr = btrfs_item_ptr(eb, path->slots[0], struct btrfs_dev_stats_item);\n\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\tbtrfs_set_dev_stats_value(eb, ptr, i,\n\t\t\t\t\t  btrfs_dev_stat_read(device, i));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_init_dev_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6444-6503",
    "snippet": "int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_device *device;\n\tstruct btrfs_path *path = NULL;\n\tint i;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tint item_size;\n\t\tstruct btrfs_dev_stats_item *ptr;\n\n\t\tkey.objectid = 0;\n\t\tkey.type = BTRFS_DEV_STATS_KEY;\n\t\tkey.offset = device->devid;\n\t\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\t\tif (ret) {\n\t\t\t__btrfs_reset_dev_stats(device);\n\t\t\tdevice->dev_stats_valid = 1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\titem_size = btrfs_item_size_nr(eb, slot);\n\n\t\tptr = btrfs_item_ptr(eb, slot,\n\t\t\t\t     struct btrfs_dev_stats_item);\n\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (item_size >= (1 + i) * sizeof(__le64))\n\t\t\t\tbtrfs_dev_stat_set(device, i,\n\t\t\t\t\tbtrfs_dev_stats_value(eb, ptr, i));\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(device, i);\n\t\t}\n\n\t\tdevice->dev_stats_valid = 1;\n\t\tbtrfs_dev_stat_print_on_load(device);\n\t\tbtrfs_release_path(path);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret < 0 ? ret : 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 6501
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 6498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 6496
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_print_on_load",
          "args": [
            "device"
          ],
          "line": 6495
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_print_on_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6615-6633",
          "snippet": "static void btrfs_dev_stat_print_on_load(struct btrfs_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\tif (btrfs_dev_stat_read(dev, i) != 0)\n\t\t\tbreak;\n\tif (i == BTRFS_DEV_STAT_VALUES_MAX)\n\t\treturn; /* all values == 0, suppress message */\n\n\tprintk_in_rcu(KERN_INFO \"BTRFS: \"\n\t\t   \"bdev %s errs: wr %u, rd %u, flush %u, corrupt %u, gen %u\\n\",\n\t       rcu_str_deref(dev->name),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_WRITE_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_READ_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_FLUSH_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_GENERATION_ERRS));\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\tif (btrfs_dev_stat_read(dev, i) != 0)\n\t\t\tbreak;\n\tif (i == BTRFS_DEV_STAT_VALUES_MAX)\n\t\treturn; /* all values == 0, suppress message */\n\n\tprintk_in_rcu(KERN_INFO \"BTRFS: \"\n\t\t   \"bdev %s errs: wr %u, rd %u, flush %u, corrupt %u, gen %u\\n\",\n\t       rcu_str_deref(dev->name),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_WRITE_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_READ_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_FLUSH_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS),\n\t       btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_GENERATION_ERRS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_reset",
          "args": [
            "device",
            "i"
          ],
          "line": 6491
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "521-525",
          "snippet": "static inline void btrfs_dev_stat_reset(struct btrfs_device *dev,\n\t\t\t\t\tint index)\n{\n\tbtrfs_dev_stat_set(dev, index, 0);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void btrfs_dev_stat_reset(struct btrfs_device *dev,\n\t\t\t\t\tint index)\n{\n\tbtrfs_dev_stat_set(dev, index, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_set",
          "args": [
            "device",
            "i",
            "btrfs_dev_stats_value(eb, ptr, i)"
          ],
          "line": 6488
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "513-519",
          "snippet": "static inline void btrfs_dev_stat_set(struct btrfs_device *dev,\n\t\t\t\t      int index, unsigned long val)\n{\n\tatomic_set(dev->dev_stat_values + index, val);\n\tsmp_mb__before_atomic();\n\tatomic_inc(&dev->dev_stats_ccnt);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void btrfs_dev_stat_set(struct btrfs_device *dev,\n\t\t\t\t      int index, unsigned long val)\n{\n\tatomic_set(dev->dev_stat_values + index, val);\n\tsmp_mb__before_atomic();\n\tatomic_inc(&dev->dev_stats_ccnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stats_value",
          "args": [
            "eb",
            "ptr",
            "i"
          ],
          "line": 6489
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stats_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3163-3174",
          "snippet": "static inline u64 btrfs_dev_stats_value(struct extent_buffer *eb,\n\t\t\t\t\tstruct btrfs_dev_stats_item *ptr,\n\t\t\t\t\tint index)\n{\n\tu64 val;\n\n\tread_extent_buffer(eb, &val,\n\t\t\t   offsetof(struct btrfs_dev_stats_item, values) +\n\t\t\t    ((unsigned long)ptr) + (index * sizeof(u64)),\n\t\t\t   sizeof(val));\n\treturn val;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_dev_stats_value(struct extent_buffer *eb,\n\t\t\t\t\tstruct btrfs_dev_stats_item *ptr,\n\t\t\t\t\tint index)\n{\n\tu64 val;\n\n\tread_extent_buffer(eb, &val,\n\t\t\t   offsetof(struct btrfs_dev_stats_item, values) +\n\t\t\t    ((unsigned long)ptr) + (index * sizeof(u64)),\n\t\t\t   sizeof(val));\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_dev_stats_item"
          ],
          "line": 6483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "eb",
            "slot"
          ],
          "line": 6481
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "&found_key",
            "slot"
          ],
          "line": 6480
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_reset_dev_stats",
          "args": [
            "device"
          ],
          "line": 6473
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_reset_dev_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6436-6442",
          "snippet": "static void __btrfs_reset_dev_stats(struct btrfs_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\tbtrfs_dev_stat_reset(dev, i);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\tbtrfs_dev_stat_reset(dev, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "dev_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 6471
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "&fs_devices->devices",
            "dev_list"
          ],
          "line": 6464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 6463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 6457
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_init_dev_stats(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_device *device;\n\tstruct btrfs_path *path = NULL;\n\tint i;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tint item_size;\n\t\tstruct btrfs_dev_stats_item *ptr;\n\n\t\tkey.objectid = 0;\n\t\tkey.type = BTRFS_DEV_STATS_KEY;\n\t\tkey.offset = device->devid;\n\t\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\t\tif (ret) {\n\t\t\t__btrfs_reset_dev_stats(device);\n\t\t\tdevice->dev_stats_valid = 1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\titem_size = btrfs_item_size_nr(eb, slot);\n\n\t\tptr = btrfs_item_ptr(eb, slot,\n\t\t\t\t     struct btrfs_dev_stats_item);\n\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (item_size >= (1 + i) * sizeof(__le64))\n\t\t\t\tbtrfs_dev_stat_set(device, i,\n\t\t\t\t\tbtrfs_dev_stats_value(eb, ptr, i));\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(device, i);\n\t\t}\n\n\t\tdevice->dev_stats_valid = 1;\n\t\tbtrfs_dev_stat_print_on_load(device);\n\t\tbtrfs_release_path(path);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret < 0 ? ret : 0;\n}"
  },
  {
    "function_name": "__btrfs_reset_dev_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6436-6442",
    "snippet": "static void __btrfs_reset_dev_stats(struct btrfs_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\tbtrfs_dev_stat_reset(dev, i);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_dev_stat_reset",
          "args": [
            "dev",
            "i"
          ],
          "line": 6441
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "521-525",
          "snippet": "static inline void btrfs_dev_stat_reset(struct btrfs_device *dev,\n\t\t\t\t\tint index)\n{\n\tbtrfs_dev_stat_set(dev, index, 0);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void btrfs_dev_stat_reset(struct btrfs_device *dev,\n\t\t\t\t\tint index)\n{\n\tbtrfs_dev_stat_set(dev, index, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\tbtrfs_dev_stat_reset(dev, i);\n}"
  },
  {
    "function_name": "btrfs_init_devices_late",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6421-6434",
    "snippet": "void btrfs_init_devices_late(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\n\twhile (fs_devices) {\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\t\tlist_for_each_entry(device, &fs_devices->devices, dev_list)\n\t\t\tdevice->dev_root = fs_info->dev_root;\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t\tfs_devices = fs_devices->seed;\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 6430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "&fs_devices->devices",
            "dev_list"
          ],
          "line": 6428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 6427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_init_devices_late(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\n\twhile (fs_devices) {\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\t\tlist_for_each_entry(device, &fs_devices->devices, dev_list)\n\t\t\tdevice->dev_root = fs_info->dev_root;\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t\tfs_devices = fs_devices->seed;\n\t}\n}"
  },
  {
    "function_name": "btrfs_read_chunk_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6354-6419",
    "snippet": "int btrfs_read_chunk_tree(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tint ret;\n\tint slot;\n\n\troot = root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&uuid_mutex);\n\tlock_chunks(root);\n\n\t/*\n\t * Read all device items, and then all the chunk items. All\n\t * device items are found before any chunk item (their object id\n\t * is smaller than the lowest possible object id for a chunk\n\t * item - BTRFS_FIRST_CHUNK_TREE_OBJECTID).\n\t */\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.type == BTRFS_DEV_ITEM_KEY) {\n\t\t\tstruct btrfs_dev_item *dev_item;\n\t\t\tdev_item = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\t  struct btrfs_dev_item);\n\t\t\tret = read_one_dev(root, leaf, dev_item);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t} else if (found_key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tstruct btrfs_chunk *chunk;\n\t\t\tchunk = btrfs_item_ptr(leaf, slot, struct btrfs_chunk);\n\t\t\tret = read_one_chunk(root, &found_key, leaf, chunk);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nerror:\n\tunlock_chunks(root);\n\tmutex_unlock(&uuid_mutex);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 6417
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 6415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_chunks",
          "args": [
            "root"
          ],
          "line": 6414
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "536-539",
          "snippet": "static inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_one_chunk",
          "args": [
            "root",
            "&found_key",
            "leaf",
            "chunk"
          ],
          "line": 6406
        },
        "resolved": true,
        "details": {
          "function_name": "read_one_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6009-6096",
          "snippet": "static int read_one_chunk(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t  struct extent_buffer *leaf,\n\t\t\t  struct btrfs_chunk *chunk)\n{\n\tstruct btrfs_mapping_tree *map_tree = &root->fs_info->mapping_tree;\n\tstruct map_lookup *map;\n\tstruct extent_map *em;\n\tu64 logical;\n\tu64 length;\n\tu64 devid;\n\tu8 uuid[BTRFS_UUID_SIZE];\n\tint num_stripes;\n\tint ret;\n\tint i;\n\n\tlogical = key->offset;\n\tlength = btrfs_chunk_length(leaf, chunk);\n\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, logical, 1);\n\tread_unlock(&map_tree->map_tree.lock);\n\n\t/* already mapped? */\n\tif (em && em->start <= logical && em->start + em->len > logical) {\n\t\tfree_extent_map(em);\n\t\treturn 0;\n\t} else if (em) {\n\t\tfree_extent_map(em);\n\t}\n\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn -ENOMEM;\n\tnum_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tmap = kmalloc(map_lookup_size(num_stripes), GFP_NOFS);\n\tif (!map) {\n\t\tfree_extent_map(em);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_bit(EXTENT_FLAG_FS_MAPPING, &em->flags);\n\tem->bdev = (struct block_device *)map;\n\tem->start = logical;\n\tem->len = length;\n\tem->orig_start = 0;\n\tem->block_start = 0;\n\tem->block_len = em->len;\n\n\tmap->num_stripes = num_stripes;\n\tmap->io_width = btrfs_chunk_io_width(leaf, chunk);\n\tmap->io_align = btrfs_chunk_io_align(leaf, chunk);\n\tmap->sector_size = btrfs_chunk_sector_size(leaf, chunk);\n\tmap->stripe_len = btrfs_chunk_stripe_len(leaf, chunk);\n\tmap->type = btrfs_chunk_type(leaf, chunk);\n\tmap->sub_stripes = btrfs_chunk_sub_stripes(leaf, chunk);\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tmap->stripes[i].physical =\n\t\t\tbtrfs_stripe_offset_nr(leaf, chunk, i);\n\t\tdevid = btrfs_stripe_devid_nr(leaf, chunk, i);\n\t\tread_extent_buffer(leaf, uuid, (unsigned long)\n\t\t\t\t   btrfs_stripe_dev_uuid_nr(chunk, i),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tmap->stripes[i].dev = btrfs_find_device(root->fs_info, devid,\n\t\t\t\t\t\t\tuuid, NULL);\n\t\tif (!map->stripes[i].dev && !btrfs_test_opt(root, DEGRADED)) {\n\t\t\tfree_extent_map(em);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!map->stripes[i].dev) {\n\t\t\tmap->stripes[i].dev =\n\t\t\t\tadd_missing_dev(root, root->fs_info->fs_devices,\n\t\t\t\t\t\tdevid, uuid);\n\t\t\tif (!map->stripes[i].dev) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tmap->stripes[i].dev->in_fs_metadata = 1;\n\t}\n\n\twrite_lock(&map_tree->map_tree.lock);\n\tret = add_extent_mapping(&map_tree->map_tree, em, 0);\n\twrite_unlock(&map_tree->map_tree.lock);\n\tBUG_ON(ret); /* Tree corruption */\n\tfree_extent_map(em);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int read_one_chunk(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t  struct extent_buffer *leaf,\n\t\t\t  struct btrfs_chunk *chunk)\n{\n\tstruct btrfs_mapping_tree *map_tree = &root->fs_info->mapping_tree;\n\tstruct map_lookup *map;\n\tstruct extent_map *em;\n\tu64 logical;\n\tu64 length;\n\tu64 devid;\n\tu8 uuid[BTRFS_UUID_SIZE];\n\tint num_stripes;\n\tint ret;\n\tint i;\n\n\tlogical = key->offset;\n\tlength = btrfs_chunk_length(leaf, chunk);\n\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, logical, 1);\n\tread_unlock(&map_tree->map_tree.lock);\n\n\t/* already mapped? */\n\tif (em && em->start <= logical && em->start + em->len > logical) {\n\t\tfree_extent_map(em);\n\t\treturn 0;\n\t} else if (em) {\n\t\tfree_extent_map(em);\n\t}\n\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn -ENOMEM;\n\tnum_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tmap = kmalloc(map_lookup_size(num_stripes), GFP_NOFS);\n\tif (!map) {\n\t\tfree_extent_map(em);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_bit(EXTENT_FLAG_FS_MAPPING, &em->flags);\n\tem->bdev = (struct block_device *)map;\n\tem->start = logical;\n\tem->len = length;\n\tem->orig_start = 0;\n\tem->block_start = 0;\n\tem->block_len = em->len;\n\n\tmap->num_stripes = num_stripes;\n\tmap->io_width = btrfs_chunk_io_width(leaf, chunk);\n\tmap->io_align = btrfs_chunk_io_align(leaf, chunk);\n\tmap->sector_size = btrfs_chunk_sector_size(leaf, chunk);\n\tmap->stripe_len = btrfs_chunk_stripe_len(leaf, chunk);\n\tmap->type = btrfs_chunk_type(leaf, chunk);\n\tmap->sub_stripes = btrfs_chunk_sub_stripes(leaf, chunk);\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tmap->stripes[i].physical =\n\t\t\tbtrfs_stripe_offset_nr(leaf, chunk, i);\n\t\tdevid = btrfs_stripe_devid_nr(leaf, chunk, i);\n\t\tread_extent_buffer(leaf, uuid, (unsigned long)\n\t\t\t\t   btrfs_stripe_dev_uuid_nr(chunk, i),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tmap->stripes[i].dev = btrfs_find_device(root->fs_info, devid,\n\t\t\t\t\t\t\tuuid, NULL);\n\t\tif (!map->stripes[i].dev && !btrfs_test_opt(root, DEGRADED)) {\n\t\t\tfree_extent_map(em);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!map->stripes[i].dev) {\n\t\t\tmap->stripes[i].dev =\n\t\t\t\tadd_missing_dev(root, root->fs_info->fs_devices,\n\t\t\t\t\t\tdevid, uuid);\n\t\t\tif (!map->stripes[i].dev) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tmap->stripes[i].dev->in_fs_metadata = 1;\n\t}\n\n\twrite_lock(&map_tree->map_tree.lock);\n\tret = add_extent_mapping(&map_tree->map_tree, em, 0);\n\twrite_unlock(&map_tree->map_tree.lock);\n\tBUG_ON(ret); /* Tree corruption */\n\tfree_extent_map(em);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_chunk"
          ],
          "line": 6405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_one_dev",
          "args": [
            "root",
            "leaf",
            "dev_item"
          ],
          "line": 6400
        },
        "resolved": true,
        "details": {
          "function_name": "read_one_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6176-6256",
          "snippet": "static int read_one_dev(struct btrfs_root *root,\n\t\t\tstruct extent_buffer *leaf,\n\t\t\tstruct btrfs_dev_item *dev_item)\n{\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tu64 devid;\n\tint ret;\n\tu8 fs_uuid[BTRFS_UUID_SIZE];\n\tu8 dev_uuid[BTRFS_UUID_SIZE];\n\n\tdevid = btrfs_device_id(leaf, dev_item);\n\tread_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),\n\t\t\t   BTRFS_UUID_SIZE);\n\tread_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),\n\t\t\t   BTRFS_UUID_SIZE);\n\n\tif (memcmp(fs_uuid, root->fs_info->fsid, BTRFS_UUID_SIZE)) {\n\t\tfs_devices = open_seed_devices(root, fs_uuid);\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn PTR_ERR(fs_devices);\n\t}\n\n\tdevice = btrfs_find_device(root->fs_info, devid, dev_uuid, fs_uuid);\n\tif (!device) {\n\t\tif (!btrfs_test_opt(root, DEGRADED))\n\t\t\treturn -EIO;\n\n\t\tbtrfs_warn(root->fs_info, \"devid %llu missing\", devid);\n\t\tdevice = add_missing_dev(root, fs_devices, devid, dev_uuid);\n\t\tif (!device)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tif (!device->bdev && !btrfs_test_opt(root, DEGRADED))\n\t\t\treturn -EIO;\n\n\t\tif(!device->bdev && !device->missing) {\n\t\t\t/*\n\t\t\t * this happens when a device that was properly setup\n\t\t\t * in the device info lists suddenly goes bad.\n\t\t\t * device->bdev is NULL, and so we have to set\n\t\t\t * device->missing to one here\n\t\t\t */\n\t\t\tdevice->fs_devices->missing_devices++;\n\t\t\tdevice->missing = 1;\n\t\t}\n\n\t\t/* Move the device to its own fs_devices */\n\t\tif (device->fs_devices != fs_devices) {\n\t\t\tASSERT(device->missing);\n\n\t\t\tlist_move(&device->dev_list, &fs_devices->devices);\n\t\t\tdevice->fs_devices->num_devices--;\n\t\t\tfs_devices->num_devices++;\n\n\t\t\tdevice->fs_devices->missing_devices--;\n\t\t\tfs_devices->missing_devices++;\n\n\t\t\tdevice->fs_devices = fs_devices;\n\t\t}\n\t}\n\n\tif (device->fs_devices != root->fs_info->fs_devices) {\n\t\tBUG_ON(device->writeable);\n\t\tif (device->generation !=\n\t\t    btrfs_device_generation(leaf, dev_item))\n\t\t\treturn -EINVAL;\n\t}\n\n\tfill_device_from_item(leaf, dev_item, device);\n\tdevice->in_fs_metadata = 1;\n\tif (device->writeable && !device->is_tgtdev_for_dev_replace) {\n\t\tdevice->fs_devices->total_rw_bytes += device->total_bytes;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space += device->total_bytes -\n\t\t\tdevice->bytes_used;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t}\n\tret = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int read_one_dev(struct btrfs_root *root,\n\t\t\tstruct extent_buffer *leaf,\n\t\t\tstruct btrfs_dev_item *dev_item)\n{\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tu64 devid;\n\tint ret;\n\tu8 fs_uuid[BTRFS_UUID_SIZE];\n\tu8 dev_uuid[BTRFS_UUID_SIZE];\n\n\tdevid = btrfs_device_id(leaf, dev_item);\n\tread_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),\n\t\t\t   BTRFS_UUID_SIZE);\n\tread_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),\n\t\t\t   BTRFS_UUID_SIZE);\n\n\tif (memcmp(fs_uuid, root->fs_info->fsid, BTRFS_UUID_SIZE)) {\n\t\tfs_devices = open_seed_devices(root, fs_uuid);\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn PTR_ERR(fs_devices);\n\t}\n\n\tdevice = btrfs_find_device(root->fs_info, devid, dev_uuid, fs_uuid);\n\tif (!device) {\n\t\tif (!btrfs_test_opt(root, DEGRADED))\n\t\t\treturn -EIO;\n\n\t\tbtrfs_warn(root->fs_info, \"devid %llu missing\", devid);\n\t\tdevice = add_missing_dev(root, fs_devices, devid, dev_uuid);\n\t\tif (!device)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tif (!device->bdev && !btrfs_test_opt(root, DEGRADED))\n\t\t\treturn -EIO;\n\n\t\tif(!device->bdev && !device->missing) {\n\t\t\t/*\n\t\t\t * this happens when a device that was properly setup\n\t\t\t * in the device info lists suddenly goes bad.\n\t\t\t * device->bdev is NULL, and so we have to set\n\t\t\t * device->missing to one here\n\t\t\t */\n\t\t\tdevice->fs_devices->missing_devices++;\n\t\t\tdevice->missing = 1;\n\t\t}\n\n\t\t/* Move the device to its own fs_devices */\n\t\tif (device->fs_devices != fs_devices) {\n\t\t\tASSERT(device->missing);\n\n\t\t\tlist_move(&device->dev_list, &fs_devices->devices);\n\t\t\tdevice->fs_devices->num_devices--;\n\t\t\tfs_devices->num_devices++;\n\n\t\t\tdevice->fs_devices->missing_devices--;\n\t\t\tfs_devices->missing_devices++;\n\n\t\t\tdevice->fs_devices = fs_devices;\n\t\t}\n\t}\n\n\tif (device->fs_devices != root->fs_info->fs_devices) {\n\t\tBUG_ON(device->writeable);\n\t\tif (device->generation !=\n\t\t    btrfs_device_generation(leaf, dev_item))\n\t\t\treturn -EINVAL;\n\t}\n\n\tfill_device_from_item(leaf, dev_item, device);\n\tdevice->in_fs_metadata = 1;\n\tif (device->writeable && !device->is_tgtdev_for_dev_replace) {\n\t\tdevice->fs_devices->total_rw_bytes += device->total_bytes;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space += device->total_bytes -\n\t\t\tdevice->bytes_used;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t}\n\tret = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_dev_item"
          ],
          "line": 6398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&found_key",
            "slot"
          ],
          "line": 6395
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 6388
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 6387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 6381
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 6369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 6365
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_read_chunk_tree(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tint ret;\n\tint slot;\n\n\troot = root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&uuid_mutex);\n\tlock_chunks(root);\n\n\t/*\n\t * Read all device items, and then all the chunk items. All\n\t * device items are found before any chunk item (their object id\n\t * is smaller than the lowest possible object id for a chunk\n\t * item - BTRFS_FIRST_CHUNK_TREE_OBJECTID).\n\t */\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.type == BTRFS_DEV_ITEM_KEY) {\n\t\t\tstruct btrfs_dev_item *dev_item;\n\t\t\tdev_item = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\t  struct btrfs_dev_item);\n\t\t\tret = read_one_dev(root, leaf, dev_item);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t} else if (found_key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tstruct btrfs_chunk *chunk;\n\t\t\tchunk = btrfs_item_ptr(leaf, slot, struct btrfs_chunk);\n\t\t\tret = read_one_chunk(root, &found_key, leaf, chunk);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nerror:\n\tunlock_chunks(root);\n\tmutex_unlock(&uuid_mutex);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_read_sys_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6258-6352",
    "snippet": "int btrfs_read_sys_array(struct btrfs_root *root)\n{\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tstruct extent_buffer *sb;\n\tstruct btrfs_disk_key *disk_key;\n\tstruct btrfs_chunk *chunk;\n\tu8 *array_ptr;\n\tunsigned long sb_array_offset;\n\tint ret = 0;\n\tu32 num_stripes;\n\tu32 array_size;\n\tu32 len = 0;\n\tu32 cur_offset;\n\tstruct btrfs_key key;\n\n\tASSERT(BTRFS_SUPER_INFO_SIZE <= root->nodesize);\n\t/*\n\t * This will create extent buffer of nodesize, superblock size is\n\t * fixed to BTRFS_SUPER_INFO_SIZE. If nodesize > sb size, this will\n\t * overallocate but we can keep it as-is, only the first page is used.\n\t */\n\tsb = btrfs_find_create_tree_block(root, BTRFS_SUPER_INFO_OFFSET);\n\tif (!sb)\n\t\treturn -ENOMEM;\n\tbtrfs_set_buffer_uptodate(sb);\n\tbtrfs_set_buffer_lockdep_class(root->root_key.objectid, sb, 0);\n\t/*\n\t * The sb extent buffer is artifical and just used to read the system array.\n\t * btrfs_set_buffer_uptodate() call does not properly mark all it's\n\t * pages up-to-date when the page is larger: extent does not cover the\n\t * whole page and consequently check_page_uptodate does not find all\n\t * the page's extents up-to-date (the hole beyond sb),\n\t * write_extent_buffer then triggers a WARN_ON.\n\t *\n\t * Regular short extents go through mark_extent_buffer_dirty/writeback cycle,\n\t * but sb spans only this function. Add an explicit SetPageUptodate call\n\t * to silence the warning eg. on PowerPC 64.\n\t */\n\tif (PAGE_CACHE_SIZE > BTRFS_SUPER_INFO_SIZE)\n\t\tSetPageUptodate(sb->pages[0]);\n\n\twrite_extent_buffer(sb, super_copy, 0, BTRFS_SUPER_INFO_SIZE);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\n\tarray_ptr = super_copy->sys_chunk_array;\n\tsb_array_offset = offsetof(struct btrfs_super_block, sys_chunk_array);\n\tcur_offset = 0;\n\n\twhile (cur_offset < array_size) {\n\t\tdisk_key = (struct btrfs_disk_key *)array_ptr;\n\t\tlen = sizeof(*disk_key);\n\t\tif (cur_offset + len > array_size)\n\t\t\tgoto out_short_read;\n\n\t\tbtrfs_disk_key_to_cpu(&key, disk_key);\n\n\t\tarray_ptr += len;\n\t\tsb_array_offset += len;\n\t\tcur_offset += len;\n\n\t\tif (key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tchunk = (struct btrfs_chunk *)sb_array_offset;\n\t\t\t/*\n\t\t\t * At least one btrfs_chunk with one stripe must be\n\t\t\t * present, exact stripe count check comes afterwards\n\t\t\t */\n\t\t\tlen = btrfs_chunk_item_size(1);\n\t\t\tif (cur_offset + len > array_size)\n\t\t\t\tgoto out_short_read;\n\n\t\t\tnum_stripes = btrfs_chunk_num_stripes(sb, chunk);\n\t\t\tlen = btrfs_chunk_item_size(num_stripes);\n\t\t\tif (cur_offset + len > array_size)\n\t\t\t\tgoto out_short_read;\n\n\t\t\tret = read_one_chunk(root, &key, sb, chunk);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tarray_ptr += len;\n\t\tsb_array_offset += len;\n\t\tcur_offset += len;\n\t}\n\tfree_extent_buffer(sb);\n\treturn ret;\n\nout_short_read:\n\tprintk(KERN_ERR \"BTRFS: sys_array too short to read %u bytes at offset %u\\n\",\n\t\t\tlen, cur_offset);\n\tfree_extent_buffer(sb);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "sb"
          ],
          "line": 6350
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BTRFS: sys_array too short to read %u bytes at offset %u\\n\"",
            "len",
            "cur_offset"
          ],
          "line": 6348
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_one_chunk",
          "args": [
            "root",
            "&key",
            "sb",
            "chunk"
          ],
          "line": 6333
        },
        "resolved": true,
        "details": {
          "function_name": "read_one_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6009-6096",
          "snippet": "static int read_one_chunk(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t  struct extent_buffer *leaf,\n\t\t\t  struct btrfs_chunk *chunk)\n{\n\tstruct btrfs_mapping_tree *map_tree = &root->fs_info->mapping_tree;\n\tstruct map_lookup *map;\n\tstruct extent_map *em;\n\tu64 logical;\n\tu64 length;\n\tu64 devid;\n\tu8 uuid[BTRFS_UUID_SIZE];\n\tint num_stripes;\n\tint ret;\n\tint i;\n\n\tlogical = key->offset;\n\tlength = btrfs_chunk_length(leaf, chunk);\n\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, logical, 1);\n\tread_unlock(&map_tree->map_tree.lock);\n\n\t/* already mapped? */\n\tif (em && em->start <= logical && em->start + em->len > logical) {\n\t\tfree_extent_map(em);\n\t\treturn 0;\n\t} else if (em) {\n\t\tfree_extent_map(em);\n\t}\n\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn -ENOMEM;\n\tnum_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tmap = kmalloc(map_lookup_size(num_stripes), GFP_NOFS);\n\tif (!map) {\n\t\tfree_extent_map(em);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_bit(EXTENT_FLAG_FS_MAPPING, &em->flags);\n\tem->bdev = (struct block_device *)map;\n\tem->start = logical;\n\tem->len = length;\n\tem->orig_start = 0;\n\tem->block_start = 0;\n\tem->block_len = em->len;\n\n\tmap->num_stripes = num_stripes;\n\tmap->io_width = btrfs_chunk_io_width(leaf, chunk);\n\tmap->io_align = btrfs_chunk_io_align(leaf, chunk);\n\tmap->sector_size = btrfs_chunk_sector_size(leaf, chunk);\n\tmap->stripe_len = btrfs_chunk_stripe_len(leaf, chunk);\n\tmap->type = btrfs_chunk_type(leaf, chunk);\n\tmap->sub_stripes = btrfs_chunk_sub_stripes(leaf, chunk);\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tmap->stripes[i].physical =\n\t\t\tbtrfs_stripe_offset_nr(leaf, chunk, i);\n\t\tdevid = btrfs_stripe_devid_nr(leaf, chunk, i);\n\t\tread_extent_buffer(leaf, uuid, (unsigned long)\n\t\t\t\t   btrfs_stripe_dev_uuid_nr(chunk, i),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tmap->stripes[i].dev = btrfs_find_device(root->fs_info, devid,\n\t\t\t\t\t\t\tuuid, NULL);\n\t\tif (!map->stripes[i].dev && !btrfs_test_opt(root, DEGRADED)) {\n\t\t\tfree_extent_map(em);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!map->stripes[i].dev) {\n\t\t\tmap->stripes[i].dev =\n\t\t\t\tadd_missing_dev(root, root->fs_info->fs_devices,\n\t\t\t\t\t\tdevid, uuid);\n\t\t\tif (!map->stripes[i].dev) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tmap->stripes[i].dev->in_fs_metadata = 1;\n\t}\n\n\twrite_lock(&map_tree->map_tree.lock);\n\tret = add_extent_mapping(&map_tree->map_tree, em, 0);\n\twrite_unlock(&map_tree->map_tree.lock);\n\tBUG_ON(ret); /* Tree corruption */\n\tfree_extent_map(em);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int read_one_chunk(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t  struct extent_buffer *leaf,\n\t\t\t  struct btrfs_chunk *chunk)\n{\n\tstruct btrfs_mapping_tree *map_tree = &root->fs_info->mapping_tree;\n\tstruct map_lookup *map;\n\tstruct extent_map *em;\n\tu64 logical;\n\tu64 length;\n\tu64 devid;\n\tu8 uuid[BTRFS_UUID_SIZE];\n\tint num_stripes;\n\tint ret;\n\tint i;\n\n\tlogical = key->offset;\n\tlength = btrfs_chunk_length(leaf, chunk);\n\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, logical, 1);\n\tread_unlock(&map_tree->map_tree.lock);\n\n\t/* already mapped? */\n\tif (em && em->start <= logical && em->start + em->len > logical) {\n\t\tfree_extent_map(em);\n\t\treturn 0;\n\t} else if (em) {\n\t\tfree_extent_map(em);\n\t}\n\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn -ENOMEM;\n\tnum_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tmap = kmalloc(map_lookup_size(num_stripes), GFP_NOFS);\n\tif (!map) {\n\t\tfree_extent_map(em);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_bit(EXTENT_FLAG_FS_MAPPING, &em->flags);\n\tem->bdev = (struct block_device *)map;\n\tem->start = logical;\n\tem->len = length;\n\tem->orig_start = 0;\n\tem->block_start = 0;\n\tem->block_len = em->len;\n\n\tmap->num_stripes = num_stripes;\n\tmap->io_width = btrfs_chunk_io_width(leaf, chunk);\n\tmap->io_align = btrfs_chunk_io_align(leaf, chunk);\n\tmap->sector_size = btrfs_chunk_sector_size(leaf, chunk);\n\tmap->stripe_len = btrfs_chunk_stripe_len(leaf, chunk);\n\tmap->type = btrfs_chunk_type(leaf, chunk);\n\tmap->sub_stripes = btrfs_chunk_sub_stripes(leaf, chunk);\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tmap->stripes[i].physical =\n\t\t\tbtrfs_stripe_offset_nr(leaf, chunk, i);\n\t\tdevid = btrfs_stripe_devid_nr(leaf, chunk, i);\n\t\tread_extent_buffer(leaf, uuid, (unsigned long)\n\t\t\t\t   btrfs_stripe_dev_uuid_nr(chunk, i),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tmap->stripes[i].dev = btrfs_find_device(root->fs_info, devid,\n\t\t\t\t\t\t\tuuid, NULL);\n\t\tif (!map->stripes[i].dev && !btrfs_test_opt(root, DEGRADED)) {\n\t\t\tfree_extent_map(em);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!map->stripes[i].dev) {\n\t\t\tmap->stripes[i].dev =\n\t\t\t\tadd_missing_dev(root, root->fs_info->fs_devices,\n\t\t\t\t\t\tdevid, uuid);\n\t\t\tif (!map->stripes[i].dev) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tmap->stripes[i].dev->in_fs_metadata = 1;\n\t}\n\n\twrite_lock(&map_tree->map_tree.lock);\n\tret = add_extent_mapping(&map_tree->map_tree, em, 0);\n\twrite_unlock(&map_tree->map_tree.lock);\n\tBUG_ON(ret); /* Tree corruption */\n\tfree_extent_map(em);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_item_size",
          "args": [
            "num_stripes"
          ],
          "line": 6329
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_chunk_item_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "335-340",
          "snippet": "static inline unsigned long btrfs_chunk_item_size(int num_stripes)\n{\n\tBUG_ON(num_stripes == 0);\n\treturn sizeof(struct btrfs_chunk) +\n\t\tsizeof(struct btrfs_stripe) * (num_stripes - 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_chunk_item_size(int num_stripes)\n{\n\tBUG_ON(num_stripes == 0);\n\treturn sizeof(struct btrfs_chunk) +\n\t\tsizeof(struct btrfs_stripe) * (num_stripes - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_num_stripes",
          "args": [
            "sb",
            "chunk"
          ],
          "line": 6328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_to_cpu",
          "args": [
            "&key",
            "disk_key"
          ],
          "line": 6312
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_disk_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2731-2737",
          "snippet": "static inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_sys_array_size",
          "args": [
            "super_copy"
          ],
          "line": 6300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "sb",
            "super_copy",
            "0",
            "BTRFS_SUPER_INFO_SIZE"
          ],
          "line": 6299
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "sb->pages[0]"
          ],
          "line": 6297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_buffer_lockdep_class",
          "args": [
            "root->root_key.objectid",
            "sb",
            "0"
          ],
          "line": 6283
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_lockdep_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "154-157",
          "snippet": "static inline void btrfs_set_buffer_lockdep_class(u64 objectid,\n\t\t\t\t\tstruct extent_buffer *eb, int level)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_set_buffer_lockdep_class(u64 objectid,\n\t\t\t\t\tstruct extent_buffer *eb, int level)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_buffer_uptodate",
          "args": [
            "sb"
          ],
          "line": 6282
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_create_tree_block",
          "args": [
            "root",
            "BTRFS_SUPER_INFO_OFFSET"
          ],
          "line": 6279
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_create_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1128-1134",
          "snippet": "struct extent_buffer *btrfs_find_create_tree_block(struct btrfs_root *root,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn alloc_test_extent_buffer(root->fs_info, bytenr);\n\treturn alloc_extent_buffer(root->fs_info, bytenr);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *btrfs_find_create_tree_block(struct btrfs_root *root,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn alloc_test_extent_buffer(root->fs_info, bytenr);\n\treturn alloc_extent_buffer(root->fs_info, bytenr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "BTRFS_SUPER_INFO_SIZE <= root->nodesize"
          ],
          "line": 6273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_read_sys_array(struct btrfs_root *root)\n{\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tstruct extent_buffer *sb;\n\tstruct btrfs_disk_key *disk_key;\n\tstruct btrfs_chunk *chunk;\n\tu8 *array_ptr;\n\tunsigned long sb_array_offset;\n\tint ret = 0;\n\tu32 num_stripes;\n\tu32 array_size;\n\tu32 len = 0;\n\tu32 cur_offset;\n\tstruct btrfs_key key;\n\n\tASSERT(BTRFS_SUPER_INFO_SIZE <= root->nodesize);\n\t/*\n\t * This will create extent buffer of nodesize, superblock size is\n\t * fixed to BTRFS_SUPER_INFO_SIZE. If nodesize > sb size, this will\n\t * overallocate but we can keep it as-is, only the first page is used.\n\t */\n\tsb = btrfs_find_create_tree_block(root, BTRFS_SUPER_INFO_OFFSET);\n\tif (!sb)\n\t\treturn -ENOMEM;\n\tbtrfs_set_buffer_uptodate(sb);\n\tbtrfs_set_buffer_lockdep_class(root->root_key.objectid, sb, 0);\n\t/*\n\t * The sb extent buffer is artifical and just used to read the system array.\n\t * btrfs_set_buffer_uptodate() call does not properly mark all it's\n\t * pages up-to-date when the page is larger: extent does not cover the\n\t * whole page and consequently check_page_uptodate does not find all\n\t * the page's extents up-to-date (the hole beyond sb),\n\t * write_extent_buffer then triggers a WARN_ON.\n\t *\n\t * Regular short extents go through mark_extent_buffer_dirty/writeback cycle,\n\t * but sb spans only this function. Add an explicit SetPageUptodate call\n\t * to silence the warning eg. on PowerPC 64.\n\t */\n\tif (PAGE_CACHE_SIZE > BTRFS_SUPER_INFO_SIZE)\n\t\tSetPageUptodate(sb->pages[0]);\n\n\twrite_extent_buffer(sb, super_copy, 0, BTRFS_SUPER_INFO_SIZE);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\n\tarray_ptr = super_copy->sys_chunk_array;\n\tsb_array_offset = offsetof(struct btrfs_super_block, sys_chunk_array);\n\tcur_offset = 0;\n\n\twhile (cur_offset < array_size) {\n\t\tdisk_key = (struct btrfs_disk_key *)array_ptr;\n\t\tlen = sizeof(*disk_key);\n\t\tif (cur_offset + len > array_size)\n\t\t\tgoto out_short_read;\n\n\t\tbtrfs_disk_key_to_cpu(&key, disk_key);\n\n\t\tarray_ptr += len;\n\t\tsb_array_offset += len;\n\t\tcur_offset += len;\n\n\t\tif (key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tchunk = (struct btrfs_chunk *)sb_array_offset;\n\t\t\t/*\n\t\t\t * At least one btrfs_chunk with one stripe must be\n\t\t\t * present, exact stripe count check comes afterwards\n\t\t\t */\n\t\t\tlen = btrfs_chunk_item_size(1);\n\t\t\tif (cur_offset + len > array_size)\n\t\t\t\tgoto out_short_read;\n\n\t\t\tnum_stripes = btrfs_chunk_num_stripes(sb, chunk);\n\t\t\tlen = btrfs_chunk_item_size(num_stripes);\n\t\t\tif (cur_offset + len > array_size)\n\t\t\t\tgoto out_short_read;\n\n\t\t\tret = read_one_chunk(root, &key, sb, chunk);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tarray_ptr += len;\n\t\tsb_array_offset += len;\n\t\tcur_offset += len;\n\t}\n\tfree_extent_buffer(sb);\n\treturn ret;\n\nout_short_read:\n\tprintk(KERN_ERR \"BTRFS: sys_array too short to read %u bytes at offset %u\\n\",\n\t\t\tlen, cur_offset);\n\tfree_extent_buffer(sb);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "read_one_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6176-6256",
    "snippet": "static int read_one_dev(struct btrfs_root *root,\n\t\t\tstruct extent_buffer *leaf,\n\t\t\tstruct btrfs_dev_item *dev_item)\n{\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tu64 devid;\n\tint ret;\n\tu8 fs_uuid[BTRFS_UUID_SIZE];\n\tu8 dev_uuid[BTRFS_UUID_SIZE];\n\n\tdevid = btrfs_device_id(leaf, dev_item);\n\tread_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),\n\t\t\t   BTRFS_UUID_SIZE);\n\tread_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),\n\t\t\t   BTRFS_UUID_SIZE);\n\n\tif (memcmp(fs_uuid, root->fs_info->fsid, BTRFS_UUID_SIZE)) {\n\t\tfs_devices = open_seed_devices(root, fs_uuid);\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn PTR_ERR(fs_devices);\n\t}\n\n\tdevice = btrfs_find_device(root->fs_info, devid, dev_uuid, fs_uuid);\n\tif (!device) {\n\t\tif (!btrfs_test_opt(root, DEGRADED))\n\t\t\treturn -EIO;\n\n\t\tbtrfs_warn(root->fs_info, \"devid %llu missing\", devid);\n\t\tdevice = add_missing_dev(root, fs_devices, devid, dev_uuid);\n\t\tif (!device)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tif (!device->bdev && !btrfs_test_opt(root, DEGRADED))\n\t\t\treturn -EIO;\n\n\t\tif(!device->bdev && !device->missing) {\n\t\t\t/*\n\t\t\t * this happens when a device that was properly setup\n\t\t\t * in the device info lists suddenly goes bad.\n\t\t\t * device->bdev is NULL, and so we have to set\n\t\t\t * device->missing to one here\n\t\t\t */\n\t\t\tdevice->fs_devices->missing_devices++;\n\t\t\tdevice->missing = 1;\n\t\t}\n\n\t\t/* Move the device to its own fs_devices */\n\t\tif (device->fs_devices != fs_devices) {\n\t\t\tASSERT(device->missing);\n\n\t\t\tlist_move(&device->dev_list, &fs_devices->devices);\n\t\t\tdevice->fs_devices->num_devices--;\n\t\t\tfs_devices->num_devices++;\n\n\t\t\tdevice->fs_devices->missing_devices--;\n\t\t\tfs_devices->missing_devices++;\n\n\t\t\tdevice->fs_devices = fs_devices;\n\t\t}\n\t}\n\n\tif (device->fs_devices != root->fs_info->fs_devices) {\n\t\tBUG_ON(device->writeable);\n\t\tif (device->generation !=\n\t\t    btrfs_device_generation(leaf, dev_item))\n\t\t\treturn -EINVAL;\n\t}\n\n\tfill_device_from_item(leaf, dev_item, device);\n\tdevice->in_fs_metadata = 1;\n\tif (device->writeable && !device->is_tgtdev_for_dev_replace) {\n\t\tdevice->fs_devices->total_rw_bytes += device->total_bytes;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space += device->total_bytes -\n\t\t\tdevice->bytes_used;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t}\n\tret = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->free_chunk_lock"
          ],
          "line": 6252
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->free_chunk_lock"
          ],
          "line": 6249
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_device_from_item",
          "args": [
            "leaf",
            "dev_item",
            "device"
          ],
          "line": 6245
        },
        "resolved": true,
        "details": {
          "function_name": "fill_device_from_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6098-6119",
          "snippet": "static void fill_device_from_item(struct extent_buffer *leaf,\n\t\t\t\t struct btrfs_dev_item *dev_item,\n\t\t\t\t struct btrfs_device *device)\n{\n\tunsigned long ptr;\n\n\tdevice->devid = btrfs_device_id(leaf, dev_item);\n\tdevice->disk_total_bytes = btrfs_device_total_bytes(leaf, dev_item);\n\tdevice->total_bytes = device->disk_total_bytes;\n\tdevice->commit_total_bytes = device->disk_total_bytes;\n\tdevice->bytes_used = btrfs_device_bytes_used(leaf, dev_item);\n\tdevice->commit_bytes_used = device->bytes_used;\n\tdevice->type = btrfs_device_type(leaf, dev_item);\n\tdevice->io_align = btrfs_device_io_align(leaf, dev_item);\n\tdevice->io_width = btrfs_device_io_width(leaf, dev_item);\n\tdevice->sector_size = btrfs_device_sector_size(leaf, dev_item);\n\tWARN_ON(device->devid == BTRFS_DEV_REPLACE_DEVID);\n\tdevice->is_tgtdev_for_dev_replace = 0;\n\n\tptr = btrfs_device_uuid(dev_item);\n\tread_extent_buffer(leaf, device->uuid, ptr, BTRFS_UUID_SIZE);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void fill_device_from_item(struct extent_buffer *leaf,\n\t\t\t\t struct btrfs_dev_item *dev_item,\n\t\t\t\t struct btrfs_device *device)\n{\n\tunsigned long ptr;\n\n\tdevice->devid = btrfs_device_id(leaf, dev_item);\n\tdevice->disk_total_bytes = btrfs_device_total_bytes(leaf, dev_item);\n\tdevice->total_bytes = device->disk_total_bytes;\n\tdevice->commit_total_bytes = device->disk_total_bytes;\n\tdevice->bytes_used = btrfs_device_bytes_used(leaf, dev_item);\n\tdevice->commit_bytes_used = device->bytes_used;\n\tdevice->type = btrfs_device_type(leaf, dev_item);\n\tdevice->io_align = btrfs_device_io_align(leaf, dev_item);\n\tdevice->io_width = btrfs_device_io_width(leaf, dev_item);\n\tdevice->sector_size = btrfs_device_sector_size(leaf, dev_item);\n\tWARN_ON(device->devid == BTRFS_DEV_REPLACE_DEVID);\n\tdevice->is_tgtdev_for_dev_replace = 0;\n\n\tptr = btrfs_device_uuid(dev_item);\n\tread_extent_buffer(leaf, device->uuid, ptr, BTRFS_UUID_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_generation",
          "args": [
            "leaf",
            "dev_item"
          ],
          "line": 6241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "device->writeable"
          ],
          "line": 6239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&device->dev_list",
            "&fs_devices->devices"
          ],
          "line": 6227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "device->missing"
          ],
          "line": 6225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "DEGRADED"
          ],
          "line": 6209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_missing_dev",
          "args": [
            "root",
            "fs_devices",
            "devid",
            "dev_uuid"
          ],
          "line": 6205
        },
        "resolved": true,
        "details": {
          "function_name": "add_missing_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5938-5956",
          "snippet": "static struct btrfs_device *add_missing_dev(struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_fs_devices *fs_devices,\n\t\t\t\t\t    u64 devid, u8 *dev_uuid)\n{\n\tstruct btrfs_device *device;\n\n\tdevice = btrfs_alloc_device(NULL, &devid, dev_uuid);\n\tif (IS_ERR(device))\n\t\treturn NULL;\n\n\tlist_add(&device->dev_list, &fs_devices->devices);\n\tdevice->fs_devices = fs_devices;\n\tfs_devices->num_devices++;\n\n\tdevice->missing = 1;\n\tfs_devices->missing_devices++;\n\n\treturn device;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_device *add_missing_dev(struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_fs_devices *fs_devices,\n\t\t\t\t\t    u64 devid, u8 *dev_uuid)\n{\n\tstruct btrfs_device *device;\n\n\tdevice = btrfs_alloc_device(NULL, &devid, dev_uuid);\n\tif (IS_ERR(device))\n\t\treturn NULL;\n\n\tlist_add(&device->dev_list, &fs_devices->devices);\n\tdevice->fs_devices = fs_devices;\n\tfs_devices->num_devices++;\n\n\tdevice->missing = 1;\n\tfs_devices->missing_devices++;\n\n\treturn device;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"devid %llu missing\"",
            "devid"
          ],
          "line": 6204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "DEGRADED"
          ],
          "line": 6201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_device",
          "args": [
            "root->fs_info",
            "devid",
            "dev_uuid",
            "fs_uuid"
          ],
          "line": 6199
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5918-5936",
          "snippet": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fs_devices"
          ],
          "line": 6196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_devices"
          ],
          "line": 6195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_seed_devices",
          "args": [
            "root",
            "fs_uuid"
          ],
          "line": 6194
        },
        "resolved": true,
        "details": {
          "function_name": "open_seed_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6121-6174",
          "snippet": "static struct btrfs_fs_devices *open_seed_devices(struct btrfs_root *root,\n\t\t\t\t\t\t  u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tint ret;\n\n\tBUG_ON(!mutex_is_locked(&uuid_mutex));\n\n\tfs_devices = root->fs_info->fs_devices->seed;\n\twhile (fs_devices) {\n\t\tif (!memcmp(fs_devices->fsid, fsid, BTRFS_UUID_SIZE))\n\t\t\treturn fs_devices;\n\n\t\tfs_devices = fs_devices->seed;\n\t}\n\n\tfs_devices = find_fsid(fsid);\n\tif (!fs_devices) {\n\t\tif (!btrfs_test_opt(root, DEGRADED))\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\tfs_devices = alloc_fs_devices(fsid);\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn fs_devices;\n\n\t\tfs_devices->seeding = 1;\n\t\tfs_devices->opened = 1;\n\t\treturn fs_devices;\n\t}\n\n\tfs_devices = clone_fs_devices(fs_devices);\n\tif (IS_ERR(fs_devices))\n\t\treturn fs_devices;\n\n\tret = __btrfs_open_devices(fs_devices, FMODE_READ,\n\t\t\t\t   root->fs_info->bdev_holder);\n\tif (ret) {\n\t\tfree_fs_devices(fs_devices);\n\t\tfs_devices = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tif (!fs_devices->seeding) {\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t\tfs_devices = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tfs_devices->seed = root->fs_info->fs_devices->seed;\n\troot->fs_info->fs_devices->seed = fs_devices;\nout:\n\treturn fs_devices;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_fs_devices *open_seed_devices(struct btrfs_root *root,\n\t\t\t\t\t\t  u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tint ret;\n\n\tBUG_ON(!mutex_is_locked(&uuid_mutex));\n\n\tfs_devices = root->fs_info->fs_devices->seed;\n\twhile (fs_devices) {\n\t\tif (!memcmp(fs_devices->fsid, fsid, BTRFS_UUID_SIZE))\n\t\t\treturn fs_devices;\n\n\t\tfs_devices = fs_devices->seed;\n\t}\n\n\tfs_devices = find_fsid(fsid);\n\tif (!fs_devices) {\n\t\tif (!btrfs_test_opt(root, DEGRADED))\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\tfs_devices = alloc_fs_devices(fsid);\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn fs_devices;\n\n\t\tfs_devices->seeding = 1;\n\t\tfs_devices->opened = 1;\n\t\treturn fs_devices;\n\t}\n\n\tfs_devices = clone_fs_devices(fs_devices);\n\tif (IS_ERR(fs_devices))\n\t\treturn fs_devices;\n\n\tret = __btrfs_open_devices(fs_devices, FMODE_READ,\n\t\t\t\t   root->fs_info->bdev_holder);\n\tif (ret) {\n\t\tfree_fs_devices(fs_devices);\n\t\tfs_devices = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tif (!fs_devices->seeding) {\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t\tfs_devices = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tfs_devices->seed = root->fs_info->fs_devices->seed;\n\troot->fs_info->fs_devices->seed = fs_devices;\nout:\n\treturn fs_devices;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "fs_uuid",
            "root->fs_info->fsid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 6193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "fs_uuid",
            "btrfs_device_fsid(dev_item)",
            "BTRFS_UUID_SIZE"
          ],
          "line": 6190
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_fsid",
          "args": [
            "dev_item"
          ],
          "line": 6190
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_device_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2352-2355",
          "snippet": "static inline unsigned long btrfs_device_fsid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, fsid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_device_fsid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, fsid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_uuid",
          "args": [
            "dev_item"
          ],
          "line": 6188
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_device_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2347-2350",
          "snippet": "static inline unsigned long btrfs_device_uuid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, uuid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_device_uuid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, uuid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_id",
          "args": [
            "leaf",
            "dev_item"
          ],
          "line": 6187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int read_one_dev(struct btrfs_root *root,\n\t\t\tstruct extent_buffer *leaf,\n\t\t\tstruct btrfs_dev_item *dev_item)\n{\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tu64 devid;\n\tint ret;\n\tu8 fs_uuid[BTRFS_UUID_SIZE];\n\tu8 dev_uuid[BTRFS_UUID_SIZE];\n\n\tdevid = btrfs_device_id(leaf, dev_item);\n\tread_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),\n\t\t\t   BTRFS_UUID_SIZE);\n\tread_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),\n\t\t\t   BTRFS_UUID_SIZE);\n\n\tif (memcmp(fs_uuid, root->fs_info->fsid, BTRFS_UUID_SIZE)) {\n\t\tfs_devices = open_seed_devices(root, fs_uuid);\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn PTR_ERR(fs_devices);\n\t}\n\n\tdevice = btrfs_find_device(root->fs_info, devid, dev_uuid, fs_uuid);\n\tif (!device) {\n\t\tif (!btrfs_test_opt(root, DEGRADED))\n\t\t\treturn -EIO;\n\n\t\tbtrfs_warn(root->fs_info, \"devid %llu missing\", devid);\n\t\tdevice = add_missing_dev(root, fs_devices, devid, dev_uuid);\n\t\tif (!device)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tif (!device->bdev && !btrfs_test_opt(root, DEGRADED))\n\t\t\treturn -EIO;\n\n\t\tif(!device->bdev && !device->missing) {\n\t\t\t/*\n\t\t\t * this happens when a device that was properly setup\n\t\t\t * in the device info lists suddenly goes bad.\n\t\t\t * device->bdev is NULL, and so we have to set\n\t\t\t * device->missing to one here\n\t\t\t */\n\t\t\tdevice->fs_devices->missing_devices++;\n\t\t\tdevice->missing = 1;\n\t\t}\n\n\t\t/* Move the device to its own fs_devices */\n\t\tif (device->fs_devices != fs_devices) {\n\t\t\tASSERT(device->missing);\n\n\t\t\tlist_move(&device->dev_list, &fs_devices->devices);\n\t\t\tdevice->fs_devices->num_devices--;\n\t\t\tfs_devices->num_devices++;\n\n\t\t\tdevice->fs_devices->missing_devices--;\n\t\t\tfs_devices->missing_devices++;\n\n\t\t\tdevice->fs_devices = fs_devices;\n\t\t}\n\t}\n\n\tif (device->fs_devices != root->fs_info->fs_devices) {\n\t\tBUG_ON(device->writeable);\n\t\tif (device->generation !=\n\t\t    btrfs_device_generation(leaf, dev_item))\n\t\t\treturn -EINVAL;\n\t}\n\n\tfill_device_from_item(leaf, dev_item, device);\n\tdevice->in_fs_metadata = 1;\n\tif (device->writeable && !device->is_tgtdev_for_dev_replace) {\n\t\tdevice->fs_devices->total_rw_bytes += device->total_bytes;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space += device->total_bytes -\n\t\t\tdevice->bytes_used;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t}\n\tret = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "open_seed_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6121-6174",
    "snippet": "static struct btrfs_fs_devices *open_seed_devices(struct btrfs_root *root,\n\t\t\t\t\t\t  u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tint ret;\n\n\tBUG_ON(!mutex_is_locked(&uuid_mutex));\n\n\tfs_devices = root->fs_info->fs_devices->seed;\n\twhile (fs_devices) {\n\t\tif (!memcmp(fs_devices->fsid, fsid, BTRFS_UUID_SIZE))\n\t\t\treturn fs_devices;\n\n\t\tfs_devices = fs_devices->seed;\n\t}\n\n\tfs_devices = find_fsid(fsid);\n\tif (!fs_devices) {\n\t\tif (!btrfs_test_opt(root, DEGRADED))\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\tfs_devices = alloc_fs_devices(fsid);\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn fs_devices;\n\n\t\tfs_devices->seeding = 1;\n\t\tfs_devices->opened = 1;\n\t\treturn fs_devices;\n\t}\n\n\tfs_devices = clone_fs_devices(fs_devices);\n\tif (IS_ERR(fs_devices))\n\t\treturn fs_devices;\n\n\tret = __btrfs_open_devices(fs_devices, FMODE_READ,\n\t\t\t\t   root->fs_info->bdev_holder);\n\tif (ret) {\n\t\tfree_fs_devices(fs_devices);\n\t\tfs_devices = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tif (!fs_devices->seeding) {\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t\tfs_devices = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tfs_devices->seed = root->fs_info->fs_devices->seed;\n\troot->fs_info->fs_devices->seed = fs_devices;\nout:\n\treturn fs_devices;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 6166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_fs_devices",
          "args": [
            "fs_devices"
          ],
          "line": 6165
        },
        "resolved": true,
        "details": {
          "function_name": "free_fs_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "99-111",
          "snippet": "static void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_close_devices",
          "args": [
            "fs_devices"
          ],
          "line": 6164
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_close_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "696-744",
          "snippet": "static int __btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\n\tif (--fs_devices->opened > 0)\n\t\treturn 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tstruct btrfs_device *new_device;\n\t\tstruct rcu_string *name;\n\n\t\tif (device->bdev)\n\t\t\tfs_devices->open_devices--;\n\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tfs_devices->rw_devices--;\n\t\t}\n\n\t\tif (device->missing)\n\t\t\tfs_devices->missing_devices--;\n\n\t\tnew_device = btrfs_alloc_device(NULL, &device->devid,\n\t\t\t\t\t\tdevice->uuid);\n\t\tBUG_ON(IS_ERR(new_device)); /* -ENOMEM */\n\n\t\t/* Safe because we are under uuid_mutex */\n\t\tif (device->name) {\n\t\t\tname = rcu_string_strdup(device->name->str, GFP_NOFS);\n\t\t\tBUG_ON(!name); /* -ENOMEM */\n\t\t\trcu_assign_pointer(new_device->name, name);\n\t\t}\n\n\t\tlist_replace_rcu(&device->dev_list, &new_device->dev_list);\n\t\tnew_device->fs_devices = device->fs_devices;\n\n\t\tcall_rcu(&device->rcu, free_device);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tWARN_ON(fs_devices->open_devices);\n\tWARN_ON(fs_devices->rw_devices);\n\tfs_devices->opened = 0;\n\tfs_devices->seeding = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\n\tif (--fs_devices->opened > 0)\n\t\treturn 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tstruct btrfs_device *new_device;\n\t\tstruct rcu_string *name;\n\n\t\tif (device->bdev)\n\t\t\tfs_devices->open_devices--;\n\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tfs_devices->rw_devices--;\n\t\t}\n\n\t\tif (device->missing)\n\t\t\tfs_devices->missing_devices--;\n\n\t\tnew_device = btrfs_alloc_device(NULL, &device->devid,\n\t\t\t\t\t\tdevice->uuid);\n\t\tBUG_ON(IS_ERR(new_device)); /* -ENOMEM */\n\n\t\t/* Safe because we are under uuid_mutex */\n\t\tif (device->name) {\n\t\t\tname = rcu_string_strdup(device->name->str, GFP_NOFS);\n\t\t\tBUG_ON(!name); /* -ENOMEM */\n\t\t\trcu_assign_pointer(new_device->name, name);\n\t\t}\n\n\t\tlist_replace_rcu(&device->dev_list, &new_device->dev_list);\n\t\tnew_device->fs_devices = device->fs_devices;\n\n\t\tcall_rcu(&device->rcu, free_device);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tWARN_ON(fs_devices->open_devices);\n\tWARN_ON(fs_devices->rw_devices);\n\tfs_devices->opened = 0;\n\tfs_devices->seeding = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 6159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_open_devices",
          "args": [
            "fs_devices",
            "FMODE_READ",
            "root->fs_info->bdev_holder"
          ],
          "line": 6155
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_open_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "774-858",
          "snippet": "static int __btrfs_open_devices(struct btrfs_fs_devices *fs_devices,\n\t\t\t\tfmode_t flags, void *holder)\n{\n\tstruct request_queue *q;\n\tstruct block_device *bdev;\n\tstruct list_head *head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *latest_dev = NULL;\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tint seeding = 1;\n\tint ret = 0;\n\n\tflags |= FMODE_EXCL;\n\n\tlist_for_each_entry(device, head, dev_list) {\n\t\tif (device->bdev)\n\t\t\tcontinue;\n\t\tif (!device->name)\n\t\t\tcontinue;\n\n\t\t/* Just open everything we can; ignore failures here */\n\t\tif (btrfs_get_bdev_and_sb(device->name->str, flags, holder, 1,\n\t\t\t\t\t    &bdev, &bh))\n\t\t\tcontinue;\n\n\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\t\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\t\tif (devid != device->devid)\n\t\t\tgoto error_brelse;\n\n\t\tif (memcmp(device->uuid, disk_super->dev_item.uuid,\n\t\t\t   BTRFS_UUID_SIZE))\n\t\t\tgoto error_brelse;\n\n\t\tdevice->generation = btrfs_super_generation(disk_super);\n\t\tif (!latest_dev ||\n\t\t    device->generation > latest_dev->generation)\n\t\t\tlatest_dev = device;\n\n\t\tif (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_SEEDING) {\n\t\t\tdevice->writeable = 0;\n\t\t} else {\n\t\t\tdevice->writeable = !bdev_read_only(bdev);\n\t\t\tseeding = 0;\n\t\t}\n\n\t\tq = bdev_get_queue(bdev);\n\t\tif (blk_queue_discard(q))\n\t\t\tdevice->can_discard = 1;\n\n\t\tdevice->bdev = bdev;\n\t\tdevice->in_fs_metadata = 0;\n\t\tdevice->mode = flags;\n\n\t\tif (!blk_queue_nonrot(bdev_get_queue(bdev)))\n\t\t\tfs_devices->rotating = 1;\n\n\t\tfs_devices->open_devices++;\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tfs_devices->rw_devices++;\n\t\t\tlist_add(&device->dev_alloc_list,\n\t\t\t\t &fs_devices->alloc_list);\n\t\t}\n\t\tbrelse(bh);\n\t\tcontinue;\n\nerror_brelse:\n\t\tbrelse(bh);\n\t\tblkdev_put(bdev, flags);\n\t\tcontinue;\n\t}\n\tif (fs_devices->open_devices == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfs_devices->seeding = seeding;\n\tfs_devices->opened = 1;\n\tfs_devices->latest_bdev = latest_dev->bdev;\n\tfs_devices->total_rw_bytes = 0;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_open_devices(struct btrfs_fs_devices *fs_devices,\n\t\t\t\tfmode_t flags, void *holder)\n{\n\tstruct request_queue *q;\n\tstruct block_device *bdev;\n\tstruct list_head *head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *latest_dev = NULL;\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tint seeding = 1;\n\tint ret = 0;\n\n\tflags |= FMODE_EXCL;\n\n\tlist_for_each_entry(device, head, dev_list) {\n\t\tif (device->bdev)\n\t\t\tcontinue;\n\t\tif (!device->name)\n\t\t\tcontinue;\n\n\t\t/* Just open everything we can; ignore failures here */\n\t\tif (btrfs_get_bdev_and_sb(device->name->str, flags, holder, 1,\n\t\t\t\t\t    &bdev, &bh))\n\t\t\tcontinue;\n\n\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\t\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\t\tif (devid != device->devid)\n\t\t\tgoto error_brelse;\n\n\t\tif (memcmp(device->uuid, disk_super->dev_item.uuid,\n\t\t\t   BTRFS_UUID_SIZE))\n\t\t\tgoto error_brelse;\n\n\t\tdevice->generation = btrfs_super_generation(disk_super);\n\t\tif (!latest_dev ||\n\t\t    device->generation > latest_dev->generation)\n\t\t\tlatest_dev = device;\n\n\t\tif (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_SEEDING) {\n\t\t\tdevice->writeable = 0;\n\t\t} else {\n\t\t\tdevice->writeable = !bdev_read_only(bdev);\n\t\t\tseeding = 0;\n\t\t}\n\n\t\tq = bdev_get_queue(bdev);\n\t\tif (blk_queue_discard(q))\n\t\t\tdevice->can_discard = 1;\n\n\t\tdevice->bdev = bdev;\n\t\tdevice->in_fs_metadata = 0;\n\t\tdevice->mode = flags;\n\n\t\tif (!blk_queue_nonrot(bdev_get_queue(bdev)))\n\t\t\tfs_devices->rotating = 1;\n\n\t\tfs_devices->open_devices++;\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tfs_devices->rw_devices++;\n\t\t\tlist_add(&device->dev_alloc_list,\n\t\t\t\t &fs_devices->alloc_list);\n\t\t}\n\t\tbrelse(bh);\n\t\tcontinue;\n\nerror_brelse:\n\t\tbrelse(bh);\n\t\tblkdev_put(bdev, flags);\n\t\tcontinue;\n\t}\n\tif (fs_devices->open_devices == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfs_devices->seeding = seeding;\n\tfs_devices->opened = 1;\n\tfs_devices->latest_bdev = latest_dev->bdev;\n\tfs_devices->total_rw_bytes = 0;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_devices"
          ],
          "line": 6152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone_fs_devices",
          "args": [
            "fs_devices"
          ],
          "line": 6151
        },
        "resolved": true,
        "details": {
          "function_name": "clone_fs_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "565-610",
          "snippet": "static struct btrfs_fs_devices *clone_fs_devices(struct btrfs_fs_devices *orig)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *orig_dev;\n\n\tfs_devices = alloc_fs_devices(orig->fsid);\n\tif (IS_ERR(fs_devices))\n\t\treturn fs_devices;\n\n\tmutex_lock(&orig->device_list_mutex);\n\tfs_devices->total_devices = orig->total_devices;\n\n\t/* We have held the volume lock, it is safe to get the devices. */\n\tlist_for_each_entry(orig_dev, &orig->devices, dev_list) {\n\t\tstruct rcu_string *name;\n\n\t\tdevice = btrfs_alloc_device(NULL, &orig_dev->devid,\n\t\t\t\t\t    orig_dev->uuid);\n\t\tif (IS_ERR(device))\n\t\t\tgoto error;\n\n\t\t/*\n\t\t * This is ok to do without rcu read locked because we hold the\n\t\t * uuid mutex so nothing we touch in here is going to disappear.\n\t\t */\n\t\tif (orig_dev->name) {\n\t\t\tname = rcu_string_strdup(orig_dev->name->str, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\tkfree(device);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\trcu_assign_pointer(device->name, name);\n\t\t}\n\n\t\tlist_add(&device->dev_list, &fs_devices->devices);\n\t\tdevice->fs_devices = fs_devices;\n\t\tfs_devices->num_devices++;\n\t}\n\tmutex_unlock(&orig->device_list_mutex);\n\treturn fs_devices;\nerror:\n\tmutex_unlock(&orig->device_list_mutex);\n\tfree_fs_devices(fs_devices);\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_fs_devices *clone_fs_devices(struct btrfs_fs_devices *orig)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *orig_dev;\n\n\tfs_devices = alloc_fs_devices(orig->fsid);\n\tif (IS_ERR(fs_devices))\n\t\treturn fs_devices;\n\n\tmutex_lock(&orig->device_list_mutex);\n\tfs_devices->total_devices = orig->total_devices;\n\n\t/* We have held the volume lock, it is safe to get the devices. */\n\tlist_for_each_entry(orig_dev, &orig->devices, dev_list) {\n\t\tstruct rcu_string *name;\n\n\t\tdevice = btrfs_alloc_device(NULL, &orig_dev->devid,\n\t\t\t\t\t    orig_dev->uuid);\n\t\tif (IS_ERR(device))\n\t\t\tgoto error;\n\n\t\t/*\n\t\t * This is ok to do without rcu read locked because we hold the\n\t\t * uuid mutex so nothing we touch in here is going to disappear.\n\t\t */\n\t\tif (orig_dev->name) {\n\t\t\tname = rcu_string_strdup(orig_dev->name->str, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\tkfree(device);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\trcu_assign_pointer(device->name, name);\n\t\t}\n\n\t\tlist_add(&device->dev_list, &fs_devices->devices);\n\t\tdevice->fs_devices = fs_devices;\n\t\tfs_devices->num_devices++;\n\t}\n\tmutex_unlock(&orig->device_list_mutex);\n\treturn fs_devices;\nerror:\n\tmutex_unlock(&orig->device_list_mutex);\n\tfree_fs_devices(fs_devices);\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_devices"
          ],
          "line": 6143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_fs_devices",
          "args": [
            "fsid"
          ],
          "line": 6142
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_fs_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "83-97",
          "snippet": "static struct btrfs_fs_devices *alloc_fs_devices(const u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = __alloc_fs_devices();\n\tif (IS_ERR(fs_devs))\n\t\treturn fs_devs;\n\n\tif (fsid)\n\t\tmemcpy(fs_devs->fsid, fsid, BTRFS_FSID_SIZE);\n\telse\n\t\tgenerate_random_uuid(fs_devs->fsid);\n\n\treturn fs_devs;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_fs_devices *alloc_fs_devices(const u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = __alloc_fs_devices();\n\tif (IS_ERR(fs_devs))\n\t\treturn fs_devs;\n\n\tif (fsid)\n\t\tmemcpy(fs_devs->fsid, fsid, BTRFS_FSID_SIZE);\n\telse\n\t\tgenerate_random_uuid(fs_devs->fsid);\n\n\treturn fs_devs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 6140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "DEGRADED"
          ],
          "line": 6139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_fsid",
          "args": [
            "fsid"
          ],
          "line": 6137
        },
        "resolved": true,
        "details": {
          "function_name": "find_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "175-184",
          "snippet": "btrfs_fs_devices *find_fsid(u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\tlist_for_each_entry(fs_devices, &fs_uuids, list) {\n\t\tif (memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE) == 0)\n\t\t\treturn fs_devices;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nbtrfs_fs_devices *find_fsid(u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\tlist_for_each_entry(fs_devices, &fs_uuids, list) {\n\t\tif (memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE) == 0)\n\t\t\treturn fs_devices;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "fs_devices->fsid",
            "fsid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 6131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&uuid_mutex)"
          ],
          "line": 6127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&uuid_mutex"
          ],
          "line": 6127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_fs_devices *open_seed_devices(struct btrfs_root *root,\n\t\t\t\t\t\t  u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tint ret;\n\n\tBUG_ON(!mutex_is_locked(&uuid_mutex));\n\n\tfs_devices = root->fs_info->fs_devices->seed;\n\twhile (fs_devices) {\n\t\tif (!memcmp(fs_devices->fsid, fsid, BTRFS_UUID_SIZE))\n\t\t\treturn fs_devices;\n\n\t\tfs_devices = fs_devices->seed;\n\t}\n\n\tfs_devices = find_fsid(fsid);\n\tif (!fs_devices) {\n\t\tif (!btrfs_test_opt(root, DEGRADED))\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\tfs_devices = alloc_fs_devices(fsid);\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn fs_devices;\n\n\t\tfs_devices->seeding = 1;\n\t\tfs_devices->opened = 1;\n\t\treturn fs_devices;\n\t}\n\n\tfs_devices = clone_fs_devices(fs_devices);\n\tif (IS_ERR(fs_devices))\n\t\treturn fs_devices;\n\n\tret = __btrfs_open_devices(fs_devices, FMODE_READ,\n\t\t\t\t   root->fs_info->bdev_holder);\n\tif (ret) {\n\t\tfree_fs_devices(fs_devices);\n\t\tfs_devices = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tif (!fs_devices->seeding) {\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t\tfs_devices = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tfs_devices->seed = root->fs_info->fs_devices->seed;\n\troot->fs_info->fs_devices->seed = fs_devices;\nout:\n\treturn fs_devices;\n}"
  },
  {
    "function_name": "fill_device_from_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6098-6119",
    "snippet": "static void fill_device_from_item(struct extent_buffer *leaf,\n\t\t\t\t struct btrfs_dev_item *dev_item,\n\t\t\t\t struct btrfs_device *device)\n{\n\tunsigned long ptr;\n\n\tdevice->devid = btrfs_device_id(leaf, dev_item);\n\tdevice->disk_total_bytes = btrfs_device_total_bytes(leaf, dev_item);\n\tdevice->total_bytes = device->disk_total_bytes;\n\tdevice->commit_total_bytes = device->disk_total_bytes;\n\tdevice->bytes_used = btrfs_device_bytes_used(leaf, dev_item);\n\tdevice->commit_bytes_used = device->bytes_used;\n\tdevice->type = btrfs_device_type(leaf, dev_item);\n\tdevice->io_align = btrfs_device_io_align(leaf, dev_item);\n\tdevice->io_width = btrfs_device_io_width(leaf, dev_item);\n\tdevice->sector_size = btrfs_device_sector_size(leaf, dev_item);\n\tWARN_ON(device->devid == BTRFS_DEV_REPLACE_DEVID);\n\tdevice->is_tgtdev_for_dev_replace = 0;\n\n\tptr = btrfs_device_uuid(dev_item);\n\tread_extent_buffer(leaf, device->uuid, ptr, BTRFS_UUID_SIZE);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "device->uuid",
            "ptr",
            "BTRFS_UUID_SIZE"
          ],
          "line": 6118
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_uuid",
          "args": [
            "dev_item"
          ],
          "line": 6117
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_device_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2347-2350",
          "snippet": "static inline unsigned long btrfs_device_uuid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, uuid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_device_uuid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, uuid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "device->devid == BTRFS_DEV_REPLACE_DEVID"
          ],
          "line": 6114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_sector_size",
          "args": [
            "leaf",
            "dev_item"
          ],
          "line": 6113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_io_width",
          "args": [
            "leaf",
            "dev_item"
          ],
          "line": 6112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_io_align",
          "args": [
            "leaf",
            "dev_item"
          ],
          "line": 6111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_type",
          "args": [
            "leaf",
            "dev_item"
          ],
          "line": 6110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_bytes_used",
          "args": [
            "leaf",
            "dev_item"
          ],
          "line": 6108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_total_bytes",
          "args": [
            "leaf",
            "dev_item"
          ],
          "line": 6105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_id",
          "args": [
            "leaf",
            "dev_item"
          ],
          "line": 6104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void fill_device_from_item(struct extent_buffer *leaf,\n\t\t\t\t struct btrfs_dev_item *dev_item,\n\t\t\t\t struct btrfs_device *device)\n{\n\tunsigned long ptr;\n\n\tdevice->devid = btrfs_device_id(leaf, dev_item);\n\tdevice->disk_total_bytes = btrfs_device_total_bytes(leaf, dev_item);\n\tdevice->total_bytes = device->disk_total_bytes;\n\tdevice->commit_total_bytes = device->disk_total_bytes;\n\tdevice->bytes_used = btrfs_device_bytes_used(leaf, dev_item);\n\tdevice->commit_bytes_used = device->bytes_used;\n\tdevice->type = btrfs_device_type(leaf, dev_item);\n\tdevice->io_align = btrfs_device_io_align(leaf, dev_item);\n\tdevice->io_width = btrfs_device_io_width(leaf, dev_item);\n\tdevice->sector_size = btrfs_device_sector_size(leaf, dev_item);\n\tWARN_ON(device->devid == BTRFS_DEV_REPLACE_DEVID);\n\tdevice->is_tgtdev_for_dev_replace = 0;\n\n\tptr = btrfs_device_uuid(dev_item);\n\tread_extent_buffer(leaf, device->uuid, ptr, BTRFS_UUID_SIZE);\n}"
  },
  {
    "function_name": "read_one_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "6009-6096",
    "snippet": "static int read_one_chunk(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t  struct extent_buffer *leaf,\n\t\t\t  struct btrfs_chunk *chunk)\n{\n\tstruct btrfs_mapping_tree *map_tree = &root->fs_info->mapping_tree;\n\tstruct map_lookup *map;\n\tstruct extent_map *em;\n\tu64 logical;\n\tu64 length;\n\tu64 devid;\n\tu8 uuid[BTRFS_UUID_SIZE];\n\tint num_stripes;\n\tint ret;\n\tint i;\n\n\tlogical = key->offset;\n\tlength = btrfs_chunk_length(leaf, chunk);\n\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, logical, 1);\n\tread_unlock(&map_tree->map_tree.lock);\n\n\t/* already mapped? */\n\tif (em && em->start <= logical && em->start + em->len > logical) {\n\t\tfree_extent_map(em);\n\t\treturn 0;\n\t} else if (em) {\n\t\tfree_extent_map(em);\n\t}\n\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn -ENOMEM;\n\tnum_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tmap = kmalloc(map_lookup_size(num_stripes), GFP_NOFS);\n\tif (!map) {\n\t\tfree_extent_map(em);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_bit(EXTENT_FLAG_FS_MAPPING, &em->flags);\n\tem->bdev = (struct block_device *)map;\n\tem->start = logical;\n\tem->len = length;\n\tem->orig_start = 0;\n\tem->block_start = 0;\n\tem->block_len = em->len;\n\n\tmap->num_stripes = num_stripes;\n\tmap->io_width = btrfs_chunk_io_width(leaf, chunk);\n\tmap->io_align = btrfs_chunk_io_align(leaf, chunk);\n\tmap->sector_size = btrfs_chunk_sector_size(leaf, chunk);\n\tmap->stripe_len = btrfs_chunk_stripe_len(leaf, chunk);\n\tmap->type = btrfs_chunk_type(leaf, chunk);\n\tmap->sub_stripes = btrfs_chunk_sub_stripes(leaf, chunk);\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tmap->stripes[i].physical =\n\t\t\tbtrfs_stripe_offset_nr(leaf, chunk, i);\n\t\tdevid = btrfs_stripe_devid_nr(leaf, chunk, i);\n\t\tread_extent_buffer(leaf, uuid, (unsigned long)\n\t\t\t\t   btrfs_stripe_dev_uuid_nr(chunk, i),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tmap->stripes[i].dev = btrfs_find_device(root->fs_info, devid,\n\t\t\t\t\t\t\tuuid, NULL);\n\t\tif (!map->stripes[i].dev && !btrfs_test_opt(root, DEGRADED)) {\n\t\t\tfree_extent_map(em);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!map->stripes[i].dev) {\n\t\t\tmap->stripes[i].dev =\n\t\t\t\tadd_missing_dev(root, root->fs_info->fs_devices,\n\t\t\t\t\t\tdevid, uuid);\n\t\t\tif (!map->stripes[i].dev) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tmap->stripes[i].dev->in_fs_metadata = 1;\n\t}\n\n\twrite_lock(&map_tree->map_tree.lock);\n\tret = add_extent_mapping(&map_tree->map_tree, em, 0);\n\twrite_unlock(&map_tree->map_tree.lock);\n\tBUG_ON(ret); /* Tree corruption */\n\tfree_extent_map(em);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 6093
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 6092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&map_tree->map_tree.lock"
          ],
          "line": 6091
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_extent_mapping",
          "args": [
            "&map_tree->map_tree",
            "em",
            "0"
          ],
          "line": 6090
        },
        "resolved": true,
        "details": {
          "function_name": "add_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "345-357",
          "snippet": "int add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&map_tree->map_tree.lock"
          ],
          "line": 6089
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_missing_dev",
          "args": [
            "root",
            "root->fs_info->fs_devices",
            "devid",
            "uuid"
          ],
          "line": 6079
        },
        "resolved": true,
        "details": {
          "function_name": "add_missing_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5938-5956",
          "snippet": "static struct btrfs_device *add_missing_dev(struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_fs_devices *fs_devices,\n\t\t\t\t\t    u64 devid, u8 *dev_uuid)\n{\n\tstruct btrfs_device *device;\n\n\tdevice = btrfs_alloc_device(NULL, &devid, dev_uuid);\n\tif (IS_ERR(device))\n\t\treturn NULL;\n\n\tlist_add(&device->dev_list, &fs_devices->devices);\n\tdevice->fs_devices = fs_devices;\n\tfs_devices->num_devices++;\n\n\tdevice->missing = 1;\n\tfs_devices->missing_devices++;\n\n\treturn device;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_device *add_missing_dev(struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_fs_devices *fs_devices,\n\t\t\t\t\t    u64 devid, u8 *dev_uuid)\n{\n\tstruct btrfs_device *device;\n\n\tdevice = btrfs_alloc_device(NULL, &devid, dev_uuid);\n\tif (IS_ERR(device))\n\t\treturn NULL;\n\n\tlist_add(&device->dev_list, &fs_devices->devices);\n\tdevice->fs_devices = fs_devices;\n\tfs_devices->num_devices++;\n\n\tdevice->missing = 1;\n\tfs_devices->missing_devices++;\n\n\treturn device;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "DEGRADED"
          ],
          "line": 6073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_device",
          "args": [
            "root->fs_info",
            "devid",
            "uuid",
            "NULL"
          ],
          "line": 6071
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5918-5936",
          "snippet": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "uuid",
            "(unsigned long)\n\t\t\t\t   btrfs_stripe_dev_uuid_nr(chunk, i)",
            "BTRFS_UUID_SIZE"
          ],
          "line": 6068
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stripe_dev_uuid_nr",
          "args": [
            "chunk",
            "i"
          ],
          "line": 6069
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_stripe_dev_uuid_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2401-2404",
          "snippet": "static inline char *btrfs_stripe_dev_uuid_nr(struct btrfs_chunk *c, int nr)\n{\n\treturn btrfs_stripe_dev_uuid(btrfs_stripe_nr(c, nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline char *btrfs_stripe_dev_uuid_nr(struct btrfs_chunk *c, int nr)\n{\n\treturn btrfs_stripe_dev_uuid(btrfs_stripe_nr(c, nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stripe_devid_nr",
          "args": [
            "leaf",
            "chunk",
            "i"
          ],
          "line": 6067
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_stripe_devid_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2412-2416",
          "snippet": "static inline u64 btrfs_stripe_devid_nr(struct extent_buffer *eb,\n\t\t\t\t\t struct btrfs_chunk *c, int nr)\n{\n\treturn btrfs_stripe_devid(eb, btrfs_stripe_nr(c, nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_stripe_devid_nr(struct extent_buffer *eb,\n\t\t\t\t\t struct btrfs_chunk *c, int nr)\n{\n\treturn btrfs_stripe_devid(eb, btrfs_stripe_nr(c, nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stripe_offset_nr",
          "args": [
            "leaf",
            "chunk",
            "i"
          ],
          "line": 6066
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_stripe_offset_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2406-2410",
          "snippet": "static inline u64 btrfs_stripe_offset_nr(struct extent_buffer *eb,\n\t\t\t\t\t struct btrfs_chunk *c, int nr)\n{\n\treturn btrfs_stripe_offset(eb, btrfs_stripe_nr(c, nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_stripe_offset_nr(struct extent_buffer *eb,\n\t\t\t\t\t struct btrfs_chunk *c, int nr)\n{\n\treturn btrfs_stripe_offset(eb, btrfs_stripe_nr(c, nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_sub_stripes",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 6063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_type",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 6062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_stripe_len",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 6061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_sector_size",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 6060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_io_align",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 6059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_io_width",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 6058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_FLAG_FS_MAPPING",
            "&em->flags"
          ],
          "line": 6049
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "map_lookup_size(num_stripes)",
            "GFP_NOFS"
          ],
          "line": 6043
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_lookup_size",
          "args": [
            "num_stripes"
          ],
          "line": 6043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_num_stripes",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 6042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_extent_map",
          "args": [],
          "line": 6039
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "48-61",
          "snippet": "struct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nstruct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&map_tree->map_tree.lock"
          ],
          "line": 6029
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "&map_tree->map_tree",
            "logical",
            "1"
          ],
          "line": 6028
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&map_tree->map_tree.lock"
          ],
          "line": 6027
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_length",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 6025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int read_one_chunk(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t  struct extent_buffer *leaf,\n\t\t\t  struct btrfs_chunk *chunk)\n{\n\tstruct btrfs_mapping_tree *map_tree = &root->fs_info->mapping_tree;\n\tstruct map_lookup *map;\n\tstruct extent_map *em;\n\tu64 logical;\n\tu64 length;\n\tu64 devid;\n\tu8 uuid[BTRFS_UUID_SIZE];\n\tint num_stripes;\n\tint ret;\n\tint i;\n\n\tlogical = key->offset;\n\tlength = btrfs_chunk_length(leaf, chunk);\n\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, logical, 1);\n\tread_unlock(&map_tree->map_tree.lock);\n\n\t/* already mapped? */\n\tif (em && em->start <= logical && em->start + em->len > logical) {\n\t\tfree_extent_map(em);\n\t\treturn 0;\n\t} else if (em) {\n\t\tfree_extent_map(em);\n\t}\n\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn -ENOMEM;\n\tnum_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tmap = kmalloc(map_lookup_size(num_stripes), GFP_NOFS);\n\tif (!map) {\n\t\tfree_extent_map(em);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_bit(EXTENT_FLAG_FS_MAPPING, &em->flags);\n\tem->bdev = (struct block_device *)map;\n\tem->start = logical;\n\tem->len = length;\n\tem->orig_start = 0;\n\tem->block_start = 0;\n\tem->block_len = em->len;\n\n\tmap->num_stripes = num_stripes;\n\tmap->io_width = btrfs_chunk_io_width(leaf, chunk);\n\tmap->io_align = btrfs_chunk_io_align(leaf, chunk);\n\tmap->sector_size = btrfs_chunk_sector_size(leaf, chunk);\n\tmap->stripe_len = btrfs_chunk_stripe_len(leaf, chunk);\n\tmap->type = btrfs_chunk_type(leaf, chunk);\n\tmap->sub_stripes = btrfs_chunk_sub_stripes(leaf, chunk);\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tmap->stripes[i].physical =\n\t\t\tbtrfs_stripe_offset_nr(leaf, chunk, i);\n\t\tdevid = btrfs_stripe_devid_nr(leaf, chunk, i);\n\t\tread_extent_buffer(leaf, uuid, (unsigned long)\n\t\t\t\t   btrfs_stripe_dev_uuid_nr(chunk, i),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tmap->stripes[i].dev = btrfs_find_device(root->fs_info, devid,\n\t\t\t\t\t\t\tuuid, NULL);\n\t\tif (!map->stripes[i].dev && !btrfs_test_opt(root, DEGRADED)) {\n\t\t\tfree_extent_map(em);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!map->stripes[i].dev) {\n\t\t\tmap->stripes[i].dev =\n\t\t\t\tadd_missing_dev(root, root->fs_info->fs_devices,\n\t\t\t\t\t\tdevid, uuid);\n\t\t\tif (!map->stripes[i].dev) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tmap->stripes[i].dev->in_fs_metadata = 1;\n\t}\n\n\twrite_lock(&map_tree->map_tree.lock);\n\tret = add_extent_mapping(&map_tree->map_tree, em, 0);\n\twrite_unlock(&map_tree->map_tree.lock);\n\tBUG_ON(ret); /* Tree corruption */\n\tfree_extent_map(em);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_alloc_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5971-6007",
    "snippet": "struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&dev->work",
            "btrfs_submit_helper",
            "pending_bios_fn",
            "NULL",
            "NULL"
          ],
          "line": 6003
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generate_random_uuid",
          "args": [
            "dev->uuid"
          ],
          "line": 6001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dev->uuid",
            "uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 5999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 5993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dev"
          ],
          "line": 5992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_devid",
          "args": [
            "fs_info",
            "&tmp"
          ],
          "line": 5990
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_devid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1383-1419",
          "snippet": "static noinline int find_next_devid(struct btrfs_fs_info *fs_info,\n\t\t\t\t    u64 *devid_ret)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->chunk_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tBUG_ON(ret == 0); /* Corruption */\n\n\tret = btrfs_previous_item(fs_info->chunk_root, path,\n\t\t\t\t  BTRFS_DEV_ITEMS_OBJECTID,\n\t\t\t\t  BTRFS_DEV_ITEM_KEY);\n\tif (ret) {\n\t\t*devid_ret = 1;\n\t} else {\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\t*devid_ret = found_key.offset + 1;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline int find_next_devid(struct btrfs_fs_info *fs_info,\n\t\t\t\t    u64 *devid_ret)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->chunk_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tBUG_ON(ret == 0); /* Corruption */\n\n\tret = btrfs_previous_item(fs_info->chunk_root, path,\n\t\t\t\t  BTRFS_DEV_ITEMS_OBJECTID,\n\t\t\t\t  BTRFS_DEV_ITEM_KEY);\n\tif (ret) {\n\t\t*devid_ret = 1;\n\t} else {\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\t*devid_ret = found_key.offset + 1;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dev"
          ],
          "line": 5982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_device",
          "args": [],
          "line": 5981
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "138-159",
          "snippet": "static struct btrfs_device *__alloc_device(void)\n{\n\tstruct btrfs_device *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_NOFS);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&dev->dev_list);\n\tINIT_LIST_HEAD(&dev->dev_alloc_list);\n\tINIT_LIST_HEAD(&dev->resized_list);\n\n\tspin_lock_init(&dev->io_lock);\n\n\tspin_lock_init(&dev->reada_lock);\n\tatomic_set(&dev->reada_in_flight, 0);\n\tatomic_set(&dev->dev_stats_ccnt, 0);\n\tINIT_RADIX_TREE(&dev->reada_zones, GFP_NOFS & ~__GFP_WAIT);\n\tINIT_RADIX_TREE(&dev->reada_extents, GFP_NOFS & ~__GFP_WAIT);\n\n\treturn dev;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_device *__alloc_device(void)\n{\n\tstruct btrfs_device *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_NOFS);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&dev->dev_list);\n\tINIT_LIST_HEAD(&dev->dev_alloc_list);\n\tINIT_LIST_HEAD(&dev->resized_list);\n\n\tspin_lock_init(&dev->io_lock);\n\n\tspin_lock_init(&dev->reada_lock);\n\tatomic_set(&dev->reada_in_flight, 0);\n\tatomic_set(&dev->dev_stats_ccnt, 0);\n\tINIT_RADIX_TREE(&dev->reada_zones, GFP_NOFS & ~__GFP_WAIT);\n\tINIT_RADIX_TREE(&dev->reada_extents, GFP_NOFS & ~__GFP_WAIT);\n\n\treturn dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 5979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!devid && !fs_info"
          ],
          "line": 5978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}"
  },
  {
    "function_name": "add_missing_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5938-5956",
    "snippet": "static struct btrfs_device *add_missing_dev(struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_fs_devices *fs_devices,\n\t\t\t\t\t    u64 devid, u8 *dev_uuid)\n{\n\tstruct btrfs_device *device;\n\n\tdevice = btrfs_alloc_device(NULL, &devid, dev_uuid);\n\tif (IS_ERR(device))\n\t\treturn NULL;\n\n\tlist_add(&device->dev_list, &fs_devices->devices);\n\tdevice->fs_devices = fs_devices;\n\tfs_devices->num_devices++;\n\n\tdevice->missing = 1;\n\tfs_devices->missing_devices++;\n\n\treturn device;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&device->dev_list",
            "&fs_devices->devices"
          ],
          "line": 5948
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "device"
          ],
          "line": 5945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_device",
          "args": [
            "NULL",
            "&devid",
            "dev_uuid"
          ],
          "line": 5944
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5971-6007",
          "snippet": "struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_device *add_missing_dev(struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_fs_devices *fs_devices,\n\t\t\t\t\t    u64 devid, u8 *dev_uuid)\n{\n\tstruct btrfs_device *device;\n\n\tdevice = btrfs_alloc_device(NULL, &devid, dev_uuid);\n\tif (IS_ERR(device))\n\t\treturn NULL;\n\n\tlist_add(&device->dev_list, &fs_devices->devices);\n\tdevice->fs_devices = fs_devices;\n\tfs_devices->num_devices++;\n\n\tdevice->missing = 1;\n\tfs_devices->missing_devices++;\n\n\treturn device;\n}"
  },
  {
    "function_name": "btrfs_find_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5918-5936",
    "snippet": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__find_device",
          "args": [
            "&cur_devices->devices",
            "devid",
            "uuid"
          ],
          "line": 5928
        },
        "resolved": true,
        "details": {
          "function_name": "__find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "161-173",
          "snippet": "btrfs_device *__find_device(struct list_head *head,\n\t\t\t\t\t\t   u64 devid, u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\n\tlist_for_each_entry(dev, head, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nbtrfs_device *__find_device(struct list_head *head,\n\t\t\t\t\t\t   u64 devid, u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\n\tlist_for_each_entry(dev, head, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "cur_devices->fsid",
            "fsid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 5927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "btrfs_map_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5829-5916",
    "snippet": "int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,\n\t\t  int mirror_num, int async_submit)\n{\n\tstruct btrfs_device *dev;\n\tstruct bio *first_bio = bio;\n\tu64 logical = (u64)bio->bi_iter.bi_sector << 9;\n\tu64 length = 0;\n\tu64 map_length;\n\tint ret;\n\tint dev_nr = 0;\n\tint total_devs = 1;\n\tstruct btrfs_bio *bbio = NULL;\n\n\tlength = bio->bi_iter.bi_size;\n\tmap_length = length;\n\n\tbtrfs_bio_counter_inc_blocked(root->fs_info);\n\tret = __btrfs_map_block(root->fs_info, rw, logical, &map_length, &bbio,\n\t\t\t      mirror_num, 1);\n\tif (ret) {\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\ttotal_devs = bbio->num_stripes;\n\tbbio->orig_bio = first_bio;\n\tbbio->private = first_bio->bi_private;\n\tbbio->end_io = first_bio->bi_end_io;\n\tbbio->fs_info = root->fs_info;\n\tatomic_set(&bbio->stripes_pending, bbio->num_stripes);\n\n\tif (bbio->raid_map) {\n\t\t/* In this case, map_length has been set to the length of\n\t\t   a single stripe; not the whole write */\n\t\tif (rw & WRITE) {\n\t\t\tret = raid56_parity_write(root, bio, bbio, map_length);\n\t\t} else {\n\t\t\tret = raid56_parity_recover(root, bio, bbio, map_length,\n\t\t\t\t\t\t    mirror_num, 1);\n\t\t}\n\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tif (map_length < length) {\n\t\tbtrfs_crit(root->fs_info, \"mapping failed logical %llu bio len %llu len %llu\",\n\t\t\tlogical, length, map_length);\n\t\tBUG();\n\t}\n\n\twhile (dev_nr < total_devs) {\n\t\tdev = bbio->stripes[dev_nr].dev;\n\t\tif (!dev || !dev->bdev || (rw & WRITE && !dev->writeable)) {\n\t\t\tbbio_error(bbio, first_bio, logical);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check and see if we're ok with this bio based on it's size\n\t\t * and offset with the given device.\n\t\t */\n\t\tif (!bio_size_ok(dev->bdev, first_bio,\n\t\t\t\t bbio->stripes[dev_nr].physical >> 9)) {\n\t\t\tret = breakup_stripe_bio(root, bbio, first_bio, dev,\n\t\t\t\t\t\t dev_nr, rw, async_submit);\n\t\t\tBUG_ON(ret);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_nr < total_devs - 1) {\n\t\t\tbio = btrfs_bio_clone(first_bio, GFP_NOFS);\n\t\t\tBUG_ON(!bio); /* -ENOMEM */\n\t\t} else {\n\t\t\tbio = first_bio;\n\t\t\tbbio->flags |= BTRFS_BIO_ORIG_BIO_SUBMITTED;\n\t\t}\n\n\t\tsubmit_stripe_bio(root, bbio, bio,\n\t\t\t\t  bbio->stripes[dev_nr].physical, dev_nr, rw,\n\t\t\t\t  async_submit);\n\t\tdev_nr++;\n\t}\n\tbtrfs_bio_counter_dec(root->fs_info);\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_bio_counter_dec",
          "args": [
            "root->fs_info"
          ],
          "line": 5914
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_counter_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4159-4162",
          "snippet": "static inline void btrfs_bio_counter_dec(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_bio_counter_sub(fs_info, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_bio_counter_dec(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_bio_counter_sub(fs_info, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_stripe_bio",
          "args": [
            "root",
            "bbio",
            "bio",
            "bbio->stripes[dev_nr].physical",
            "dev_nr",
            "rw",
            "async_submit"
          ],
          "line": 5909
        },
        "resolved": true,
        "details": {
          "function_name": "submit_stripe_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5748-5779",
          "snippet": "static void submit_stripe_bio(struct btrfs_root *root, struct btrfs_bio *bbio,\n\t\t\t      struct bio *bio, u64 physical, int dev_nr,\n\t\t\t      int rw, int async)\n{\n\tstruct btrfs_device *dev = bbio->stripes[dev_nr].dev;\n\n\tbio->bi_private = bbio;\n\tbtrfs_io_bio(bio)->stripe_index = dev_nr;\n\tbio->bi_end_io = btrfs_end_bio;\n\tbio->bi_iter.bi_sector = physical >> 9;\n#ifdef DEBUG\n\t{\n\t\tstruct rcu_string *name;\n\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tpr_debug(\"btrfs_map_bio: rw %d, sector=%llu, dev=%lu \"\n\t\t\t \"(%s id %llu), size=%u\\n\", rw,\n\t\t\t (u64)bio->bi_iter.bi_sector, (u_long)dev->bdev->bd_dev,\n\t\t\t name->str, dev->devid, bio->bi_iter.bi_size);\n\t\trcu_read_unlock();\n\t}\n#endif\n\tbio->bi_bdev = dev->bdev;\n\n\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\n\tif (async)\n\t\tbtrfs_schedule_bio(root, dev, rw, bio);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void submit_stripe_bio(struct btrfs_root *root, struct btrfs_bio *bbio,\n\t\t\t      struct bio *bio, u64 physical, int dev_nr,\n\t\t\t      int rw, int async)\n{\n\tstruct btrfs_device *dev = bbio->stripes[dev_nr].dev;\n\n\tbio->bi_private = bbio;\n\tbtrfs_io_bio(bio)->stripe_index = dev_nr;\n\tbio->bi_end_io = btrfs_end_bio;\n\tbio->bi_iter.bi_sector = physical >> 9;\n#ifdef DEBUG\n\t{\n\t\tstruct rcu_string *name;\n\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tpr_debug(\"btrfs_map_bio: rw %d, sector=%llu, dev=%lu \"\n\t\t\t \"(%s id %llu), size=%u\\n\", rw,\n\t\t\t (u64)bio->bi_iter.bi_sector, (u_long)dev->bdev->bd_dev,\n\t\t\t name->str, dev->devid, bio->bi_iter.bi_size);\n\t\trcu_read_unlock();\n\t}\n#endif\n\tbio->bi_bdev = dev->bdev;\n\n\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\n\tif (async)\n\t\tbtrfs_schedule_bio(root, dev, rw, bio);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bio"
          ],
          "line": 5903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_bio_clone",
          "args": [
            "first_bio",
            "GFP_NOFS"
          ],
          "line": 5902
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2717-2730",
          "snippet": "struct bio *btrfs_bio_clone(struct bio *bio, gfp_t gfp_mask)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *new;\n\n\tnew = bio_clone_bioset(bio, gfp_mask, btrfs_bioset);\n\tif (new) {\n\t\tbtrfs_bio = btrfs_io_bio(new);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn new;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_bio_clone(struct bio *bio, gfp_t gfp_mask)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *new;\n\n\tnew = bio_clone_bioset(bio, gfp_mask, btrfs_bioset);\n\tif (new) {\n\t\tbtrfs_bio = btrfs_io_bio(new);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 5896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "breakup_stripe_bio",
          "args": [
            "root",
            "bbio",
            "first_bio",
            "dev",
            "dev_nr",
            "rw",
            "async_submit"
          ],
          "line": 5894
        },
        "resolved": true,
        "details": {
          "function_name": "breakup_stripe_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5781-5811",
          "snippet": "static int breakup_stripe_bio(struct btrfs_root *root, struct btrfs_bio *bbio,\n\t\t\t      struct bio *first_bio, struct btrfs_device *dev,\n\t\t\t      int dev_nr, int rw, int async)\n{\n\tstruct bio_vec *bvec = first_bio->bi_io_vec;\n\tstruct bio *bio;\n\tint nr_vecs = bio_get_nr_vecs(dev->bdev);\n\tu64 physical = bbio->stripes[dev_nr].physical;\n\nagain:\n\tbio = btrfs_bio_alloc(dev->bdev, physical >> 9, nr_vecs, GFP_NOFS);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\twhile (bvec <= (first_bio->bi_io_vec + first_bio->bi_vcnt - 1)) {\n\t\tif (bio_add_page(bio, bvec->bv_page, bvec->bv_len,\n\t\t\t\t bvec->bv_offset) < bvec->bv_len) {\n\t\t\tu64 len = bio->bi_iter.bi_size;\n\n\t\t\tatomic_inc(&bbio->stripes_pending);\n\t\t\tsubmit_stripe_bio(root, bbio, bio, physical, dev_nr,\n\t\t\t\t\t  rw, async);\n\t\t\tphysical += len;\n\t\t\tgoto again;\n\t\t}\n\t\tbvec++;\n\t}\n\n\tsubmit_stripe_bio(root, bbio, bio, physical, dev_nr, rw, async);\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int breakup_stripe_bio(struct btrfs_root *root, struct btrfs_bio *bbio,\n\t\t\t      struct bio *first_bio, struct btrfs_device *dev,\n\t\t\t      int dev_nr, int rw, int async)\n{\n\tstruct bio_vec *bvec = first_bio->bi_io_vec;\n\tstruct bio *bio;\n\tint nr_vecs = bio_get_nr_vecs(dev->bdev);\n\tu64 physical = bbio->stripes[dev_nr].physical;\n\nagain:\n\tbio = btrfs_bio_alloc(dev->bdev, physical >> 9, nr_vecs, GFP_NOFS);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\twhile (bvec <= (first_bio->bi_io_vec + first_bio->bi_vcnt - 1)) {\n\t\tif (bio_add_page(bio, bvec->bv_page, bvec->bv_len,\n\t\t\t\t bvec->bv_offset) < bvec->bv_len) {\n\t\t\tu64 len = bio->bi_iter.bi_size;\n\n\t\t\tatomic_inc(&bbio->stripes_pending);\n\t\t\tsubmit_stripe_bio(root, bbio, bio, physical, dev_nr,\n\t\t\t\t\t  rw, async);\n\t\t\tphysical += len;\n\t\t\tgoto again;\n\t\t}\n\t\tbvec++;\n\t}\n\n\tsubmit_stripe_bio(root, bbio, bio, physical, dev_nr, rw, async);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_size_ok",
          "args": [
            "dev->bdev",
            "first_bio",
            "bbio->stripes[dev_nr].physical >> 9"
          ],
          "line": 5892
        },
        "resolved": true,
        "details": {
          "function_name": "bio_size_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5720-5746",
          "snippet": "static int bio_size_ok(struct block_device *bdev, struct bio *bio,\n\t\t       sector_t sector)\n{\n\tstruct bio_vec *prev;\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tunsigned int max_sectors = queue_max_sectors(q);\n\tstruct bvec_merge_data bvm = {\n\t\t.bi_bdev = bdev,\n\t\t.bi_sector = sector,\n\t\t.bi_rw = bio->bi_rw,\n\t};\n\n\tif (WARN_ON(bio->bi_vcnt == 0))\n\t\treturn 1;\n\n\tprev = &bio->bi_io_vec[bio->bi_vcnt - 1];\n\tif (bio_sectors(bio) > max_sectors)\n\t\treturn 0;\n\n\tif (!q->merge_bvec_fn)\n\t\treturn 1;\n\n\tbvm.bi_size = bio->bi_iter.bi_size - prev->bv_len;\n\tif (q->merge_bvec_fn(q, &bvm, prev) < prev->bv_len)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int bio_size_ok(struct block_device *bdev, struct bio *bio,\n\t\t       sector_t sector)\n{\n\tstruct bio_vec *prev;\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tunsigned int max_sectors = queue_max_sectors(q);\n\tstruct bvec_merge_data bvm = {\n\t\t.bi_bdev = bdev,\n\t\t.bi_sector = sector,\n\t\t.bi_rw = bio->bi_rw,\n\t};\n\n\tif (WARN_ON(bio->bi_vcnt == 0))\n\t\treturn 1;\n\n\tprev = &bio->bi_io_vec[bio->bi_vcnt - 1];\n\tif (bio_sectors(bio) > max_sectors)\n\t\treturn 0;\n\n\tif (!q->merge_bvec_fn)\n\t\treturn 1;\n\n\tbvm.bi_size = bio->bi_iter.bi_size - prev->bv_len;\n\tif (q->merge_bvec_fn(q, &bvm, prev) < prev->bv_len)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bbio_error",
          "args": [
            "bbio",
            "first_bio",
            "logical"
          ],
          "line": 5883
        },
        "resolved": true,
        "details": {
          "function_name": "bbio_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5813-5827",
          "snippet": "static void bbio_error(struct btrfs_bio *bbio, struct bio *bio, u64 logical)\n{\n\tatomic_inc(&bbio->error);\n\tif (atomic_dec_and_test(&bbio->stripes_pending)) {\n\t\t/* Shoud be the original bio. */\n\t\tWARN_ON(bio != bbio->orig_bio);\n\n\t\tbio->bi_private = bbio->private;\n\t\tbio->bi_end_io = bbio->end_io;\n\t\tbtrfs_io_bio(bio)->mirror_num = bbio->mirror_num;\n\t\tbio->bi_iter.bi_sector = logical >> 9;\n\n\t\tbtrfs_end_bbio(bbio, bio, -EIO);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void bbio_error(struct btrfs_bio *bbio, struct bio *bio, u64 logical)\n{\n\tatomic_inc(&bbio->error);\n\tif (atomic_dec_and_test(&bbio->stripes_pending)) {\n\t\t/* Shoud be the original bio. */\n\t\tWARN_ON(bio != bbio->orig_bio);\n\n\t\tbio->bi_private = bbio->private;\n\t\tbio->bi_end_io = bbio->end_io;\n\t\tbtrfs_io_bio(bio)->mirror_num = bbio->mirror_num;\n\t\tbio->bi_iter.bi_sector = logical >> 9;\n\n\t\tbtrfs_end_bbio(bbio, bio, -EIO);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 5877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "root->fs_info",
            "\"mapping failed logical %llu bio len %llu len %llu\"",
            "logical",
            "length",
            "map_length"
          ],
          "line": 5875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raid56_parity_recover",
          "args": [
            "root",
            "bio",
            "bbio",
            "map_length",
            "mirror_num",
            "1"
          ],
          "line": 5866
        },
        "resolved": true,
        "details": {
          "function_name": "raid56_parity_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2123-2182",
          "snippet": "int raid56_parity_recover(struct btrfs_root *root, struct bio *bio,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len,\n\t\t\t  int mirror_num, int generic_io)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint ret;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio)) {\n\t\tif (generic_io)\n\t\t\tbtrfs_put_bbio(bbio);\n\t\treturn PTR_ERR(rbio);\n\t}\n\n\trbio->operation = BTRFS_RBIO_READ_REBUILD;\n\tbio_list_add(&rbio->bio_list, bio);\n\trbio->bio_list_bytes = bio->bi_iter.bi_size;\n\n\trbio->faila = find_logical_bio_stripe(rbio, bio);\n\tif (rbio->faila == -1) {\n\t\tBUG();\n\t\tif (generic_io)\n\t\t\tbtrfs_put_bbio(bbio);\n\t\tkfree(rbio);\n\t\treturn -EIO;\n\t}\n\n\tif (generic_io) {\n\t\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\t\trbio->generic_bio_cnt = 1;\n\t} else {\n\t\tbtrfs_get_bbio(bbio);\n\t}\n\n\t/*\n\t * reconstruct from the q stripe if they are\n\t * asking for mirror 3\n\t */\n\tif (mirror_num == 3)\n\t\trbio->failb = rbio->real_stripes - 2;\n\n\tret = lock_stripe_add(rbio);\n\n\t/*\n\t * __raid56_parity_recover will end the bio with\n\t * any errors it hits.  We don't want to return\n\t * its error value up the stack because our caller\n\t * will end up calling bio_endio with any nonzero\n\t * return\n\t */\n\tif (ret == 0)\n\t\t__raid56_parity_recover(rbio);\n\t/*\n\t * our rbio has been added to the list of\n\t * rbios that will be handled after the\n\t * currently lock owner is done\n\t */\n\treturn 0;\n\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nint raid56_parity_recover(struct btrfs_root *root, struct bio *bio,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len,\n\t\t\t  int mirror_num, int generic_io)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint ret;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio)) {\n\t\tif (generic_io)\n\t\t\tbtrfs_put_bbio(bbio);\n\t\treturn PTR_ERR(rbio);\n\t}\n\n\trbio->operation = BTRFS_RBIO_READ_REBUILD;\n\tbio_list_add(&rbio->bio_list, bio);\n\trbio->bio_list_bytes = bio->bi_iter.bi_size;\n\n\trbio->faila = find_logical_bio_stripe(rbio, bio);\n\tif (rbio->faila == -1) {\n\t\tBUG();\n\t\tif (generic_io)\n\t\t\tbtrfs_put_bbio(bbio);\n\t\tkfree(rbio);\n\t\treturn -EIO;\n\t}\n\n\tif (generic_io) {\n\t\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\t\trbio->generic_bio_cnt = 1;\n\t} else {\n\t\tbtrfs_get_bbio(bbio);\n\t}\n\n\t/*\n\t * reconstruct from the q stripe if they are\n\t * asking for mirror 3\n\t */\n\tif (mirror_num == 3)\n\t\trbio->failb = rbio->real_stripes - 2;\n\n\tret = lock_stripe_add(rbio);\n\n\t/*\n\t * __raid56_parity_recover will end the bio with\n\t * any errors it hits.  We don't want to return\n\t * its error value up the stack because our caller\n\t * will end up calling bio_endio with any nonzero\n\t * return\n\t */\n\tif (ret == 0)\n\t\t__raid56_parity_recover(rbio);\n\t/*\n\t * our rbio has been added to the list of\n\t * rbios that will be handled after the\n\t * currently lock owner is done\n\t */\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "raid56_parity_write",
          "args": [
            "root",
            "bio",
            "bbio",
            "map_length"
          ],
          "line": 5864
        },
        "resolved": true,
        "details": {
          "function_name": "raid56_parity_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1746-1793",
          "snippet": "int raid56_parity_write(struct btrfs_root *root, struct bio *bio,\n\t\t\tstruct btrfs_bio *bbio, u64 stripe_len)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tstruct btrfs_plug_cb *plug = NULL;\n\tstruct blk_plug_cb *cb;\n\tint ret;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio)) {\n\t\tbtrfs_put_bbio(bbio);\n\t\treturn PTR_ERR(rbio);\n\t}\n\tbio_list_add(&rbio->bio_list, bio);\n\trbio->bio_list_bytes = bio->bi_iter.bi_size;\n\trbio->operation = BTRFS_RBIO_WRITE;\n\n\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\trbio->generic_bio_cnt = 1;\n\n\t/*\n\t * don't plug on full rbios, just get them out the door\n\t * as quickly as we can\n\t */\n\tif (rbio_is_full(rbio)) {\n\t\tret = full_stripe_write(rbio);\n\t\tif (ret)\n\t\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tcb = blk_check_plugged(btrfs_raid_unplug, root->fs_info,\n\t\t\t       sizeof(*plug));\n\tif (cb) {\n\t\tplug = container_of(cb, struct btrfs_plug_cb, cb);\n\t\tif (!plug->info) {\n\t\t\tplug->info = root->fs_info;\n\t\t\tINIT_LIST_HEAD(&plug->rbio_list);\n\t\t}\n\t\tlist_add_tail(&rbio->plug_list, &plug->rbio_list);\n\t\tret = 0;\n\t} else {\n\t\tret = __raid56_parity_write(rbio);\n\t\tif (ret)\n\t\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nint raid56_parity_write(struct btrfs_root *root, struct bio *bio,\n\t\t\tstruct btrfs_bio *bbio, u64 stripe_len)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tstruct btrfs_plug_cb *plug = NULL;\n\tstruct blk_plug_cb *cb;\n\tint ret;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio)) {\n\t\tbtrfs_put_bbio(bbio);\n\t\treturn PTR_ERR(rbio);\n\t}\n\tbio_list_add(&rbio->bio_list, bio);\n\trbio->bio_list_bytes = bio->bi_iter.bi_size;\n\trbio->operation = BTRFS_RBIO_WRITE;\n\n\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\trbio->generic_bio_cnt = 1;\n\n\t/*\n\t * don't plug on full rbios, just get them out the door\n\t * as quickly as we can\n\t */\n\tif (rbio_is_full(rbio)) {\n\t\tret = full_stripe_write(rbio);\n\t\tif (ret)\n\t\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tcb = blk_check_plugged(btrfs_raid_unplug, root->fs_info,\n\t\t\t       sizeof(*plug));\n\tif (cb) {\n\t\tplug = container_of(cb, struct btrfs_plug_cb, cb);\n\t\tif (!plug->info) {\n\t\t\tplug->info = root->fs_info;\n\t\t\tINIT_LIST_HEAD(&plug->rbio_list);\n\t\t}\n\t\tlist_add_tail(&rbio->plug_list, &plug->rbio_list);\n\t\tret = 0;\n\t} else {\n\t\tret = __raid56_parity_write(rbio);\n\t\tif (ret)\n\t\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bbio->stripes_pending",
            "bbio->num_stripes"
          ],
          "line": 5858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_map_block",
          "args": [
            "root->fs_info",
            "rw",
            "logical",
            "&map_length",
            "&bbio",
            "mirror_num",
            "1"
          ],
          "line": 5846
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4941-5482",
          "snippet": "static int __btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t\t     u64 logical, u64 *length,\n\t\t\t     struct btrfs_bio **bbio_ret,\n\t\t\t     int mirror_num, int need_raid_map)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tu64 offset;\n\tu64 stripe_offset;\n\tu64 stripe_end_offset;\n\tu64 stripe_nr;\n\tu64 stripe_nr_orig;\n\tu64 stripe_nr_end;\n\tu64 stripe_len;\n\tint stripe_index;\n\tint i;\n\tint ret = 0;\n\tint num_stripes;\n\tint max_errors = 0;\n\tint tgtdev_indexes = 0;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint dev_replace_is_ongoing = 0;\n\tint num_alloc_stripes;\n\tint patch_the_first_stripe_for_dev_replace = 0;\n\tu64 physical_to_patch_in_first_stripe = 0;\n\tu64 raid56_full_stripe_start = (u64)-1;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, *length);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"unable to find logical %llu len %llu\",\n\t\t\tlogical, *length);\n\t\treturn -EINVAL;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"found a bad mapping, wanted %Lu, \"\n\t\t\t   \"found %Lu-%Lu\", logical, em->start,\n\t\t\t   em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\toffset = logical - em->start;\n\n\tstripe_len = map->stripe_len;\n\tstripe_nr = offset;\n\t/*\n\t * stripe_nr counts the total number of stripes we have to stride\n\t * to get to this block\n\t */\n\tdo_div(stripe_nr, stripe_len);\n\n\tstripe_offset = stripe_nr * stripe_len;\n\tBUG_ON(offset < stripe_offset);\n\n\t/* stripe_offset is the offset of this block in its stripe*/\n\tstripe_offset = offset - stripe_offset;\n\n\t/* if we're here for raid56, we need to know the stripe aligned start */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tunsigned long full_stripe_len = stripe_len * nr_data_stripes(map);\n\t\traid56_full_stripe_start = offset;\n\n\t\t/* allow a write of a full stripe, but make sure we don't\n\t\t * allow straddling of stripes\n\t\t */\n\t\tdo_div(raid56_full_stripe_start, full_stripe_len);\n\t\traid56_full_stripe_start *= full_stripe_len;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\t/* we don't discard raid56 yet */\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, *length);\n\t} else if (map->type & BTRFS_BLOCK_GROUP_PROFILE_MASK) {\n\t\tu64 max_len;\n\t\t/* For writes to RAID[56], allow a full stripeset across all disks.\n\t\t   For other RAID types and for RAID[56] reads, just allow a single\n\t\t   stripe (on a single disk). */\n\t\tif ((map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) &&\n\t\t    (rw & REQ_WRITE)) {\n\t\t\tmax_len = stripe_len * nr_data_stripes(map) -\n\t\t\t\t(offset - raid56_full_stripe_start);\n\t\t} else {\n\t\t\t/* we limit the length of each bio to what fits in a stripe */\n\t\t\tmax_len = stripe_len - stripe_offset;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, max_len);\n\t} else {\n\t\t*length = em->len - offset;\n\t}\n\n\t/* This is for when we're called from btrfs_merge_bio_hook() and all\n\t   it cares about is the length */\n\tif (!bbio_ret)\n\t\tgoto out;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(dev_replace);\n\tif (!dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tif (dev_replace_is_ongoing && mirror_num == map->num_stripes + 1 &&\n\t    !(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\t/*\n\t\t * in dev-replace case, for repair case (that's the only\n\t\t * case where the mirror is selected explicitly when\n\t\t * calling btrfs_map_block), blocks left of the left cursor\n\t\t * can also be read from the target drive.\n\t\t * For REQ_GET_READ_MIRRORS, the target drive is added as\n\t\t * the last one to the array of stripes. For READ, it also\n\t\t * needs to be supported using the same mirror number.\n\t\t * If the requested block is not left of the left cursor,\n\t\t * EIO is returned. This can happen because btrfs_num_copies()\n\t\t * returns one more in the dev-replace case.\n\t\t */\n\t\tu64 tmp_length = *length;\n\t\tstruct btrfs_bio *tmp_bbio = NULL;\n\t\tint tmp_num_stripes;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\tret = __btrfs_map_block(fs_info, REQ_GET_READ_MIRRORS,\n\t\t\t     logical, &tmp_length, &tmp_bbio, 0, 0);\n\t\tif (ret) {\n\t\t\tWARN_ON(tmp_bbio != NULL);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttmp_num_stripes = tmp_bbio->num_stripes;\n\t\tif (mirror_num > tmp_num_stripes) {\n\t\t\t/*\n\t\t\t * REQ_GET_READ_MIRRORS does not contain this\n\t\t\t * mirror, that means that the requested area\n\t\t\t * is not left of the left cursor\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * process the rest of the function using the mirror_num\n\t\t * of the source drive. Therefore look it up first.\n\t\t * At the end, patch the device pointer to the one of the\n\t\t * target drive.\n\t\t */\n\t\tfor (i = 0; i < tmp_num_stripes; i++) {\n\t\t\tif (tmp_bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     tmp_bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found =\n\t\t\t\t\ttmp_bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tmirror_num = index_srcdev + 1;\n\t\t\tpatch_the_first_stripe_for_dev_replace = 1;\n\t\t\tphysical_to_patch_in_first_stripe = physical_of_found;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_put_bbio(tmp_bbio);\n\t} else if (mirror_num > map->num_stripes) {\n\t\tmirror_num = 0;\n\t}\n\n\tnum_stripes = 1;\n\tstripe_index = 0;\n\tstripe_nr_orig = stripe_nr;\n\tstripe_nr_end = ALIGN(offset + *length, map->stripe_len);\n\tdo_div(stripe_nr_end, map->stripe_len);\n\tstripe_end_offset = stripe_nr_end * map->stripe_len -\n\t\t\t    (offset + *length);\n\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\tif (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->num_stripes,\n\t\t\t\t\t    stripe_nr_end - stripe_nr_orig);\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)))\n\t\t\tmirror_num = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->num_stripes;\n\t\telse if (mirror_num)\n\t\t\tstripe_index = mirror_num - 1;\n\t\telse {\n\t\t\tstripe_index = find_live_mirror(fs_info, map, 0,\n\t\t\t\t\t    map->num_stripes,\n\t\t\t\t\t    current->pid % map->num_stripes,\n\t\t\t\t\t    dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_DUP) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) {\n\t\t\tnum_stripes = map->num_stripes;\n\t\t} else if (mirror_num) {\n\t\t\tstripe_index = mirror_num - 1;\n\t\t} else {\n\t\t\tmirror_num = 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tint factor = map->num_stripes / map->sub_stripes;\n\n\t\tstripe_index = do_div(stripe_nr, factor);\n\t\tstripe_index *= map->sub_stripes;\n\n\t\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->sub_stripes;\n\t\telse if (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->sub_stripes *\n\t\t\t\t\t    (stripe_nr_end - stripe_nr_orig),\n\t\t\t\t\t    map->num_stripes);\n\t\telse if (mirror_num)\n\t\t\tstripe_index += mirror_num - 1;\n\t\telse {\n\t\t\tint old_stripe_index = stripe_index;\n\t\t\tstripe_index = find_live_mirror(fs_info, map,\n\t\t\t\t\t      stripe_index,\n\t\t\t\t\t      map->sub_stripes, stripe_index +\n\t\t\t\t\t      current->pid % map->sub_stripes,\n\t\t\t\t\t      dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index - old_stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tif (need_raid_map &&\n\t\t    ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t\t     mirror_num > 1)) {\n\t\t\t/* push stripe_nr back to the start of the full stripe */\n\t\t\tstripe_nr = raid56_full_stripe_start;\n\t\t\tdo_div(stripe_nr, stripe_len * nr_data_stripes(map));\n\n\t\t\t/* RAID[56] write or recovery. Return all stripes */\n\t\t\tnum_stripes = map->num_stripes;\n\t\t\tmax_errors = nr_parity_stripes(map);\n\n\t\t\t*length = map->stripe_len;\n\t\t\tstripe_index = 0;\n\t\t\tstripe_offset = 0;\n\t\t} else {\n\t\t\tu64 tmp;\n\n\t\t\t/*\n\t\t\t * Mirror #0 or #1 means the original data block.\n\t\t\t * Mirror #2 is RAID5 parity block.\n\t\t\t * Mirror #3 is RAID6 Q block.\n\t\t\t */\n\t\t\tstripe_index = do_div(stripe_nr, nr_data_stripes(map));\n\t\t\tif (mirror_num > 1)\n\t\t\t\tstripe_index = nr_data_stripes(map) +\n\t\t\t\t\t\tmirror_num - 2;\n\n\t\t\t/* We distribute the parity blocks across stripes */\n\t\t\ttmp = stripe_nr + stripe_index;\n\t\t\tstripe_index = do_div(tmp, map->num_stripes);\n\t\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD |\n\t\t\t\t    REQ_GET_READ_MIRRORS)) && mirror_num <= 1)\n\t\t\t\tmirror_num = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * after this do_div call, stripe_nr is the number of stripes\n\t\t * on this device we have to walk to find the data, and\n\t\t * stripe_index is the number of our device in the stripe array\n\t\t */\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tmirror_num = stripe_index + 1;\n\t}\n\tBUG_ON(stripe_index >= map->num_stripes);\n\n\tnum_alloc_stripes = num_stripes;\n\tif (dev_replace_is_ongoing) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD))\n\t\t\tnum_alloc_stripes <<= 1;\n\t\tif (rw & REQ_GET_READ_MIRRORS)\n\t\t\tnum_alloc_stripes++;\n\t\ttgtdev_indexes = num_stripes;\n\t}\n\n\tbbio = alloc_btrfs_bio(num_alloc_stripes, tgtdev_indexes);\n\tif (!bbio) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (dev_replace_is_ongoing)\n\t\tbbio->tgtdev_map = (int *)(bbio->stripes + num_alloc_stripes);\n\n\t/* build raid_map */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK &&\n\t    need_raid_map && ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t    mirror_num > 1)) {\n\t\tu64 tmp;\n\t\tint i, rot;\n\n\t\tbbio->raid_map = (u64 *)((void *)bbio->stripes +\n\t\t\t\t sizeof(struct btrfs_bio_stripe) *\n\t\t\t\t num_alloc_stripes +\n\t\t\t\t sizeof(int) * tgtdev_indexes);\n\n\t\t/* Work out the disk rotation on this stripe-set */\n\t\ttmp = stripe_nr;\n\t\trot = do_div(tmp, num_stripes);\n\n\t\t/* Fill in the logical address of each stripe */\n\t\ttmp = stripe_nr * nr_data_stripes(map);\n\t\tfor (i = 0; i < nr_data_stripes(map); i++)\n\t\t\tbbio->raid_map[(i+rot) % num_stripes] =\n\t\t\t\tem->start + (tmp + i) * map->stripe_len;\n\n\t\tbbio->raid_map[(i+rot) % map->num_stripes] = RAID5_P_STRIPE;\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\t\tbbio->raid_map[(i+rot+1) % num_stripes] =\n\t\t\t\tRAID6_Q_STRIPE;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\tint factor = 0;\n\t\tint sub_stripes = 0;\n\t\tu64 stripes_per_dev = 0;\n\t\tu32 remaining_stripes = 0;\n\t\tu32 last_stripe = 0;\n\n\t\tif (map->type &\n\t\t    (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID0)\n\t\t\t\tsub_stripes = 1;\n\t\t\telse\n\t\t\t\tsub_stripes = map->sub_stripes;\n\n\t\t\tfactor = map->num_stripes / sub_stripes;\n\t\t\tstripes_per_dev = div_u64_rem(stripe_nr_end -\n\t\t\t\t\t\t      stripe_nr_orig,\n\t\t\t\t\t\t      factor,\n\t\t\t\t\t\t      &remaining_stripes);\n\t\t\tdiv_u64_rem(stripe_nr_end - 1, factor, &last_stripe);\n\t\t\tlast_stripe *= sub_stripes;\n\t\t}\n\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset + stripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev = map->stripes[stripe_index].dev;\n\n\t\t\tif (map->type & (BTRFS_BLOCK_GROUP_RAID0 |\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\tbbio->stripes[i].length = stripes_per_dev *\n\t\t\t\t\t\t\t  map->stripe_len;\n\n\t\t\t\tif (i / sub_stripes < remaining_stripes)\n\t\t\t\t\tbbio->stripes[i].length +=\n\t\t\t\t\t\tmap->stripe_len;\n\n\t\t\t\t/*\n\t\t\t\t * Special for the first stripe and\n\t\t\t\t * the last stripe:\n\t\t\t\t *\n\t\t\t\t * |-------|...|-------|\n\t\t\t\t *     |----------|\n\t\t\t\t *    off     end_off\n\t\t\t\t */\n\t\t\t\tif (i < sub_stripes)\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_offset;\n\n\t\t\t\tif (stripe_index >= last_stripe &&\n\t\t\t\t    stripe_index <= (last_stripe +\n\t\t\t\t\t\t     sub_stripes - 1))\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_end_offset;\n\n\t\t\t\tif (i == sub_stripes - 1)\n\t\t\t\t\tstripe_offset = 0;\n\t\t\t} else\n\t\t\t\tbbio->stripes[i].length = *length;\n\n\t\t\tstripe_index++;\n\t\t\tif (stripe_index == map->num_stripes) {\n\t\t\t\t/* This could only happen for RAID0/10 */\n\t\t\t\tstripe_index = 0;\n\t\t\t\tstripe_nr++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset +\n\t\t\t\tstripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev =\n\t\t\t\tmap->stripes[stripe_index].dev;\n\t\t\tstripe_index++;\n\t\t}\n\t}\n\n\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\tmax_errors = btrfs_chunk_max_errors(map);\n\n\tif (bbio->raid_map)\n\t\tsort_parity_stripes(bbio, num_stripes);\n\n\ttgtdev_indexes = 0;\n\tif (dev_replace_is_ongoing && (rw & (REQ_WRITE | REQ_DISCARD)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\tint index_where_to_add;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\n\t\t/*\n\t\t * duplicate the write operations while the dev replace\n\t\t * procedure is running. Since the copying of the old disk\n\t\t * to the new disk takes place at run time while the\n\t\t * filesystem is mounted writable, the regular write\n\t\t * operations to the old disk have to be duplicated to go\n\t\t * to the new disk as well.\n\t\t * Note that device->missing is handled by the caller, and\n\t\t * that the write to the old disk is already set up in the\n\t\t * stripes array.\n\t\t */\n\t\tindex_where_to_add = num_stripes;\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/* write to new disk, too */\n\t\t\t\tstruct btrfs_bio_stripe *new =\n\t\t\t\t\tbbio->stripes + index_where_to_add;\n\t\t\t\tstruct btrfs_bio_stripe *old =\n\t\t\t\t\tbbio->stripes + i;\n\n\t\t\t\tnew->physical = old->physical;\n\t\t\t\tnew->length = old->length;\n\t\t\t\tnew->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[i] = index_where_to_add;\n\t\t\t\tindex_where_to_add++;\n\t\t\t\tmax_errors++;\n\t\t\t\ttgtdev_indexes++;\n\t\t\t}\n\t\t}\n\t\tnum_stripes = index_where_to_add;\n\t} else if (dev_replace_is_ongoing && (rw & REQ_GET_READ_MIRRORS) &&\n\t\t   dev_replace->tgtdev != NULL) {\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\t/*\n\t\t * During the dev-replace procedure, the target drive can\n\t\t * also be used to read data in case it is needed to repair\n\t\t * a corrupt block elsewhere. This is possible if the\n\t\t * requested area is left of the left cursor. In this area,\n\t\t * the target drive is a full copy of the source drive.\n\t\t */\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found = bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tu64 length = map->stripe_len;\n\n\t\t\tif (physical_of_found + length <=\n\t\t\t    dev_replace->cursor_left) {\n\t\t\t\tstruct btrfs_bio_stripe *tgtdev_stripe =\n\t\t\t\t\tbbio->stripes + num_stripes;\n\n\t\t\t\ttgtdev_stripe->physical = physical_of_found;\n\t\t\t\ttgtdev_stripe->length =\n\t\t\t\t\tbbio->stripes[index_srcdev].length;\n\t\t\t\ttgtdev_stripe->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[index_srcdev] = num_stripes;\n\n\t\t\t\ttgtdev_indexes++;\n\t\t\t\tnum_stripes++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*bbio_ret = bbio;\n\tbbio->map_type = map->type;\n\tbbio->num_stripes = num_stripes;\n\tbbio->max_errors = max_errors;\n\tbbio->mirror_num = mirror_num;\n\tbbio->num_tgtdevs = tgtdev_indexes;\n\n\t/*\n\t * this is the case that REQ_READ && dev_replace_is_ongoing &&\n\t * mirror_num == num_stripes + 1 && dev_replace target drive is\n\t * available as a mirror\n\t */\n\tif (patch_the_first_stripe_for_dev_replace && num_stripes > 0) {\n\t\tWARN_ON(num_stripes > 1);\n\t\tbbio->stripes[0].dev = dev_replace->tgtdev;\n\t\tbbio->stripes[0].physical = physical_to_patch_in_first_stripe;\n\t\tbbio->mirror_num = map->num_stripes + 1;\n\t}\nout:\n\tif (dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\tfree_extent_map(em);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t\t     u64 logical, u64 *length,\n\t\t\t     struct btrfs_bio **bbio_ret,\n\t\t\t     int mirror_num, int need_raid_map)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tu64 offset;\n\tu64 stripe_offset;\n\tu64 stripe_end_offset;\n\tu64 stripe_nr;\n\tu64 stripe_nr_orig;\n\tu64 stripe_nr_end;\n\tu64 stripe_len;\n\tint stripe_index;\n\tint i;\n\tint ret = 0;\n\tint num_stripes;\n\tint max_errors = 0;\n\tint tgtdev_indexes = 0;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint dev_replace_is_ongoing = 0;\n\tint num_alloc_stripes;\n\tint patch_the_first_stripe_for_dev_replace = 0;\n\tu64 physical_to_patch_in_first_stripe = 0;\n\tu64 raid56_full_stripe_start = (u64)-1;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, *length);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"unable to find logical %llu len %llu\",\n\t\t\tlogical, *length);\n\t\treturn -EINVAL;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"found a bad mapping, wanted %Lu, \"\n\t\t\t   \"found %Lu-%Lu\", logical, em->start,\n\t\t\t   em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\toffset = logical - em->start;\n\n\tstripe_len = map->stripe_len;\n\tstripe_nr = offset;\n\t/*\n\t * stripe_nr counts the total number of stripes we have to stride\n\t * to get to this block\n\t */\n\tdo_div(stripe_nr, stripe_len);\n\n\tstripe_offset = stripe_nr * stripe_len;\n\tBUG_ON(offset < stripe_offset);\n\n\t/* stripe_offset is the offset of this block in its stripe*/\n\tstripe_offset = offset - stripe_offset;\n\n\t/* if we're here for raid56, we need to know the stripe aligned start */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tunsigned long full_stripe_len = stripe_len * nr_data_stripes(map);\n\t\traid56_full_stripe_start = offset;\n\n\t\t/* allow a write of a full stripe, but make sure we don't\n\t\t * allow straddling of stripes\n\t\t */\n\t\tdo_div(raid56_full_stripe_start, full_stripe_len);\n\t\traid56_full_stripe_start *= full_stripe_len;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\t/* we don't discard raid56 yet */\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, *length);\n\t} else if (map->type & BTRFS_BLOCK_GROUP_PROFILE_MASK) {\n\t\tu64 max_len;\n\t\t/* For writes to RAID[56], allow a full stripeset across all disks.\n\t\t   For other RAID types and for RAID[56] reads, just allow a single\n\t\t   stripe (on a single disk). */\n\t\tif ((map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) &&\n\t\t    (rw & REQ_WRITE)) {\n\t\t\tmax_len = stripe_len * nr_data_stripes(map) -\n\t\t\t\t(offset - raid56_full_stripe_start);\n\t\t} else {\n\t\t\t/* we limit the length of each bio to what fits in a stripe */\n\t\t\tmax_len = stripe_len - stripe_offset;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, max_len);\n\t} else {\n\t\t*length = em->len - offset;\n\t}\n\n\t/* This is for when we're called from btrfs_merge_bio_hook() and all\n\t   it cares about is the length */\n\tif (!bbio_ret)\n\t\tgoto out;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(dev_replace);\n\tif (!dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tif (dev_replace_is_ongoing && mirror_num == map->num_stripes + 1 &&\n\t    !(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\t/*\n\t\t * in dev-replace case, for repair case (that's the only\n\t\t * case where the mirror is selected explicitly when\n\t\t * calling btrfs_map_block), blocks left of the left cursor\n\t\t * can also be read from the target drive.\n\t\t * For REQ_GET_READ_MIRRORS, the target drive is added as\n\t\t * the last one to the array of stripes. For READ, it also\n\t\t * needs to be supported using the same mirror number.\n\t\t * If the requested block is not left of the left cursor,\n\t\t * EIO is returned. This can happen because btrfs_num_copies()\n\t\t * returns one more in the dev-replace case.\n\t\t */\n\t\tu64 tmp_length = *length;\n\t\tstruct btrfs_bio *tmp_bbio = NULL;\n\t\tint tmp_num_stripes;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\tret = __btrfs_map_block(fs_info, REQ_GET_READ_MIRRORS,\n\t\t\t     logical, &tmp_length, &tmp_bbio, 0, 0);\n\t\tif (ret) {\n\t\t\tWARN_ON(tmp_bbio != NULL);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttmp_num_stripes = tmp_bbio->num_stripes;\n\t\tif (mirror_num > tmp_num_stripes) {\n\t\t\t/*\n\t\t\t * REQ_GET_READ_MIRRORS does not contain this\n\t\t\t * mirror, that means that the requested area\n\t\t\t * is not left of the left cursor\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * process the rest of the function using the mirror_num\n\t\t * of the source drive. Therefore look it up first.\n\t\t * At the end, patch the device pointer to the one of the\n\t\t * target drive.\n\t\t */\n\t\tfor (i = 0; i < tmp_num_stripes; i++) {\n\t\t\tif (tmp_bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     tmp_bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found =\n\t\t\t\t\ttmp_bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tmirror_num = index_srcdev + 1;\n\t\t\tpatch_the_first_stripe_for_dev_replace = 1;\n\t\t\tphysical_to_patch_in_first_stripe = physical_of_found;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_put_bbio(tmp_bbio);\n\t} else if (mirror_num > map->num_stripes) {\n\t\tmirror_num = 0;\n\t}\n\n\tnum_stripes = 1;\n\tstripe_index = 0;\n\tstripe_nr_orig = stripe_nr;\n\tstripe_nr_end = ALIGN(offset + *length, map->stripe_len);\n\tdo_div(stripe_nr_end, map->stripe_len);\n\tstripe_end_offset = stripe_nr_end * map->stripe_len -\n\t\t\t    (offset + *length);\n\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\tif (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->num_stripes,\n\t\t\t\t\t    stripe_nr_end - stripe_nr_orig);\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)))\n\t\t\tmirror_num = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->num_stripes;\n\t\telse if (mirror_num)\n\t\t\tstripe_index = mirror_num - 1;\n\t\telse {\n\t\t\tstripe_index = find_live_mirror(fs_info, map, 0,\n\t\t\t\t\t    map->num_stripes,\n\t\t\t\t\t    current->pid % map->num_stripes,\n\t\t\t\t\t    dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_DUP) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) {\n\t\t\tnum_stripes = map->num_stripes;\n\t\t} else if (mirror_num) {\n\t\t\tstripe_index = mirror_num - 1;\n\t\t} else {\n\t\t\tmirror_num = 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tint factor = map->num_stripes / map->sub_stripes;\n\n\t\tstripe_index = do_div(stripe_nr, factor);\n\t\tstripe_index *= map->sub_stripes;\n\n\t\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->sub_stripes;\n\t\telse if (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->sub_stripes *\n\t\t\t\t\t    (stripe_nr_end - stripe_nr_orig),\n\t\t\t\t\t    map->num_stripes);\n\t\telse if (mirror_num)\n\t\t\tstripe_index += mirror_num - 1;\n\t\telse {\n\t\t\tint old_stripe_index = stripe_index;\n\t\t\tstripe_index = find_live_mirror(fs_info, map,\n\t\t\t\t\t      stripe_index,\n\t\t\t\t\t      map->sub_stripes, stripe_index +\n\t\t\t\t\t      current->pid % map->sub_stripes,\n\t\t\t\t\t      dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index - old_stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tif (need_raid_map &&\n\t\t    ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t\t     mirror_num > 1)) {\n\t\t\t/* push stripe_nr back to the start of the full stripe */\n\t\t\tstripe_nr = raid56_full_stripe_start;\n\t\t\tdo_div(stripe_nr, stripe_len * nr_data_stripes(map));\n\n\t\t\t/* RAID[56] write or recovery. Return all stripes */\n\t\t\tnum_stripes = map->num_stripes;\n\t\t\tmax_errors = nr_parity_stripes(map);\n\n\t\t\t*length = map->stripe_len;\n\t\t\tstripe_index = 0;\n\t\t\tstripe_offset = 0;\n\t\t} else {\n\t\t\tu64 tmp;\n\n\t\t\t/*\n\t\t\t * Mirror #0 or #1 means the original data block.\n\t\t\t * Mirror #2 is RAID5 parity block.\n\t\t\t * Mirror #3 is RAID6 Q block.\n\t\t\t */\n\t\t\tstripe_index = do_div(stripe_nr, nr_data_stripes(map));\n\t\t\tif (mirror_num > 1)\n\t\t\t\tstripe_index = nr_data_stripes(map) +\n\t\t\t\t\t\tmirror_num - 2;\n\n\t\t\t/* We distribute the parity blocks across stripes */\n\t\t\ttmp = stripe_nr + stripe_index;\n\t\t\tstripe_index = do_div(tmp, map->num_stripes);\n\t\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD |\n\t\t\t\t    REQ_GET_READ_MIRRORS)) && mirror_num <= 1)\n\t\t\t\tmirror_num = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * after this do_div call, stripe_nr is the number of stripes\n\t\t * on this device we have to walk to find the data, and\n\t\t * stripe_index is the number of our device in the stripe array\n\t\t */\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tmirror_num = stripe_index + 1;\n\t}\n\tBUG_ON(stripe_index >= map->num_stripes);\n\n\tnum_alloc_stripes = num_stripes;\n\tif (dev_replace_is_ongoing) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD))\n\t\t\tnum_alloc_stripes <<= 1;\n\t\tif (rw & REQ_GET_READ_MIRRORS)\n\t\t\tnum_alloc_stripes++;\n\t\ttgtdev_indexes = num_stripes;\n\t}\n\n\tbbio = alloc_btrfs_bio(num_alloc_stripes, tgtdev_indexes);\n\tif (!bbio) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (dev_replace_is_ongoing)\n\t\tbbio->tgtdev_map = (int *)(bbio->stripes + num_alloc_stripes);\n\n\t/* build raid_map */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK &&\n\t    need_raid_map && ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t    mirror_num > 1)) {\n\t\tu64 tmp;\n\t\tint i, rot;\n\n\t\tbbio->raid_map = (u64 *)((void *)bbio->stripes +\n\t\t\t\t sizeof(struct btrfs_bio_stripe) *\n\t\t\t\t num_alloc_stripes +\n\t\t\t\t sizeof(int) * tgtdev_indexes);\n\n\t\t/* Work out the disk rotation on this stripe-set */\n\t\ttmp = stripe_nr;\n\t\trot = do_div(tmp, num_stripes);\n\n\t\t/* Fill in the logical address of each stripe */\n\t\ttmp = stripe_nr * nr_data_stripes(map);\n\t\tfor (i = 0; i < nr_data_stripes(map); i++)\n\t\t\tbbio->raid_map[(i+rot) % num_stripes] =\n\t\t\t\tem->start + (tmp + i) * map->stripe_len;\n\n\t\tbbio->raid_map[(i+rot) % map->num_stripes] = RAID5_P_STRIPE;\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\t\tbbio->raid_map[(i+rot+1) % num_stripes] =\n\t\t\t\tRAID6_Q_STRIPE;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\tint factor = 0;\n\t\tint sub_stripes = 0;\n\t\tu64 stripes_per_dev = 0;\n\t\tu32 remaining_stripes = 0;\n\t\tu32 last_stripe = 0;\n\n\t\tif (map->type &\n\t\t    (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID0)\n\t\t\t\tsub_stripes = 1;\n\t\t\telse\n\t\t\t\tsub_stripes = map->sub_stripes;\n\n\t\t\tfactor = map->num_stripes / sub_stripes;\n\t\t\tstripes_per_dev = div_u64_rem(stripe_nr_end -\n\t\t\t\t\t\t      stripe_nr_orig,\n\t\t\t\t\t\t      factor,\n\t\t\t\t\t\t      &remaining_stripes);\n\t\t\tdiv_u64_rem(stripe_nr_end - 1, factor, &last_stripe);\n\t\t\tlast_stripe *= sub_stripes;\n\t\t}\n\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset + stripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev = map->stripes[stripe_index].dev;\n\n\t\t\tif (map->type & (BTRFS_BLOCK_GROUP_RAID0 |\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\tbbio->stripes[i].length = stripes_per_dev *\n\t\t\t\t\t\t\t  map->stripe_len;\n\n\t\t\t\tif (i / sub_stripes < remaining_stripes)\n\t\t\t\t\tbbio->stripes[i].length +=\n\t\t\t\t\t\tmap->stripe_len;\n\n\t\t\t\t/*\n\t\t\t\t * Special for the first stripe and\n\t\t\t\t * the last stripe:\n\t\t\t\t *\n\t\t\t\t * |-------|...|-------|\n\t\t\t\t *     |----------|\n\t\t\t\t *    off     end_off\n\t\t\t\t */\n\t\t\t\tif (i < sub_stripes)\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_offset;\n\n\t\t\t\tif (stripe_index >= last_stripe &&\n\t\t\t\t    stripe_index <= (last_stripe +\n\t\t\t\t\t\t     sub_stripes - 1))\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_end_offset;\n\n\t\t\t\tif (i == sub_stripes - 1)\n\t\t\t\t\tstripe_offset = 0;\n\t\t\t} else\n\t\t\t\tbbio->stripes[i].length = *length;\n\n\t\t\tstripe_index++;\n\t\t\tif (stripe_index == map->num_stripes) {\n\t\t\t\t/* This could only happen for RAID0/10 */\n\t\t\t\tstripe_index = 0;\n\t\t\t\tstripe_nr++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset +\n\t\t\t\tstripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev =\n\t\t\t\tmap->stripes[stripe_index].dev;\n\t\t\tstripe_index++;\n\t\t}\n\t}\n\n\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\tmax_errors = btrfs_chunk_max_errors(map);\n\n\tif (bbio->raid_map)\n\t\tsort_parity_stripes(bbio, num_stripes);\n\n\ttgtdev_indexes = 0;\n\tif (dev_replace_is_ongoing && (rw & (REQ_WRITE | REQ_DISCARD)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\tint index_where_to_add;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\n\t\t/*\n\t\t * duplicate the write operations while the dev replace\n\t\t * procedure is running. Since the copying of the old disk\n\t\t * to the new disk takes place at run time while the\n\t\t * filesystem is mounted writable, the regular write\n\t\t * operations to the old disk have to be duplicated to go\n\t\t * to the new disk as well.\n\t\t * Note that device->missing is handled by the caller, and\n\t\t * that the write to the old disk is already set up in the\n\t\t * stripes array.\n\t\t */\n\t\tindex_where_to_add = num_stripes;\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/* write to new disk, too */\n\t\t\t\tstruct btrfs_bio_stripe *new =\n\t\t\t\t\tbbio->stripes + index_where_to_add;\n\t\t\t\tstruct btrfs_bio_stripe *old =\n\t\t\t\t\tbbio->stripes + i;\n\n\t\t\t\tnew->physical = old->physical;\n\t\t\t\tnew->length = old->length;\n\t\t\t\tnew->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[i] = index_where_to_add;\n\t\t\t\tindex_where_to_add++;\n\t\t\t\tmax_errors++;\n\t\t\t\ttgtdev_indexes++;\n\t\t\t}\n\t\t}\n\t\tnum_stripes = index_where_to_add;\n\t} else if (dev_replace_is_ongoing && (rw & REQ_GET_READ_MIRRORS) &&\n\t\t   dev_replace->tgtdev != NULL) {\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\t/*\n\t\t * During the dev-replace procedure, the target drive can\n\t\t * also be used to read data in case it is needed to repair\n\t\t * a corrupt block elsewhere. This is possible if the\n\t\t * requested area is left of the left cursor. In this area,\n\t\t * the target drive is a full copy of the source drive.\n\t\t */\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found = bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tu64 length = map->stripe_len;\n\n\t\t\tif (physical_of_found + length <=\n\t\t\t    dev_replace->cursor_left) {\n\t\t\t\tstruct btrfs_bio_stripe *tgtdev_stripe =\n\t\t\t\t\tbbio->stripes + num_stripes;\n\n\t\t\t\ttgtdev_stripe->physical = physical_of_found;\n\t\t\t\ttgtdev_stripe->length =\n\t\t\t\t\tbbio->stripes[index_srcdev].length;\n\t\t\t\ttgtdev_stripe->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[index_srcdev] = num_stripes;\n\n\t\t\t\ttgtdev_indexes++;\n\t\t\t\tnum_stripes++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*bbio_ret = bbio;\n\tbbio->map_type = map->type;\n\tbbio->num_stripes = num_stripes;\n\tbbio->max_errors = max_errors;\n\tbbio->mirror_num = mirror_num;\n\tbbio->num_tgtdevs = tgtdev_indexes;\n\n\t/*\n\t * this is the case that REQ_READ && dev_replace_is_ongoing &&\n\t * mirror_num == num_stripes + 1 && dev_replace target drive is\n\t * available as a mirror\n\t */\n\tif (patch_the_first_stripe_for_dev_replace && num_stripes > 0) {\n\t\tWARN_ON(num_stripes > 1);\n\t\tbbio->stripes[0].dev = dev_replace->tgtdev;\n\t\tbbio->stripes[0].physical = physical_to_patch_in_first_stripe;\n\t\tbbio->mirror_num = map->num_stripes + 1;\n\t}\nout:\n\tif (dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\tfree_extent_map(em);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_bio_counter_inc_blocked",
          "args": [
            "root->fs_info"
          ],
          "line": 5845
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_counter_inc_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "924-937",
          "snippet": "void btrfs_bio_counter_inc_blocked(struct btrfs_fs_info *fs_info)\n{\n\twhile (1) {\n\t\tpercpu_counter_inc(&fs_info->bio_counter);\n\t\tif (likely(!test_bit(BTRFS_FS_STATE_DEV_REPLACING,\n\t\t\t\t     &fs_info->fs_state)))\n\t\t\tbreak;\n\n\t\tbtrfs_bio_counter_dec(fs_info);\n\t\twait_event(fs_info->replace_wait,\n\t\t\t   !test_bit(BTRFS_FS_STATE_DEV_REPLACING,\n\t\t\t\t     &fs_info->fs_state));\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_bio_counter_inc_blocked(struct btrfs_fs_info *fs_info)\n{\n\twhile (1) {\n\t\tpercpu_counter_inc(&fs_info->bio_counter);\n\t\tif (likely(!test_bit(BTRFS_FS_STATE_DEV_REPLACING,\n\t\t\t\t     &fs_info->fs_state)))\n\t\t\tbreak;\n\n\t\tbtrfs_bio_counter_dec(fs_info);\n\t\twait_event(fs_info->replace_wait,\n\t\t\t   !test_bit(BTRFS_FS_STATE_DEV_REPLACING,\n\t\t\t\t     &fs_info->fs_state));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,\n\t\t  int mirror_num, int async_submit)\n{\n\tstruct btrfs_device *dev;\n\tstruct bio *first_bio = bio;\n\tu64 logical = (u64)bio->bi_iter.bi_sector << 9;\n\tu64 length = 0;\n\tu64 map_length;\n\tint ret;\n\tint dev_nr = 0;\n\tint total_devs = 1;\n\tstruct btrfs_bio *bbio = NULL;\n\n\tlength = bio->bi_iter.bi_size;\n\tmap_length = length;\n\n\tbtrfs_bio_counter_inc_blocked(root->fs_info);\n\tret = __btrfs_map_block(root->fs_info, rw, logical, &map_length, &bbio,\n\t\t\t      mirror_num, 1);\n\tif (ret) {\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\ttotal_devs = bbio->num_stripes;\n\tbbio->orig_bio = first_bio;\n\tbbio->private = first_bio->bi_private;\n\tbbio->end_io = first_bio->bi_end_io;\n\tbbio->fs_info = root->fs_info;\n\tatomic_set(&bbio->stripes_pending, bbio->num_stripes);\n\n\tif (bbio->raid_map) {\n\t\t/* In this case, map_length has been set to the length of\n\t\t   a single stripe; not the whole write */\n\t\tif (rw & WRITE) {\n\t\t\tret = raid56_parity_write(root, bio, bbio, map_length);\n\t\t} else {\n\t\t\tret = raid56_parity_recover(root, bio, bbio, map_length,\n\t\t\t\t\t\t    mirror_num, 1);\n\t\t}\n\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tif (map_length < length) {\n\t\tbtrfs_crit(root->fs_info, \"mapping failed logical %llu bio len %llu len %llu\",\n\t\t\tlogical, length, map_length);\n\t\tBUG();\n\t}\n\n\twhile (dev_nr < total_devs) {\n\t\tdev = bbio->stripes[dev_nr].dev;\n\t\tif (!dev || !dev->bdev || (rw & WRITE && !dev->writeable)) {\n\t\t\tbbio_error(bbio, first_bio, logical);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check and see if we're ok with this bio based on it's size\n\t\t * and offset with the given device.\n\t\t */\n\t\tif (!bio_size_ok(dev->bdev, first_bio,\n\t\t\t\t bbio->stripes[dev_nr].physical >> 9)) {\n\t\t\tret = breakup_stripe_bio(root, bbio, first_bio, dev,\n\t\t\t\t\t\t dev_nr, rw, async_submit);\n\t\t\tBUG_ON(ret);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_nr < total_devs - 1) {\n\t\t\tbio = btrfs_bio_clone(first_bio, GFP_NOFS);\n\t\t\tBUG_ON(!bio); /* -ENOMEM */\n\t\t} else {\n\t\t\tbio = first_bio;\n\t\t\tbbio->flags |= BTRFS_BIO_ORIG_BIO_SUBMITTED;\n\t\t}\n\n\t\tsubmit_stripe_bio(root, bbio, bio,\n\t\t\t\t  bbio->stripes[dev_nr].physical, dev_nr, rw,\n\t\t\t\t  async_submit);\n\t\tdev_nr++;\n\t}\n\tbtrfs_bio_counter_dec(root->fs_info);\n\treturn 0;\n}"
  },
  {
    "function_name": "bbio_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5813-5827",
    "snippet": "static void bbio_error(struct btrfs_bio *bbio, struct bio *bio, u64 logical)\n{\n\tatomic_inc(&bbio->error);\n\tif (atomic_dec_and_test(&bbio->stripes_pending)) {\n\t\t/* Shoud be the original bio. */\n\t\tWARN_ON(bio != bbio->orig_bio);\n\n\t\tbio->bi_private = bbio->private;\n\t\tbio->bi_end_io = bbio->end_io;\n\t\tbtrfs_io_bio(bio)->mirror_num = bbio->mirror_num;\n\t\tbio->bi_iter.bi_sector = logical >> 9;\n\n\t\tbtrfs_end_bbio(bbio, bio, -EIO);\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_end_bbio",
          "args": [
            "bbio",
            "bio",
            "-EIO"
          ],
          "line": 5825
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5588-5595",
          "snippet": "static inline void btrfs_end_bbio(struct btrfs_bio *bbio, struct bio *bio, int err)\n{\n\tif (likely(bbio->flags & BTRFS_BIO_ORIG_BIO_SUBMITTED))\n\t\tbio_endio_nodec(bio, err);\n\telse\n\t\tbio_endio(bio, err);\n\tbtrfs_put_bbio(bbio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic inline void btrfs_end_bbio(struct btrfs_bio *bbio, struct bio *bio, int err)\n{\n\tif (likely(bbio->flags & BTRFS_BIO_ORIG_BIO_SUBMITTED))\n\t\tbio_endio_nodec(bio, err);\n\telse\n\t\tbio_endio(bio, err);\n\tbtrfs_put_bbio(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio",
          "args": [
            "bio"
          ],
          "line": 5822
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "281-284",
          "snippet": "static inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bio != bbio->orig_bio"
          ],
          "line": 5818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&bbio->stripes_pending"
          ],
          "line": 5816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bbio->error"
          ],
          "line": 5815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void bbio_error(struct btrfs_bio *bbio, struct bio *bio, u64 logical)\n{\n\tatomic_inc(&bbio->error);\n\tif (atomic_dec_and_test(&bbio->stripes_pending)) {\n\t\t/* Shoud be the original bio. */\n\t\tWARN_ON(bio != bbio->orig_bio);\n\n\t\tbio->bi_private = bbio->private;\n\t\tbio->bi_end_io = bbio->end_io;\n\t\tbtrfs_io_bio(bio)->mirror_num = bbio->mirror_num;\n\t\tbio->bi_iter.bi_sector = logical >> 9;\n\n\t\tbtrfs_end_bbio(bbio, bio, -EIO);\n\t}\n}"
  },
  {
    "function_name": "breakup_stripe_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5781-5811",
    "snippet": "static int breakup_stripe_bio(struct btrfs_root *root, struct btrfs_bio *bbio,\n\t\t\t      struct bio *first_bio, struct btrfs_device *dev,\n\t\t\t      int dev_nr, int rw, int async)\n{\n\tstruct bio_vec *bvec = first_bio->bi_io_vec;\n\tstruct bio *bio;\n\tint nr_vecs = bio_get_nr_vecs(dev->bdev);\n\tu64 physical = bbio->stripes[dev_nr].physical;\n\nagain:\n\tbio = btrfs_bio_alloc(dev->bdev, physical >> 9, nr_vecs, GFP_NOFS);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\twhile (bvec <= (first_bio->bi_io_vec + first_bio->bi_vcnt - 1)) {\n\t\tif (bio_add_page(bio, bvec->bv_page, bvec->bv_len,\n\t\t\t\t bvec->bv_offset) < bvec->bv_len) {\n\t\t\tu64 len = bio->bi_iter.bi_size;\n\n\t\t\tatomic_inc(&bbio->stripes_pending);\n\t\t\tsubmit_stripe_bio(root, bbio, bio, physical, dev_nr,\n\t\t\t\t\t  rw, async);\n\t\t\tphysical += len;\n\t\t\tgoto again;\n\t\t}\n\t\tbvec++;\n\t}\n\n\tsubmit_stripe_bio(root, bbio, bio, physical, dev_nr, rw, async);\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_stripe_bio",
          "args": [
            "root",
            "bbio",
            "bio",
            "physical",
            "dev_nr",
            "rw",
            "async"
          ],
          "line": 5809
        },
        "resolved": true,
        "details": {
          "function_name": "submit_stripe_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5748-5779",
          "snippet": "static void submit_stripe_bio(struct btrfs_root *root, struct btrfs_bio *bbio,\n\t\t\t      struct bio *bio, u64 physical, int dev_nr,\n\t\t\t      int rw, int async)\n{\n\tstruct btrfs_device *dev = bbio->stripes[dev_nr].dev;\n\n\tbio->bi_private = bbio;\n\tbtrfs_io_bio(bio)->stripe_index = dev_nr;\n\tbio->bi_end_io = btrfs_end_bio;\n\tbio->bi_iter.bi_sector = physical >> 9;\n#ifdef DEBUG\n\t{\n\t\tstruct rcu_string *name;\n\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tpr_debug(\"btrfs_map_bio: rw %d, sector=%llu, dev=%lu \"\n\t\t\t \"(%s id %llu), size=%u\\n\", rw,\n\t\t\t (u64)bio->bi_iter.bi_sector, (u_long)dev->bdev->bd_dev,\n\t\t\t name->str, dev->devid, bio->bi_iter.bi_size);\n\t\trcu_read_unlock();\n\t}\n#endif\n\tbio->bi_bdev = dev->bdev;\n\n\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\n\tif (async)\n\t\tbtrfs_schedule_bio(root, dev, rw, bio);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void submit_stripe_bio(struct btrfs_root *root, struct btrfs_bio *bbio,\n\t\t\t      struct bio *bio, u64 physical, int dev_nr,\n\t\t\t      int rw, int async)\n{\n\tstruct btrfs_device *dev = bbio->stripes[dev_nr].dev;\n\n\tbio->bi_private = bbio;\n\tbtrfs_io_bio(bio)->stripe_index = dev_nr;\n\tbio->bi_end_io = btrfs_end_bio;\n\tbio->bi_iter.bi_sector = physical >> 9;\n#ifdef DEBUG\n\t{\n\t\tstruct rcu_string *name;\n\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tpr_debug(\"btrfs_map_bio: rw %d, sector=%llu, dev=%lu \"\n\t\t\t \"(%s id %llu), size=%u\\n\", rw,\n\t\t\t (u64)bio->bi_iter.bi_sector, (u_long)dev->bdev->bd_dev,\n\t\t\t name->str, dev->devid, bio->bi_iter.bi_size);\n\t\trcu_read_unlock();\n\t}\n#endif\n\tbio->bi_bdev = dev->bdev;\n\n\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\n\tif (async)\n\t\tbtrfs_schedule_bio(root, dev, rw, bio);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bbio->stripes_pending"
          ],
          "line": 5800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "bvec->bv_page",
            "bvec->bv_len",
            "bvec->bv_offset"
          ],
          "line": 5796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_bio_alloc",
          "args": [
            "dev->bdev",
            "physical >> 9",
            "nr_vecs",
            "GFP_NOFS"
          ],
          "line": 5791
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2690-2715",
          "snippet": "struct bio *\nbtrfs_bio_alloc(struct block_device *bdev, u64 first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_flags, nr_vecs, btrfs_bioset);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2)) {\n\t\t\tbio = bio_alloc_bioset(gfp_flags,\n\t\t\t\t\t       nr_vecs, btrfs_bioset);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *\nbtrfs_bio_alloc(struct block_device *bdev, u64 first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_flags, nr_vecs, btrfs_bioset);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2)) {\n\t\t\tbio = bio_alloc_bioset(gfp_flags,\n\t\t\t\t\t       nr_vecs, btrfs_bioset);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_get_nr_vecs",
          "args": [
            "dev->bdev"
          ],
          "line": 5787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int breakup_stripe_bio(struct btrfs_root *root, struct btrfs_bio *bbio,\n\t\t\t      struct bio *first_bio, struct btrfs_device *dev,\n\t\t\t      int dev_nr, int rw, int async)\n{\n\tstruct bio_vec *bvec = first_bio->bi_io_vec;\n\tstruct bio *bio;\n\tint nr_vecs = bio_get_nr_vecs(dev->bdev);\n\tu64 physical = bbio->stripes[dev_nr].physical;\n\nagain:\n\tbio = btrfs_bio_alloc(dev->bdev, physical >> 9, nr_vecs, GFP_NOFS);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\twhile (bvec <= (first_bio->bi_io_vec + first_bio->bi_vcnt - 1)) {\n\t\tif (bio_add_page(bio, bvec->bv_page, bvec->bv_len,\n\t\t\t\t bvec->bv_offset) < bvec->bv_len) {\n\t\t\tu64 len = bio->bi_iter.bi_size;\n\n\t\t\tatomic_inc(&bbio->stripes_pending);\n\t\t\tsubmit_stripe_bio(root, bbio, bio, physical, dev_nr,\n\t\t\t\t\t  rw, async);\n\t\t\tphysical += len;\n\t\t\tgoto again;\n\t\t}\n\t\tbvec++;\n\t}\n\n\tsubmit_stripe_bio(root, bbio, bio, physical, dev_nr, rw, async);\n\treturn 0;\n}"
  },
  {
    "function_name": "submit_stripe_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5748-5779",
    "snippet": "static void submit_stripe_bio(struct btrfs_root *root, struct btrfs_bio *bbio,\n\t\t\t      struct bio *bio, u64 physical, int dev_nr,\n\t\t\t      int rw, int async)\n{\n\tstruct btrfs_device *dev = bbio->stripes[dev_nr].dev;\n\n\tbio->bi_private = bbio;\n\tbtrfs_io_bio(bio)->stripe_index = dev_nr;\n\tbio->bi_end_io = btrfs_end_bio;\n\tbio->bi_iter.bi_sector = physical >> 9;\n#ifdef DEBUG\n\t{\n\t\tstruct rcu_string *name;\n\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tpr_debug(\"btrfs_map_bio: rw %d, sector=%llu, dev=%lu \"\n\t\t\t \"(%s id %llu), size=%u\\n\", rw,\n\t\t\t (u64)bio->bi_iter.bi_sector, (u_long)dev->bdev->bd_dev,\n\t\t\t name->str, dev->devid, bio->bi_iter.bi_size);\n\t\trcu_read_unlock();\n\t}\n#endif\n\tbio->bi_bdev = dev->bdev;\n\n\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\n\tif (async)\n\t\tbtrfs_schedule_bio(root, dev, rw, bio);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_submit_bio",
          "args": [
            "rw",
            "bio"
          ],
          "line": 5778
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_schedule_bio",
          "args": [
            "root",
            "dev",
            "rw",
            "bio"
          ],
          "line": 5776
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_schedule_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5667-5718",
          "snippet": "static noinline void btrfs_schedule_bio(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_device *device,\n\t\t\t\t\tint rw, struct bio *bio)\n{\n\tint should_queue = 1;\n\tstruct btrfs_pending_bios *pending_bios;\n\n\tif (device->missing || !device->bdev) {\n\t\tbio_endio(bio, -EIO);\n\t\treturn;\n\t}\n\n\t/* don't bother with additional async steps for reads, right now */\n\tif (!(rw & REQ_WRITE)) {\n\t\tbio_get(bio);\n\t\tbtrfsic_submit_bio(rw, bio);\n\t\tbio_put(bio);\n\t\treturn;\n\t}\n\n\t/*\n\t * nr_async_bios allows us to reliably return congestion to the\n\t * higher layers.  Otherwise, the async bio makes it appear we have\n\t * made progress against dirty pages when we've really just put it\n\t * on a queue for later\n\t */\n\tatomic_inc(&root->fs_info->nr_async_bios);\n\tWARN_ON(bio->bi_next);\n\tbio->bi_next = NULL;\n\tbio->bi_rw |= rw;\n\n\tspin_lock(&device->io_lock);\n\tif (bio->bi_rw & REQ_SYNC)\n\t\tpending_bios = &device->pending_sync_bios;\n\telse\n\t\tpending_bios = &device->pending_bios;\n\n\tif (pending_bios->tail)\n\t\tpending_bios->tail->bi_next = bio;\n\n\tpending_bios->tail = bio;\n\tif (!pending_bios->head)\n\t\tpending_bios->head = bio;\n\tif (device->running_pending)\n\t\tshould_queue = 0;\n\n\tspin_unlock(&device->io_lock);\n\n\tif (should_queue)\n\t\tbtrfs_queue_work(root->fs_info->submit_workers,\n\t\t\t\t &device->work);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline void btrfs_schedule_bio(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_device *device,\n\t\t\t\t\tint rw, struct bio *bio)\n{\n\tint should_queue = 1;\n\tstruct btrfs_pending_bios *pending_bios;\n\n\tif (device->missing || !device->bdev) {\n\t\tbio_endio(bio, -EIO);\n\t\treturn;\n\t}\n\n\t/* don't bother with additional async steps for reads, right now */\n\tif (!(rw & REQ_WRITE)) {\n\t\tbio_get(bio);\n\t\tbtrfsic_submit_bio(rw, bio);\n\t\tbio_put(bio);\n\t\treturn;\n\t}\n\n\t/*\n\t * nr_async_bios allows us to reliably return congestion to the\n\t * higher layers.  Otherwise, the async bio makes it appear we have\n\t * made progress against dirty pages when we've really just put it\n\t * on a queue for later\n\t */\n\tatomic_inc(&root->fs_info->nr_async_bios);\n\tWARN_ON(bio->bi_next);\n\tbio->bi_next = NULL;\n\tbio->bi_rw |= rw;\n\n\tspin_lock(&device->io_lock);\n\tif (bio->bi_rw & REQ_SYNC)\n\t\tpending_bios = &device->pending_sync_bios;\n\telse\n\t\tpending_bios = &device->pending_bios;\n\n\tif (pending_bios->tail)\n\t\tpending_bios->tail->bi_next = bio;\n\n\tpending_bios->tail = bio;\n\tif (!pending_bios->head)\n\t\tpending_bios->head = bio;\n\tif (device->running_pending)\n\t\tshould_queue = 0;\n\n\tspin_unlock(&device->io_lock);\n\n\tif (should_queue)\n\t\tbtrfs_queue_work(root->fs_info->submit_workers,\n\t\t\t\t &device->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_bio_counter_inc_noblocked",
          "args": [
            "root->fs_info"
          ],
          "line": 5773
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_counter_inc_noblocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "911-914",
          "snippet": "void btrfs_bio_counter_inc_noblocked(struct btrfs_fs_info *fs_info)\n{\n\tpercpu_counter_inc(&fs_info->bio_counter);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_bio_counter_inc_noblocked(struct btrfs_fs_info *fs_info)\n{\n\tpercpu_counter_inc(&fs_info->bio_counter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 5768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"btrfs_map_bio: rw %d, sector=%llu, dev=%lu \"\n\t\t\t \"(%s id %llu), size=%u\\n\"",
            "rw",
            "(u64)bio->bi_iter.bi_sector",
            "(u_long)dev->bdev->bd_dev",
            "name->str",
            "dev->devid",
            "bio->bi_iter.bi_size"
          ],
          "line": 5764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "dev->name"
          ],
          "line": 5763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 5762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio",
          "args": [
            "bio"
          ],
          "line": 5755
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "281-284",
          "snippet": "static inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void submit_stripe_bio(struct btrfs_root *root, struct btrfs_bio *bbio,\n\t\t\t      struct bio *bio, u64 physical, int dev_nr,\n\t\t\t      int rw, int async)\n{\n\tstruct btrfs_device *dev = bbio->stripes[dev_nr].dev;\n\n\tbio->bi_private = bbio;\n\tbtrfs_io_bio(bio)->stripe_index = dev_nr;\n\tbio->bi_end_io = btrfs_end_bio;\n\tbio->bi_iter.bi_sector = physical >> 9;\n#ifdef DEBUG\n\t{\n\t\tstruct rcu_string *name;\n\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tpr_debug(\"btrfs_map_bio: rw %d, sector=%llu, dev=%lu \"\n\t\t\t \"(%s id %llu), size=%u\\n\", rw,\n\t\t\t (u64)bio->bi_iter.bi_sector, (u_long)dev->bdev->bd_dev,\n\t\t\t name->str, dev->devid, bio->bi_iter.bi_size);\n\t\trcu_read_unlock();\n\t}\n#endif\n\tbio->bi_bdev = dev->bdev;\n\n\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\n\tif (async)\n\t\tbtrfs_schedule_bio(root, dev, rw, bio);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n}"
  },
  {
    "function_name": "bio_size_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5720-5746",
    "snippet": "static int bio_size_ok(struct block_device *bdev, struct bio *bio,\n\t\t       sector_t sector)\n{\n\tstruct bio_vec *prev;\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tunsigned int max_sectors = queue_max_sectors(q);\n\tstruct bvec_merge_data bvm = {\n\t\t.bi_bdev = bdev,\n\t\t.bi_sector = sector,\n\t\t.bi_rw = bio->bi_rw,\n\t};\n\n\tif (WARN_ON(bio->bi_vcnt == 0))\n\t\treturn 1;\n\n\tprev = &bio->bi_io_vec[bio->bi_vcnt - 1];\n\tif (bio_sectors(bio) > max_sectors)\n\t\treturn 0;\n\n\tif (!q->merge_bvec_fn)\n\t\treturn 1;\n\n\tbvm.bi_size = bio->bi_iter.bi_size - prev->bv_len;\n\tif (q->merge_bvec_fn(q, &bvm, prev) < prev->bv_len)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "q->merge_bvec_fn",
          "args": [
            "q",
            "&bvm",
            "prev"
          ],
          "line": 5743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_sectors",
          "args": [
            "bio"
          ],
          "line": 5736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bio->bi_vcnt == 0"
          ],
          "line": 5732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_max_sectors",
          "args": [
            "q"
          ],
          "line": 5725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "bdev"
          ],
          "line": 5724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int bio_size_ok(struct block_device *bdev, struct bio *bio,\n\t\t       sector_t sector)\n{\n\tstruct bio_vec *prev;\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tunsigned int max_sectors = queue_max_sectors(q);\n\tstruct bvec_merge_data bvm = {\n\t\t.bi_bdev = bdev,\n\t\t.bi_sector = sector,\n\t\t.bi_rw = bio->bi_rw,\n\t};\n\n\tif (WARN_ON(bio->bi_vcnt == 0))\n\t\treturn 1;\n\n\tprev = &bio->bi_io_vec[bio->bi_vcnt - 1];\n\tif (bio_sectors(bio) > max_sectors)\n\t\treturn 0;\n\n\tif (!q->merge_bvec_fn)\n\t\treturn 1;\n\n\tbvm.bi_size = bio->bi_iter.bi_size - prev->bv_len;\n\tif (q->merge_bvec_fn(q, &bvm, prev) < prev->bv_len)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_schedule_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5667-5718",
    "snippet": "static noinline void btrfs_schedule_bio(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_device *device,\n\t\t\t\t\tint rw, struct bio *bio)\n{\n\tint should_queue = 1;\n\tstruct btrfs_pending_bios *pending_bios;\n\n\tif (device->missing || !device->bdev) {\n\t\tbio_endio(bio, -EIO);\n\t\treturn;\n\t}\n\n\t/* don't bother with additional async steps for reads, right now */\n\tif (!(rw & REQ_WRITE)) {\n\t\tbio_get(bio);\n\t\tbtrfsic_submit_bio(rw, bio);\n\t\tbio_put(bio);\n\t\treturn;\n\t}\n\n\t/*\n\t * nr_async_bios allows us to reliably return congestion to the\n\t * higher layers.  Otherwise, the async bio makes it appear we have\n\t * made progress against dirty pages when we've really just put it\n\t * on a queue for later\n\t */\n\tatomic_inc(&root->fs_info->nr_async_bios);\n\tWARN_ON(bio->bi_next);\n\tbio->bi_next = NULL;\n\tbio->bi_rw |= rw;\n\n\tspin_lock(&device->io_lock);\n\tif (bio->bi_rw & REQ_SYNC)\n\t\tpending_bios = &device->pending_sync_bios;\n\telse\n\t\tpending_bios = &device->pending_bios;\n\n\tif (pending_bios->tail)\n\t\tpending_bios->tail->bi_next = bio;\n\n\tpending_bios->tail = bio;\n\tif (!pending_bios->head)\n\t\tpending_bios->head = bio;\n\tif (device->running_pending)\n\t\tshould_queue = 0;\n\n\tspin_unlock(&device->io_lock);\n\n\tif (should_queue)\n\t\tbtrfs_queue_work(root->fs_info->submit_workers,\n\t\t\t\t &device->work);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "root->fs_info->submit_workers",
            "&device->work"
          ],
          "line": 5716
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&device->io_lock"
          ],
          "line": 5713
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&device->io_lock"
          ],
          "line": 5698
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bio->bi_next"
          ],
          "line": 5694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->fs_info->nr_async_bios"
          ],
          "line": 5693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 5683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_submit_bio",
          "args": [
            "rw",
            "bio"
          ],
          "line": 5682
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_get",
          "args": [
            "bio"
          ],
          "line": 5681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_endio",
          "args": [
            "bio",
            "-EIO"
          ],
          "line": 5675
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_bio_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2667-2679",
          "snippet": "static void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline void btrfs_schedule_bio(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_device *device,\n\t\t\t\t\tint rw, struct bio *bio)\n{\n\tint should_queue = 1;\n\tstruct btrfs_pending_bios *pending_bios;\n\n\tif (device->missing || !device->bdev) {\n\t\tbio_endio(bio, -EIO);\n\t\treturn;\n\t}\n\n\t/* don't bother with additional async steps for reads, right now */\n\tif (!(rw & REQ_WRITE)) {\n\t\tbio_get(bio);\n\t\tbtrfsic_submit_bio(rw, bio);\n\t\tbio_put(bio);\n\t\treturn;\n\t}\n\n\t/*\n\t * nr_async_bios allows us to reliably return congestion to the\n\t * higher layers.  Otherwise, the async bio makes it appear we have\n\t * made progress against dirty pages when we've really just put it\n\t * on a queue for later\n\t */\n\tatomic_inc(&root->fs_info->nr_async_bios);\n\tWARN_ON(bio->bi_next);\n\tbio->bi_next = NULL;\n\tbio->bi_rw |= rw;\n\n\tspin_lock(&device->io_lock);\n\tif (bio->bi_rw & REQ_SYNC)\n\t\tpending_bios = &device->pending_sync_bios;\n\telse\n\t\tpending_bios = &device->pending_bios;\n\n\tif (pending_bios->tail)\n\t\tpending_bios->tail->bi_next = bio;\n\n\tpending_bios->tail = bio;\n\tif (!pending_bios->head)\n\t\tpending_bios->head = bio;\n\tif (device->running_pending)\n\t\tshould_queue = 0;\n\n\tspin_unlock(&device->io_lock);\n\n\tif (should_queue)\n\t\tbtrfs_queue_work(root->fs_info->submit_workers,\n\t\t\t\t &device->work);\n}"
  },
  {
    "function_name": "btrfs_end_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5597-5658",
    "snippet": "static void btrfs_end_bio(struct bio *bio, int err)\n{\n\tstruct btrfs_bio *bbio = bio->bi_private;\n\tstruct btrfs_device *dev = bbio->stripes[0].dev;\n\tint is_orig_bio = 0;\n\n\tif (err) {\n\t\tatomic_inc(&bbio->error);\n\t\tif (err == -EIO || err == -EREMOTEIO) {\n\t\t\tunsigned int stripe_index =\n\t\t\t\tbtrfs_io_bio(bio)->stripe_index;\n\n\t\t\tBUG_ON(stripe_index >= bbio->num_stripes);\n\t\t\tdev = bbio->stripes[stripe_index].dev;\n\t\t\tif (dev->bdev) {\n\t\t\t\tif (bio->bi_rw & WRITE)\n\t\t\t\t\tbtrfs_dev_stat_inc(dev,\n\t\t\t\t\t\tBTRFS_DEV_STAT_WRITE_ERRS);\n\t\t\t\telse\n\t\t\t\t\tbtrfs_dev_stat_inc(dev,\n\t\t\t\t\t\tBTRFS_DEV_STAT_READ_ERRS);\n\t\t\t\tif ((bio->bi_rw & WRITE_FLUSH) == WRITE_FLUSH)\n\t\t\t\t\tbtrfs_dev_stat_inc(dev,\n\t\t\t\t\t\tBTRFS_DEV_STAT_FLUSH_ERRS);\n\t\t\t\tbtrfs_dev_stat_print_on_error(dev);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bio == bbio->orig_bio)\n\t\tis_orig_bio = 1;\n\n\tbtrfs_bio_counter_dec(bbio->fs_info);\n\n\tif (atomic_dec_and_test(&bbio->stripes_pending)) {\n\t\tif (!is_orig_bio) {\n\t\t\tbio_put(bio);\n\t\t\tbio = bbio->orig_bio;\n\t\t}\n\n\t\tbio->bi_private = bbio->private;\n\t\tbio->bi_end_io = bbio->end_io;\n\t\tbtrfs_io_bio(bio)->mirror_num = bbio->mirror_num;\n\t\t/* only send an error to the higher layers if it is\n\t\t * beyond the tolerance of the btrfs bio\n\t\t */\n\t\tif (atomic_read(&bbio->error) > bbio->max_errors) {\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\t/*\n\t\t\t * this bio is actually up to date, we didn't\n\t\t\t * go over the max number of errors\n\t\t\t */\n\t\t\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\t\t\terr = 0;\n\t\t}\n\n\t\tbtrfs_end_bbio(bbio, bio, err);\n\t} else if (!is_orig_bio) {\n\t\tbio_put(bio);\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 5656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_bbio",
          "args": [
            "bbio",
            "bio",
            "err"
          ],
          "line": 5654
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5588-5595",
          "snippet": "static inline void btrfs_end_bbio(struct btrfs_bio *bbio, struct bio *bio, int err)\n{\n\tif (likely(bbio->flags & BTRFS_BIO_ORIG_BIO_SUBMITTED))\n\t\tbio_endio_nodec(bio, err);\n\telse\n\t\tbio_endio(bio, err);\n\tbtrfs_put_bbio(bbio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic inline void btrfs_end_bbio(struct btrfs_bio *bbio, struct bio *bio, int err)\n{\n\tif (likely(bbio->flags & BTRFS_BIO_ORIG_BIO_SUBMITTED))\n\t\tbio_endio_nodec(bio, err);\n\telse\n\t\tbio_endio(bio, err);\n\tbtrfs_put_bbio(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 5650
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bbio->error"
          ],
          "line": 5643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio",
          "args": [
            "bio"
          ],
          "line": 5639
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "281-284",
          "snippet": "static inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 5633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&bbio->stripes_pending"
          ],
          "line": 5631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_bio_counter_dec",
          "args": [
            "bbio->fs_info"
          ],
          "line": 5629
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_counter_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4159-4162",
          "snippet": "static inline void btrfs_bio_counter_dec(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_bio_counter_sub(fs_info, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_bio_counter_dec(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_bio_counter_sub(fs_info, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_print_on_error",
          "args": [
            "dev"
          ],
          "line": 5621
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_print_on_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6601-6613",
          "snippet": "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev)\n{\n\tif (!dev->dev_stats_valid)\n\t\treturn;\n\tprintk_ratelimited_in_rcu(KERN_ERR \"BTRFS: \"\n\t\t\t   \"bdev %s errs: wr %u, rd %u, flush %u, corrupt %u, gen %u\\n\",\n\t\t\t   rcu_str_deref(dev->name),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_WRITE_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_READ_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_FLUSH_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_GENERATION_ERRS));\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev)\n{\n\tif (!dev->dev_stats_valid)\n\t\treturn;\n\tprintk_ratelimited_in_rcu(KERN_ERR \"BTRFS: \"\n\t\t\t   \"bdev %s errs: wr %u, rd %u, flush %u, corrupt %u, gen %u\\n\",\n\t\t\t   rcu_str_deref(dev->name),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_WRITE_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_READ_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_FLUSH_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS),\n\t\t\t   btrfs_dev_stat_read(dev, BTRFS_DEV_STAT_GENERATION_ERRS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_inc",
          "args": [
            "dev",
            "BTRFS_DEV_STAT_FLUSH_ERRS"
          ],
          "line": 5619
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_inc_and_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6595-6599",
          "snippet": "void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "stripe_index >= bbio->num_stripes"
          ],
          "line": 5609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bbio->error"
          ],
          "line": 5604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void btrfs_end_bio(struct bio *bio, int err)\n{\n\tstruct btrfs_bio *bbio = bio->bi_private;\n\tstruct btrfs_device *dev = bbio->stripes[0].dev;\n\tint is_orig_bio = 0;\n\n\tif (err) {\n\t\tatomic_inc(&bbio->error);\n\t\tif (err == -EIO || err == -EREMOTEIO) {\n\t\t\tunsigned int stripe_index =\n\t\t\t\tbtrfs_io_bio(bio)->stripe_index;\n\n\t\t\tBUG_ON(stripe_index >= bbio->num_stripes);\n\t\t\tdev = bbio->stripes[stripe_index].dev;\n\t\t\tif (dev->bdev) {\n\t\t\t\tif (bio->bi_rw & WRITE)\n\t\t\t\t\tbtrfs_dev_stat_inc(dev,\n\t\t\t\t\t\tBTRFS_DEV_STAT_WRITE_ERRS);\n\t\t\t\telse\n\t\t\t\t\tbtrfs_dev_stat_inc(dev,\n\t\t\t\t\t\tBTRFS_DEV_STAT_READ_ERRS);\n\t\t\t\tif ((bio->bi_rw & WRITE_FLUSH) == WRITE_FLUSH)\n\t\t\t\t\tbtrfs_dev_stat_inc(dev,\n\t\t\t\t\t\tBTRFS_DEV_STAT_FLUSH_ERRS);\n\t\t\t\tbtrfs_dev_stat_print_on_error(dev);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bio == bbio->orig_bio)\n\t\tis_orig_bio = 1;\n\n\tbtrfs_bio_counter_dec(bbio->fs_info);\n\n\tif (atomic_dec_and_test(&bbio->stripes_pending)) {\n\t\tif (!is_orig_bio) {\n\t\t\tbio_put(bio);\n\t\t\tbio = bbio->orig_bio;\n\t\t}\n\n\t\tbio->bi_private = bbio->private;\n\t\tbio->bi_end_io = bbio->end_io;\n\t\tbtrfs_io_bio(bio)->mirror_num = bbio->mirror_num;\n\t\t/* only send an error to the higher layers if it is\n\t\t * beyond the tolerance of the btrfs bio\n\t\t */\n\t\tif (atomic_read(&bbio->error) > bbio->max_errors) {\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\t/*\n\t\t\t * this bio is actually up to date, we didn't\n\t\t\t * go over the max number of errors\n\t\t\t */\n\t\t\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\t\t\terr = 0;\n\t\t}\n\n\t\tbtrfs_end_bbio(bbio, bio, err);\n\t} else if (!is_orig_bio) {\n\t\tbio_put(bio);\n\t}\n}"
  },
  {
    "function_name": "btrfs_end_bbio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5588-5595",
    "snippet": "static inline void btrfs_end_bbio(struct btrfs_bio *bbio, struct bio *bio, int err)\n{\n\tif (likely(bbio->flags & BTRFS_BIO_ORIG_BIO_SUBMITTED))\n\t\tbio_endio_nodec(bio, err);\n\telse\n\t\tbio_endio(bio, err);\n\tbtrfs_put_bbio(bbio);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_bbio",
          "args": [
            "bbio"
          ],
          "line": 5594
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4933-4939",
          "snippet": "void btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_endio",
          "args": [
            "bio",
            "err"
          ],
          "line": 5593
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_bio_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2667-2679",
          "snippet": "static void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_endio_nodec",
          "args": [
            "bio",
            "err"
          ],
          "line": 5591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "bbio->flags & BTRFS_BIO_ORIG_BIO_SUBMITTED"
          ],
          "line": 5590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic inline void btrfs_end_bbio(struct btrfs_bio *bbio, struct bio *bio, int err)\n{\n\tif (likely(bbio->flags & BTRFS_BIO_ORIG_BIO_SUBMITTED))\n\t\tbio_endio_nodec(bio, err);\n\telse\n\t\tbio_endio(bio, err);\n\tbtrfs_put_bbio(bbio);\n}"
  },
  {
    "function_name": "btrfs_rmap_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5502-5586",
    "snippet": "int btrfs_rmap_block(struct btrfs_mapping_tree *map_tree,\n\t\t     u64 chunk_start, u64 physical, u64 devid,\n\t\t     u64 **logical, int *naddrs, int *stripe_len)\n{\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tu64 *buf;\n\tu64 bytenr;\n\tu64 length;\n\tu64 stripe_nr;\n\tu64 rmap_len;\n\tint i, j, nr = 0;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, chunk_start, 1);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't find em for chunk %Lu\\n\",\n\t\t       chunk_start);\n\t\treturn -EIO;\n\t}\n\n\tif (em->start != chunk_start) {\n\t\tprintk(KERN_ERR \"BTRFS: bad chunk start, em=%Lu, wanted=%Lu\\n\",\n\t\t       em->start, chunk_start);\n\t\tfree_extent_map(em);\n\t\treturn -EIO;\n\t}\n\tmap = (struct map_lookup *)em->bdev;\n\n\tlength = em->len;\n\trmap_len = map->stripe_len;\n\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tdo_div(length, map->num_stripes / map->sub_stripes);\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID0)\n\t\tdo_div(length, map->num_stripes);\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tdo_div(length, nr_data_stripes(map));\n\t\trmap_len = map->stripe_len * nr_data_stripes(map);\n\t}\n\n\tbuf = kzalloc(sizeof(u64) * map->num_stripes, GFP_NOFS);\n\tBUG_ON(!buf); /* -ENOMEM */\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tif (devid && map->stripes[i].dev->devid != devid)\n\t\t\tcontinue;\n\t\tif (map->stripes[i].physical > physical ||\n\t\t    map->stripes[i].physical + length <= physical)\n\t\t\tcontinue;\n\n\t\tstripe_nr = physical - map->stripes[i].physical;\n\t\tdo_div(stripe_nr, map->stripe_len);\n\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\t\tstripe_nr = stripe_nr * map->num_stripes + i;\n\t\t\tdo_div(stripe_nr, map->sub_stripes);\n\t\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\t\tstripe_nr = stripe_nr * map->num_stripes + i;\n\t\t} /* else if RAID[56], multiply by nr_data_stripes().\n\t\t   * Alternatively, just use rmap_len below instead of\n\t\t   * map->stripe_len */\n\n\t\tbytenr = chunk_start + stripe_nr * rmap_len;\n\t\tWARN_ON(nr >= map->num_stripes);\n\t\tfor (j = 0; j < nr; j++) {\n\t\t\tif (buf[j] == bytenr)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == nr) {\n\t\t\tWARN_ON(nr >= map->num_stripes);\n\t\t\tbuf[nr++] = bytenr;\n\t\t}\n\t}\n\n\t*logical = buf;\n\t*naddrs = nr;\n\t*stripe_len = rmap_len;\n\n\tfree_extent_map(em);\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 5584
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "nr >= map->num_stripes"
          ],
          "line": 5575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "nr >= map->num_stripes"
          ],
          "line": 5569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_nr",
            "map->sub_stripes"
          ],
          "line": 5561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_nr",
            "map->stripe_len"
          ],
          "line": 5557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buf"
          ],
          "line": 5547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(u64) * map->num_stripes",
            "GFP_NOFS"
          ],
          "line": 5546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_data_stripes",
          "args": [
            "map"
          ],
          "line": 5543
        },
        "resolved": true,
        "details": {
          "function_name": "nr_data_stripes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.h",
          "lines": "32-35",
          "snippet": "static inline int nr_data_stripes(struct map_lookup *map)\n{\n\treturn map->num_stripes - nr_parity_stripes(map);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int nr_data_stripes(struct map_lookup *map)\n{\n\treturn map->num_stripes - nr_parity_stripes(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "length",
            "nr_data_stripes(map)"
          ],
          "line": 5542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "length",
            "map->num_stripes"
          ],
          "line": 5540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "length",
            "map->num_stripes / map->sub_stripes"
          ],
          "line": 5538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BTRFS: bad chunk start, em=%Lu, wanted=%Lu\\n\"",
            "em->start",
            "chunk_start"
          ],
          "line": 5527
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 5518
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "chunk_start",
            "1"
          ],
          "line": 5517
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 5516
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_rmap_block(struct btrfs_mapping_tree *map_tree,\n\t\t     u64 chunk_start, u64 physical, u64 devid,\n\t\t     u64 **logical, int *naddrs, int *stripe_len)\n{\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tu64 *buf;\n\tu64 bytenr;\n\tu64 length;\n\tu64 stripe_nr;\n\tu64 rmap_len;\n\tint i, j, nr = 0;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, chunk_start, 1);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't find em for chunk %Lu\\n\",\n\t\t       chunk_start);\n\t\treturn -EIO;\n\t}\n\n\tif (em->start != chunk_start) {\n\t\tprintk(KERN_ERR \"BTRFS: bad chunk start, em=%Lu, wanted=%Lu\\n\",\n\t\t       em->start, chunk_start);\n\t\tfree_extent_map(em);\n\t\treturn -EIO;\n\t}\n\tmap = (struct map_lookup *)em->bdev;\n\n\tlength = em->len;\n\trmap_len = map->stripe_len;\n\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tdo_div(length, map->num_stripes / map->sub_stripes);\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID0)\n\t\tdo_div(length, map->num_stripes);\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tdo_div(length, nr_data_stripes(map));\n\t\trmap_len = map->stripe_len * nr_data_stripes(map);\n\t}\n\n\tbuf = kzalloc(sizeof(u64) * map->num_stripes, GFP_NOFS);\n\tBUG_ON(!buf); /* -ENOMEM */\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tif (devid && map->stripes[i].dev->devid != devid)\n\t\t\tcontinue;\n\t\tif (map->stripes[i].physical > physical ||\n\t\t    map->stripes[i].physical + length <= physical)\n\t\t\tcontinue;\n\n\t\tstripe_nr = physical - map->stripes[i].physical;\n\t\tdo_div(stripe_nr, map->stripe_len);\n\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\t\tstripe_nr = stripe_nr * map->num_stripes + i;\n\t\t\tdo_div(stripe_nr, map->sub_stripes);\n\t\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\t\tstripe_nr = stripe_nr * map->num_stripes + i;\n\t\t} /* else if RAID[56], multiply by nr_data_stripes().\n\t\t   * Alternatively, just use rmap_len below instead of\n\t\t   * map->stripe_len */\n\n\t\tbytenr = chunk_start + stripe_nr * rmap_len;\n\t\tWARN_ON(nr >= map->num_stripes);\n\t\tfor (j = 0; j < nr; j++) {\n\t\t\tif (buf[j] == bytenr)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == nr) {\n\t\t\tWARN_ON(nr >= map->num_stripes);\n\t\t\tbuf[nr++] = bytenr;\n\t\t}\n\t}\n\n\t*logical = buf;\n\t*naddrs = nr;\n\t*stripe_len = rmap_len;\n\n\tfree_extent_map(em);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_map_sblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5493-5500",
    "snippet": "int btrfs_map_sblock(struct btrfs_fs_info *fs_info, int rw,\n\t\t     u64 logical, u64 *length,\n\t\t     struct btrfs_bio **bbio_ret, int mirror_num,\n\t\t     int need_raid_map)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, need_raid_map);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_map_block",
          "args": [
            "fs_info",
            "rw",
            "logical",
            "length",
            "bbio_ret",
            "mirror_num",
            "need_raid_map"
          ],
          "line": 5498
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4941-5482",
          "snippet": "static int __btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t\t     u64 logical, u64 *length,\n\t\t\t     struct btrfs_bio **bbio_ret,\n\t\t\t     int mirror_num, int need_raid_map)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tu64 offset;\n\tu64 stripe_offset;\n\tu64 stripe_end_offset;\n\tu64 stripe_nr;\n\tu64 stripe_nr_orig;\n\tu64 stripe_nr_end;\n\tu64 stripe_len;\n\tint stripe_index;\n\tint i;\n\tint ret = 0;\n\tint num_stripes;\n\tint max_errors = 0;\n\tint tgtdev_indexes = 0;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint dev_replace_is_ongoing = 0;\n\tint num_alloc_stripes;\n\tint patch_the_first_stripe_for_dev_replace = 0;\n\tu64 physical_to_patch_in_first_stripe = 0;\n\tu64 raid56_full_stripe_start = (u64)-1;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, *length);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"unable to find logical %llu len %llu\",\n\t\t\tlogical, *length);\n\t\treturn -EINVAL;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"found a bad mapping, wanted %Lu, \"\n\t\t\t   \"found %Lu-%Lu\", logical, em->start,\n\t\t\t   em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\toffset = logical - em->start;\n\n\tstripe_len = map->stripe_len;\n\tstripe_nr = offset;\n\t/*\n\t * stripe_nr counts the total number of stripes we have to stride\n\t * to get to this block\n\t */\n\tdo_div(stripe_nr, stripe_len);\n\n\tstripe_offset = stripe_nr * stripe_len;\n\tBUG_ON(offset < stripe_offset);\n\n\t/* stripe_offset is the offset of this block in its stripe*/\n\tstripe_offset = offset - stripe_offset;\n\n\t/* if we're here for raid56, we need to know the stripe aligned start */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tunsigned long full_stripe_len = stripe_len * nr_data_stripes(map);\n\t\traid56_full_stripe_start = offset;\n\n\t\t/* allow a write of a full stripe, but make sure we don't\n\t\t * allow straddling of stripes\n\t\t */\n\t\tdo_div(raid56_full_stripe_start, full_stripe_len);\n\t\traid56_full_stripe_start *= full_stripe_len;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\t/* we don't discard raid56 yet */\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, *length);\n\t} else if (map->type & BTRFS_BLOCK_GROUP_PROFILE_MASK) {\n\t\tu64 max_len;\n\t\t/* For writes to RAID[56], allow a full stripeset across all disks.\n\t\t   For other RAID types and for RAID[56] reads, just allow a single\n\t\t   stripe (on a single disk). */\n\t\tif ((map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) &&\n\t\t    (rw & REQ_WRITE)) {\n\t\t\tmax_len = stripe_len * nr_data_stripes(map) -\n\t\t\t\t(offset - raid56_full_stripe_start);\n\t\t} else {\n\t\t\t/* we limit the length of each bio to what fits in a stripe */\n\t\t\tmax_len = stripe_len - stripe_offset;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, max_len);\n\t} else {\n\t\t*length = em->len - offset;\n\t}\n\n\t/* This is for when we're called from btrfs_merge_bio_hook() and all\n\t   it cares about is the length */\n\tif (!bbio_ret)\n\t\tgoto out;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(dev_replace);\n\tif (!dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tif (dev_replace_is_ongoing && mirror_num == map->num_stripes + 1 &&\n\t    !(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\t/*\n\t\t * in dev-replace case, for repair case (that's the only\n\t\t * case where the mirror is selected explicitly when\n\t\t * calling btrfs_map_block), blocks left of the left cursor\n\t\t * can also be read from the target drive.\n\t\t * For REQ_GET_READ_MIRRORS, the target drive is added as\n\t\t * the last one to the array of stripes. For READ, it also\n\t\t * needs to be supported using the same mirror number.\n\t\t * If the requested block is not left of the left cursor,\n\t\t * EIO is returned. This can happen because btrfs_num_copies()\n\t\t * returns one more in the dev-replace case.\n\t\t */\n\t\tu64 tmp_length = *length;\n\t\tstruct btrfs_bio *tmp_bbio = NULL;\n\t\tint tmp_num_stripes;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\tret = __btrfs_map_block(fs_info, REQ_GET_READ_MIRRORS,\n\t\t\t     logical, &tmp_length, &tmp_bbio, 0, 0);\n\t\tif (ret) {\n\t\t\tWARN_ON(tmp_bbio != NULL);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttmp_num_stripes = tmp_bbio->num_stripes;\n\t\tif (mirror_num > tmp_num_stripes) {\n\t\t\t/*\n\t\t\t * REQ_GET_READ_MIRRORS does not contain this\n\t\t\t * mirror, that means that the requested area\n\t\t\t * is not left of the left cursor\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * process the rest of the function using the mirror_num\n\t\t * of the source drive. Therefore look it up first.\n\t\t * At the end, patch the device pointer to the one of the\n\t\t * target drive.\n\t\t */\n\t\tfor (i = 0; i < tmp_num_stripes; i++) {\n\t\t\tif (tmp_bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     tmp_bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found =\n\t\t\t\t\ttmp_bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tmirror_num = index_srcdev + 1;\n\t\t\tpatch_the_first_stripe_for_dev_replace = 1;\n\t\t\tphysical_to_patch_in_first_stripe = physical_of_found;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_put_bbio(tmp_bbio);\n\t} else if (mirror_num > map->num_stripes) {\n\t\tmirror_num = 0;\n\t}\n\n\tnum_stripes = 1;\n\tstripe_index = 0;\n\tstripe_nr_orig = stripe_nr;\n\tstripe_nr_end = ALIGN(offset + *length, map->stripe_len);\n\tdo_div(stripe_nr_end, map->stripe_len);\n\tstripe_end_offset = stripe_nr_end * map->stripe_len -\n\t\t\t    (offset + *length);\n\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\tif (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->num_stripes,\n\t\t\t\t\t    stripe_nr_end - stripe_nr_orig);\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)))\n\t\t\tmirror_num = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->num_stripes;\n\t\telse if (mirror_num)\n\t\t\tstripe_index = mirror_num - 1;\n\t\telse {\n\t\t\tstripe_index = find_live_mirror(fs_info, map, 0,\n\t\t\t\t\t    map->num_stripes,\n\t\t\t\t\t    current->pid % map->num_stripes,\n\t\t\t\t\t    dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_DUP) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) {\n\t\t\tnum_stripes = map->num_stripes;\n\t\t} else if (mirror_num) {\n\t\t\tstripe_index = mirror_num - 1;\n\t\t} else {\n\t\t\tmirror_num = 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tint factor = map->num_stripes / map->sub_stripes;\n\n\t\tstripe_index = do_div(stripe_nr, factor);\n\t\tstripe_index *= map->sub_stripes;\n\n\t\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->sub_stripes;\n\t\telse if (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->sub_stripes *\n\t\t\t\t\t    (stripe_nr_end - stripe_nr_orig),\n\t\t\t\t\t    map->num_stripes);\n\t\telse if (mirror_num)\n\t\t\tstripe_index += mirror_num - 1;\n\t\telse {\n\t\t\tint old_stripe_index = stripe_index;\n\t\t\tstripe_index = find_live_mirror(fs_info, map,\n\t\t\t\t\t      stripe_index,\n\t\t\t\t\t      map->sub_stripes, stripe_index +\n\t\t\t\t\t      current->pid % map->sub_stripes,\n\t\t\t\t\t      dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index - old_stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tif (need_raid_map &&\n\t\t    ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t\t     mirror_num > 1)) {\n\t\t\t/* push stripe_nr back to the start of the full stripe */\n\t\t\tstripe_nr = raid56_full_stripe_start;\n\t\t\tdo_div(stripe_nr, stripe_len * nr_data_stripes(map));\n\n\t\t\t/* RAID[56] write or recovery. Return all stripes */\n\t\t\tnum_stripes = map->num_stripes;\n\t\t\tmax_errors = nr_parity_stripes(map);\n\n\t\t\t*length = map->stripe_len;\n\t\t\tstripe_index = 0;\n\t\t\tstripe_offset = 0;\n\t\t} else {\n\t\t\tu64 tmp;\n\n\t\t\t/*\n\t\t\t * Mirror #0 or #1 means the original data block.\n\t\t\t * Mirror #2 is RAID5 parity block.\n\t\t\t * Mirror #3 is RAID6 Q block.\n\t\t\t */\n\t\t\tstripe_index = do_div(stripe_nr, nr_data_stripes(map));\n\t\t\tif (mirror_num > 1)\n\t\t\t\tstripe_index = nr_data_stripes(map) +\n\t\t\t\t\t\tmirror_num - 2;\n\n\t\t\t/* We distribute the parity blocks across stripes */\n\t\t\ttmp = stripe_nr + stripe_index;\n\t\t\tstripe_index = do_div(tmp, map->num_stripes);\n\t\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD |\n\t\t\t\t    REQ_GET_READ_MIRRORS)) && mirror_num <= 1)\n\t\t\t\tmirror_num = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * after this do_div call, stripe_nr is the number of stripes\n\t\t * on this device we have to walk to find the data, and\n\t\t * stripe_index is the number of our device in the stripe array\n\t\t */\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tmirror_num = stripe_index + 1;\n\t}\n\tBUG_ON(stripe_index >= map->num_stripes);\n\n\tnum_alloc_stripes = num_stripes;\n\tif (dev_replace_is_ongoing) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD))\n\t\t\tnum_alloc_stripes <<= 1;\n\t\tif (rw & REQ_GET_READ_MIRRORS)\n\t\t\tnum_alloc_stripes++;\n\t\ttgtdev_indexes = num_stripes;\n\t}\n\n\tbbio = alloc_btrfs_bio(num_alloc_stripes, tgtdev_indexes);\n\tif (!bbio) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (dev_replace_is_ongoing)\n\t\tbbio->tgtdev_map = (int *)(bbio->stripes + num_alloc_stripes);\n\n\t/* build raid_map */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK &&\n\t    need_raid_map && ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t    mirror_num > 1)) {\n\t\tu64 tmp;\n\t\tint i, rot;\n\n\t\tbbio->raid_map = (u64 *)((void *)bbio->stripes +\n\t\t\t\t sizeof(struct btrfs_bio_stripe) *\n\t\t\t\t num_alloc_stripes +\n\t\t\t\t sizeof(int) * tgtdev_indexes);\n\n\t\t/* Work out the disk rotation on this stripe-set */\n\t\ttmp = stripe_nr;\n\t\trot = do_div(tmp, num_stripes);\n\n\t\t/* Fill in the logical address of each stripe */\n\t\ttmp = stripe_nr * nr_data_stripes(map);\n\t\tfor (i = 0; i < nr_data_stripes(map); i++)\n\t\t\tbbio->raid_map[(i+rot) % num_stripes] =\n\t\t\t\tem->start + (tmp + i) * map->stripe_len;\n\n\t\tbbio->raid_map[(i+rot) % map->num_stripes] = RAID5_P_STRIPE;\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\t\tbbio->raid_map[(i+rot+1) % num_stripes] =\n\t\t\t\tRAID6_Q_STRIPE;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\tint factor = 0;\n\t\tint sub_stripes = 0;\n\t\tu64 stripes_per_dev = 0;\n\t\tu32 remaining_stripes = 0;\n\t\tu32 last_stripe = 0;\n\n\t\tif (map->type &\n\t\t    (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID0)\n\t\t\t\tsub_stripes = 1;\n\t\t\telse\n\t\t\t\tsub_stripes = map->sub_stripes;\n\n\t\t\tfactor = map->num_stripes / sub_stripes;\n\t\t\tstripes_per_dev = div_u64_rem(stripe_nr_end -\n\t\t\t\t\t\t      stripe_nr_orig,\n\t\t\t\t\t\t      factor,\n\t\t\t\t\t\t      &remaining_stripes);\n\t\t\tdiv_u64_rem(stripe_nr_end - 1, factor, &last_stripe);\n\t\t\tlast_stripe *= sub_stripes;\n\t\t}\n\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset + stripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev = map->stripes[stripe_index].dev;\n\n\t\t\tif (map->type & (BTRFS_BLOCK_GROUP_RAID0 |\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\tbbio->stripes[i].length = stripes_per_dev *\n\t\t\t\t\t\t\t  map->stripe_len;\n\n\t\t\t\tif (i / sub_stripes < remaining_stripes)\n\t\t\t\t\tbbio->stripes[i].length +=\n\t\t\t\t\t\tmap->stripe_len;\n\n\t\t\t\t/*\n\t\t\t\t * Special for the first stripe and\n\t\t\t\t * the last stripe:\n\t\t\t\t *\n\t\t\t\t * |-------|...|-------|\n\t\t\t\t *     |----------|\n\t\t\t\t *    off     end_off\n\t\t\t\t */\n\t\t\t\tif (i < sub_stripes)\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_offset;\n\n\t\t\t\tif (stripe_index >= last_stripe &&\n\t\t\t\t    stripe_index <= (last_stripe +\n\t\t\t\t\t\t     sub_stripes - 1))\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_end_offset;\n\n\t\t\t\tif (i == sub_stripes - 1)\n\t\t\t\t\tstripe_offset = 0;\n\t\t\t} else\n\t\t\t\tbbio->stripes[i].length = *length;\n\n\t\t\tstripe_index++;\n\t\t\tif (stripe_index == map->num_stripes) {\n\t\t\t\t/* This could only happen for RAID0/10 */\n\t\t\t\tstripe_index = 0;\n\t\t\t\tstripe_nr++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset +\n\t\t\t\tstripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev =\n\t\t\t\tmap->stripes[stripe_index].dev;\n\t\t\tstripe_index++;\n\t\t}\n\t}\n\n\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\tmax_errors = btrfs_chunk_max_errors(map);\n\n\tif (bbio->raid_map)\n\t\tsort_parity_stripes(bbio, num_stripes);\n\n\ttgtdev_indexes = 0;\n\tif (dev_replace_is_ongoing && (rw & (REQ_WRITE | REQ_DISCARD)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\tint index_where_to_add;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\n\t\t/*\n\t\t * duplicate the write operations while the dev replace\n\t\t * procedure is running. Since the copying of the old disk\n\t\t * to the new disk takes place at run time while the\n\t\t * filesystem is mounted writable, the regular write\n\t\t * operations to the old disk have to be duplicated to go\n\t\t * to the new disk as well.\n\t\t * Note that device->missing is handled by the caller, and\n\t\t * that the write to the old disk is already set up in the\n\t\t * stripes array.\n\t\t */\n\t\tindex_where_to_add = num_stripes;\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/* write to new disk, too */\n\t\t\t\tstruct btrfs_bio_stripe *new =\n\t\t\t\t\tbbio->stripes + index_where_to_add;\n\t\t\t\tstruct btrfs_bio_stripe *old =\n\t\t\t\t\tbbio->stripes + i;\n\n\t\t\t\tnew->physical = old->physical;\n\t\t\t\tnew->length = old->length;\n\t\t\t\tnew->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[i] = index_where_to_add;\n\t\t\t\tindex_where_to_add++;\n\t\t\t\tmax_errors++;\n\t\t\t\ttgtdev_indexes++;\n\t\t\t}\n\t\t}\n\t\tnum_stripes = index_where_to_add;\n\t} else if (dev_replace_is_ongoing && (rw & REQ_GET_READ_MIRRORS) &&\n\t\t   dev_replace->tgtdev != NULL) {\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\t/*\n\t\t * During the dev-replace procedure, the target drive can\n\t\t * also be used to read data in case it is needed to repair\n\t\t * a corrupt block elsewhere. This is possible if the\n\t\t * requested area is left of the left cursor. In this area,\n\t\t * the target drive is a full copy of the source drive.\n\t\t */\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found = bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tu64 length = map->stripe_len;\n\n\t\t\tif (physical_of_found + length <=\n\t\t\t    dev_replace->cursor_left) {\n\t\t\t\tstruct btrfs_bio_stripe *tgtdev_stripe =\n\t\t\t\t\tbbio->stripes + num_stripes;\n\n\t\t\t\ttgtdev_stripe->physical = physical_of_found;\n\t\t\t\ttgtdev_stripe->length =\n\t\t\t\t\tbbio->stripes[index_srcdev].length;\n\t\t\t\ttgtdev_stripe->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[index_srcdev] = num_stripes;\n\n\t\t\t\ttgtdev_indexes++;\n\t\t\t\tnum_stripes++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*bbio_ret = bbio;\n\tbbio->map_type = map->type;\n\tbbio->num_stripes = num_stripes;\n\tbbio->max_errors = max_errors;\n\tbbio->mirror_num = mirror_num;\n\tbbio->num_tgtdevs = tgtdev_indexes;\n\n\t/*\n\t * this is the case that REQ_READ && dev_replace_is_ongoing &&\n\t * mirror_num == num_stripes + 1 && dev_replace target drive is\n\t * available as a mirror\n\t */\n\tif (patch_the_first_stripe_for_dev_replace && num_stripes > 0) {\n\t\tWARN_ON(num_stripes > 1);\n\t\tbbio->stripes[0].dev = dev_replace->tgtdev;\n\t\tbbio->stripes[0].physical = physical_to_patch_in_first_stripe;\n\t\tbbio->mirror_num = map->num_stripes + 1;\n\t}\nout:\n\tif (dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\tfree_extent_map(em);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t\t     u64 logical, u64 *length,\n\t\t\t     struct btrfs_bio **bbio_ret,\n\t\t\t     int mirror_num, int need_raid_map)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tu64 offset;\n\tu64 stripe_offset;\n\tu64 stripe_end_offset;\n\tu64 stripe_nr;\n\tu64 stripe_nr_orig;\n\tu64 stripe_nr_end;\n\tu64 stripe_len;\n\tint stripe_index;\n\tint i;\n\tint ret = 0;\n\tint num_stripes;\n\tint max_errors = 0;\n\tint tgtdev_indexes = 0;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint dev_replace_is_ongoing = 0;\n\tint num_alloc_stripes;\n\tint patch_the_first_stripe_for_dev_replace = 0;\n\tu64 physical_to_patch_in_first_stripe = 0;\n\tu64 raid56_full_stripe_start = (u64)-1;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, *length);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"unable to find logical %llu len %llu\",\n\t\t\tlogical, *length);\n\t\treturn -EINVAL;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"found a bad mapping, wanted %Lu, \"\n\t\t\t   \"found %Lu-%Lu\", logical, em->start,\n\t\t\t   em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\toffset = logical - em->start;\n\n\tstripe_len = map->stripe_len;\n\tstripe_nr = offset;\n\t/*\n\t * stripe_nr counts the total number of stripes we have to stride\n\t * to get to this block\n\t */\n\tdo_div(stripe_nr, stripe_len);\n\n\tstripe_offset = stripe_nr * stripe_len;\n\tBUG_ON(offset < stripe_offset);\n\n\t/* stripe_offset is the offset of this block in its stripe*/\n\tstripe_offset = offset - stripe_offset;\n\n\t/* if we're here for raid56, we need to know the stripe aligned start */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tunsigned long full_stripe_len = stripe_len * nr_data_stripes(map);\n\t\traid56_full_stripe_start = offset;\n\n\t\t/* allow a write of a full stripe, but make sure we don't\n\t\t * allow straddling of stripes\n\t\t */\n\t\tdo_div(raid56_full_stripe_start, full_stripe_len);\n\t\traid56_full_stripe_start *= full_stripe_len;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\t/* we don't discard raid56 yet */\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, *length);\n\t} else if (map->type & BTRFS_BLOCK_GROUP_PROFILE_MASK) {\n\t\tu64 max_len;\n\t\t/* For writes to RAID[56], allow a full stripeset across all disks.\n\t\t   For other RAID types and for RAID[56] reads, just allow a single\n\t\t   stripe (on a single disk). */\n\t\tif ((map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) &&\n\t\t    (rw & REQ_WRITE)) {\n\t\t\tmax_len = stripe_len * nr_data_stripes(map) -\n\t\t\t\t(offset - raid56_full_stripe_start);\n\t\t} else {\n\t\t\t/* we limit the length of each bio to what fits in a stripe */\n\t\t\tmax_len = stripe_len - stripe_offset;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, max_len);\n\t} else {\n\t\t*length = em->len - offset;\n\t}\n\n\t/* This is for when we're called from btrfs_merge_bio_hook() and all\n\t   it cares about is the length */\n\tif (!bbio_ret)\n\t\tgoto out;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(dev_replace);\n\tif (!dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tif (dev_replace_is_ongoing && mirror_num == map->num_stripes + 1 &&\n\t    !(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\t/*\n\t\t * in dev-replace case, for repair case (that's the only\n\t\t * case where the mirror is selected explicitly when\n\t\t * calling btrfs_map_block), blocks left of the left cursor\n\t\t * can also be read from the target drive.\n\t\t * For REQ_GET_READ_MIRRORS, the target drive is added as\n\t\t * the last one to the array of stripes. For READ, it also\n\t\t * needs to be supported using the same mirror number.\n\t\t * If the requested block is not left of the left cursor,\n\t\t * EIO is returned. This can happen because btrfs_num_copies()\n\t\t * returns one more in the dev-replace case.\n\t\t */\n\t\tu64 tmp_length = *length;\n\t\tstruct btrfs_bio *tmp_bbio = NULL;\n\t\tint tmp_num_stripes;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\tret = __btrfs_map_block(fs_info, REQ_GET_READ_MIRRORS,\n\t\t\t     logical, &tmp_length, &tmp_bbio, 0, 0);\n\t\tif (ret) {\n\t\t\tWARN_ON(tmp_bbio != NULL);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttmp_num_stripes = tmp_bbio->num_stripes;\n\t\tif (mirror_num > tmp_num_stripes) {\n\t\t\t/*\n\t\t\t * REQ_GET_READ_MIRRORS does not contain this\n\t\t\t * mirror, that means that the requested area\n\t\t\t * is not left of the left cursor\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * process the rest of the function using the mirror_num\n\t\t * of the source drive. Therefore look it up first.\n\t\t * At the end, patch the device pointer to the one of the\n\t\t * target drive.\n\t\t */\n\t\tfor (i = 0; i < tmp_num_stripes; i++) {\n\t\t\tif (tmp_bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     tmp_bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found =\n\t\t\t\t\ttmp_bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tmirror_num = index_srcdev + 1;\n\t\t\tpatch_the_first_stripe_for_dev_replace = 1;\n\t\t\tphysical_to_patch_in_first_stripe = physical_of_found;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_put_bbio(tmp_bbio);\n\t} else if (mirror_num > map->num_stripes) {\n\t\tmirror_num = 0;\n\t}\n\n\tnum_stripes = 1;\n\tstripe_index = 0;\n\tstripe_nr_orig = stripe_nr;\n\tstripe_nr_end = ALIGN(offset + *length, map->stripe_len);\n\tdo_div(stripe_nr_end, map->stripe_len);\n\tstripe_end_offset = stripe_nr_end * map->stripe_len -\n\t\t\t    (offset + *length);\n\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\tif (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->num_stripes,\n\t\t\t\t\t    stripe_nr_end - stripe_nr_orig);\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)))\n\t\t\tmirror_num = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->num_stripes;\n\t\telse if (mirror_num)\n\t\t\tstripe_index = mirror_num - 1;\n\t\telse {\n\t\t\tstripe_index = find_live_mirror(fs_info, map, 0,\n\t\t\t\t\t    map->num_stripes,\n\t\t\t\t\t    current->pid % map->num_stripes,\n\t\t\t\t\t    dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_DUP) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) {\n\t\t\tnum_stripes = map->num_stripes;\n\t\t} else if (mirror_num) {\n\t\t\tstripe_index = mirror_num - 1;\n\t\t} else {\n\t\t\tmirror_num = 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tint factor = map->num_stripes / map->sub_stripes;\n\n\t\tstripe_index = do_div(stripe_nr, factor);\n\t\tstripe_index *= map->sub_stripes;\n\n\t\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->sub_stripes;\n\t\telse if (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->sub_stripes *\n\t\t\t\t\t    (stripe_nr_end - stripe_nr_orig),\n\t\t\t\t\t    map->num_stripes);\n\t\telse if (mirror_num)\n\t\t\tstripe_index += mirror_num - 1;\n\t\telse {\n\t\t\tint old_stripe_index = stripe_index;\n\t\t\tstripe_index = find_live_mirror(fs_info, map,\n\t\t\t\t\t      stripe_index,\n\t\t\t\t\t      map->sub_stripes, stripe_index +\n\t\t\t\t\t      current->pid % map->sub_stripes,\n\t\t\t\t\t      dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index - old_stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tif (need_raid_map &&\n\t\t    ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t\t     mirror_num > 1)) {\n\t\t\t/* push stripe_nr back to the start of the full stripe */\n\t\t\tstripe_nr = raid56_full_stripe_start;\n\t\t\tdo_div(stripe_nr, stripe_len * nr_data_stripes(map));\n\n\t\t\t/* RAID[56] write or recovery. Return all stripes */\n\t\t\tnum_stripes = map->num_stripes;\n\t\t\tmax_errors = nr_parity_stripes(map);\n\n\t\t\t*length = map->stripe_len;\n\t\t\tstripe_index = 0;\n\t\t\tstripe_offset = 0;\n\t\t} else {\n\t\t\tu64 tmp;\n\n\t\t\t/*\n\t\t\t * Mirror #0 or #1 means the original data block.\n\t\t\t * Mirror #2 is RAID5 parity block.\n\t\t\t * Mirror #3 is RAID6 Q block.\n\t\t\t */\n\t\t\tstripe_index = do_div(stripe_nr, nr_data_stripes(map));\n\t\t\tif (mirror_num > 1)\n\t\t\t\tstripe_index = nr_data_stripes(map) +\n\t\t\t\t\t\tmirror_num - 2;\n\n\t\t\t/* We distribute the parity blocks across stripes */\n\t\t\ttmp = stripe_nr + stripe_index;\n\t\t\tstripe_index = do_div(tmp, map->num_stripes);\n\t\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD |\n\t\t\t\t    REQ_GET_READ_MIRRORS)) && mirror_num <= 1)\n\t\t\t\tmirror_num = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * after this do_div call, stripe_nr is the number of stripes\n\t\t * on this device we have to walk to find the data, and\n\t\t * stripe_index is the number of our device in the stripe array\n\t\t */\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tmirror_num = stripe_index + 1;\n\t}\n\tBUG_ON(stripe_index >= map->num_stripes);\n\n\tnum_alloc_stripes = num_stripes;\n\tif (dev_replace_is_ongoing) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD))\n\t\t\tnum_alloc_stripes <<= 1;\n\t\tif (rw & REQ_GET_READ_MIRRORS)\n\t\t\tnum_alloc_stripes++;\n\t\ttgtdev_indexes = num_stripes;\n\t}\n\n\tbbio = alloc_btrfs_bio(num_alloc_stripes, tgtdev_indexes);\n\tif (!bbio) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (dev_replace_is_ongoing)\n\t\tbbio->tgtdev_map = (int *)(bbio->stripes + num_alloc_stripes);\n\n\t/* build raid_map */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK &&\n\t    need_raid_map && ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t    mirror_num > 1)) {\n\t\tu64 tmp;\n\t\tint i, rot;\n\n\t\tbbio->raid_map = (u64 *)((void *)bbio->stripes +\n\t\t\t\t sizeof(struct btrfs_bio_stripe) *\n\t\t\t\t num_alloc_stripes +\n\t\t\t\t sizeof(int) * tgtdev_indexes);\n\n\t\t/* Work out the disk rotation on this stripe-set */\n\t\ttmp = stripe_nr;\n\t\trot = do_div(tmp, num_stripes);\n\n\t\t/* Fill in the logical address of each stripe */\n\t\ttmp = stripe_nr * nr_data_stripes(map);\n\t\tfor (i = 0; i < nr_data_stripes(map); i++)\n\t\t\tbbio->raid_map[(i+rot) % num_stripes] =\n\t\t\t\tem->start + (tmp + i) * map->stripe_len;\n\n\t\tbbio->raid_map[(i+rot) % map->num_stripes] = RAID5_P_STRIPE;\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\t\tbbio->raid_map[(i+rot+1) % num_stripes] =\n\t\t\t\tRAID6_Q_STRIPE;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\tint factor = 0;\n\t\tint sub_stripes = 0;\n\t\tu64 stripes_per_dev = 0;\n\t\tu32 remaining_stripes = 0;\n\t\tu32 last_stripe = 0;\n\n\t\tif (map->type &\n\t\t    (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID0)\n\t\t\t\tsub_stripes = 1;\n\t\t\telse\n\t\t\t\tsub_stripes = map->sub_stripes;\n\n\t\t\tfactor = map->num_stripes / sub_stripes;\n\t\t\tstripes_per_dev = div_u64_rem(stripe_nr_end -\n\t\t\t\t\t\t      stripe_nr_orig,\n\t\t\t\t\t\t      factor,\n\t\t\t\t\t\t      &remaining_stripes);\n\t\t\tdiv_u64_rem(stripe_nr_end - 1, factor, &last_stripe);\n\t\t\tlast_stripe *= sub_stripes;\n\t\t}\n\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset + stripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev = map->stripes[stripe_index].dev;\n\n\t\t\tif (map->type & (BTRFS_BLOCK_GROUP_RAID0 |\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\tbbio->stripes[i].length = stripes_per_dev *\n\t\t\t\t\t\t\t  map->stripe_len;\n\n\t\t\t\tif (i / sub_stripes < remaining_stripes)\n\t\t\t\t\tbbio->stripes[i].length +=\n\t\t\t\t\t\tmap->stripe_len;\n\n\t\t\t\t/*\n\t\t\t\t * Special for the first stripe and\n\t\t\t\t * the last stripe:\n\t\t\t\t *\n\t\t\t\t * |-------|...|-------|\n\t\t\t\t *     |----------|\n\t\t\t\t *    off     end_off\n\t\t\t\t */\n\t\t\t\tif (i < sub_stripes)\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_offset;\n\n\t\t\t\tif (stripe_index >= last_stripe &&\n\t\t\t\t    stripe_index <= (last_stripe +\n\t\t\t\t\t\t     sub_stripes - 1))\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_end_offset;\n\n\t\t\t\tif (i == sub_stripes - 1)\n\t\t\t\t\tstripe_offset = 0;\n\t\t\t} else\n\t\t\t\tbbio->stripes[i].length = *length;\n\n\t\t\tstripe_index++;\n\t\t\tif (stripe_index == map->num_stripes) {\n\t\t\t\t/* This could only happen for RAID0/10 */\n\t\t\t\tstripe_index = 0;\n\t\t\t\tstripe_nr++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset +\n\t\t\t\tstripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev =\n\t\t\t\tmap->stripes[stripe_index].dev;\n\t\t\tstripe_index++;\n\t\t}\n\t}\n\n\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\tmax_errors = btrfs_chunk_max_errors(map);\n\n\tif (bbio->raid_map)\n\t\tsort_parity_stripes(bbio, num_stripes);\n\n\ttgtdev_indexes = 0;\n\tif (dev_replace_is_ongoing && (rw & (REQ_WRITE | REQ_DISCARD)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\tint index_where_to_add;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\n\t\t/*\n\t\t * duplicate the write operations while the dev replace\n\t\t * procedure is running. Since the copying of the old disk\n\t\t * to the new disk takes place at run time while the\n\t\t * filesystem is mounted writable, the regular write\n\t\t * operations to the old disk have to be duplicated to go\n\t\t * to the new disk as well.\n\t\t * Note that device->missing is handled by the caller, and\n\t\t * that the write to the old disk is already set up in the\n\t\t * stripes array.\n\t\t */\n\t\tindex_where_to_add = num_stripes;\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/* write to new disk, too */\n\t\t\t\tstruct btrfs_bio_stripe *new =\n\t\t\t\t\tbbio->stripes + index_where_to_add;\n\t\t\t\tstruct btrfs_bio_stripe *old =\n\t\t\t\t\tbbio->stripes + i;\n\n\t\t\t\tnew->physical = old->physical;\n\t\t\t\tnew->length = old->length;\n\t\t\t\tnew->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[i] = index_where_to_add;\n\t\t\t\tindex_where_to_add++;\n\t\t\t\tmax_errors++;\n\t\t\t\ttgtdev_indexes++;\n\t\t\t}\n\t\t}\n\t\tnum_stripes = index_where_to_add;\n\t} else if (dev_replace_is_ongoing && (rw & REQ_GET_READ_MIRRORS) &&\n\t\t   dev_replace->tgtdev != NULL) {\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\t/*\n\t\t * During the dev-replace procedure, the target drive can\n\t\t * also be used to read data in case it is needed to repair\n\t\t * a corrupt block elsewhere. This is possible if the\n\t\t * requested area is left of the left cursor. In this area,\n\t\t * the target drive is a full copy of the source drive.\n\t\t */\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found = bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tu64 length = map->stripe_len;\n\n\t\t\tif (physical_of_found + length <=\n\t\t\t    dev_replace->cursor_left) {\n\t\t\t\tstruct btrfs_bio_stripe *tgtdev_stripe =\n\t\t\t\t\tbbio->stripes + num_stripes;\n\n\t\t\t\ttgtdev_stripe->physical = physical_of_found;\n\t\t\t\ttgtdev_stripe->length =\n\t\t\t\t\tbbio->stripes[index_srcdev].length;\n\t\t\t\ttgtdev_stripe->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[index_srcdev] = num_stripes;\n\n\t\t\t\ttgtdev_indexes++;\n\t\t\t\tnum_stripes++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*bbio_ret = bbio;\n\tbbio->map_type = map->type;\n\tbbio->num_stripes = num_stripes;\n\tbbio->max_errors = max_errors;\n\tbbio->mirror_num = mirror_num;\n\tbbio->num_tgtdevs = tgtdev_indexes;\n\n\t/*\n\t * this is the case that REQ_READ && dev_replace_is_ongoing &&\n\t * mirror_num == num_stripes + 1 && dev_replace target drive is\n\t * available as a mirror\n\t */\n\tif (patch_the_first_stripe_for_dev_replace && num_stripes > 0) {\n\t\tWARN_ON(num_stripes > 1);\n\t\tbbio->stripes[0].dev = dev_replace->tgtdev;\n\t\tbbio->stripes[0].physical = physical_to_patch_in_first_stripe;\n\t\tbbio->mirror_num = map->num_stripes + 1;\n\t}\nout:\n\tif (dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\tfree_extent_map(em);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_map_sblock(struct btrfs_fs_info *fs_info, int rw,\n\t\t     u64 logical, u64 *length,\n\t\t     struct btrfs_bio **bbio_ret, int mirror_num,\n\t\t     int need_raid_map)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, need_raid_map);\n}"
  },
  {
    "function_name": "btrfs_map_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "5484-5490",
    "snippet": "int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t      u64 logical, u64 *length,\n\t\t      struct btrfs_bio **bbio_ret, int mirror_num)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, 0);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_map_block",
          "args": [
            "fs_info",
            "rw",
            "logical",
            "length",
            "bbio_ret",
            "mirror_num",
            "0"
          ],
          "line": 5488
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4941-5482",
          "snippet": "static int __btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t\t     u64 logical, u64 *length,\n\t\t\t     struct btrfs_bio **bbio_ret,\n\t\t\t     int mirror_num, int need_raid_map)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tu64 offset;\n\tu64 stripe_offset;\n\tu64 stripe_end_offset;\n\tu64 stripe_nr;\n\tu64 stripe_nr_orig;\n\tu64 stripe_nr_end;\n\tu64 stripe_len;\n\tint stripe_index;\n\tint i;\n\tint ret = 0;\n\tint num_stripes;\n\tint max_errors = 0;\n\tint tgtdev_indexes = 0;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint dev_replace_is_ongoing = 0;\n\tint num_alloc_stripes;\n\tint patch_the_first_stripe_for_dev_replace = 0;\n\tu64 physical_to_patch_in_first_stripe = 0;\n\tu64 raid56_full_stripe_start = (u64)-1;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, *length);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"unable to find logical %llu len %llu\",\n\t\t\tlogical, *length);\n\t\treturn -EINVAL;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"found a bad mapping, wanted %Lu, \"\n\t\t\t   \"found %Lu-%Lu\", logical, em->start,\n\t\t\t   em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\toffset = logical - em->start;\n\n\tstripe_len = map->stripe_len;\n\tstripe_nr = offset;\n\t/*\n\t * stripe_nr counts the total number of stripes we have to stride\n\t * to get to this block\n\t */\n\tdo_div(stripe_nr, stripe_len);\n\n\tstripe_offset = stripe_nr * stripe_len;\n\tBUG_ON(offset < stripe_offset);\n\n\t/* stripe_offset is the offset of this block in its stripe*/\n\tstripe_offset = offset - stripe_offset;\n\n\t/* if we're here for raid56, we need to know the stripe aligned start */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tunsigned long full_stripe_len = stripe_len * nr_data_stripes(map);\n\t\traid56_full_stripe_start = offset;\n\n\t\t/* allow a write of a full stripe, but make sure we don't\n\t\t * allow straddling of stripes\n\t\t */\n\t\tdo_div(raid56_full_stripe_start, full_stripe_len);\n\t\traid56_full_stripe_start *= full_stripe_len;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\t/* we don't discard raid56 yet */\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, *length);\n\t} else if (map->type & BTRFS_BLOCK_GROUP_PROFILE_MASK) {\n\t\tu64 max_len;\n\t\t/* For writes to RAID[56], allow a full stripeset across all disks.\n\t\t   For other RAID types and for RAID[56] reads, just allow a single\n\t\t   stripe (on a single disk). */\n\t\tif ((map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) &&\n\t\t    (rw & REQ_WRITE)) {\n\t\t\tmax_len = stripe_len * nr_data_stripes(map) -\n\t\t\t\t(offset - raid56_full_stripe_start);\n\t\t} else {\n\t\t\t/* we limit the length of each bio to what fits in a stripe */\n\t\t\tmax_len = stripe_len - stripe_offset;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, max_len);\n\t} else {\n\t\t*length = em->len - offset;\n\t}\n\n\t/* This is for when we're called from btrfs_merge_bio_hook() and all\n\t   it cares about is the length */\n\tif (!bbio_ret)\n\t\tgoto out;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(dev_replace);\n\tif (!dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tif (dev_replace_is_ongoing && mirror_num == map->num_stripes + 1 &&\n\t    !(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\t/*\n\t\t * in dev-replace case, for repair case (that's the only\n\t\t * case where the mirror is selected explicitly when\n\t\t * calling btrfs_map_block), blocks left of the left cursor\n\t\t * can also be read from the target drive.\n\t\t * For REQ_GET_READ_MIRRORS, the target drive is added as\n\t\t * the last one to the array of stripes. For READ, it also\n\t\t * needs to be supported using the same mirror number.\n\t\t * If the requested block is not left of the left cursor,\n\t\t * EIO is returned. This can happen because btrfs_num_copies()\n\t\t * returns one more in the dev-replace case.\n\t\t */\n\t\tu64 tmp_length = *length;\n\t\tstruct btrfs_bio *tmp_bbio = NULL;\n\t\tint tmp_num_stripes;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\tret = __btrfs_map_block(fs_info, REQ_GET_READ_MIRRORS,\n\t\t\t     logical, &tmp_length, &tmp_bbio, 0, 0);\n\t\tif (ret) {\n\t\t\tWARN_ON(tmp_bbio != NULL);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttmp_num_stripes = tmp_bbio->num_stripes;\n\t\tif (mirror_num > tmp_num_stripes) {\n\t\t\t/*\n\t\t\t * REQ_GET_READ_MIRRORS does not contain this\n\t\t\t * mirror, that means that the requested area\n\t\t\t * is not left of the left cursor\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * process the rest of the function using the mirror_num\n\t\t * of the source drive. Therefore look it up first.\n\t\t * At the end, patch the device pointer to the one of the\n\t\t * target drive.\n\t\t */\n\t\tfor (i = 0; i < tmp_num_stripes; i++) {\n\t\t\tif (tmp_bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     tmp_bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found =\n\t\t\t\t\ttmp_bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tmirror_num = index_srcdev + 1;\n\t\t\tpatch_the_first_stripe_for_dev_replace = 1;\n\t\t\tphysical_to_patch_in_first_stripe = physical_of_found;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_put_bbio(tmp_bbio);\n\t} else if (mirror_num > map->num_stripes) {\n\t\tmirror_num = 0;\n\t}\n\n\tnum_stripes = 1;\n\tstripe_index = 0;\n\tstripe_nr_orig = stripe_nr;\n\tstripe_nr_end = ALIGN(offset + *length, map->stripe_len);\n\tdo_div(stripe_nr_end, map->stripe_len);\n\tstripe_end_offset = stripe_nr_end * map->stripe_len -\n\t\t\t    (offset + *length);\n\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\tif (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->num_stripes,\n\t\t\t\t\t    stripe_nr_end - stripe_nr_orig);\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)))\n\t\t\tmirror_num = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->num_stripes;\n\t\telse if (mirror_num)\n\t\t\tstripe_index = mirror_num - 1;\n\t\telse {\n\t\t\tstripe_index = find_live_mirror(fs_info, map, 0,\n\t\t\t\t\t    map->num_stripes,\n\t\t\t\t\t    current->pid % map->num_stripes,\n\t\t\t\t\t    dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_DUP) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) {\n\t\t\tnum_stripes = map->num_stripes;\n\t\t} else if (mirror_num) {\n\t\t\tstripe_index = mirror_num - 1;\n\t\t} else {\n\t\t\tmirror_num = 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tint factor = map->num_stripes / map->sub_stripes;\n\n\t\tstripe_index = do_div(stripe_nr, factor);\n\t\tstripe_index *= map->sub_stripes;\n\n\t\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->sub_stripes;\n\t\telse if (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->sub_stripes *\n\t\t\t\t\t    (stripe_nr_end - stripe_nr_orig),\n\t\t\t\t\t    map->num_stripes);\n\t\telse if (mirror_num)\n\t\t\tstripe_index += mirror_num - 1;\n\t\telse {\n\t\t\tint old_stripe_index = stripe_index;\n\t\t\tstripe_index = find_live_mirror(fs_info, map,\n\t\t\t\t\t      stripe_index,\n\t\t\t\t\t      map->sub_stripes, stripe_index +\n\t\t\t\t\t      current->pid % map->sub_stripes,\n\t\t\t\t\t      dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index - old_stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tif (need_raid_map &&\n\t\t    ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t\t     mirror_num > 1)) {\n\t\t\t/* push stripe_nr back to the start of the full stripe */\n\t\t\tstripe_nr = raid56_full_stripe_start;\n\t\t\tdo_div(stripe_nr, stripe_len * nr_data_stripes(map));\n\n\t\t\t/* RAID[56] write or recovery. Return all stripes */\n\t\t\tnum_stripes = map->num_stripes;\n\t\t\tmax_errors = nr_parity_stripes(map);\n\n\t\t\t*length = map->stripe_len;\n\t\t\tstripe_index = 0;\n\t\t\tstripe_offset = 0;\n\t\t} else {\n\t\t\tu64 tmp;\n\n\t\t\t/*\n\t\t\t * Mirror #0 or #1 means the original data block.\n\t\t\t * Mirror #2 is RAID5 parity block.\n\t\t\t * Mirror #3 is RAID6 Q block.\n\t\t\t */\n\t\t\tstripe_index = do_div(stripe_nr, nr_data_stripes(map));\n\t\t\tif (mirror_num > 1)\n\t\t\t\tstripe_index = nr_data_stripes(map) +\n\t\t\t\t\t\tmirror_num - 2;\n\n\t\t\t/* We distribute the parity blocks across stripes */\n\t\t\ttmp = stripe_nr + stripe_index;\n\t\t\tstripe_index = do_div(tmp, map->num_stripes);\n\t\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD |\n\t\t\t\t    REQ_GET_READ_MIRRORS)) && mirror_num <= 1)\n\t\t\t\tmirror_num = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * after this do_div call, stripe_nr is the number of stripes\n\t\t * on this device we have to walk to find the data, and\n\t\t * stripe_index is the number of our device in the stripe array\n\t\t */\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tmirror_num = stripe_index + 1;\n\t}\n\tBUG_ON(stripe_index >= map->num_stripes);\n\n\tnum_alloc_stripes = num_stripes;\n\tif (dev_replace_is_ongoing) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD))\n\t\t\tnum_alloc_stripes <<= 1;\n\t\tif (rw & REQ_GET_READ_MIRRORS)\n\t\t\tnum_alloc_stripes++;\n\t\ttgtdev_indexes = num_stripes;\n\t}\n\n\tbbio = alloc_btrfs_bio(num_alloc_stripes, tgtdev_indexes);\n\tif (!bbio) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (dev_replace_is_ongoing)\n\t\tbbio->tgtdev_map = (int *)(bbio->stripes + num_alloc_stripes);\n\n\t/* build raid_map */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK &&\n\t    need_raid_map && ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t    mirror_num > 1)) {\n\t\tu64 tmp;\n\t\tint i, rot;\n\n\t\tbbio->raid_map = (u64 *)((void *)bbio->stripes +\n\t\t\t\t sizeof(struct btrfs_bio_stripe) *\n\t\t\t\t num_alloc_stripes +\n\t\t\t\t sizeof(int) * tgtdev_indexes);\n\n\t\t/* Work out the disk rotation on this stripe-set */\n\t\ttmp = stripe_nr;\n\t\trot = do_div(tmp, num_stripes);\n\n\t\t/* Fill in the logical address of each stripe */\n\t\ttmp = stripe_nr * nr_data_stripes(map);\n\t\tfor (i = 0; i < nr_data_stripes(map); i++)\n\t\t\tbbio->raid_map[(i+rot) % num_stripes] =\n\t\t\t\tem->start + (tmp + i) * map->stripe_len;\n\n\t\tbbio->raid_map[(i+rot) % map->num_stripes] = RAID5_P_STRIPE;\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\t\tbbio->raid_map[(i+rot+1) % num_stripes] =\n\t\t\t\tRAID6_Q_STRIPE;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\tint factor = 0;\n\t\tint sub_stripes = 0;\n\t\tu64 stripes_per_dev = 0;\n\t\tu32 remaining_stripes = 0;\n\t\tu32 last_stripe = 0;\n\n\t\tif (map->type &\n\t\t    (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID0)\n\t\t\t\tsub_stripes = 1;\n\t\t\telse\n\t\t\t\tsub_stripes = map->sub_stripes;\n\n\t\t\tfactor = map->num_stripes / sub_stripes;\n\t\t\tstripes_per_dev = div_u64_rem(stripe_nr_end -\n\t\t\t\t\t\t      stripe_nr_orig,\n\t\t\t\t\t\t      factor,\n\t\t\t\t\t\t      &remaining_stripes);\n\t\t\tdiv_u64_rem(stripe_nr_end - 1, factor, &last_stripe);\n\t\t\tlast_stripe *= sub_stripes;\n\t\t}\n\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset + stripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev = map->stripes[stripe_index].dev;\n\n\t\t\tif (map->type & (BTRFS_BLOCK_GROUP_RAID0 |\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\tbbio->stripes[i].length = stripes_per_dev *\n\t\t\t\t\t\t\t  map->stripe_len;\n\n\t\t\t\tif (i / sub_stripes < remaining_stripes)\n\t\t\t\t\tbbio->stripes[i].length +=\n\t\t\t\t\t\tmap->stripe_len;\n\n\t\t\t\t/*\n\t\t\t\t * Special for the first stripe and\n\t\t\t\t * the last stripe:\n\t\t\t\t *\n\t\t\t\t * |-------|...|-------|\n\t\t\t\t *     |----------|\n\t\t\t\t *    off     end_off\n\t\t\t\t */\n\t\t\t\tif (i < sub_stripes)\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_offset;\n\n\t\t\t\tif (stripe_index >= last_stripe &&\n\t\t\t\t    stripe_index <= (last_stripe +\n\t\t\t\t\t\t     sub_stripes - 1))\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_end_offset;\n\n\t\t\t\tif (i == sub_stripes - 1)\n\t\t\t\t\tstripe_offset = 0;\n\t\t\t} else\n\t\t\t\tbbio->stripes[i].length = *length;\n\n\t\t\tstripe_index++;\n\t\t\tif (stripe_index == map->num_stripes) {\n\t\t\t\t/* This could only happen for RAID0/10 */\n\t\t\t\tstripe_index = 0;\n\t\t\t\tstripe_nr++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset +\n\t\t\t\tstripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev =\n\t\t\t\tmap->stripes[stripe_index].dev;\n\t\t\tstripe_index++;\n\t\t}\n\t}\n\n\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\tmax_errors = btrfs_chunk_max_errors(map);\n\n\tif (bbio->raid_map)\n\t\tsort_parity_stripes(bbio, num_stripes);\n\n\ttgtdev_indexes = 0;\n\tif (dev_replace_is_ongoing && (rw & (REQ_WRITE | REQ_DISCARD)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\tint index_where_to_add;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\n\t\t/*\n\t\t * duplicate the write operations while the dev replace\n\t\t * procedure is running. Since the copying of the old disk\n\t\t * to the new disk takes place at run time while the\n\t\t * filesystem is mounted writable, the regular write\n\t\t * operations to the old disk have to be duplicated to go\n\t\t * to the new disk as well.\n\t\t * Note that device->missing is handled by the caller, and\n\t\t * that the write to the old disk is already set up in the\n\t\t * stripes array.\n\t\t */\n\t\tindex_where_to_add = num_stripes;\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/* write to new disk, too */\n\t\t\t\tstruct btrfs_bio_stripe *new =\n\t\t\t\t\tbbio->stripes + index_where_to_add;\n\t\t\t\tstruct btrfs_bio_stripe *old =\n\t\t\t\t\tbbio->stripes + i;\n\n\t\t\t\tnew->physical = old->physical;\n\t\t\t\tnew->length = old->length;\n\t\t\t\tnew->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[i] = index_where_to_add;\n\t\t\t\tindex_where_to_add++;\n\t\t\t\tmax_errors++;\n\t\t\t\ttgtdev_indexes++;\n\t\t\t}\n\t\t}\n\t\tnum_stripes = index_where_to_add;\n\t} else if (dev_replace_is_ongoing && (rw & REQ_GET_READ_MIRRORS) &&\n\t\t   dev_replace->tgtdev != NULL) {\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\t/*\n\t\t * During the dev-replace procedure, the target drive can\n\t\t * also be used to read data in case it is needed to repair\n\t\t * a corrupt block elsewhere. This is possible if the\n\t\t * requested area is left of the left cursor. In this area,\n\t\t * the target drive is a full copy of the source drive.\n\t\t */\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found = bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tu64 length = map->stripe_len;\n\n\t\t\tif (physical_of_found + length <=\n\t\t\t    dev_replace->cursor_left) {\n\t\t\t\tstruct btrfs_bio_stripe *tgtdev_stripe =\n\t\t\t\t\tbbio->stripes + num_stripes;\n\n\t\t\t\ttgtdev_stripe->physical = physical_of_found;\n\t\t\t\ttgtdev_stripe->length =\n\t\t\t\t\tbbio->stripes[index_srcdev].length;\n\t\t\t\ttgtdev_stripe->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[index_srcdev] = num_stripes;\n\n\t\t\t\ttgtdev_indexes++;\n\t\t\t\tnum_stripes++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*bbio_ret = bbio;\n\tbbio->map_type = map->type;\n\tbbio->num_stripes = num_stripes;\n\tbbio->max_errors = max_errors;\n\tbbio->mirror_num = mirror_num;\n\tbbio->num_tgtdevs = tgtdev_indexes;\n\n\t/*\n\t * this is the case that REQ_READ && dev_replace_is_ongoing &&\n\t * mirror_num == num_stripes + 1 && dev_replace target drive is\n\t * available as a mirror\n\t */\n\tif (patch_the_first_stripe_for_dev_replace && num_stripes > 0) {\n\t\tWARN_ON(num_stripes > 1);\n\t\tbbio->stripes[0].dev = dev_replace->tgtdev;\n\t\tbbio->stripes[0].physical = physical_to_patch_in_first_stripe;\n\t\tbbio->mirror_num = map->num_stripes + 1;\n\t}\nout:\n\tif (dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\tfree_extent_map(em);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t\t     u64 logical, u64 *length,\n\t\t\t     struct btrfs_bio **bbio_ret,\n\t\t\t     int mirror_num, int need_raid_map)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tu64 offset;\n\tu64 stripe_offset;\n\tu64 stripe_end_offset;\n\tu64 stripe_nr;\n\tu64 stripe_nr_orig;\n\tu64 stripe_nr_end;\n\tu64 stripe_len;\n\tint stripe_index;\n\tint i;\n\tint ret = 0;\n\tint num_stripes;\n\tint max_errors = 0;\n\tint tgtdev_indexes = 0;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint dev_replace_is_ongoing = 0;\n\tint num_alloc_stripes;\n\tint patch_the_first_stripe_for_dev_replace = 0;\n\tu64 physical_to_patch_in_first_stripe = 0;\n\tu64 raid56_full_stripe_start = (u64)-1;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, *length);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"unable to find logical %llu len %llu\",\n\t\t\tlogical, *length);\n\t\treturn -EINVAL;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"found a bad mapping, wanted %Lu, \"\n\t\t\t   \"found %Lu-%Lu\", logical, em->start,\n\t\t\t   em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\toffset = logical - em->start;\n\n\tstripe_len = map->stripe_len;\n\tstripe_nr = offset;\n\t/*\n\t * stripe_nr counts the total number of stripes we have to stride\n\t * to get to this block\n\t */\n\tdo_div(stripe_nr, stripe_len);\n\n\tstripe_offset = stripe_nr * stripe_len;\n\tBUG_ON(offset < stripe_offset);\n\n\t/* stripe_offset is the offset of this block in its stripe*/\n\tstripe_offset = offset - stripe_offset;\n\n\t/* if we're here for raid56, we need to know the stripe aligned start */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tunsigned long full_stripe_len = stripe_len * nr_data_stripes(map);\n\t\traid56_full_stripe_start = offset;\n\n\t\t/* allow a write of a full stripe, but make sure we don't\n\t\t * allow straddling of stripes\n\t\t */\n\t\tdo_div(raid56_full_stripe_start, full_stripe_len);\n\t\traid56_full_stripe_start *= full_stripe_len;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\t/* we don't discard raid56 yet */\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, *length);\n\t} else if (map->type & BTRFS_BLOCK_GROUP_PROFILE_MASK) {\n\t\tu64 max_len;\n\t\t/* For writes to RAID[56], allow a full stripeset across all disks.\n\t\t   For other RAID types and for RAID[56] reads, just allow a single\n\t\t   stripe (on a single disk). */\n\t\tif ((map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) &&\n\t\t    (rw & REQ_WRITE)) {\n\t\t\tmax_len = stripe_len * nr_data_stripes(map) -\n\t\t\t\t(offset - raid56_full_stripe_start);\n\t\t} else {\n\t\t\t/* we limit the length of each bio to what fits in a stripe */\n\t\t\tmax_len = stripe_len - stripe_offset;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, max_len);\n\t} else {\n\t\t*length = em->len - offset;\n\t}\n\n\t/* This is for when we're called from btrfs_merge_bio_hook() and all\n\t   it cares about is the length */\n\tif (!bbio_ret)\n\t\tgoto out;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(dev_replace);\n\tif (!dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tif (dev_replace_is_ongoing && mirror_num == map->num_stripes + 1 &&\n\t    !(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\t/*\n\t\t * in dev-replace case, for repair case (that's the only\n\t\t * case where the mirror is selected explicitly when\n\t\t * calling btrfs_map_block), blocks left of the left cursor\n\t\t * can also be read from the target drive.\n\t\t * For REQ_GET_READ_MIRRORS, the target drive is added as\n\t\t * the last one to the array of stripes. For READ, it also\n\t\t * needs to be supported using the same mirror number.\n\t\t * If the requested block is not left of the left cursor,\n\t\t * EIO is returned. This can happen because btrfs_num_copies()\n\t\t * returns one more in the dev-replace case.\n\t\t */\n\t\tu64 tmp_length = *length;\n\t\tstruct btrfs_bio *tmp_bbio = NULL;\n\t\tint tmp_num_stripes;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\tret = __btrfs_map_block(fs_info, REQ_GET_READ_MIRRORS,\n\t\t\t     logical, &tmp_length, &tmp_bbio, 0, 0);\n\t\tif (ret) {\n\t\t\tWARN_ON(tmp_bbio != NULL);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttmp_num_stripes = tmp_bbio->num_stripes;\n\t\tif (mirror_num > tmp_num_stripes) {\n\t\t\t/*\n\t\t\t * REQ_GET_READ_MIRRORS does not contain this\n\t\t\t * mirror, that means that the requested area\n\t\t\t * is not left of the left cursor\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * process the rest of the function using the mirror_num\n\t\t * of the source drive. Therefore look it up first.\n\t\t * At the end, patch the device pointer to the one of the\n\t\t * target drive.\n\t\t */\n\t\tfor (i = 0; i < tmp_num_stripes; i++) {\n\t\t\tif (tmp_bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     tmp_bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found =\n\t\t\t\t\ttmp_bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tmirror_num = index_srcdev + 1;\n\t\t\tpatch_the_first_stripe_for_dev_replace = 1;\n\t\t\tphysical_to_patch_in_first_stripe = physical_of_found;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_put_bbio(tmp_bbio);\n\t} else if (mirror_num > map->num_stripes) {\n\t\tmirror_num = 0;\n\t}\n\n\tnum_stripes = 1;\n\tstripe_index = 0;\n\tstripe_nr_orig = stripe_nr;\n\tstripe_nr_end = ALIGN(offset + *length, map->stripe_len);\n\tdo_div(stripe_nr_end, map->stripe_len);\n\tstripe_end_offset = stripe_nr_end * map->stripe_len -\n\t\t\t    (offset + *length);\n\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\tif (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->num_stripes,\n\t\t\t\t\t    stripe_nr_end - stripe_nr_orig);\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)))\n\t\t\tmirror_num = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->num_stripes;\n\t\telse if (mirror_num)\n\t\t\tstripe_index = mirror_num - 1;\n\t\telse {\n\t\t\tstripe_index = find_live_mirror(fs_info, map, 0,\n\t\t\t\t\t    map->num_stripes,\n\t\t\t\t\t    current->pid % map->num_stripes,\n\t\t\t\t\t    dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_DUP) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) {\n\t\t\tnum_stripes = map->num_stripes;\n\t\t} else if (mirror_num) {\n\t\t\tstripe_index = mirror_num - 1;\n\t\t} else {\n\t\t\tmirror_num = 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tint factor = map->num_stripes / map->sub_stripes;\n\n\t\tstripe_index = do_div(stripe_nr, factor);\n\t\tstripe_index *= map->sub_stripes;\n\n\t\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->sub_stripes;\n\t\telse if (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->sub_stripes *\n\t\t\t\t\t    (stripe_nr_end - stripe_nr_orig),\n\t\t\t\t\t    map->num_stripes);\n\t\telse if (mirror_num)\n\t\t\tstripe_index += mirror_num - 1;\n\t\telse {\n\t\t\tint old_stripe_index = stripe_index;\n\t\t\tstripe_index = find_live_mirror(fs_info, map,\n\t\t\t\t\t      stripe_index,\n\t\t\t\t\t      map->sub_stripes, stripe_index +\n\t\t\t\t\t      current->pid % map->sub_stripes,\n\t\t\t\t\t      dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index - old_stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tif (need_raid_map &&\n\t\t    ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t\t     mirror_num > 1)) {\n\t\t\t/* push stripe_nr back to the start of the full stripe */\n\t\t\tstripe_nr = raid56_full_stripe_start;\n\t\t\tdo_div(stripe_nr, stripe_len * nr_data_stripes(map));\n\n\t\t\t/* RAID[56] write or recovery. Return all stripes */\n\t\t\tnum_stripes = map->num_stripes;\n\t\t\tmax_errors = nr_parity_stripes(map);\n\n\t\t\t*length = map->stripe_len;\n\t\t\tstripe_index = 0;\n\t\t\tstripe_offset = 0;\n\t\t} else {\n\t\t\tu64 tmp;\n\n\t\t\t/*\n\t\t\t * Mirror #0 or #1 means the original data block.\n\t\t\t * Mirror #2 is RAID5 parity block.\n\t\t\t * Mirror #3 is RAID6 Q block.\n\t\t\t */\n\t\t\tstripe_index = do_div(stripe_nr, nr_data_stripes(map));\n\t\t\tif (mirror_num > 1)\n\t\t\t\tstripe_index = nr_data_stripes(map) +\n\t\t\t\t\t\tmirror_num - 2;\n\n\t\t\t/* We distribute the parity blocks across stripes */\n\t\t\ttmp = stripe_nr + stripe_index;\n\t\t\tstripe_index = do_div(tmp, map->num_stripes);\n\t\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD |\n\t\t\t\t    REQ_GET_READ_MIRRORS)) && mirror_num <= 1)\n\t\t\t\tmirror_num = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * after this do_div call, stripe_nr is the number of stripes\n\t\t * on this device we have to walk to find the data, and\n\t\t * stripe_index is the number of our device in the stripe array\n\t\t */\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tmirror_num = stripe_index + 1;\n\t}\n\tBUG_ON(stripe_index >= map->num_stripes);\n\n\tnum_alloc_stripes = num_stripes;\n\tif (dev_replace_is_ongoing) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD))\n\t\t\tnum_alloc_stripes <<= 1;\n\t\tif (rw & REQ_GET_READ_MIRRORS)\n\t\t\tnum_alloc_stripes++;\n\t\ttgtdev_indexes = num_stripes;\n\t}\n\n\tbbio = alloc_btrfs_bio(num_alloc_stripes, tgtdev_indexes);\n\tif (!bbio) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (dev_replace_is_ongoing)\n\t\tbbio->tgtdev_map = (int *)(bbio->stripes + num_alloc_stripes);\n\n\t/* build raid_map */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK &&\n\t    need_raid_map && ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t    mirror_num > 1)) {\n\t\tu64 tmp;\n\t\tint i, rot;\n\n\t\tbbio->raid_map = (u64 *)((void *)bbio->stripes +\n\t\t\t\t sizeof(struct btrfs_bio_stripe) *\n\t\t\t\t num_alloc_stripes +\n\t\t\t\t sizeof(int) * tgtdev_indexes);\n\n\t\t/* Work out the disk rotation on this stripe-set */\n\t\ttmp = stripe_nr;\n\t\trot = do_div(tmp, num_stripes);\n\n\t\t/* Fill in the logical address of each stripe */\n\t\ttmp = stripe_nr * nr_data_stripes(map);\n\t\tfor (i = 0; i < nr_data_stripes(map); i++)\n\t\t\tbbio->raid_map[(i+rot) % num_stripes] =\n\t\t\t\tem->start + (tmp + i) * map->stripe_len;\n\n\t\tbbio->raid_map[(i+rot) % map->num_stripes] = RAID5_P_STRIPE;\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\t\tbbio->raid_map[(i+rot+1) % num_stripes] =\n\t\t\t\tRAID6_Q_STRIPE;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\tint factor = 0;\n\t\tint sub_stripes = 0;\n\t\tu64 stripes_per_dev = 0;\n\t\tu32 remaining_stripes = 0;\n\t\tu32 last_stripe = 0;\n\n\t\tif (map->type &\n\t\t    (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID0)\n\t\t\t\tsub_stripes = 1;\n\t\t\telse\n\t\t\t\tsub_stripes = map->sub_stripes;\n\n\t\t\tfactor = map->num_stripes / sub_stripes;\n\t\t\tstripes_per_dev = div_u64_rem(stripe_nr_end -\n\t\t\t\t\t\t      stripe_nr_orig,\n\t\t\t\t\t\t      factor,\n\t\t\t\t\t\t      &remaining_stripes);\n\t\t\tdiv_u64_rem(stripe_nr_end - 1, factor, &last_stripe);\n\t\t\tlast_stripe *= sub_stripes;\n\t\t}\n\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset + stripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev = map->stripes[stripe_index].dev;\n\n\t\t\tif (map->type & (BTRFS_BLOCK_GROUP_RAID0 |\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\tbbio->stripes[i].length = stripes_per_dev *\n\t\t\t\t\t\t\t  map->stripe_len;\n\n\t\t\t\tif (i / sub_stripes < remaining_stripes)\n\t\t\t\t\tbbio->stripes[i].length +=\n\t\t\t\t\t\tmap->stripe_len;\n\n\t\t\t\t/*\n\t\t\t\t * Special for the first stripe and\n\t\t\t\t * the last stripe:\n\t\t\t\t *\n\t\t\t\t * |-------|...|-------|\n\t\t\t\t *     |----------|\n\t\t\t\t *    off     end_off\n\t\t\t\t */\n\t\t\t\tif (i < sub_stripes)\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_offset;\n\n\t\t\t\tif (stripe_index >= last_stripe &&\n\t\t\t\t    stripe_index <= (last_stripe +\n\t\t\t\t\t\t     sub_stripes - 1))\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_end_offset;\n\n\t\t\t\tif (i == sub_stripes - 1)\n\t\t\t\t\tstripe_offset = 0;\n\t\t\t} else\n\t\t\t\tbbio->stripes[i].length = *length;\n\n\t\t\tstripe_index++;\n\t\t\tif (stripe_index == map->num_stripes) {\n\t\t\t\t/* This could only happen for RAID0/10 */\n\t\t\t\tstripe_index = 0;\n\t\t\t\tstripe_nr++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset +\n\t\t\t\tstripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev =\n\t\t\t\tmap->stripes[stripe_index].dev;\n\t\t\tstripe_index++;\n\t\t}\n\t}\n\n\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\tmax_errors = btrfs_chunk_max_errors(map);\n\n\tif (bbio->raid_map)\n\t\tsort_parity_stripes(bbio, num_stripes);\n\n\ttgtdev_indexes = 0;\n\tif (dev_replace_is_ongoing && (rw & (REQ_WRITE | REQ_DISCARD)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\tint index_where_to_add;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\n\t\t/*\n\t\t * duplicate the write operations while the dev replace\n\t\t * procedure is running. Since the copying of the old disk\n\t\t * to the new disk takes place at run time while the\n\t\t * filesystem is mounted writable, the regular write\n\t\t * operations to the old disk have to be duplicated to go\n\t\t * to the new disk as well.\n\t\t * Note that device->missing is handled by the caller, and\n\t\t * that the write to the old disk is already set up in the\n\t\t * stripes array.\n\t\t */\n\t\tindex_where_to_add = num_stripes;\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/* write to new disk, too */\n\t\t\t\tstruct btrfs_bio_stripe *new =\n\t\t\t\t\tbbio->stripes + index_where_to_add;\n\t\t\t\tstruct btrfs_bio_stripe *old =\n\t\t\t\t\tbbio->stripes + i;\n\n\t\t\t\tnew->physical = old->physical;\n\t\t\t\tnew->length = old->length;\n\t\t\t\tnew->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[i] = index_where_to_add;\n\t\t\t\tindex_where_to_add++;\n\t\t\t\tmax_errors++;\n\t\t\t\ttgtdev_indexes++;\n\t\t\t}\n\t\t}\n\t\tnum_stripes = index_where_to_add;\n\t} else if (dev_replace_is_ongoing && (rw & REQ_GET_READ_MIRRORS) &&\n\t\t   dev_replace->tgtdev != NULL) {\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\t/*\n\t\t * During the dev-replace procedure, the target drive can\n\t\t * also be used to read data in case it is needed to repair\n\t\t * a corrupt block elsewhere. This is possible if the\n\t\t * requested area is left of the left cursor. In this area,\n\t\t * the target drive is a full copy of the source drive.\n\t\t */\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found = bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tu64 length = map->stripe_len;\n\n\t\t\tif (physical_of_found + length <=\n\t\t\t    dev_replace->cursor_left) {\n\t\t\t\tstruct btrfs_bio_stripe *tgtdev_stripe =\n\t\t\t\t\tbbio->stripes + num_stripes;\n\n\t\t\t\ttgtdev_stripe->physical = physical_of_found;\n\t\t\t\ttgtdev_stripe->length =\n\t\t\t\t\tbbio->stripes[index_srcdev].length;\n\t\t\t\ttgtdev_stripe->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[index_srcdev] = num_stripes;\n\n\t\t\t\ttgtdev_indexes++;\n\t\t\t\tnum_stripes++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*bbio_ret = bbio;\n\tbbio->map_type = map->type;\n\tbbio->num_stripes = num_stripes;\n\tbbio->max_errors = max_errors;\n\tbbio->mirror_num = mirror_num;\n\tbbio->num_tgtdevs = tgtdev_indexes;\n\n\t/*\n\t * this is the case that REQ_READ && dev_replace_is_ongoing &&\n\t * mirror_num == num_stripes + 1 && dev_replace target drive is\n\t * available as a mirror\n\t */\n\tif (patch_the_first_stripe_for_dev_replace && num_stripes > 0) {\n\t\tWARN_ON(num_stripes > 1);\n\t\tbbio->stripes[0].dev = dev_replace->tgtdev;\n\t\tbbio->stripes[0].physical = physical_to_patch_in_first_stripe;\n\t\tbbio->mirror_num = map->num_stripes + 1;\n\t}\nout:\n\tif (dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\tfree_extent_map(em);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t      u64 logical, u64 *length,\n\t\t      struct btrfs_bio **bbio_ret, int mirror_num)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, 0);\n}"
  },
  {
    "function_name": "__btrfs_map_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4941-5482",
    "snippet": "static int __btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t\t     u64 logical, u64 *length,\n\t\t\t     struct btrfs_bio **bbio_ret,\n\t\t\t     int mirror_num, int need_raid_map)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tu64 offset;\n\tu64 stripe_offset;\n\tu64 stripe_end_offset;\n\tu64 stripe_nr;\n\tu64 stripe_nr_orig;\n\tu64 stripe_nr_end;\n\tu64 stripe_len;\n\tint stripe_index;\n\tint i;\n\tint ret = 0;\n\tint num_stripes;\n\tint max_errors = 0;\n\tint tgtdev_indexes = 0;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint dev_replace_is_ongoing = 0;\n\tint num_alloc_stripes;\n\tint patch_the_first_stripe_for_dev_replace = 0;\n\tu64 physical_to_patch_in_first_stripe = 0;\n\tu64 raid56_full_stripe_start = (u64)-1;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, *length);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"unable to find logical %llu len %llu\",\n\t\t\tlogical, *length);\n\t\treturn -EINVAL;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"found a bad mapping, wanted %Lu, \"\n\t\t\t   \"found %Lu-%Lu\", logical, em->start,\n\t\t\t   em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\toffset = logical - em->start;\n\n\tstripe_len = map->stripe_len;\n\tstripe_nr = offset;\n\t/*\n\t * stripe_nr counts the total number of stripes we have to stride\n\t * to get to this block\n\t */\n\tdo_div(stripe_nr, stripe_len);\n\n\tstripe_offset = stripe_nr * stripe_len;\n\tBUG_ON(offset < stripe_offset);\n\n\t/* stripe_offset is the offset of this block in its stripe*/\n\tstripe_offset = offset - stripe_offset;\n\n\t/* if we're here for raid56, we need to know the stripe aligned start */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tunsigned long full_stripe_len = stripe_len * nr_data_stripes(map);\n\t\traid56_full_stripe_start = offset;\n\n\t\t/* allow a write of a full stripe, but make sure we don't\n\t\t * allow straddling of stripes\n\t\t */\n\t\tdo_div(raid56_full_stripe_start, full_stripe_len);\n\t\traid56_full_stripe_start *= full_stripe_len;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\t/* we don't discard raid56 yet */\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, *length);\n\t} else if (map->type & BTRFS_BLOCK_GROUP_PROFILE_MASK) {\n\t\tu64 max_len;\n\t\t/* For writes to RAID[56], allow a full stripeset across all disks.\n\t\t   For other RAID types and for RAID[56] reads, just allow a single\n\t\t   stripe (on a single disk). */\n\t\tif ((map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) &&\n\t\t    (rw & REQ_WRITE)) {\n\t\t\tmax_len = stripe_len * nr_data_stripes(map) -\n\t\t\t\t(offset - raid56_full_stripe_start);\n\t\t} else {\n\t\t\t/* we limit the length of each bio to what fits in a stripe */\n\t\t\tmax_len = stripe_len - stripe_offset;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, max_len);\n\t} else {\n\t\t*length = em->len - offset;\n\t}\n\n\t/* This is for when we're called from btrfs_merge_bio_hook() and all\n\t   it cares about is the length */\n\tif (!bbio_ret)\n\t\tgoto out;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(dev_replace);\n\tif (!dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tif (dev_replace_is_ongoing && mirror_num == map->num_stripes + 1 &&\n\t    !(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\t/*\n\t\t * in dev-replace case, for repair case (that's the only\n\t\t * case where the mirror is selected explicitly when\n\t\t * calling btrfs_map_block), blocks left of the left cursor\n\t\t * can also be read from the target drive.\n\t\t * For REQ_GET_READ_MIRRORS, the target drive is added as\n\t\t * the last one to the array of stripes. For READ, it also\n\t\t * needs to be supported using the same mirror number.\n\t\t * If the requested block is not left of the left cursor,\n\t\t * EIO is returned. This can happen because btrfs_num_copies()\n\t\t * returns one more in the dev-replace case.\n\t\t */\n\t\tu64 tmp_length = *length;\n\t\tstruct btrfs_bio *tmp_bbio = NULL;\n\t\tint tmp_num_stripes;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\tret = __btrfs_map_block(fs_info, REQ_GET_READ_MIRRORS,\n\t\t\t     logical, &tmp_length, &tmp_bbio, 0, 0);\n\t\tif (ret) {\n\t\t\tWARN_ON(tmp_bbio != NULL);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttmp_num_stripes = tmp_bbio->num_stripes;\n\t\tif (mirror_num > tmp_num_stripes) {\n\t\t\t/*\n\t\t\t * REQ_GET_READ_MIRRORS does not contain this\n\t\t\t * mirror, that means that the requested area\n\t\t\t * is not left of the left cursor\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * process the rest of the function using the mirror_num\n\t\t * of the source drive. Therefore look it up first.\n\t\t * At the end, patch the device pointer to the one of the\n\t\t * target drive.\n\t\t */\n\t\tfor (i = 0; i < tmp_num_stripes; i++) {\n\t\t\tif (tmp_bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     tmp_bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found =\n\t\t\t\t\ttmp_bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tmirror_num = index_srcdev + 1;\n\t\t\tpatch_the_first_stripe_for_dev_replace = 1;\n\t\t\tphysical_to_patch_in_first_stripe = physical_of_found;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_put_bbio(tmp_bbio);\n\t} else if (mirror_num > map->num_stripes) {\n\t\tmirror_num = 0;\n\t}\n\n\tnum_stripes = 1;\n\tstripe_index = 0;\n\tstripe_nr_orig = stripe_nr;\n\tstripe_nr_end = ALIGN(offset + *length, map->stripe_len);\n\tdo_div(stripe_nr_end, map->stripe_len);\n\tstripe_end_offset = stripe_nr_end * map->stripe_len -\n\t\t\t    (offset + *length);\n\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\tif (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->num_stripes,\n\t\t\t\t\t    stripe_nr_end - stripe_nr_orig);\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)))\n\t\t\tmirror_num = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->num_stripes;\n\t\telse if (mirror_num)\n\t\t\tstripe_index = mirror_num - 1;\n\t\telse {\n\t\t\tstripe_index = find_live_mirror(fs_info, map, 0,\n\t\t\t\t\t    map->num_stripes,\n\t\t\t\t\t    current->pid % map->num_stripes,\n\t\t\t\t\t    dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_DUP) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) {\n\t\t\tnum_stripes = map->num_stripes;\n\t\t} else if (mirror_num) {\n\t\t\tstripe_index = mirror_num - 1;\n\t\t} else {\n\t\t\tmirror_num = 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tint factor = map->num_stripes / map->sub_stripes;\n\n\t\tstripe_index = do_div(stripe_nr, factor);\n\t\tstripe_index *= map->sub_stripes;\n\n\t\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->sub_stripes;\n\t\telse if (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->sub_stripes *\n\t\t\t\t\t    (stripe_nr_end - stripe_nr_orig),\n\t\t\t\t\t    map->num_stripes);\n\t\telse if (mirror_num)\n\t\t\tstripe_index += mirror_num - 1;\n\t\telse {\n\t\t\tint old_stripe_index = stripe_index;\n\t\t\tstripe_index = find_live_mirror(fs_info, map,\n\t\t\t\t\t      stripe_index,\n\t\t\t\t\t      map->sub_stripes, stripe_index +\n\t\t\t\t\t      current->pid % map->sub_stripes,\n\t\t\t\t\t      dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index - old_stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tif (need_raid_map &&\n\t\t    ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t\t     mirror_num > 1)) {\n\t\t\t/* push stripe_nr back to the start of the full stripe */\n\t\t\tstripe_nr = raid56_full_stripe_start;\n\t\t\tdo_div(stripe_nr, stripe_len * nr_data_stripes(map));\n\n\t\t\t/* RAID[56] write or recovery. Return all stripes */\n\t\t\tnum_stripes = map->num_stripes;\n\t\t\tmax_errors = nr_parity_stripes(map);\n\n\t\t\t*length = map->stripe_len;\n\t\t\tstripe_index = 0;\n\t\t\tstripe_offset = 0;\n\t\t} else {\n\t\t\tu64 tmp;\n\n\t\t\t/*\n\t\t\t * Mirror #0 or #1 means the original data block.\n\t\t\t * Mirror #2 is RAID5 parity block.\n\t\t\t * Mirror #3 is RAID6 Q block.\n\t\t\t */\n\t\t\tstripe_index = do_div(stripe_nr, nr_data_stripes(map));\n\t\t\tif (mirror_num > 1)\n\t\t\t\tstripe_index = nr_data_stripes(map) +\n\t\t\t\t\t\tmirror_num - 2;\n\n\t\t\t/* We distribute the parity blocks across stripes */\n\t\t\ttmp = stripe_nr + stripe_index;\n\t\t\tstripe_index = do_div(tmp, map->num_stripes);\n\t\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD |\n\t\t\t\t    REQ_GET_READ_MIRRORS)) && mirror_num <= 1)\n\t\t\t\tmirror_num = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * after this do_div call, stripe_nr is the number of stripes\n\t\t * on this device we have to walk to find the data, and\n\t\t * stripe_index is the number of our device in the stripe array\n\t\t */\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tmirror_num = stripe_index + 1;\n\t}\n\tBUG_ON(stripe_index >= map->num_stripes);\n\n\tnum_alloc_stripes = num_stripes;\n\tif (dev_replace_is_ongoing) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD))\n\t\t\tnum_alloc_stripes <<= 1;\n\t\tif (rw & REQ_GET_READ_MIRRORS)\n\t\t\tnum_alloc_stripes++;\n\t\ttgtdev_indexes = num_stripes;\n\t}\n\n\tbbio = alloc_btrfs_bio(num_alloc_stripes, tgtdev_indexes);\n\tif (!bbio) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (dev_replace_is_ongoing)\n\t\tbbio->tgtdev_map = (int *)(bbio->stripes + num_alloc_stripes);\n\n\t/* build raid_map */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK &&\n\t    need_raid_map && ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t    mirror_num > 1)) {\n\t\tu64 tmp;\n\t\tint i, rot;\n\n\t\tbbio->raid_map = (u64 *)((void *)bbio->stripes +\n\t\t\t\t sizeof(struct btrfs_bio_stripe) *\n\t\t\t\t num_alloc_stripes +\n\t\t\t\t sizeof(int) * tgtdev_indexes);\n\n\t\t/* Work out the disk rotation on this stripe-set */\n\t\ttmp = stripe_nr;\n\t\trot = do_div(tmp, num_stripes);\n\n\t\t/* Fill in the logical address of each stripe */\n\t\ttmp = stripe_nr * nr_data_stripes(map);\n\t\tfor (i = 0; i < nr_data_stripes(map); i++)\n\t\t\tbbio->raid_map[(i+rot) % num_stripes] =\n\t\t\t\tem->start + (tmp + i) * map->stripe_len;\n\n\t\tbbio->raid_map[(i+rot) % map->num_stripes] = RAID5_P_STRIPE;\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\t\tbbio->raid_map[(i+rot+1) % num_stripes] =\n\t\t\t\tRAID6_Q_STRIPE;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\tint factor = 0;\n\t\tint sub_stripes = 0;\n\t\tu64 stripes_per_dev = 0;\n\t\tu32 remaining_stripes = 0;\n\t\tu32 last_stripe = 0;\n\n\t\tif (map->type &\n\t\t    (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID0)\n\t\t\t\tsub_stripes = 1;\n\t\t\telse\n\t\t\t\tsub_stripes = map->sub_stripes;\n\n\t\t\tfactor = map->num_stripes / sub_stripes;\n\t\t\tstripes_per_dev = div_u64_rem(stripe_nr_end -\n\t\t\t\t\t\t      stripe_nr_orig,\n\t\t\t\t\t\t      factor,\n\t\t\t\t\t\t      &remaining_stripes);\n\t\t\tdiv_u64_rem(stripe_nr_end - 1, factor, &last_stripe);\n\t\t\tlast_stripe *= sub_stripes;\n\t\t}\n\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset + stripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev = map->stripes[stripe_index].dev;\n\n\t\t\tif (map->type & (BTRFS_BLOCK_GROUP_RAID0 |\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\tbbio->stripes[i].length = stripes_per_dev *\n\t\t\t\t\t\t\t  map->stripe_len;\n\n\t\t\t\tif (i / sub_stripes < remaining_stripes)\n\t\t\t\t\tbbio->stripes[i].length +=\n\t\t\t\t\t\tmap->stripe_len;\n\n\t\t\t\t/*\n\t\t\t\t * Special for the first stripe and\n\t\t\t\t * the last stripe:\n\t\t\t\t *\n\t\t\t\t * |-------|...|-------|\n\t\t\t\t *     |----------|\n\t\t\t\t *    off     end_off\n\t\t\t\t */\n\t\t\t\tif (i < sub_stripes)\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_offset;\n\n\t\t\t\tif (stripe_index >= last_stripe &&\n\t\t\t\t    stripe_index <= (last_stripe +\n\t\t\t\t\t\t     sub_stripes - 1))\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_end_offset;\n\n\t\t\t\tif (i == sub_stripes - 1)\n\t\t\t\t\tstripe_offset = 0;\n\t\t\t} else\n\t\t\t\tbbio->stripes[i].length = *length;\n\n\t\t\tstripe_index++;\n\t\t\tif (stripe_index == map->num_stripes) {\n\t\t\t\t/* This could only happen for RAID0/10 */\n\t\t\t\tstripe_index = 0;\n\t\t\t\tstripe_nr++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset +\n\t\t\t\tstripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev =\n\t\t\t\tmap->stripes[stripe_index].dev;\n\t\t\tstripe_index++;\n\t\t}\n\t}\n\n\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\tmax_errors = btrfs_chunk_max_errors(map);\n\n\tif (bbio->raid_map)\n\t\tsort_parity_stripes(bbio, num_stripes);\n\n\ttgtdev_indexes = 0;\n\tif (dev_replace_is_ongoing && (rw & (REQ_WRITE | REQ_DISCARD)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\tint index_where_to_add;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\n\t\t/*\n\t\t * duplicate the write operations while the dev replace\n\t\t * procedure is running. Since the copying of the old disk\n\t\t * to the new disk takes place at run time while the\n\t\t * filesystem is mounted writable, the regular write\n\t\t * operations to the old disk have to be duplicated to go\n\t\t * to the new disk as well.\n\t\t * Note that device->missing is handled by the caller, and\n\t\t * that the write to the old disk is already set up in the\n\t\t * stripes array.\n\t\t */\n\t\tindex_where_to_add = num_stripes;\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/* write to new disk, too */\n\t\t\t\tstruct btrfs_bio_stripe *new =\n\t\t\t\t\tbbio->stripes + index_where_to_add;\n\t\t\t\tstruct btrfs_bio_stripe *old =\n\t\t\t\t\tbbio->stripes + i;\n\n\t\t\t\tnew->physical = old->physical;\n\t\t\t\tnew->length = old->length;\n\t\t\t\tnew->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[i] = index_where_to_add;\n\t\t\t\tindex_where_to_add++;\n\t\t\t\tmax_errors++;\n\t\t\t\ttgtdev_indexes++;\n\t\t\t}\n\t\t}\n\t\tnum_stripes = index_where_to_add;\n\t} else if (dev_replace_is_ongoing && (rw & REQ_GET_READ_MIRRORS) &&\n\t\t   dev_replace->tgtdev != NULL) {\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\t/*\n\t\t * During the dev-replace procedure, the target drive can\n\t\t * also be used to read data in case it is needed to repair\n\t\t * a corrupt block elsewhere. This is possible if the\n\t\t * requested area is left of the left cursor. In this area,\n\t\t * the target drive is a full copy of the source drive.\n\t\t */\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found = bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tu64 length = map->stripe_len;\n\n\t\t\tif (physical_of_found + length <=\n\t\t\t    dev_replace->cursor_left) {\n\t\t\t\tstruct btrfs_bio_stripe *tgtdev_stripe =\n\t\t\t\t\tbbio->stripes + num_stripes;\n\n\t\t\t\ttgtdev_stripe->physical = physical_of_found;\n\t\t\t\ttgtdev_stripe->length =\n\t\t\t\t\tbbio->stripes[index_srcdev].length;\n\t\t\t\ttgtdev_stripe->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[index_srcdev] = num_stripes;\n\n\t\t\t\ttgtdev_indexes++;\n\t\t\t\tnum_stripes++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*bbio_ret = bbio;\n\tbbio->map_type = map->type;\n\tbbio->num_stripes = num_stripes;\n\tbbio->max_errors = max_errors;\n\tbbio->mirror_num = mirror_num;\n\tbbio->num_tgtdevs = tgtdev_indexes;\n\n\t/*\n\t * this is the case that REQ_READ && dev_replace_is_ongoing &&\n\t * mirror_num == num_stripes + 1 && dev_replace target drive is\n\t * available as a mirror\n\t */\n\tif (patch_the_first_stripe_for_dev_replace && num_stripes > 0) {\n\t\tWARN_ON(num_stripes > 1);\n\t\tbbio->stripes[0].dev = dev_replace->tgtdev;\n\t\tbbio->stripes[0].physical = physical_to_patch_in_first_stripe;\n\t\tbbio->mirror_num = map->num_stripes + 1;\n\t}\nout:\n\tif (dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\tfree_extent_map(em);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 5480
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_unlock",
          "args": [
            "dev_replace"
          ],
          "line": 5479
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "895-909",
          "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "num_stripes > 1"
          ],
          "line": 5472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort_parity_stripes",
          "args": [
            "bbio",
            "num_stripes"
          ],
          "line": 5371
        },
        "resolved": true,
        "details": {
          "function_name": "sort_parity_stripes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4878-4901",
          "snippet": "static void sort_parity_stripes(struct btrfs_bio *bbio, int num_stripes)\n{\n\tstruct btrfs_bio_stripe s;\n\tint i;\n\tu64 l;\n\tint again = 1;\n\n\twhile (again) {\n\t\tagain = 0;\n\t\tfor (i = 0; i < num_stripes - 1; i++) {\n\t\t\tif (parity_smaller(bbio->raid_map[i],\n\t\t\t\t\t   bbio->raid_map[i+1])) {\n\t\t\t\ts = bbio->stripes[i];\n\t\t\t\tl = bbio->raid_map[i];\n\t\t\t\tbbio->stripes[i] = bbio->stripes[i+1];\n\t\t\t\tbbio->raid_map[i] = bbio->raid_map[i+1];\n\t\t\t\tbbio->stripes[i+1] = s;\n\t\t\t\tbbio->raid_map[i+1] = l;\n\n\t\t\t\tagain = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void sort_parity_stripes(struct btrfs_bio *bbio, int num_stripes)\n{\n\tstruct btrfs_bio_stripe s;\n\tint i;\n\tu64 l;\n\tint again = 1;\n\n\twhile (again) {\n\t\tagain = 0;\n\t\tfor (i = 0; i < num_stripes - 1; i++) {\n\t\t\tif (parity_smaller(bbio->raid_map[i],\n\t\t\t\t\t   bbio->raid_map[i+1])) {\n\t\t\t\ts = bbio->stripes[i];\n\t\t\t\tl = bbio->raid_map[i];\n\t\t\t\tbbio->stripes[i] = bbio->stripes[i+1];\n\t\t\t\tbbio->raid_map[i] = bbio->raid_map[i+1];\n\t\t\t\tbbio->stripes[i+1] = s;\n\t\t\t\tbbio->raid_map[i+1] = l;\n\n\t\t\t\tagain = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_max_errors",
          "args": [
            "map"
          ],
          "line": 5368
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_chunk_max_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4658-4674",
          "snippet": "static inline int btrfs_chunk_max_errors(struct map_lookup *map)\n{\n\tint max_errors;\n\n\tif (map->type & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t BTRFS_BLOCK_GROUP_DUP)) {\n\t\tmax_errors = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\tmax_errors = 2;\n\t} else {\n\t\tmax_errors = 0;\n\t}\n\n\treturn max_errors;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic inline int btrfs_chunk_max_errors(struct map_lookup *map)\n{\n\tint max_errors;\n\n\tif (map->type & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t BTRFS_BLOCK_GROUP_DUP)) {\n\t\tmax_errors = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\tmax_errors = 2;\n\t} else {\n\t\tmax_errors = 0;\n\t}\n\n\treturn max_errors;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_u64_rem",
          "args": [
            "stripe_nr_end - 1",
            "factor",
            "&last_stripe"
          ],
          "line": 5306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64_rem",
          "args": [
            "stripe_nr_end -\n\t\t\t\t\t\t      stripe_nr_orig",
            "factor",
            "&remaining_stripes"
          ],
          "line": 5302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_data_stripes",
          "args": [
            "map"
          ],
          "line": 5277
        },
        "resolved": true,
        "details": {
          "function_name": "nr_data_stripes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.h",
          "lines": "32-35",
          "snippet": "static inline int nr_data_stripes(struct map_lookup *map)\n{\n\treturn map->num_stripes - nr_parity_stripes(map);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int nr_data_stripes(struct map_lookup *map)\n{\n\treturn map->num_stripes - nr_parity_stripes(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "num_stripes"
          ],
          "line": 5273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_btrfs_bio",
          "args": [
            "num_alloc_stripes",
            "tgtdev_indexes"
          ],
          "line": 5251
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_btrfs_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4903-4925",
          "snippet": "static struct btrfs_bio *alloc_btrfs_bio(int total_stripes, int real_stripes)\n{\n\tstruct btrfs_bio *bbio = kzalloc(\n\t\t /* the size of the btrfs_bio */\n\t\tsizeof(struct btrfs_bio) +\n\t\t/* plus the variable array for the stripes */\n\t\tsizeof(struct btrfs_bio_stripe) * (total_stripes) +\n\t\t/* plus the variable array for the tgt dev */\n\t\tsizeof(int) * (real_stripes) +\n\t\t/*\n\t\t * plus the raid_map, which includes both the tgt dev\n\t\t * and the stripes\n\t\t */\n\t\tsizeof(u64) * (total_stripes),\n\t\tGFP_NOFS);\n\tif (!bbio)\n\t\treturn NULL;\n\n\tatomic_set(&bbio->error, 0);\n\tatomic_set(&bbio->refs, 1);\n\n\treturn bbio;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_bio *alloc_btrfs_bio(int total_stripes, int real_stripes)\n{\n\tstruct btrfs_bio *bbio = kzalloc(\n\t\t /* the size of the btrfs_bio */\n\t\tsizeof(struct btrfs_bio) +\n\t\t/* plus the variable array for the stripes */\n\t\tsizeof(struct btrfs_bio_stripe) * (total_stripes) +\n\t\t/* plus the variable array for the tgt dev */\n\t\tsizeof(int) * (real_stripes) +\n\t\t/*\n\t\t * plus the raid_map, which includes both the tgt dev\n\t\t * and the stripes\n\t\t */\n\t\tsizeof(u64) * (total_stripes),\n\t\tGFP_NOFS);\n\tif (!bbio)\n\t\treturn NULL;\n\n\tatomic_set(&bbio->error, 0);\n\tatomic_set(&bbio->refs, 1);\n\n\treturn bbio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "stripe_index >= map->num_stripes"
          ],
          "line": 5240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_nr",
            "map->num_stripes"
          ],
          "line": 5237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "map->num_stripes"
          ],
          "line": 5226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_nr",
            "nr_data_stripes(map)"
          ],
          "line": 5219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_parity_stripes",
          "args": [
            "map"
          ],
          "line": 5206
        },
        "resolved": true,
        "details": {
          "function_name": "nr_parity_stripes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.h",
          "lines": "22-30",
          "snippet": "static inline int nr_parity_stripes(struct map_lookup *map)\n{\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\treturn 1;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\treturn 2;\n\telse\n\t\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int nr_parity_stripes(struct map_lookup *map)\n{\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\treturn 1;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\treturn 2;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_nr",
            "stripe_len * nr_data_stripes(map)"
          ],
          "line": 5202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_live_mirror",
          "args": [
            "fs_info",
            "map",
            "stripe_index",
            "map->sub_stripes",
            "stripe_index +\n\t\t\t\t\t      current->pid % map->sub_stripes",
            "dev_replace_is_ongoing"
          ],
          "line": 5188
        },
        "resolved": true,
        "details": {
          "function_name": "find_live_mirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4835-4870",
          "snippet": "static int find_live_mirror(struct btrfs_fs_info *fs_info,\n\t\t\t    struct map_lookup *map, int first, int num,\n\t\t\t    int optimal, int dev_replace_is_ongoing)\n{\n\tint i;\n\tint tolerance;\n\tstruct btrfs_device *srcdev;\n\n\tif (dev_replace_is_ongoing &&\n\t    fs_info->dev_replace.cont_reading_from_srcdev_mode ==\n\t     BTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_AVOID)\n\t\tsrcdev = fs_info->dev_replace.srcdev;\n\telse\n\t\tsrcdev = NULL;\n\n\t/*\n\t * try to avoid the drive that is the source drive for a\n\t * dev-replace procedure, only choose it if no other non-missing\n\t * mirror is available\n\t */\n\tfor (tolerance = 0; tolerance < 2; tolerance++) {\n\t\tif (map->stripes[optimal].dev->bdev &&\n\t\t    (tolerance || map->stripes[optimal].dev != srcdev))\n\t\t\treturn optimal;\n\t\tfor (i = first; i < first + num; i++) {\n\t\t\tif (map->stripes[i].dev->bdev &&\n\t\t\t    (tolerance || map->stripes[i].dev != srcdev))\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\t/* we couldn't find one that doesn't fail.  Just return something\n\t * and the io error handling code will clean up eventually\n\t */\n\treturn optimal;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int find_live_mirror(struct btrfs_fs_info *fs_info,\n\t\t\t    struct map_lookup *map, int first, int num,\n\t\t\t    int optimal, int dev_replace_is_ongoing)\n{\n\tint i;\n\tint tolerance;\n\tstruct btrfs_device *srcdev;\n\n\tif (dev_replace_is_ongoing &&\n\t    fs_info->dev_replace.cont_reading_from_srcdev_mode ==\n\t     BTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_AVOID)\n\t\tsrcdev = fs_info->dev_replace.srcdev;\n\telse\n\t\tsrcdev = NULL;\n\n\t/*\n\t * try to avoid the drive that is the source drive for a\n\t * dev-replace procedure, only choose it if no other non-missing\n\t * mirror is available\n\t */\n\tfor (tolerance = 0; tolerance < 2; tolerance++) {\n\t\tif (map->stripes[optimal].dev->bdev &&\n\t\t    (tolerance || map->stripes[optimal].dev != srcdev))\n\t\t\treturn optimal;\n\t\tfor (i = first; i < first + num; i++) {\n\t\t\tif (map->stripes[i].dev->bdev &&\n\t\t\t    (tolerance || map->stripes[i].dev != srcdev))\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\t/* we couldn't find one that doesn't fail.  Just return something\n\t * and the io error handling code will clean up eventually\n\t */\n\treturn optimal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "map->sub_stripes *\n\t\t\t\t\t    (stripe_nr_end - stripe_nr_orig)",
            "map->num_stripes"
          ],
          "line": 5181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_nr",
            "factor"
          ],
          "line": 5175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_nr",
            "map->num_stripes"
          ],
          "line": 5147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "map->num_stripes",
            "stripe_nr_end - stripe_nr_orig"
          ],
          "line": 5145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_nr_end",
            "map->stripe_len"
          ],
          "line": 5139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "offset + *length",
            "map->stripe_len"
          ],
          "line": 5138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_bbio",
          "args": [
            "tmp_bbio"
          ],
          "line": 5130
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4933-4939",
          "snippet": "void btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 5124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "tmp_bbio != NULL"
          ],
          "line": 5079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_map_block",
          "args": [
            "fs_info",
            "REQ_GET_READ_MIRRORS",
            "logical",
            "&tmp_length",
            "&tmp_bbio",
            "0",
            "0"
          ],
          "line": 5076
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4941-5482",
          "snippet": "static int __btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t\t     u64 logical, u64 *length,\n\t\t\t     struct btrfs_bio **bbio_ret,\n\t\t\t     int mirror_num, int need_raid_map)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tu64 offset;\n\tu64 stripe_offset;\n\tu64 stripe_end_offset;\n\tu64 stripe_nr;\n\tu64 stripe_nr_orig;\n\tu64 stripe_nr_end;\n\tu64 stripe_len;\n\tint stripe_index;\n\tint i;\n\tint ret = 0;\n\tint num_stripes;\n\tint max_errors = 0;\n\tint tgtdev_indexes = 0;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint dev_replace_is_ongoing = 0;\n\tint num_alloc_stripes;\n\tint patch_the_first_stripe_for_dev_replace = 0;\n\tu64 physical_to_patch_in_first_stripe = 0;\n\tu64 raid56_full_stripe_start = (u64)-1;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, *length);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"unable to find logical %llu len %llu\",\n\t\t\tlogical, *length);\n\t\treturn -EINVAL;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"found a bad mapping, wanted %Lu, \"\n\t\t\t   \"found %Lu-%Lu\", logical, em->start,\n\t\t\t   em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\toffset = logical - em->start;\n\n\tstripe_len = map->stripe_len;\n\tstripe_nr = offset;\n\t/*\n\t * stripe_nr counts the total number of stripes we have to stride\n\t * to get to this block\n\t */\n\tdo_div(stripe_nr, stripe_len);\n\n\tstripe_offset = stripe_nr * stripe_len;\n\tBUG_ON(offset < stripe_offset);\n\n\t/* stripe_offset is the offset of this block in its stripe*/\n\tstripe_offset = offset - stripe_offset;\n\n\t/* if we're here for raid56, we need to know the stripe aligned start */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tunsigned long full_stripe_len = stripe_len * nr_data_stripes(map);\n\t\traid56_full_stripe_start = offset;\n\n\t\t/* allow a write of a full stripe, but make sure we don't\n\t\t * allow straddling of stripes\n\t\t */\n\t\tdo_div(raid56_full_stripe_start, full_stripe_len);\n\t\traid56_full_stripe_start *= full_stripe_len;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\t/* we don't discard raid56 yet */\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, *length);\n\t} else if (map->type & BTRFS_BLOCK_GROUP_PROFILE_MASK) {\n\t\tu64 max_len;\n\t\t/* For writes to RAID[56], allow a full stripeset across all disks.\n\t\t   For other RAID types and for RAID[56] reads, just allow a single\n\t\t   stripe (on a single disk). */\n\t\tif ((map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) &&\n\t\t    (rw & REQ_WRITE)) {\n\t\t\tmax_len = stripe_len * nr_data_stripes(map) -\n\t\t\t\t(offset - raid56_full_stripe_start);\n\t\t} else {\n\t\t\t/* we limit the length of each bio to what fits in a stripe */\n\t\t\tmax_len = stripe_len - stripe_offset;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, max_len);\n\t} else {\n\t\t*length = em->len - offset;\n\t}\n\n\t/* This is for when we're called from btrfs_merge_bio_hook() and all\n\t   it cares about is the length */\n\tif (!bbio_ret)\n\t\tgoto out;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(dev_replace);\n\tif (!dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tif (dev_replace_is_ongoing && mirror_num == map->num_stripes + 1 &&\n\t    !(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\t/*\n\t\t * in dev-replace case, for repair case (that's the only\n\t\t * case where the mirror is selected explicitly when\n\t\t * calling btrfs_map_block), blocks left of the left cursor\n\t\t * can also be read from the target drive.\n\t\t * For REQ_GET_READ_MIRRORS, the target drive is added as\n\t\t * the last one to the array of stripes. For READ, it also\n\t\t * needs to be supported using the same mirror number.\n\t\t * If the requested block is not left of the left cursor,\n\t\t * EIO is returned. This can happen because btrfs_num_copies()\n\t\t * returns one more in the dev-replace case.\n\t\t */\n\t\tu64 tmp_length = *length;\n\t\tstruct btrfs_bio *tmp_bbio = NULL;\n\t\tint tmp_num_stripes;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\tret = __btrfs_map_block(fs_info, REQ_GET_READ_MIRRORS,\n\t\t\t     logical, &tmp_length, &tmp_bbio, 0, 0);\n\t\tif (ret) {\n\t\t\tWARN_ON(tmp_bbio != NULL);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttmp_num_stripes = tmp_bbio->num_stripes;\n\t\tif (mirror_num > tmp_num_stripes) {\n\t\t\t/*\n\t\t\t * REQ_GET_READ_MIRRORS does not contain this\n\t\t\t * mirror, that means that the requested area\n\t\t\t * is not left of the left cursor\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * process the rest of the function using the mirror_num\n\t\t * of the source drive. Therefore look it up first.\n\t\t * At the end, patch the device pointer to the one of the\n\t\t * target drive.\n\t\t */\n\t\tfor (i = 0; i < tmp_num_stripes; i++) {\n\t\t\tif (tmp_bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     tmp_bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found =\n\t\t\t\t\ttmp_bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tmirror_num = index_srcdev + 1;\n\t\t\tpatch_the_first_stripe_for_dev_replace = 1;\n\t\t\tphysical_to_patch_in_first_stripe = physical_of_found;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_put_bbio(tmp_bbio);\n\t} else if (mirror_num > map->num_stripes) {\n\t\tmirror_num = 0;\n\t}\n\n\tnum_stripes = 1;\n\tstripe_index = 0;\n\tstripe_nr_orig = stripe_nr;\n\tstripe_nr_end = ALIGN(offset + *length, map->stripe_len);\n\tdo_div(stripe_nr_end, map->stripe_len);\n\tstripe_end_offset = stripe_nr_end * map->stripe_len -\n\t\t\t    (offset + *length);\n\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\tif (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->num_stripes,\n\t\t\t\t\t    stripe_nr_end - stripe_nr_orig);\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)))\n\t\t\tmirror_num = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->num_stripes;\n\t\telse if (mirror_num)\n\t\t\tstripe_index = mirror_num - 1;\n\t\telse {\n\t\t\tstripe_index = find_live_mirror(fs_info, map, 0,\n\t\t\t\t\t    map->num_stripes,\n\t\t\t\t\t    current->pid % map->num_stripes,\n\t\t\t\t\t    dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_DUP) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) {\n\t\t\tnum_stripes = map->num_stripes;\n\t\t} else if (mirror_num) {\n\t\t\tstripe_index = mirror_num - 1;\n\t\t} else {\n\t\t\tmirror_num = 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tint factor = map->num_stripes / map->sub_stripes;\n\n\t\tstripe_index = do_div(stripe_nr, factor);\n\t\tstripe_index *= map->sub_stripes;\n\n\t\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->sub_stripes;\n\t\telse if (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->sub_stripes *\n\t\t\t\t\t    (stripe_nr_end - stripe_nr_orig),\n\t\t\t\t\t    map->num_stripes);\n\t\telse if (mirror_num)\n\t\t\tstripe_index += mirror_num - 1;\n\t\telse {\n\t\t\tint old_stripe_index = stripe_index;\n\t\t\tstripe_index = find_live_mirror(fs_info, map,\n\t\t\t\t\t      stripe_index,\n\t\t\t\t\t      map->sub_stripes, stripe_index +\n\t\t\t\t\t      current->pid % map->sub_stripes,\n\t\t\t\t\t      dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index - old_stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tif (need_raid_map &&\n\t\t    ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t\t     mirror_num > 1)) {\n\t\t\t/* push stripe_nr back to the start of the full stripe */\n\t\t\tstripe_nr = raid56_full_stripe_start;\n\t\t\tdo_div(stripe_nr, stripe_len * nr_data_stripes(map));\n\n\t\t\t/* RAID[56] write or recovery. Return all stripes */\n\t\t\tnum_stripes = map->num_stripes;\n\t\t\tmax_errors = nr_parity_stripes(map);\n\n\t\t\t*length = map->stripe_len;\n\t\t\tstripe_index = 0;\n\t\t\tstripe_offset = 0;\n\t\t} else {\n\t\t\tu64 tmp;\n\n\t\t\t/*\n\t\t\t * Mirror #0 or #1 means the original data block.\n\t\t\t * Mirror #2 is RAID5 parity block.\n\t\t\t * Mirror #3 is RAID6 Q block.\n\t\t\t */\n\t\t\tstripe_index = do_div(stripe_nr, nr_data_stripes(map));\n\t\t\tif (mirror_num > 1)\n\t\t\t\tstripe_index = nr_data_stripes(map) +\n\t\t\t\t\t\tmirror_num - 2;\n\n\t\t\t/* We distribute the parity blocks across stripes */\n\t\t\ttmp = stripe_nr + stripe_index;\n\t\t\tstripe_index = do_div(tmp, map->num_stripes);\n\t\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD |\n\t\t\t\t    REQ_GET_READ_MIRRORS)) && mirror_num <= 1)\n\t\t\t\tmirror_num = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * after this do_div call, stripe_nr is the number of stripes\n\t\t * on this device we have to walk to find the data, and\n\t\t * stripe_index is the number of our device in the stripe array\n\t\t */\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tmirror_num = stripe_index + 1;\n\t}\n\tBUG_ON(stripe_index >= map->num_stripes);\n\n\tnum_alloc_stripes = num_stripes;\n\tif (dev_replace_is_ongoing) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD))\n\t\t\tnum_alloc_stripes <<= 1;\n\t\tif (rw & REQ_GET_READ_MIRRORS)\n\t\t\tnum_alloc_stripes++;\n\t\ttgtdev_indexes = num_stripes;\n\t}\n\n\tbbio = alloc_btrfs_bio(num_alloc_stripes, tgtdev_indexes);\n\tif (!bbio) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (dev_replace_is_ongoing)\n\t\tbbio->tgtdev_map = (int *)(bbio->stripes + num_alloc_stripes);\n\n\t/* build raid_map */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK &&\n\t    need_raid_map && ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t    mirror_num > 1)) {\n\t\tu64 tmp;\n\t\tint i, rot;\n\n\t\tbbio->raid_map = (u64 *)((void *)bbio->stripes +\n\t\t\t\t sizeof(struct btrfs_bio_stripe) *\n\t\t\t\t num_alloc_stripes +\n\t\t\t\t sizeof(int) * tgtdev_indexes);\n\n\t\t/* Work out the disk rotation on this stripe-set */\n\t\ttmp = stripe_nr;\n\t\trot = do_div(tmp, num_stripes);\n\n\t\t/* Fill in the logical address of each stripe */\n\t\ttmp = stripe_nr * nr_data_stripes(map);\n\t\tfor (i = 0; i < nr_data_stripes(map); i++)\n\t\t\tbbio->raid_map[(i+rot) % num_stripes] =\n\t\t\t\tem->start + (tmp + i) * map->stripe_len;\n\n\t\tbbio->raid_map[(i+rot) % map->num_stripes] = RAID5_P_STRIPE;\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\t\tbbio->raid_map[(i+rot+1) % num_stripes] =\n\t\t\t\tRAID6_Q_STRIPE;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\tint factor = 0;\n\t\tint sub_stripes = 0;\n\t\tu64 stripes_per_dev = 0;\n\t\tu32 remaining_stripes = 0;\n\t\tu32 last_stripe = 0;\n\n\t\tif (map->type &\n\t\t    (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID0)\n\t\t\t\tsub_stripes = 1;\n\t\t\telse\n\t\t\t\tsub_stripes = map->sub_stripes;\n\n\t\t\tfactor = map->num_stripes / sub_stripes;\n\t\t\tstripes_per_dev = div_u64_rem(stripe_nr_end -\n\t\t\t\t\t\t      stripe_nr_orig,\n\t\t\t\t\t\t      factor,\n\t\t\t\t\t\t      &remaining_stripes);\n\t\t\tdiv_u64_rem(stripe_nr_end - 1, factor, &last_stripe);\n\t\t\tlast_stripe *= sub_stripes;\n\t\t}\n\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset + stripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev = map->stripes[stripe_index].dev;\n\n\t\t\tif (map->type & (BTRFS_BLOCK_GROUP_RAID0 |\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\tbbio->stripes[i].length = stripes_per_dev *\n\t\t\t\t\t\t\t  map->stripe_len;\n\n\t\t\t\tif (i / sub_stripes < remaining_stripes)\n\t\t\t\t\tbbio->stripes[i].length +=\n\t\t\t\t\t\tmap->stripe_len;\n\n\t\t\t\t/*\n\t\t\t\t * Special for the first stripe and\n\t\t\t\t * the last stripe:\n\t\t\t\t *\n\t\t\t\t * |-------|...|-------|\n\t\t\t\t *     |----------|\n\t\t\t\t *    off     end_off\n\t\t\t\t */\n\t\t\t\tif (i < sub_stripes)\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_offset;\n\n\t\t\t\tif (stripe_index >= last_stripe &&\n\t\t\t\t    stripe_index <= (last_stripe +\n\t\t\t\t\t\t     sub_stripes - 1))\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_end_offset;\n\n\t\t\t\tif (i == sub_stripes - 1)\n\t\t\t\t\tstripe_offset = 0;\n\t\t\t} else\n\t\t\t\tbbio->stripes[i].length = *length;\n\n\t\t\tstripe_index++;\n\t\t\tif (stripe_index == map->num_stripes) {\n\t\t\t\t/* This could only happen for RAID0/10 */\n\t\t\t\tstripe_index = 0;\n\t\t\t\tstripe_nr++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset +\n\t\t\t\tstripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev =\n\t\t\t\tmap->stripes[stripe_index].dev;\n\t\t\tstripe_index++;\n\t\t}\n\t}\n\n\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\tmax_errors = btrfs_chunk_max_errors(map);\n\n\tif (bbio->raid_map)\n\t\tsort_parity_stripes(bbio, num_stripes);\n\n\ttgtdev_indexes = 0;\n\tif (dev_replace_is_ongoing && (rw & (REQ_WRITE | REQ_DISCARD)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\tint index_where_to_add;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\n\t\t/*\n\t\t * duplicate the write operations while the dev replace\n\t\t * procedure is running. Since the copying of the old disk\n\t\t * to the new disk takes place at run time while the\n\t\t * filesystem is mounted writable, the regular write\n\t\t * operations to the old disk have to be duplicated to go\n\t\t * to the new disk as well.\n\t\t * Note that device->missing is handled by the caller, and\n\t\t * that the write to the old disk is already set up in the\n\t\t * stripes array.\n\t\t */\n\t\tindex_where_to_add = num_stripes;\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/* write to new disk, too */\n\t\t\t\tstruct btrfs_bio_stripe *new =\n\t\t\t\t\tbbio->stripes + index_where_to_add;\n\t\t\t\tstruct btrfs_bio_stripe *old =\n\t\t\t\t\tbbio->stripes + i;\n\n\t\t\t\tnew->physical = old->physical;\n\t\t\t\tnew->length = old->length;\n\t\t\t\tnew->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[i] = index_where_to_add;\n\t\t\t\tindex_where_to_add++;\n\t\t\t\tmax_errors++;\n\t\t\t\ttgtdev_indexes++;\n\t\t\t}\n\t\t}\n\t\tnum_stripes = index_where_to_add;\n\t} else if (dev_replace_is_ongoing && (rw & REQ_GET_READ_MIRRORS) &&\n\t\t   dev_replace->tgtdev != NULL) {\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\t/*\n\t\t * During the dev-replace procedure, the target drive can\n\t\t * also be used to read data in case it is needed to repair\n\t\t * a corrupt block elsewhere. This is possible if the\n\t\t * requested area is left of the left cursor. In this area,\n\t\t * the target drive is a full copy of the source drive.\n\t\t */\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found = bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tu64 length = map->stripe_len;\n\n\t\t\tif (physical_of_found + length <=\n\t\t\t    dev_replace->cursor_left) {\n\t\t\t\tstruct btrfs_bio_stripe *tgtdev_stripe =\n\t\t\t\t\tbbio->stripes + num_stripes;\n\n\t\t\t\ttgtdev_stripe->physical = physical_of_found;\n\t\t\t\ttgtdev_stripe->length =\n\t\t\t\t\tbbio->stripes[index_srcdev].length;\n\t\t\t\ttgtdev_stripe->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[index_srcdev] = num_stripes;\n\n\t\t\t\ttgtdev_indexes++;\n\t\t\t\tnum_stripes++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*bbio_ret = bbio;\n\tbbio->map_type = map->type;\n\tbbio->num_stripes = num_stripes;\n\tbbio->max_errors = max_errors;\n\tbbio->mirror_num = mirror_num;\n\tbbio->num_tgtdevs = tgtdev_indexes;\n\n\t/*\n\t * this is the case that REQ_READ && dev_replace_is_ongoing &&\n\t * mirror_num == num_stripes + 1 && dev_replace target drive is\n\t * available as a mirror\n\t */\n\tif (patch_the_first_stripe_for_dev_replace && num_stripes > 0) {\n\t\tWARN_ON(num_stripes > 1);\n\t\tbbio->stripes[0].dev = dev_replace->tgtdev;\n\t\tbbio->stripes[0].physical = physical_to_patch_in_first_stripe;\n\t\tbbio->mirror_num = map->num_stripes + 1;\n\t}\nout:\n\tif (dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\tfree_extent_map(em);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_is_ongoing",
          "args": [
            "dev_replace"
          ],
          "line": 5049
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_is_ongoing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "840-865",
          "snippet": "int btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\n\nint btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_lock",
          "args": [
            "dev_replace"
          ],
          "line": 5048
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "867-893",
          "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "em->len - offset",
            "max_len"
          ],
          "line": 5038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "em->len - offset",
            "*length"
          ],
          "line": 5024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "raid56_full_stripe_start",
            "full_stripe_len"
          ],
          "line": 5014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset < stripe_offset"
          ],
          "line": 5001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_nr",
            "stripe_len"
          ],
          "line": 4998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "fs_info",
            "\"found a bad mapping, wanted %Lu, \"\n\t\t\t   \"found %Lu-%Lu\"",
            "logical",
            "em->start",
            "em->start + em->len"
          ],
          "line": 4982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "fs_info",
            "\"unable to find logical %llu len %llu\"",
            "logical",
            "*length"
          ],
          "line": 4976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4973
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "logical",
            "*length"
          ],
          "line": 4972
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4971
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t\t     u64 logical, u64 *length,\n\t\t\t     struct btrfs_bio **bbio_ret,\n\t\t\t     int mirror_num, int need_raid_map)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tu64 offset;\n\tu64 stripe_offset;\n\tu64 stripe_end_offset;\n\tu64 stripe_nr;\n\tu64 stripe_nr_orig;\n\tu64 stripe_nr_end;\n\tu64 stripe_len;\n\tint stripe_index;\n\tint i;\n\tint ret = 0;\n\tint num_stripes;\n\tint max_errors = 0;\n\tint tgtdev_indexes = 0;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint dev_replace_is_ongoing = 0;\n\tint num_alloc_stripes;\n\tint patch_the_first_stripe_for_dev_replace = 0;\n\tu64 physical_to_patch_in_first_stripe = 0;\n\tu64 raid56_full_stripe_start = (u64)-1;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, *length);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"unable to find logical %llu len %llu\",\n\t\t\tlogical, *length);\n\t\treturn -EINVAL;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"found a bad mapping, wanted %Lu, \"\n\t\t\t   \"found %Lu-%Lu\", logical, em->start,\n\t\t\t   em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\toffset = logical - em->start;\n\n\tstripe_len = map->stripe_len;\n\tstripe_nr = offset;\n\t/*\n\t * stripe_nr counts the total number of stripes we have to stride\n\t * to get to this block\n\t */\n\tdo_div(stripe_nr, stripe_len);\n\n\tstripe_offset = stripe_nr * stripe_len;\n\tBUG_ON(offset < stripe_offset);\n\n\t/* stripe_offset is the offset of this block in its stripe*/\n\tstripe_offset = offset - stripe_offset;\n\n\t/* if we're here for raid56, we need to know the stripe aligned start */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tunsigned long full_stripe_len = stripe_len * nr_data_stripes(map);\n\t\traid56_full_stripe_start = offset;\n\n\t\t/* allow a write of a full stripe, but make sure we don't\n\t\t * allow straddling of stripes\n\t\t */\n\t\tdo_div(raid56_full_stripe_start, full_stripe_len);\n\t\traid56_full_stripe_start *= full_stripe_len;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\t/* we don't discard raid56 yet */\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, *length);\n\t} else if (map->type & BTRFS_BLOCK_GROUP_PROFILE_MASK) {\n\t\tu64 max_len;\n\t\t/* For writes to RAID[56], allow a full stripeset across all disks.\n\t\t   For other RAID types and for RAID[56] reads, just allow a single\n\t\t   stripe (on a single disk). */\n\t\tif ((map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) &&\n\t\t    (rw & REQ_WRITE)) {\n\t\t\tmax_len = stripe_len * nr_data_stripes(map) -\n\t\t\t\t(offset - raid56_full_stripe_start);\n\t\t} else {\n\t\t\t/* we limit the length of each bio to what fits in a stripe */\n\t\t\tmax_len = stripe_len - stripe_offset;\n\t\t}\n\t\t*length = min_t(u64, em->len - offset, max_len);\n\t} else {\n\t\t*length = em->len - offset;\n\t}\n\n\t/* This is for when we're called from btrfs_merge_bio_hook() and all\n\t   it cares about is the length */\n\tif (!bbio_ret)\n\t\tgoto out;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(dev_replace);\n\tif (!dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tif (dev_replace_is_ongoing && mirror_num == map->num_stripes + 1 &&\n\t    !(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\t/*\n\t\t * in dev-replace case, for repair case (that's the only\n\t\t * case where the mirror is selected explicitly when\n\t\t * calling btrfs_map_block), blocks left of the left cursor\n\t\t * can also be read from the target drive.\n\t\t * For REQ_GET_READ_MIRRORS, the target drive is added as\n\t\t * the last one to the array of stripes. For READ, it also\n\t\t * needs to be supported using the same mirror number.\n\t\t * If the requested block is not left of the left cursor,\n\t\t * EIO is returned. This can happen because btrfs_num_copies()\n\t\t * returns one more in the dev-replace case.\n\t\t */\n\t\tu64 tmp_length = *length;\n\t\tstruct btrfs_bio *tmp_bbio = NULL;\n\t\tint tmp_num_stripes;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\tret = __btrfs_map_block(fs_info, REQ_GET_READ_MIRRORS,\n\t\t\t     logical, &tmp_length, &tmp_bbio, 0, 0);\n\t\tif (ret) {\n\t\t\tWARN_ON(tmp_bbio != NULL);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttmp_num_stripes = tmp_bbio->num_stripes;\n\t\tif (mirror_num > tmp_num_stripes) {\n\t\t\t/*\n\t\t\t * REQ_GET_READ_MIRRORS does not contain this\n\t\t\t * mirror, that means that the requested area\n\t\t\t * is not left of the left cursor\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * process the rest of the function using the mirror_num\n\t\t * of the source drive. Therefore look it up first.\n\t\t * At the end, patch the device pointer to the one of the\n\t\t * target drive.\n\t\t */\n\t\tfor (i = 0; i < tmp_num_stripes; i++) {\n\t\t\tif (tmp_bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     tmp_bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found =\n\t\t\t\t\ttmp_bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tmirror_num = index_srcdev + 1;\n\t\t\tpatch_the_first_stripe_for_dev_replace = 1;\n\t\t\tphysical_to_patch_in_first_stripe = physical_of_found;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\tret = -EIO;\n\t\t\tbtrfs_put_bbio(tmp_bbio);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_put_bbio(tmp_bbio);\n\t} else if (mirror_num > map->num_stripes) {\n\t\tmirror_num = 0;\n\t}\n\n\tnum_stripes = 1;\n\tstripe_index = 0;\n\tstripe_nr_orig = stripe_nr;\n\tstripe_nr_end = ALIGN(offset + *length, map->stripe_len);\n\tdo_div(stripe_nr_end, map->stripe_len);\n\tstripe_end_offset = stripe_nr_end * map->stripe_len -\n\t\t\t    (offset + *length);\n\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\tif (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->num_stripes,\n\t\t\t\t\t    stripe_nr_end - stripe_nr_orig);\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)))\n\t\t\tmirror_num = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->num_stripes;\n\t\telse if (mirror_num)\n\t\t\tstripe_index = mirror_num - 1;\n\t\telse {\n\t\t\tstripe_index = find_live_mirror(fs_info, map, 0,\n\t\t\t\t\t    map->num_stripes,\n\t\t\t\t\t    current->pid % map->num_stripes,\n\t\t\t\t\t    dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_DUP) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD | REQ_GET_READ_MIRRORS)) {\n\t\t\tnum_stripes = map->num_stripes;\n\t\t} else if (mirror_num) {\n\t\t\tstripe_index = mirror_num - 1;\n\t\t} else {\n\t\t\tmirror_num = 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tint factor = map->num_stripes / map->sub_stripes;\n\n\t\tstripe_index = do_div(stripe_nr, factor);\n\t\tstripe_index *= map->sub_stripes;\n\n\t\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\t\tnum_stripes = map->sub_stripes;\n\t\telse if (rw & REQ_DISCARD)\n\t\t\tnum_stripes = min_t(u64, map->sub_stripes *\n\t\t\t\t\t    (stripe_nr_end - stripe_nr_orig),\n\t\t\t\t\t    map->num_stripes);\n\t\telse if (mirror_num)\n\t\t\tstripe_index += mirror_num - 1;\n\t\telse {\n\t\t\tint old_stripe_index = stripe_index;\n\t\t\tstripe_index = find_live_mirror(fs_info, map,\n\t\t\t\t\t      stripe_index,\n\t\t\t\t\t      map->sub_stripes, stripe_index +\n\t\t\t\t\t      current->pid % map->sub_stripes,\n\t\t\t\t\t      dev_replace_is_ongoing);\n\t\t\tmirror_num = stripe_index - old_stripe_index + 1;\n\t\t}\n\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\tif (need_raid_map &&\n\t\t    ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t\t     mirror_num > 1)) {\n\t\t\t/* push stripe_nr back to the start of the full stripe */\n\t\t\tstripe_nr = raid56_full_stripe_start;\n\t\t\tdo_div(stripe_nr, stripe_len * nr_data_stripes(map));\n\n\t\t\t/* RAID[56] write or recovery. Return all stripes */\n\t\t\tnum_stripes = map->num_stripes;\n\t\t\tmax_errors = nr_parity_stripes(map);\n\n\t\t\t*length = map->stripe_len;\n\t\t\tstripe_index = 0;\n\t\t\tstripe_offset = 0;\n\t\t} else {\n\t\t\tu64 tmp;\n\n\t\t\t/*\n\t\t\t * Mirror #0 or #1 means the original data block.\n\t\t\t * Mirror #2 is RAID5 parity block.\n\t\t\t * Mirror #3 is RAID6 Q block.\n\t\t\t */\n\t\t\tstripe_index = do_div(stripe_nr, nr_data_stripes(map));\n\t\t\tif (mirror_num > 1)\n\t\t\t\tstripe_index = nr_data_stripes(map) +\n\t\t\t\t\t\tmirror_num - 2;\n\n\t\t\t/* We distribute the parity blocks across stripes */\n\t\t\ttmp = stripe_nr + stripe_index;\n\t\t\tstripe_index = do_div(tmp, map->num_stripes);\n\t\t\tif (!(rw & (REQ_WRITE | REQ_DISCARD |\n\t\t\t\t    REQ_GET_READ_MIRRORS)) && mirror_num <= 1)\n\t\t\t\tmirror_num = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * after this do_div call, stripe_nr is the number of stripes\n\t\t * on this device we have to walk to find the data, and\n\t\t * stripe_index is the number of our device in the stripe array\n\t\t */\n\t\tstripe_index = do_div(stripe_nr, map->num_stripes);\n\t\tmirror_num = stripe_index + 1;\n\t}\n\tBUG_ON(stripe_index >= map->num_stripes);\n\n\tnum_alloc_stripes = num_stripes;\n\tif (dev_replace_is_ongoing) {\n\t\tif (rw & (REQ_WRITE | REQ_DISCARD))\n\t\t\tnum_alloc_stripes <<= 1;\n\t\tif (rw & REQ_GET_READ_MIRRORS)\n\t\t\tnum_alloc_stripes++;\n\t\ttgtdev_indexes = num_stripes;\n\t}\n\n\tbbio = alloc_btrfs_bio(num_alloc_stripes, tgtdev_indexes);\n\tif (!bbio) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (dev_replace_is_ongoing)\n\t\tbbio->tgtdev_map = (int *)(bbio->stripes + num_alloc_stripes);\n\n\t/* build raid_map */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK &&\n\t    need_raid_map && ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||\n\t    mirror_num > 1)) {\n\t\tu64 tmp;\n\t\tint i, rot;\n\n\t\tbbio->raid_map = (u64 *)((void *)bbio->stripes +\n\t\t\t\t sizeof(struct btrfs_bio_stripe) *\n\t\t\t\t num_alloc_stripes +\n\t\t\t\t sizeof(int) * tgtdev_indexes);\n\n\t\t/* Work out the disk rotation on this stripe-set */\n\t\ttmp = stripe_nr;\n\t\trot = do_div(tmp, num_stripes);\n\n\t\t/* Fill in the logical address of each stripe */\n\t\ttmp = stripe_nr * nr_data_stripes(map);\n\t\tfor (i = 0; i < nr_data_stripes(map); i++)\n\t\t\tbbio->raid_map[(i+rot) % num_stripes] =\n\t\t\t\tem->start + (tmp + i) * map->stripe_len;\n\n\t\tbbio->raid_map[(i+rot) % map->num_stripes] = RAID5_P_STRIPE;\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\t\tbbio->raid_map[(i+rot+1) % num_stripes] =\n\t\t\t\tRAID6_Q_STRIPE;\n\t}\n\n\tif (rw & REQ_DISCARD) {\n\t\tint factor = 0;\n\t\tint sub_stripes = 0;\n\t\tu64 stripes_per_dev = 0;\n\t\tu32 remaining_stripes = 0;\n\t\tu32 last_stripe = 0;\n\n\t\tif (map->type &\n\t\t    (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID0)\n\t\t\t\tsub_stripes = 1;\n\t\t\telse\n\t\t\t\tsub_stripes = map->sub_stripes;\n\n\t\t\tfactor = map->num_stripes / sub_stripes;\n\t\t\tstripes_per_dev = div_u64_rem(stripe_nr_end -\n\t\t\t\t\t\t      stripe_nr_orig,\n\t\t\t\t\t\t      factor,\n\t\t\t\t\t\t      &remaining_stripes);\n\t\t\tdiv_u64_rem(stripe_nr_end - 1, factor, &last_stripe);\n\t\t\tlast_stripe *= sub_stripes;\n\t\t}\n\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset + stripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev = map->stripes[stripe_index].dev;\n\n\t\t\tif (map->type & (BTRFS_BLOCK_GROUP_RAID0 |\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\tbbio->stripes[i].length = stripes_per_dev *\n\t\t\t\t\t\t\t  map->stripe_len;\n\n\t\t\t\tif (i / sub_stripes < remaining_stripes)\n\t\t\t\t\tbbio->stripes[i].length +=\n\t\t\t\t\t\tmap->stripe_len;\n\n\t\t\t\t/*\n\t\t\t\t * Special for the first stripe and\n\t\t\t\t * the last stripe:\n\t\t\t\t *\n\t\t\t\t * |-------|...|-------|\n\t\t\t\t *     |----------|\n\t\t\t\t *    off     end_off\n\t\t\t\t */\n\t\t\t\tif (i < sub_stripes)\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_offset;\n\n\t\t\t\tif (stripe_index >= last_stripe &&\n\t\t\t\t    stripe_index <= (last_stripe +\n\t\t\t\t\t\t     sub_stripes - 1))\n\t\t\t\t\tbbio->stripes[i].length -=\n\t\t\t\t\t\tstripe_end_offset;\n\n\t\t\t\tif (i == sub_stripes - 1)\n\t\t\t\t\tstripe_offset = 0;\n\t\t\t} else\n\t\t\t\tbbio->stripes[i].length = *length;\n\n\t\t\tstripe_index++;\n\t\t\tif (stripe_index == map->num_stripes) {\n\t\t\t\t/* This could only happen for RAID0/10 */\n\t\t\t\tstripe_index = 0;\n\t\t\t\tstripe_nr++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tbbio->stripes[i].physical =\n\t\t\t\tmap->stripes[stripe_index].physical +\n\t\t\t\tstripe_offset +\n\t\t\t\tstripe_nr * map->stripe_len;\n\t\t\tbbio->stripes[i].dev =\n\t\t\t\tmap->stripes[stripe_index].dev;\n\t\t\tstripe_index++;\n\t\t}\n\t}\n\n\tif (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))\n\t\tmax_errors = btrfs_chunk_max_errors(map);\n\n\tif (bbio->raid_map)\n\t\tsort_parity_stripes(bbio, num_stripes);\n\n\ttgtdev_indexes = 0;\n\tif (dev_replace_is_ongoing && (rw & (REQ_WRITE | REQ_DISCARD)) &&\n\t    dev_replace->tgtdev != NULL) {\n\t\tint index_where_to_add;\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\n\t\t/*\n\t\t * duplicate the write operations while the dev replace\n\t\t * procedure is running. Since the copying of the old disk\n\t\t * to the new disk takes place at run time while the\n\t\t * filesystem is mounted writable, the regular write\n\t\t * operations to the old disk have to be duplicated to go\n\t\t * to the new disk as well.\n\t\t * Note that device->missing is handled by the caller, and\n\t\t * that the write to the old disk is already set up in the\n\t\t * stripes array.\n\t\t */\n\t\tindex_where_to_add = num_stripes;\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/* write to new disk, too */\n\t\t\t\tstruct btrfs_bio_stripe *new =\n\t\t\t\t\tbbio->stripes + index_where_to_add;\n\t\t\t\tstruct btrfs_bio_stripe *old =\n\t\t\t\t\tbbio->stripes + i;\n\n\t\t\t\tnew->physical = old->physical;\n\t\t\t\tnew->length = old->length;\n\t\t\t\tnew->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[i] = index_where_to_add;\n\t\t\t\tindex_where_to_add++;\n\t\t\t\tmax_errors++;\n\t\t\t\ttgtdev_indexes++;\n\t\t\t}\n\t\t}\n\t\tnum_stripes = index_where_to_add;\n\t} else if (dev_replace_is_ongoing && (rw & REQ_GET_READ_MIRRORS) &&\n\t\t   dev_replace->tgtdev != NULL) {\n\t\tu64 srcdev_devid = dev_replace->srcdev->devid;\n\t\tint index_srcdev = 0;\n\t\tint found = 0;\n\t\tu64 physical_of_found = 0;\n\n\t\t/*\n\t\t * During the dev-replace procedure, the target drive can\n\t\t * also be used to read data in case it is needed to repair\n\t\t * a corrupt block elsewhere. This is possible if the\n\t\t * requested area is left of the left cursor. In this area,\n\t\t * the target drive is a full copy of the source drive.\n\t\t */\n\t\tfor (i = 0; i < num_stripes; i++) {\n\t\t\tif (bbio->stripes[i].dev->devid == srcdev_devid) {\n\t\t\t\t/*\n\t\t\t\t * In case of DUP, in order to keep it\n\t\t\t\t * simple, only add the mirror with the\n\t\t\t\t * lowest physical address\n\t\t\t\t */\n\t\t\t\tif (found &&\n\t\t\t\t    physical_of_found <=\n\t\t\t\t     bbio->stripes[i].physical)\n\t\t\t\t\tcontinue;\n\t\t\t\tindex_srcdev = i;\n\t\t\t\tfound = 1;\n\t\t\t\tphysical_of_found = bbio->stripes[i].physical;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tu64 length = map->stripe_len;\n\n\t\t\tif (physical_of_found + length <=\n\t\t\t    dev_replace->cursor_left) {\n\t\t\t\tstruct btrfs_bio_stripe *tgtdev_stripe =\n\t\t\t\t\tbbio->stripes + num_stripes;\n\n\t\t\t\ttgtdev_stripe->physical = physical_of_found;\n\t\t\t\ttgtdev_stripe->length =\n\t\t\t\t\tbbio->stripes[index_srcdev].length;\n\t\t\t\ttgtdev_stripe->dev = dev_replace->tgtdev;\n\t\t\t\tbbio->tgtdev_map[index_srcdev] = num_stripes;\n\n\t\t\t\ttgtdev_indexes++;\n\t\t\t\tnum_stripes++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*bbio_ret = bbio;\n\tbbio->map_type = map->type;\n\tbbio->num_stripes = num_stripes;\n\tbbio->max_errors = max_errors;\n\tbbio->mirror_num = mirror_num;\n\tbbio->num_tgtdevs = tgtdev_indexes;\n\n\t/*\n\t * this is the case that REQ_READ && dev_replace_is_ongoing &&\n\t * mirror_num == num_stripes + 1 && dev_replace target drive is\n\t * available as a mirror\n\t */\n\tif (patch_the_first_stripe_for_dev_replace && num_stripes > 0) {\n\t\tWARN_ON(num_stripes > 1);\n\t\tbbio->stripes[0].dev = dev_replace->tgtdev;\n\t\tbbio->stripes[0].physical = physical_to_patch_in_first_stripe;\n\t\tbbio->mirror_num = map->num_stripes + 1;\n\t}\nout:\n\tif (dev_replace_is_ongoing)\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\tfree_extent_map(em);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_put_bbio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4933-4939",
    "snippet": "void btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bbio"
          ],
          "line": 4938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&bbio->refs"
          ],
          "line": 4937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}"
  },
  {
    "function_name": "btrfs_get_bbio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4927-4931",
    "snippet": "void btrfs_get_bbio(struct btrfs_bio *bbio)\n{\n\tWARN_ON(!atomic_read(&bbio->refs));\n\tatomic_inc(&bbio->refs);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bbio->refs"
          ],
          "line": 4930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!atomic_read(&bbio->refs)"
          ],
          "line": 4929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bbio->refs"
          ],
          "line": 4929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_get_bbio(struct btrfs_bio *bbio)\n{\n\tWARN_ON(!atomic_read(&bbio->refs));\n\tatomic_inc(&bbio->refs);\n}"
  },
  {
    "function_name": "alloc_btrfs_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4903-4925",
    "snippet": "static struct btrfs_bio *alloc_btrfs_bio(int total_stripes, int real_stripes)\n{\n\tstruct btrfs_bio *bbio = kzalloc(\n\t\t /* the size of the btrfs_bio */\n\t\tsizeof(struct btrfs_bio) +\n\t\t/* plus the variable array for the stripes */\n\t\tsizeof(struct btrfs_bio_stripe) * (total_stripes) +\n\t\t/* plus the variable array for the tgt dev */\n\t\tsizeof(int) * (real_stripes) +\n\t\t/*\n\t\t * plus the raid_map, which includes both the tgt dev\n\t\t * and the stripes\n\t\t */\n\t\tsizeof(u64) * (total_stripes),\n\t\tGFP_NOFS);\n\tif (!bbio)\n\t\treturn NULL;\n\n\tatomic_set(&bbio->error, 0);\n\tatomic_set(&bbio->refs, 1);\n\n\treturn bbio;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bbio->refs",
            "1"
          ],
          "line": 4922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bbio->error",
            "0"
          ],
          "line": 4921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "/* the size of the btrfs_bio */sizeof(struct btrfs_bio) +\n\t\t/* plus the variable array for the stripes */\n\t\tsizeof(struct btrfs_bio_stripe) * (total_stripes) +\n\t\t/* plus the variable array for the tgt dev */\n\t\tsizeof(int) * (real_stripes) +\n\t\t/*\n\t\t * plus the raid_map, which includes both the tgt dev\n\t\t * and the stripes\n\t\t */\n\t\tsizeof(u64) * (total_stripes)",
            "GFP_NOFS"
          ],
          "line": 4905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_bio *alloc_btrfs_bio(int total_stripes, int real_stripes)\n{\n\tstruct btrfs_bio *bbio = kzalloc(\n\t\t /* the size of the btrfs_bio */\n\t\tsizeof(struct btrfs_bio) +\n\t\t/* plus the variable array for the stripes */\n\t\tsizeof(struct btrfs_bio_stripe) * (total_stripes) +\n\t\t/* plus the variable array for the tgt dev */\n\t\tsizeof(int) * (real_stripes) +\n\t\t/*\n\t\t * plus the raid_map, which includes both the tgt dev\n\t\t * and the stripes\n\t\t */\n\t\tsizeof(u64) * (total_stripes),\n\t\tGFP_NOFS);\n\tif (!bbio)\n\t\treturn NULL;\n\n\tatomic_set(&bbio->error, 0);\n\tatomic_set(&bbio->refs, 1);\n\n\treturn bbio;\n}"
  },
  {
    "function_name": "sort_parity_stripes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4878-4901",
    "snippet": "static void sort_parity_stripes(struct btrfs_bio *bbio, int num_stripes)\n{\n\tstruct btrfs_bio_stripe s;\n\tint i;\n\tu64 l;\n\tint again = 1;\n\n\twhile (again) {\n\t\tagain = 0;\n\t\tfor (i = 0; i < num_stripes - 1; i++) {\n\t\t\tif (parity_smaller(bbio->raid_map[i],\n\t\t\t\t\t   bbio->raid_map[i+1])) {\n\t\t\t\ts = bbio->stripes[i];\n\t\t\t\tl = bbio->raid_map[i];\n\t\t\t\tbbio->stripes[i] = bbio->stripes[i+1];\n\t\t\t\tbbio->raid_map[i] = bbio->raid_map[i+1];\n\t\t\t\tbbio->stripes[i+1] = s;\n\t\t\t\tbbio->raid_map[i+1] = l;\n\n\t\t\t\tagain = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parity_smaller",
          "args": [
            "bbio->raid_map[i]",
            "bbio->raid_map[i+1]"
          ],
          "line": 4888
        },
        "resolved": true,
        "details": {
          "function_name": "parity_smaller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4872-4875",
          "snippet": "static inline int parity_smaller(u64 a, u64 b)\n{\n\treturn a > b;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic inline int parity_smaller(u64 a, u64 b)\n{\n\treturn a > b;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void sort_parity_stripes(struct btrfs_bio *bbio, int num_stripes)\n{\n\tstruct btrfs_bio_stripe s;\n\tint i;\n\tu64 l;\n\tint again = 1;\n\n\twhile (again) {\n\t\tagain = 0;\n\t\tfor (i = 0; i < num_stripes - 1; i++) {\n\t\t\tif (parity_smaller(bbio->raid_map[i],\n\t\t\t\t\t   bbio->raid_map[i+1])) {\n\t\t\t\ts = bbio->stripes[i];\n\t\t\t\tl = bbio->raid_map[i];\n\t\t\t\tbbio->stripes[i] = bbio->stripes[i+1];\n\t\t\t\tbbio->raid_map[i] = bbio->raid_map[i+1];\n\t\t\t\tbbio->stripes[i+1] = s;\n\t\t\t\tbbio->raid_map[i+1] = l;\n\n\t\t\t\tagain = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "parity_smaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4872-4875",
    "snippet": "static inline int parity_smaller(u64 a, u64 b)\n{\n\treturn a > b;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic inline int parity_smaller(u64 a, u64 b)\n{\n\treturn a > b;\n}"
  },
  {
    "function_name": "find_live_mirror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4835-4870",
    "snippet": "static int find_live_mirror(struct btrfs_fs_info *fs_info,\n\t\t\t    struct map_lookup *map, int first, int num,\n\t\t\t    int optimal, int dev_replace_is_ongoing)\n{\n\tint i;\n\tint tolerance;\n\tstruct btrfs_device *srcdev;\n\n\tif (dev_replace_is_ongoing &&\n\t    fs_info->dev_replace.cont_reading_from_srcdev_mode ==\n\t     BTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_AVOID)\n\t\tsrcdev = fs_info->dev_replace.srcdev;\n\telse\n\t\tsrcdev = NULL;\n\n\t/*\n\t * try to avoid the drive that is the source drive for a\n\t * dev-replace procedure, only choose it if no other non-missing\n\t * mirror is available\n\t */\n\tfor (tolerance = 0; tolerance < 2; tolerance++) {\n\t\tif (map->stripes[optimal].dev->bdev &&\n\t\t    (tolerance || map->stripes[optimal].dev != srcdev))\n\t\t\treturn optimal;\n\t\tfor (i = first; i < first + num; i++) {\n\t\t\tif (map->stripes[i].dev->bdev &&\n\t\t\t    (tolerance || map->stripes[i].dev != srcdev))\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\t/* we couldn't find one that doesn't fail.  Just return something\n\t * and the io error handling code will clean up eventually\n\t */\n\treturn optimal;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int find_live_mirror(struct btrfs_fs_info *fs_info,\n\t\t\t    struct map_lookup *map, int first, int num,\n\t\t\t    int optimal, int dev_replace_is_ongoing)\n{\n\tint i;\n\tint tolerance;\n\tstruct btrfs_device *srcdev;\n\n\tif (dev_replace_is_ongoing &&\n\t    fs_info->dev_replace.cont_reading_from_srcdev_mode ==\n\t     BTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_AVOID)\n\t\tsrcdev = fs_info->dev_replace.srcdev;\n\telse\n\t\tsrcdev = NULL;\n\n\t/*\n\t * try to avoid the drive that is the source drive for a\n\t * dev-replace procedure, only choose it if no other non-missing\n\t * mirror is available\n\t */\n\tfor (tolerance = 0; tolerance < 2; tolerance++) {\n\t\tif (map->stripes[optimal].dev->bdev &&\n\t\t    (tolerance || map->stripes[optimal].dev != srcdev))\n\t\t\treturn optimal;\n\t\tfor (i = first; i < first + num; i++) {\n\t\t\tif (map->stripes[i].dev->bdev &&\n\t\t\t    (tolerance || map->stripes[i].dev != srcdev))\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\t/* we couldn't find one that doesn't fail.  Just return something\n\t * and the io error handling code will clean up eventually\n\t */\n\treturn optimal;\n}"
  },
  {
    "function_name": "btrfs_is_parity_mirror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4814-4833",
    "snippet": "int btrfs_is_parity_mirror(struct btrfs_mapping_tree *map_tree,\n\t\t\t   u64 logical, u64 len, int mirror_num)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret = 0;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\tBUG_ON(!em);\n\n\tBUG_ON(em->start > logical || em->start + em->len < logical);\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK)\n\t\tret = 1;\n\tfree_extent_map(em);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 4831
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "em->start > logical || em->start + em->len < logical"
          ],
          "line": 4827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!em"
          ],
          "line": 4825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4824
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "logical",
            "len"
          ],
          "line": 4823
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4822
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_is_parity_mirror(struct btrfs_mapping_tree *map_tree,\n\t\t\t   u64 logical, u64 len, int mirror_num)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret = 0;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\tBUG_ON(!em);\n\n\tBUG_ON(em->start > logical || em->start + em->len < logical);\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK)\n\t\tret = 1;\n\tfree_extent_map(em);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_full_stripe_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4792-4812",
    "snippet": "unsigned long btrfs_full_stripe_len(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_mapping_tree *map_tree,\n\t\t\t\t    u64 logical)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tunsigned long len = root->sectorsize;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\tBUG_ON(!em);\n\n\tBUG_ON(em->start > logical || em->start + em->len < logical);\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK)\n\t\tlen = map->stripe_len * nr_data_stripes(map);\n\tfree_extent_map(em);\n\treturn len;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 4810
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_data_stripes",
          "args": [
            "map"
          ],
          "line": 4809
        },
        "resolved": true,
        "details": {
          "function_name": "nr_data_stripes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.h",
          "lines": "32-35",
          "snippet": "static inline int nr_data_stripes(struct map_lookup *map)\n{\n\treturn map->num_stripes - nr_parity_stripes(map);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int nr_data_stripes(struct map_lookup *map)\n{\n\treturn map->num_stripes - nr_parity_stripes(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "em->start > logical || em->start + em->len < logical"
          ],
          "line": 4806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!em"
          ],
          "line": 4804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4803
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "logical",
            "len"
          ],
          "line": 4802
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4801
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nunsigned long btrfs_full_stripe_len(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_mapping_tree *map_tree,\n\t\t\t\t    u64 logical)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tunsigned long len = root->sectorsize;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\tBUG_ON(!em);\n\n\tBUG_ON(em->start > logical || em->start + em->len < logical);\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK)\n\t\tlen = map->stripe_len * nr_data_stripes(map);\n\tfree_extent_map(em);\n\treturn len;\n}"
  },
  {
    "function_name": "btrfs_num_copies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4740-4790",
    "snippet": "int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_dev_replace_unlock",
          "args": [
            "&fs_info->dev_replace"
          ],
          "line": 4787
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "895-909",
          "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_is_ongoing",
          "args": [
            "&fs_info->dev_replace"
          ],
          "line": 4785
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_is_ongoing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "840-865",
          "snippet": "int btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\n\nint btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_lock",
          "args": [
            "&fs_info->dev_replace"
          ],
          "line": 4784
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "867-893",
          "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 4782
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "fs_info",
            "\"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\"",
            "logical",
            "logical+len",
            "em->start",
            "em->start + em->len"
          ],
          "line": 4764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "fs_info",
            "\"No mapping for %Lu-%Lu\"",
            "logical",
            "logical+len"
          ],
          "line": 4758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4750
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "logical",
            "len"
          ],
          "line": 4749
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4748
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_mapping_tree_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4721-4738",
    "snippet": "void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree)\n{\n\tstruct extent_map *em;\n\n\twhile (1) {\n\t\twrite_lock(&tree->map_tree.lock);\n\t\tem = lookup_extent_mapping(&tree->map_tree, 0, (u64)-1);\n\t\tif (em)\n\t\t\tremove_extent_mapping(&tree->map_tree, em);\n\t\twrite_unlock(&tree->map_tree.lock);\n\t\tif (!em)\n\t\t\tbreak;\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree */\n\t\tfree_extent_map(em);\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 4736
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&tree->map_tree.lock"
          ],
          "line": 4730
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_extent_mapping",
          "args": [
            "&tree->map_tree",
            "em"
          ],
          "line": 4729
        },
        "resolved": true,
        "details": {
          "function_name": "remove_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "430-440",
          "snippet": "int remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tint ret = 0;\n\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &em->flags));\n\trb_erase(&em->rb_node, &tree->map);\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &em->flags))\n\t\tlist_del_init(&em->list);\n\tRB_CLEAR_NODE(&em->rb_node);\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tint ret = 0;\n\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &em->flags));\n\trb_erase(&em->rb_node, &tree->map);\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &em->flags))\n\t\tlist_del_init(&em->list);\n\tRB_CLEAR_NODE(&em->rb_node);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "&tree->map_tree",
            "0",
            "(u64)-1"
          ],
          "line": 4727
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&tree->map_tree.lock"
          ],
          "line": 4726
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree)\n{\n\tstruct extent_map *em;\n\n\twhile (1) {\n\t\twrite_lock(&tree->map_tree.lock);\n\t\tem = lookup_extent_mapping(&tree->map_tree, 0, (u64)-1);\n\t\tif (em)\n\t\t\tremove_extent_mapping(&tree->map_tree, em);\n\t\twrite_unlock(&tree->map_tree.lock);\n\t\tif (!em)\n\t\t\tbreak;\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree */\n\t\tfree_extent_map(em);\n\t}\n}"
  },
  {
    "function_name": "btrfs_mapping_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4716-4719",
    "snippet": "void btrfs_mapping_init(struct btrfs_mapping_tree *tree)\n{\n\textent_map_tree_init(&tree->map_tree);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "extent_map_tree_init",
          "args": [
            "&tree->map_tree"
          ],
          "line": 4718
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_tree_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "34-39",
          "snippet": "void extent_map_tree_init(struct extent_map_tree *tree)\n{\n\ttree->map = RB_ROOT;\n\tINIT_LIST_HEAD(&tree->modified_extents);\n\trwlock_init(&tree->lock);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nvoid extent_map_tree_init(struct extent_map_tree *tree)\n{\n\ttree->map = RB_ROOT;\n\tINIT_LIST_HEAD(&tree->modified_extents);\n\trwlock_init(&tree->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_mapping_init(struct btrfs_mapping_tree *tree)\n{\n\textent_map_tree_init(&tree->map_tree);\n}"
  },
  {
    "function_name": "btrfs_chunk_readonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4676-4714",
    "snippet": "int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_mapping_tree *map_tree = &root->fs_info->mapping_tree;\n\tint readonly = 0;\n\tint miss_ndevs = 0;\n\tint i;\n\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, chunk_offset, 1);\n\tread_unlock(&map_tree->map_tree.lock);\n\tif (!em)\n\t\treturn 1;\n\n\tmap = (struct map_lookup *)em->bdev;\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tif (map->stripes[i].dev->missing) {\n\t\t\tmiss_ndevs++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!map->stripes[i].dev->writeable) {\n\t\t\treadonly = 1;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t/*\n\t * If the number of missing devices is larger than max errors,\n\t * we can not write the data into that chunk successfully, so\n\t * set it readonly.\n\t */\n\tif (miss_ndevs > btrfs_chunk_max_errors(map))\n\t\treadonly = 1;\nend:\n\tfree_extent_map(em);\n\treturn readonly;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 4712
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_max_errors",
          "args": [
            "map"
          ],
          "line": 4709
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_chunk_max_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4658-4674",
          "snippet": "static inline int btrfs_chunk_max_errors(struct map_lookup *map)\n{\n\tint max_errors;\n\n\tif (map->type & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t BTRFS_BLOCK_GROUP_DUP)) {\n\t\tmax_errors = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\tmax_errors = 2;\n\t} else {\n\t\tmax_errors = 0;\n\t}\n\n\treturn max_errors;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic inline int btrfs_chunk_max_errors(struct map_lookup *map)\n{\n\tint max_errors;\n\n\tif (map->type & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t BTRFS_BLOCK_GROUP_DUP)) {\n\t\tmax_errors = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\tmax_errors = 2;\n\t} else {\n\t\tmax_errors = 0;\n\t}\n\n\treturn max_errors;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&map_tree->map_tree.lock"
          ],
          "line": 4687
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "&map_tree->map_tree",
            "chunk_offset",
            "1"
          ],
          "line": 4686
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&map_tree->map_tree.lock"
          ],
          "line": 4685
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_mapping_tree *map_tree = &root->fs_info->mapping_tree;\n\tint readonly = 0;\n\tint miss_ndevs = 0;\n\tint i;\n\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, chunk_offset, 1);\n\tread_unlock(&map_tree->map_tree.lock);\n\tif (!em)\n\t\treturn 1;\n\n\tmap = (struct map_lookup *)em->bdev;\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tif (map->stripes[i].dev->missing) {\n\t\t\tmiss_ndevs++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!map->stripes[i].dev->writeable) {\n\t\t\treadonly = 1;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t/*\n\t * If the number of missing devices is larger than max errors,\n\t * we can not write the data into that chunk successfully, so\n\t * set it readonly.\n\t */\n\tif (miss_ndevs > btrfs_chunk_max_errors(map))\n\t\treadonly = 1;\nend:\n\tfree_extent_map(em);\n\treturn readonly;\n}"
  },
  {
    "function_name": "btrfs_chunk_max_errors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4658-4674",
    "snippet": "static inline int btrfs_chunk_max_errors(struct map_lookup *map)\n{\n\tint max_errors;\n\n\tif (map->type & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t BTRFS_BLOCK_GROUP_DUP)) {\n\t\tmax_errors = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\tmax_errors = 2;\n\t} else {\n\t\tmax_errors = 0;\n\t}\n\n\treturn max_errors;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic inline int btrfs_chunk_max_errors(struct map_lookup *map)\n{\n\tint max_errors;\n\n\tif (map->type & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t BTRFS_BLOCK_GROUP_DUP)) {\n\t\tmax_errors = 1;\n\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\tmax_errors = 2;\n\t} else {\n\t\tmax_errors = 0;\n\t}\n\n\treturn max_errors;\n}"
  },
  {
    "function_name": "init_first_rw_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4633-4656",
    "snippet": "static noinline int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_device *device)\n{\n\tu64 chunk_offset;\n\tu64 sys_chunk_offset;\n\tu64 alloc_profile;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *extent_root = fs_info->extent_root;\n\tint ret;\n\n\tchunk_offset = find_next_chunk(fs_info);\n\talloc_profile = btrfs_get_alloc_profile(extent_root, 0);\n\tret = __btrfs_alloc_chunk(trans, extent_root, chunk_offset,\n\t\t\t\t  alloc_profile);\n\tif (ret)\n\t\treturn ret;\n\n\tsys_chunk_offset = find_next_chunk(root->fs_info);\n\talloc_profile = btrfs_get_alloc_profile(fs_info->chunk_root, 0);\n\tret = __btrfs_alloc_chunk(trans, extent_root, sys_chunk_offset,\n\t\t\t\t  alloc_profile);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_alloc_chunk",
          "args": [
            "trans",
            "extent_root",
            "sys_chunk_offset",
            "alloc_profile"
          ],
          "line": 4653
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_alloc_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4217-4511",
          "snippet": "static int __btrfs_alloc_chunk(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *extent_root, u64 start,\n\t\t\t       u64 type)\n{\n\tstruct btrfs_fs_info *info = extent_root->fs_info;\n\tstruct btrfs_fs_devices *fs_devices = info->fs_devices;\n\tstruct list_head *cur;\n\tstruct map_lookup *map = NULL;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_device_info *devices_info = NULL;\n\tu64 total_avail;\n\tint num_stripes;\t/* total number of stripes to allocate */\n\tint data_stripes;\t/* number of stripes that count for\n\t\t\t\t   block group size */\n\tint sub_stripes;\t/* sub_stripes info for map */\n\tint dev_stripes;\t/* stripes per dev */\n\tint devs_max;\t\t/* max devs to use */\n\tint devs_min;\t\t/* min devs needed */\n\tint devs_increment;\t/* ndevs has to be a multiple of this */\n\tint ncopies;\t\t/* how many copies to data has */\n\tint ret;\n\tu64 max_stripe_size;\n\tu64 max_chunk_size;\n\tu64 stripe_size;\n\tu64 num_bytes;\n\tu64 raid_stripe_len = BTRFS_STRIPE_LEN;\n\tint ndevs;\n\tint i;\n\tint j;\n\tint index;\n\n\tBUG_ON(!alloc_profile_is_valid(type, 0));\n\n\tif (list_empty(&fs_devices->alloc_list))\n\t\treturn -ENOSPC;\n\n\tindex = __get_raid_index(type);\n\n\tsub_stripes = btrfs_raid_array[index].sub_stripes;\n\tdev_stripes = btrfs_raid_array[index].dev_stripes;\n\tdevs_max = btrfs_raid_array[index].devs_max;\n\tdevs_min = btrfs_raid_array[index].devs_min;\n\tdevs_increment = btrfs_raid_array[index].devs_increment;\n\tncopies = btrfs_raid_array[index].ncopies;\n\n\tif (type & BTRFS_BLOCK_GROUP_DATA) {\n\t\tmax_stripe_size = 1024 * 1024 * 1024;\n\t\tmax_chunk_size = 10 * max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS(info->chunk_root);\n\t} else if (type & BTRFS_BLOCK_GROUP_METADATA) {\n\t\t/* for larger filesystems, use larger metadata chunks */\n\t\tif (fs_devices->total_rw_bytes > 50ULL * 1024 * 1024 * 1024)\n\t\t\tmax_stripe_size = 1024 * 1024 * 1024;\n\t\telse\n\t\t\tmax_stripe_size = 256 * 1024 * 1024;\n\t\tmax_chunk_size = max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS(info->chunk_root);\n\t} else if (type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\tmax_stripe_size = 32 * 1024 * 1024;\n\t\tmax_chunk_size = 2 * max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS_SYS_CHUNK;\n\t} else {\n\t\tbtrfs_err(info, \"invalid chunk type 0x%llx requested\",\n\t\t       type);\n\t\tBUG_ON(1);\n\t}\n\n\t/* we don't want a chunk larger than 10% of writeable space */\n\tmax_chunk_size = min(div_factor(fs_devices->total_rw_bytes, 1),\n\t\t\t     max_chunk_size);\n\n\tdevices_info = kzalloc(sizeof(*devices_info) * fs_devices->rw_devices,\n\t\t\t       GFP_NOFS);\n\tif (!devices_info)\n\t\treturn -ENOMEM;\n\n\tcur = fs_devices->alloc_list.next;\n\n\t/*\n\t * in the first pass through the devices list, we gather information\n\t * about the available holes on each device.\n\t */\n\tndevs = 0;\n\twhile (cur != &fs_devices->alloc_list) {\n\t\tstruct btrfs_device *device;\n\t\tu64 max_avail;\n\t\tu64 dev_offset;\n\n\t\tdevice = list_entry(cur, struct btrfs_device, dev_alloc_list);\n\n\t\tcur = cur->next;\n\n\t\tif (!device->writeable) {\n\t\t\tWARN(1, KERN_ERR\n\t\t\t       \"BTRFS: read-only device in alloc_list\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!device->in_fs_metadata ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tif (device->total_bytes > device->bytes_used)\n\t\t\ttotal_avail = device->total_bytes - device->bytes_used;\n\t\telse\n\t\t\ttotal_avail = 0;\n\n\t\t/* If there is no space on this device, skip it. */\n\t\tif (total_avail == 0)\n\t\t\tcontinue;\n\n\t\tret = find_free_dev_extent(trans, device,\n\t\t\t\t\t   max_stripe_size * dev_stripes,\n\t\t\t\t\t   &dev_offset, &max_avail);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto error;\n\n\t\tif (ret == 0)\n\t\t\tmax_avail = max_stripe_size * dev_stripes;\n\n\t\tif (max_avail < BTRFS_STRIPE_LEN * dev_stripes)\n\t\t\tcontinue;\n\n\t\tif (ndevs == fs_devices->rw_devices) {\n\t\t\tWARN(1, \"%s: found more than %llu devices\\n\",\n\t\t\t     __func__, fs_devices->rw_devices);\n\t\t\tbreak;\n\t\t}\n\t\tdevices_info[ndevs].dev_offset = dev_offset;\n\t\tdevices_info[ndevs].max_avail = max_avail;\n\t\tdevices_info[ndevs].total_avail = total_avail;\n\t\tdevices_info[ndevs].dev = device;\n\t\t++ndevs;\n\t}\n\n\t/*\n\t * now sort the devices by hole size / available space\n\t */\n\tsort(devices_info, ndevs, sizeof(struct btrfs_device_info),\n\t     btrfs_cmp_device_info, NULL);\n\n\t/* round down to number of usable stripes */\n\tndevs -= ndevs % devs_increment;\n\n\tif (ndevs < devs_increment * sub_stripes || ndevs < devs_min) {\n\t\tret = -ENOSPC;\n\t\tgoto error;\n\t}\n\n\tif (devs_max && ndevs > devs_max)\n\t\tndevs = devs_max;\n\t/*\n\t * the primary goal is to maximize the number of stripes, so use as many\n\t * devices as possible, even if the stripes are not maximum sized.\n\t */\n\tstripe_size = devices_info[ndevs-1].max_avail;\n\tnum_stripes = ndevs * dev_stripes;\n\n\t/*\n\t * this will have to be fixed for RAID1 and RAID10 over\n\t * more drives\n\t */\n\tdata_stripes = num_stripes / ncopies;\n\n\tif (type & BTRFS_BLOCK_GROUP_RAID5) {\n\t\traid_stripe_len = find_raid56_stripe_len(ndevs - 1,\n\t\t\t\t btrfs_super_stripesize(info->super_copy));\n\t\tdata_stripes = num_stripes - 1;\n\t}\n\tif (type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\traid_stripe_len = find_raid56_stripe_len(ndevs - 2,\n\t\t\t\t btrfs_super_stripesize(info->super_copy));\n\t\tdata_stripes = num_stripes - 2;\n\t}\n\n\t/*\n\t * Use the number of data stripes to figure out how big this chunk\n\t * is really going to be in terms of logical address space,\n\t * and compare that answer with the max chunk size\n\t */\n\tif (stripe_size * data_stripes > max_chunk_size) {\n\t\tu64 mask = (1ULL << 24) - 1;\n\t\tstripe_size = max_chunk_size;\n\t\tdo_div(stripe_size, data_stripes);\n\n\t\t/* bump the answer up to a 16MB boundary */\n\t\tstripe_size = (stripe_size + mask) & ~mask;\n\n\t\t/* but don't go higher than the limits we found\n\t\t * while searching for free extents\n\t\t */\n\t\tif (stripe_size > devices_info[ndevs-1].max_avail)\n\t\t\tstripe_size = devices_info[ndevs-1].max_avail;\n\t}\n\n\tdo_div(stripe_size, dev_stripes);\n\n\t/* align to BTRFS_STRIPE_LEN */\n\tdo_div(stripe_size, raid_stripe_len);\n\tstripe_size *= raid_stripe_len;\n\n\tmap = kmalloc(map_lookup_size(num_stripes), GFP_NOFS);\n\tif (!map) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tmap->num_stripes = num_stripes;\n\n\tfor (i = 0; i < ndevs; ++i) {\n\t\tfor (j = 0; j < dev_stripes; ++j) {\n\t\t\tint s = i * dev_stripes + j;\n\t\t\tmap->stripes[s].dev = devices_info[i].dev;\n\t\t\tmap->stripes[s].physical = devices_info[i].dev_offset +\n\t\t\t\t\t\t   j * stripe_size;\n\t\t}\n\t}\n\tmap->sector_size = extent_root->sectorsize;\n\tmap->stripe_len = raid_stripe_len;\n\tmap->io_align = raid_stripe_len;\n\tmap->io_width = raid_stripe_len;\n\tmap->type = type;\n\tmap->sub_stripes = sub_stripes;\n\n\tnum_bytes = stripe_size * data_stripes;\n\n\ttrace_btrfs_chunk_alloc(info->chunk_root, map, start, num_bytes);\n\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tkfree(map);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tset_bit(EXTENT_FLAG_FS_MAPPING, &em->flags);\n\tem->bdev = (struct block_device *)map;\n\tem->start = start;\n\tem->len = num_bytes;\n\tem->block_start = 0;\n\tem->block_len = em->len;\n\tem->orig_block_len = stripe_size;\n\n\tem_tree = &extent_root->fs_info->mapping_tree.map_tree;\n\twrite_lock(&em_tree->lock);\n\tret = add_extent_mapping(em_tree, em, 0);\n\tif (!ret) {\n\t\tlist_add_tail(&em->list, &trans->transaction->pending_chunks);\n\t\tatomic_inc(&em->refs);\n\t}\n\twrite_unlock(&em_tree->lock);\n\tif (ret) {\n\t\tfree_extent_map(em);\n\t\tgoto error;\n\t}\n\n\tret = btrfs_make_block_group(trans, extent_root, 0, type,\n\t\t\t\t     BTRFS_FIRST_CHUNK_TREE_OBJECTID,\n\t\t\t\t     start, num_bytes);\n\tif (ret)\n\t\tgoto error_del_extent;\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tnum_bytes = map->stripes[i].dev->bytes_used + stripe_size;\n\t\tbtrfs_device_set_bytes_used(map->stripes[i].dev, num_bytes);\n\t}\n\n\tspin_lock(&extent_root->fs_info->free_chunk_lock);\n\textent_root->fs_info->free_chunk_space -= (stripe_size *\n\t\t\t\t\t\t   map->num_stripes);\n\tspin_unlock(&extent_root->fs_info->free_chunk_lock);\n\n\tfree_extent_map(em);\n\tcheck_raid56_incompat_flag(extent_root->fs_info, type);\n\n\tkfree(devices_info);\n\treturn 0;\n\nerror_del_extent:\n\twrite_lock(&em_tree->lock);\n\tremove_extent_mapping(em_tree, em);\n\twrite_unlock(&em_tree->lock);\n\n\t/* One for our allocation */\n\tfree_extent_map(em);\n\t/* One for the tree reference */\n\tfree_extent_map(em);\n\t/* One for the pending_chunks list reference */\n\tfree_extent_map(em);\nerror:\n\tkfree(devices_info);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFS_MAX_DEVS_SYS_CHUNK ((BTRFS_SYSTEM_CHUNK_ARRAY_SIZE\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_disk_key)\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_chunk))\t\\\n\t\t\t\t/ sizeof(struct btrfs_stripe) + 1)"
          ],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct",
            "static struct btrfs_raid_attr btrfs_raid_array[BTRFS_NR_RAID_TYPES] = {\n\t[BTRFS_RAID_RAID10] = {\n\t\t.sub_stripes\t= 2,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\t/* 0 == as many as possible */\n\t\t.devs_min\t= 4,\n\t\t.devs_increment\t= 2,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID1] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 2,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 2,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_DUP] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 2,\n\t\t.devs_max\t= 1,\n\t\t.devs_min\t= 1,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID0] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 1,\n\t},\n\t[BTRFS_RAID_SINGLE] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 1,\n\t\t.devs_min\t= 1,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 1,\n\t},\n\t[BTRFS_RAID_RAID5] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID6] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 3,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 3,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\n#define BTRFS_MAX_DEVS_SYS_CHUNK ((BTRFS_SYSTEM_CHUNK_ARRAY_SIZE\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_disk_key)\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_chunk))\t\\\n\t\t\t\t/ sizeof(struct btrfs_stripe) + 1)\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\nstatic struct btrfs_raid_attr btrfs_raid_array[BTRFS_NR_RAID_TYPES] = {\n\t[BTRFS_RAID_RAID10] = {\n\t\t.sub_stripes\t= 2,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\t/* 0 == as many as possible */\n\t\t.devs_min\t= 4,\n\t\t.devs_increment\t= 2,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID1] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 2,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 2,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_DUP] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 2,\n\t\t.devs_max\t= 1,\n\t\t.devs_min\t= 1,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID0] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 1,\n\t},\n\t[BTRFS_RAID_SINGLE] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 1,\n\t\t.devs_min\t= 1,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 1,\n\t},\n\t[BTRFS_RAID_RAID5] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID6] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 3,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 3,\n\t},\n};\n\nstatic int __btrfs_alloc_chunk(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *extent_root, u64 start,\n\t\t\t       u64 type)\n{\n\tstruct btrfs_fs_info *info = extent_root->fs_info;\n\tstruct btrfs_fs_devices *fs_devices = info->fs_devices;\n\tstruct list_head *cur;\n\tstruct map_lookup *map = NULL;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_device_info *devices_info = NULL;\n\tu64 total_avail;\n\tint num_stripes;\t/* total number of stripes to allocate */\n\tint data_stripes;\t/* number of stripes that count for\n\t\t\t\t   block group size */\n\tint sub_stripes;\t/* sub_stripes info for map */\n\tint dev_stripes;\t/* stripes per dev */\n\tint devs_max;\t\t/* max devs to use */\n\tint devs_min;\t\t/* min devs needed */\n\tint devs_increment;\t/* ndevs has to be a multiple of this */\n\tint ncopies;\t\t/* how many copies to data has */\n\tint ret;\n\tu64 max_stripe_size;\n\tu64 max_chunk_size;\n\tu64 stripe_size;\n\tu64 num_bytes;\n\tu64 raid_stripe_len = BTRFS_STRIPE_LEN;\n\tint ndevs;\n\tint i;\n\tint j;\n\tint index;\n\n\tBUG_ON(!alloc_profile_is_valid(type, 0));\n\n\tif (list_empty(&fs_devices->alloc_list))\n\t\treturn -ENOSPC;\n\n\tindex = __get_raid_index(type);\n\n\tsub_stripes = btrfs_raid_array[index].sub_stripes;\n\tdev_stripes = btrfs_raid_array[index].dev_stripes;\n\tdevs_max = btrfs_raid_array[index].devs_max;\n\tdevs_min = btrfs_raid_array[index].devs_min;\n\tdevs_increment = btrfs_raid_array[index].devs_increment;\n\tncopies = btrfs_raid_array[index].ncopies;\n\n\tif (type & BTRFS_BLOCK_GROUP_DATA) {\n\t\tmax_stripe_size = 1024 * 1024 * 1024;\n\t\tmax_chunk_size = 10 * max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS(info->chunk_root);\n\t} else if (type & BTRFS_BLOCK_GROUP_METADATA) {\n\t\t/* for larger filesystems, use larger metadata chunks */\n\t\tif (fs_devices->total_rw_bytes > 50ULL * 1024 * 1024 * 1024)\n\t\t\tmax_stripe_size = 1024 * 1024 * 1024;\n\t\telse\n\t\t\tmax_stripe_size = 256 * 1024 * 1024;\n\t\tmax_chunk_size = max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS(info->chunk_root);\n\t} else if (type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\tmax_stripe_size = 32 * 1024 * 1024;\n\t\tmax_chunk_size = 2 * max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS_SYS_CHUNK;\n\t} else {\n\t\tbtrfs_err(info, \"invalid chunk type 0x%llx requested\",\n\t\t       type);\n\t\tBUG_ON(1);\n\t}\n\n\t/* we don't want a chunk larger than 10% of writeable space */\n\tmax_chunk_size = min(div_factor(fs_devices->total_rw_bytes, 1),\n\t\t\t     max_chunk_size);\n\n\tdevices_info = kzalloc(sizeof(*devices_info) * fs_devices->rw_devices,\n\t\t\t       GFP_NOFS);\n\tif (!devices_info)\n\t\treturn -ENOMEM;\n\n\tcur = fs_devices->alloc_list.next;\n\n\t/*\n\t * in the first pass through the devices list, we gather information\n\t * about the available holes on each device.\n\t */\n\tndevs = 0;\n\twhile (cur != &fs_devices->alloc_list) {\n\t\tstruct btrfs_device *device;\n\t\tu64 max_avail;\n\t\tu64 dev_offset;\n\n\t\tdevice = list_entry(cur, struct btrfs_device, dev_alloc_list);\n\n\t\tcur = cur->next;\n\n\t\tif (!device->writeable) {\n\t\t\tWARN(1, KERN_ERR\n\t\t\t       \"BTRFS: read-only device in alloc_list\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!device->in_fs_metadata ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tif (device->total_bytes > device->bytes_used)\n\t\t\ttotal_avail = device->total_bytes - device->bytes_used;\n\t\telse\n\t\t\ttotal_avail = 0;\n\n\t\t/* If there is no space on this device, skip it. */\n\t\tif (total_avail == 0)\n\t\t\tcontinue;\n\n\t\tret = find_free_dev_extent(trans, device,\n\t\t\t\t\t   max_stripe_size * dev_stripes,\n\t\t\t\t\t   &dev_offset, &max_avail);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto error;\n\n\t\tif (ret == 0)\n\t\t\tmax_avail = max_stripe_size * dev_stripes;\n\n\t\tif (max_avail < BTRFS_STRIPE_LEN * dev_stripes)\n\t\t\tcontinue;\n\n\t\tif (ndevs == fs_devices->rw_devices) {\n\t\t\tWARN(1, \"%s: found more than %llu devices\\n\",\n\t\t\t     __func__, fs_devices->rw_devices);\n\t\t\tbreak;\n\t\t}\n\t\tdevices_info[ndevs].dev_offset = dev_offset;\n\t\tdevices_info[ndevs].max_avail = max_avail;\n\t\tdevices_info[ndevs].total_avail = total_avail;\n\t\tdevices_info[ndevs].dev = device;\n\t\t++ndevs;\n\t}\n\n\t/*\n\t * now sort the devices by hole size / available space\n\t */\n\tsort(devices_info, ndevs, sizeof(struct btrfs_device_info),\n\t     btrfs_cmp_device_info, NULL);\n\n\t/* round down to number of usable stripes */\n\tndevs -= ndevs % devs_increment;\n\n\tif (ndevs < devs_increment * sub_stripes || ndevs < devs_min) {\n\t\tret = -ENOSPC;\n\t\tgoto error;\n\t}\n\n\tif (devs_max && ndevs > devs_max)\n\t\tndevs = devs_max;\n\t/*\n\t * the primary goal is to maximize the number of stripes, so use as many\n\t * devices as possible, even if the stripes are not maximum sized.\n\t */\n\tstripe_size = devices_info[ndevs-1].max_avail;\n\tnum_stripes = ndevs * dev_stripes;\n\n\t/*\n\t * this will have to be fixed for RAID1 and RAID10 over\n\t * more drives\n\t */\n\tdata_stripes = num_stripes / ncopies;\n\n\tif (type & BTRFS_BLOCK_GROUP_RAID5) {\n\t\traid_stripe_len = find_raid56_stripe_len(ndevs - 1,\n\t\t\t\t btrfs_super_stripesize(info->super_copy));\n\t\tdata_stripes = num_stripes - 1;\n\t}\n\tif (type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\traid_stripe_len = find_raid56_stripe_len(ndevs - 2,\n\t\t\t\t btrfs_super_stripesize(info->super_copy));\n\t\tdata_stripes = num_stripes - 2;\n\t}\n\n\t/*\n\t * Use the number of data stripes to figure out how big this chunk\n\t * is really going to be in terms of logical address space,\n\t * and compare that answer with the max chunk size\n\t */\n\tif (stripe_size * data_stripes > max_chunk_size) {\n\t\tu64 mask = (1ULL << 24) - 1;\n\t\tstripe_size = max_chunk_size;\n\t\tdo_div(stripe_size, data_stripes);\n\n\t\t/* bump the answer up to a 16MB boundary */\n\t\tstripe_size = (stripe_size + mask) & ~mask;\n\n\t\t/* but don't go higher than the limits we found\n\t\t * while searching for free extents\n\t\t */\n\t\tif (stripe_size > devices_info[ndevs-1].max_avail)\n\t\t\tstripe_size = devices_info[ndevs-1].max_avail;\n\t}\n\n\tdo_div(stripe_size, dev_stripes);\n\n\t/* align to BTRFS_STRIPE_LEN */\n\tdo_div(stripe_size, raid_stripe_len);\n\tstripe_size *= raid_stripe_len;\n\n\tmap = kmalloc(map_lookup_size(num_stripes), GFP_NOFS);\n\tif (!map) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tmap->num_stripes = num_stripes;\n\n\tfor (i = 0; i < ndevs; ++i) {\n\t\tfor (j = 0; j < dev_stripes; ++j) {\n\t\t\tint s = i * dev_stripes + j;\n\t\t\tmap->stripes[s].dev = devices_info[i].dev;\n\t\t\tmap->stripes[s].physical = devices_info[i].dev_offset +\n\t\t\t\t\t\t   j * stripe_size;\n\t\t}\n\t}\n\tmap->sector_size = extent_root->sectorsize;\n\tmap->stripe_len = raid_stripe_len;\n\tmap->io_align = raid_stripe_len;\n\tmap->io_width = raid_stripe_len;\n\tmap->type = type;\n\tmap->sub_stripes = sub_stripes;\n\n\tnum_bytes = stripe_size * data_stripes;\n\n\ttrace_btrfs_chunk_alloc(info->chunk_root, map, start, num_bytes);\n\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tkfree(map);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tset_bit(EXTENT_FLAG_FS_MAPPING, &em->flags);\n\tem->bdev = (struct block_device *)map;\n\tem->start = start;\n\tem->len = num_bytes;\n\tem->block_start = 0;\n\tem->block_len = em->len;\n\tem->orig_block_len = stripe_size;\n\n\tem_tree = &extent_root->fs_info->mapping_tree.map_tree;\n\twrite_lock(&em_tree->lock);\n\tret = add_extent_mapping(em_tree, em, 0);\n\tif (!ret) {\n\t\tlist_add_tail(&em->list, &trans->transaction->pending_chunks);\n\t\tatomic_inc(&em->refs);\n\t}\n\twrite_unlock(&em_tree->lock);\n\tif (ret) {\n\t\tfree_extent_map(em);\n\t\tgoto error;\n\t}\n\n\tret = btrfs_make_block_group(trans, extent_root, 0, type,\n\t\t\t\t     BTRFS_FIRST_CHUNK_TREE_OBJECTID,\n\t\t\t\t     start, num_bytes);\n\tif (ret)\n\t\tgoto error_del_extent;\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tnum_bytes = map->stripes[i].dev->bytes_used + stripe_size;\n\t\tbtrfs_device_set_bytes_used(map->stripes[i].dev, num_bytes);\n\t}\n\n\tspin_lock(&extent_root->fs_info->free_chunk_lock);\n\textent_root->fs_info->free_chunk_space -= (stripe_size *\n\t\t\t\t\t\t   map->num_stripes);\n\tspin_unlock(&extent_root->fs_info->free_chunk_lock);\n\n\tfree_extent_map(em);\n\tcheck_raid56_incompat_flag(extent_root->fs_info, type);\n\n\tkfree(devices_info);\n\treturn 0;\n\nerror_del_extent:\n\twrite_lock(&em_tree->lock);\n\tremove_extent_mapping(em_tree, em);\n\twrite_unlock(&em_tree->lock);\n\n\t/* One for our allocation */\n\tfree_extent_map(em);\n\t/* One for the tree reference */\n\tfree_extent_map(em);\n\t/* One for the pending_chunks list reference */\n\tfree_extent_map(em);\nerror:\n\tkfree(devices_info);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_get_alloc_profile",
          "args": [
            "fs_info->chunk_root",
            "0"
          ],
          "line": 4652
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_alloc_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3618-3632",
          "snippet": "u64 btrfs_get_alloc_profile(struct btrfs_root *root, int data)\n{\n\tu64 flags;\n\tu64 ret;\n\n\tif (data)\n\t\tflags = BTRFS_BLOCK_GROUP_DATA;\n\telse if (root == root->fs_info->chunk_root)\n\t\tflags = BTRFS_BLOCK_GROUP_SYSTEM;\n\telse\n\t\tflags = BTRFS_BLOCK_GROUP_METADATA;\n\n\tret = get_alloc_profile(root, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nu64 btrfs_get_alloc_profile(struct btrfs_root *root, int data)\n{\n\tu64 flags;\n\tu64 ret;\n\n\tif (data)\n\t\tflags = BTRFS_BLOCK_GROUP_DATA;\n\telse if (root == root->fs_info->chunk_root)\n\t\tflags = BTRFS_BLOCK_GROUP_SYSTEM;\n\telse\n\t\tflags = BTRFS_BLOCK_GROUP_METADATA;\n\n\tret = get_alloc_profile(root, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_chunk",
          "args": [
            "root->fs_info"
          ],
          "line": 4651
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1364-1381",
          "snippet": "static u64 find_next_chunk(struct btrfs_fs_info *fs_info)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct rb_node *n;\n\tu64 ret = 0;\n\n\tem_tree = &fs_info->mapping_tree.map_tree;\n\tread_lock(&em_tree->lock);\n\tn = rb_last(&em_tree->map);\n\tif (n) {\n\t\tem = rb_entry(n, struct extent_map, rb_node);\n\t\tret = em->start + em->len;\n\t}\n\tread_unlock(&em_tree->lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic u64 find_next_chunk(struct btrfs_fs_info *fs_info)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct rb_node *n;\n\tu64 ret = 0;\n\n\tem_tree = &fs_info->mapping_tree.map_tree;\n\tread_lock(&em_tree->lock);\n\tn = rb_last(&em_tree->map);\n\tif (n) {\n\t\tem = rb_entry(n, struct extent_map, rb_node);\n\t\tret = em->start + em->len;\n\t}\n\tread_unlock(&em_tree->lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_device *device)\n{\n\tu64 chunk_offset;\n\tu64 sys_chunk_offset;\n\tu64 alloc_profile;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *extent_root = fs_info->extent_root;\n\tint ret;\n\n\tchunk_offset = find_next_chunk(fs_info);\n\talloc_profile = btrfs_get_alloc_profile(extent_root, 0);\n\tret = __btrfs_alloc_chunk(trans, extent_root, chunk_offset,\n\t\t\t\t  alloc_profile);\n\tif (ret)\n\t\treturn ret;\n\n\tsys_chunk_offset = find_next_chunk(root->fs_info);\n\talloc_profile = btrfs_get_alloc_profile(fs_info->chunk_root, 0);\n\tret = __btrfs_alloc_chunk(trans, extent_root, sys_chunk_offset,\n\t\t\t\t  alloc_profile);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_alloc_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4624-4631",
    "snippet": "int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *extent_root, u64 type)\n{\n\tu64 chunk_offset;\n\n\tchunk_offset = find_next_chunk(extent_root->fs_info);\n\treturn __btrfs_alloc_chunk(trans, extent_root, chunk_offset, type);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_alloc_chunk",
          "args": [
            "trans",
            "extent_root",
            "chunk_offset",
            "type"
          ],
          "line": 4630
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_alloc_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4217-4511",
          "snippet": "static int __btrfs_alloc_chunk(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *extent_root, u64 start,\n\t\t\t       u64 type)\n{\n\tstruct btrfs_fs_info *info = extent_root->fs_info;\n\tstruct btrfs_fs_devices *fs_devices = info->fs_devices;\n\tstruct list_head *cur;\n\tstruct map_lookup *map = NULL;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_device_info *devices_info = NULL;\n\tu64 total_avail;\n\tint num_stripes;\t/* total number of stripes to allocate */\n\tint data_stripes;\t/* number of stripes that count for\n\t\t\t\t   block group size */\n\tint sub_stripes;\t/* sub_stripes info for map */\n\tint dev_stripes;\t/* stripes per dev */\n\tint devs_max;\t\t/* max devs to use */\n\tint devs_min;\t\t/* min devs needed */\n\tint devs_increment;\t/* ndevs has to be a multiple of this */\n\tint ncopies;\t\t/* how many copies to data has */\n\tint ret;\n\tu64 max_stripe_size;\n\tu64 max_chunk_size;\n\tu64 stripe_size;\n\tu64 num_bytes;\n\tu64 raid_stripe_len = BTRFS_STRIPE_LEN;\n\tint ndevs;\n\tint i;\n\tint j;\n\tint index;\n\n\tBUG_ON(!alloc_profile_is_valid(type, 0));\n\n\tif (list_empty(&fs_devices->alloc_list))\n\t\treturn -ENOSPC;\n\n\tindex = __get_raid_index(type);\n\n\tsub_stripes = btrfs_raid_array[index].sub_stripes;\n\tdev_stripes = btrfs_raid_array[index].dev_stripes;\n\tdevs_max = btrfs_raid_array[index].devs_max;\n\tdevs_min = btrfs_raid_array[index].devs_min;\n\tdevs_increment = btrfs_raid_array[index].devs_increment;\n\tncopies = btrfs_raid_array[index].ncopies;\n\n\tif (type & BTRFS_BLOCK_GROUP_DATA) {\n\t\tmax_stripe_size = 1024 * 1024 * 1024;\n\t\tmax_chunk_size = 10 * max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS(info->chunk_root);\n\t} else if (type & BTRFS_BLOCK_GROUP_METADATA) {\n\t\t/* for larger filesystems, use larger metadata chunks */\n\t\tif (fs_devices->total_rw_bytes > 50ULL * 1024 * 1024 * 1024)\n\t\t\tmax_stripe_size = 1024 * 1024 * 1024;\n\t\telse\n\t\t\tmax_stripe_size = 256 * 1024 * 1024;\n\t\tmax_chunk_size = max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS(info->chunk_root);\n\t} else if (type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\tmax_stripe_size = 32 * 1024 * 1024;\n\t\tmax_chunk_size = 2 * max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS_SYS_CHUNK;\n\t} else {\n\t\tbtrfs_err(info, \"invalid chunk type 0x%llx requested\",\n\t\t       type);\n\t\tBUG_ON(1);\n\t}\n\n\t/* we don't want a chunk larger than 10% of writeable space */\n\tmax_chunk_size = min(div_factor(fs_devices->total_rw_bytes, 1),\n\t\t\t     max_chunk_size);\n\n\tdevices_info = kzalloc(sizeof(*devices_info) * fs_devices->rw_devices,\n\t\t\t       GFP_NOFS);\n\tif (!devices_info)\n\t\treturn -ENOMEM;\n\n\tcur = fs_devices->alloc_list.next;\n\n\t/*\n\t * in the first pass through the devices list, we gather information\n\t * about the available holes on each device.\n\t */\n\tndevs = 0;\n\twhile (cur != &fs_devices->alloc_list) {\n\t\tstruct btrfs_device *device;\n\t\tu64 max_avail;\n\t\tu64 dev_offset;\n\n\t\tdevice = list_entry(cur, struct btrfs_device, dev_alloc_list);\n\n\t\tcur = cur->next;\n\n\t\tif (!device->writeable) {\n\t\t\tWARN(1, KERN_ERR\n\t\t\t       \"BTRFS: read-only device in alloc_list\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!device->in_fs_metadata ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tif (device->total_bytes > device->bytes_used)\n\t\t\ttotal_avail = device->total_bytes - device->bytes_used;\n\t\telse\n\t\t\ttotal_avail = 0;\n\n\t\t/* If there is no space on this device, skip it. */\n\t\tif (total_avail == 0)\n\t\t\tcontinue;\n\n\t\tret = find_free_dev_extent(trans, device,\n\t\t\t\t\t   max_stripe_size * dev_stripes,\n\t\t\t\t\t   &dev_offset, &max_avail);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto error;\n\n\t\tif (ret == 0)\n\t\t\tmax_avail = max_stripe_size * dev_stripes;\n\n\t\tif (max_avail < BTRFS_STRIPE_LEN * dev_stripes)\n\t\t\tcontinue;\n\n\t\tif (ndevs == fs_devices->rw_devices) {\n\t\t\tWARN(1, \"%s: found more than %llu devices\\n\",\n\t\t\t     __func__, fs_devices->rw_devices);\n\t\t\tbreak;\n\t\t}\n\t\tdevices_info[ndevs].dev_offset = dev_offset;\n\t\tdevices_info[ndevs].max_avail = max_avail;\n\t\tdevices_info[ndevs].total_avail = total_avail;\n\t\tdevices_info[ndevs].dev = device;\n\t\t++ndevs;\n\t}\n\n\t/*\n\t * now sort the devices by hole size / available space\n\t */\n\tsort(devices_info, ndevs, sizeof(struct btrfs_device_info),\n\t     btrfs_cmp_device_info, NULL);\n\n\t/* round down to number of usable stripes */\n\tndevs -= ndevs % devs_increment;\n\n\tif (ndevs < devs_increment * sub_stripes || ndevs < devs_min) {\n\t\tret = -ENOSPC;\n\t\tgoto error;\n\t}\n\n\tif (devs_max && ndevs > devs_max)\n\t\tndevs = devs_max;\n\t/*\n\t * the primary goal is to maximize the number of stripes, so use as many\n\t * devices as possible, even if the stripes are not maximum sized.\n\t */\n\tstripe_size = devices_info[ndevs-1].max_avail;\n\tnum_stripes = ndevs * dev_stripes;\n\n\t/*\n\t * this will have to be fixed for RAID1 and RAID10 over\n\t * more drives\n\t */\n\tdata_stripes = num_stripes / ncopies;\n\n\tif (type & BTRFS_BLOCK_GROUP_RAID5) {\n\t\traid_stripe_len = find_raid56_stripe_len(ndevs - 1,\n\t\t\t\t btrfs_super_stripesize(info->super_copy));\n\t\tdata_stripes = num_stripes - 1;\n\t}\n\tif (type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\traid_stripe_len = find_raid56_stripe_len(ndevs - 2,\n\t\t\t\t btrfs_super_stripesize(info->super_copy));\n\t\tdata_stripes = num_stripes - 2;\n\t}\n\n\t/*\n\t * Use the number of data stripes to figure out how big this chunk\n\t * is really going to be in terms of logical address space,\n\t * and compare that answer with the max chunk size\n\t */\n\tif (stripe_size * data_stripes > max_chunk_size) {\n\t\tu64 mask = (1ULL << 24) - 1;\n\t\tstripe_size = max_chunk_size;\n\t\tdo_div(stripe_size, data_stripes);\n\n\t\t/* bump the answer up to a 16MB boundary */\n\t\tstripe_size = (stripe_size + mask) & ~mask;\n\n\t\t/* but don't go higher than the limits we found\n\t\t * while searching for free extents\n\t\t */\n\t\tif (stripe_size > devices_info[ndevs-1].max_avail)\n\t\t\tstripe_size = devices_info[ndevs-1].max_avail;\n\t}\n\n\tdo_div(stripe_size, dev_stripes);\n\n\t/* align to BTRFS_STRIPE_LEN */\n\tdo_div(stripe_size, raid_stripe_len);\n\tstripe_size *= raid_stripe_len;\n\n\tmap = kmalloc(map_lookup_size(num_stripes), GFP_NOFS);\n\tif (!map) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tmap->num_stripes = num_stripes;\n\n\tfor (i = 0; i < ndevs; ++i) {\n\t\tfor (j = 0; j < dev_stripes; ++j) {\n\t\t\tint s = i * dev_stripes + j;\n\t\t\tmap->stripes[s].dev = devices_info[i].dev;\n\t\t\tmap->stripes[s].physical = devices_info[i].dev_offset +\n\t\t\t\t\t\t   j * stripe_size;\n\t\t}\n\t}\n\tmap->sector_size = extent_root->sectorsize;\n\tmap->stripe_len = raid_stripe_len;\n\tmap->io_align = raid_stripe_len;\n\tmap->io_width = raid_stripe_len;\n\tmap->type = type;\n\tmap->sub_stripes = sub_stripes;\n\n\tnum_bytes = stripe_size * data_stripes;\n\n\ttrace_btrfs_chunk_alloc(info->chunk_root, map, start, num_bytes);\n\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tkfree(map);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tset_bit(EXTENT_FLAG_FS_MAPPING, &em->flags);\n\tem->bdev = (struct block_device *)map;\n\tem->start = start;\n\tem->len = num_bytes;\n\tem->block_start = 0;\n\tem->block_len = em->len;\n\tem->orig_block_len = stripe_size;\n\n\tem_tree = &extent_root->fs_info->mapping_tree.map_tree;\n\twrite_lock(&em_tree->lock);\n\tret = add_extent_mapping(em_tree, em, 0);\n\tif (!ret) {\n\t\tlist_add_tail(&em->list, &trans->transaction->pending_chunks);\n\t\tatomic_inc(&em->refs);\n\t}\n\twrite_unlock(&em_tree->lock);\n\tif (ret) {\n\t\tfree_extent_map(em);\n\t\tgoto error;\n\t}\n\n\tret = btrfs_make_block_group(trans, extent_root, 0, type,\n\t\t\t\t     BTRFS_FIRST_CHUNK_TREE_OBJECTID,\n\t\t\t\t     start, num_bytes);\n\tif (ret)\n\t\tgoto error_del_extent;\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tnum_bytes = map->stripes[i].dev->bytes_used + stripe_size;\n\t\tbtrfs_device_set_bytes_used(map->stripes[i].dev, num_bytes);\n\t}\n\n\tspin_lock(&extent_root->fs_info->free_chunk_lock);\n\textent_root->fs_info->free_chunk_space -= (stripe_size *\n\t\t\t\t\t\t   map->num_stripes);\n\tspin_unlock(&extent_root->fs_info->free_chunk_lock);\n\n\tfree_extent_map(em);\n\tcheck_raid56_incompat_flag(extent_root->fs_info, type);\n\n\tkfree(devices_info);\n\treturn 0;\n\nerror_del_extent:\n\twrite_lock(&em_tree->lock);\n\tremove_extent_mapping(em_tree, em);\n\twrite_unlock(&em_tree->lock);\n\n\t/* One for our allocation */\n\tfree_extent_map(em);\n\t/* One for the tree reference */\n\tfree_extent_map(em);\n\t/* One for the pending_chunks list reference */\n\tfree_extent_map(em);\nerror:\n\tkfree(devices_info);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFS_MAX_DEVS_SYS_CHUNK ((BTRFS_SYSTEM_CHUNK_ARRAY_SIZE\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_disk_key)\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_chunk))\t\\\n\t\t\t\t/ sizeof(struct btrfs_stripe) + 1)"
          ],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct",
            "static struct btrfs_raid_attr btrfs_raid_array[BTRFS_NR_RAID_TYPES] = {\n\t[BTRFS_RAID_RAID10] = {\n\t\t.sub_stripes\t= 2,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\t/* 0 == as many as possible */\n\t\t.devs_min\t= 4,\n\t\t.devs_increment\t= 2,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID1] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 2,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 2,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_DUP] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 2,\n\t\t.devs_max\t= 1,\n\t\t.devs_min\t= 1,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID0] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 1,\n\t},\n\t[BTRFS_RAID_SINGLE] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 1,\n\t\t.devs_min\t= 1,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 1,\n\t},\n\t[BTRFS_RAID_RAID5] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID6] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 3,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 3,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\n#define BTRFS_MAX_DEVS_SYS_CHUNK ((BTRFS_SYSTEM_CHUNK_ARRAY_SIZE\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_disk_key)\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_chunk))\t\\\n\t\t\t\t/ sizeof(struct btrfs_stripe) + 1)\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\nstatic struct btrfs_raid_attr btrfs_raid_array[BTRFS_NR_RAID_TYPES] = {\n\t[BTRFS_RAID_RAID10] = {\n\t\t.sub_stripes\t= 2,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\t/* 0 == as many as possible */\n\t\t.devs_min\t= 4,\n\t\t.devs_increment\t= 2,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID1] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 2,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 2,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_DUP] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 2,\n\t\t.devs_max\t= 1,\n\t\t.devs_min\t= 1,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID0] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 1,\n\t},\n\t[BTRFS_RAID_SINGLE] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 1,\n\t\t.devs_min\t= 1,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 1,\n\t},\n\t[BTRFS_RAID_RAID5] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID6] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 3,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 3,\n\t},\n};\n\nstatic int __btrfs_alloc_chunk(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *extent_root, u64 start,\n\t\t\t       u64 type)\n{\n\tstruct btrfs_fs_info *info = extent_root->fs_info;\n\tstruct btrfs_fs_devices *fs_devices = info->fs_devices;\n\tstruct list_head *cur;\n\tstruct map_lookup *map = NULL;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_device_info *devices_info = NULL;\n\tu64 total_avail;\n\tint num_stripes;\t/* total number of stripes to allocate */\n\tint data_stripes;\t/* number of stripes that count for\n\t\t\t\t   block group size */\n\tint sub_stripes;\t/* sub_stripes info for map */\n\tint dev_stripes;\t/* stripes per dev */\n\tint devs_max;\t\t/* max devs to use */\n\tint devs_min;\t\t/* min devs needed */\n\tint devs_increment;\t/* ndevs has to be a multiple of this */\n\tint ncopies;\t\t/* how many copies to data has */\n\tint ret;\n\tu64 max_stripe_size;\n\tu64 max_chunk_size;\n\tu64 stripe_size;\n\tu64 num_bytes;\n\tu64 raid_stripe_len = BTRFS_STRIPE_LEN;\n\tint ndevs;\n\tint i;\n\tint j;\n\tint index;\n\n\tBUG_ON(!alloc_profile_is_valid(type, 0));\n\n\tif (list_empty(&fs_devices->alloc_list))\n\t\treturn -ENOSPC;\n\n\tindex = __get_raid_index(type);\n\n\tsub_stripes = btrfs_raid_array[index].sub_stripes;\n\tdev_stripes = btrfs_raid_array[index].dev_stripes;\n\tdevs_max = btrfs_raid_array[index].devs_max;\n\tdevs_min = btrfs_raid_array[index].devs_min;\n\tdevs_increment = btrfs_raid_array[index].devs_increment;\n\tncopies = btrfs_raid_array[index].ncopies;\n\n\tif (type & BTRFS_BLOCK_GROUP_DATA) {\n\t\tmax_stripe_size = 1024 * 1024 * 1024;\n\t\tmax_chunk_size = 10 * max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS(info->chunk_root);\n\t} else if (type & BTRFS_BLOCK_GROUP_METADATA) {\n\t\t/* for larger filesystems, use larger metadata chunks */\n\t\tif (fs_devices->total_rw_bytes > 50ULL * 1024 * 1024 * 1024)\n\t\t\tmax_stripe_size = 1024 * 1024 * 1024;\n\t\telse\n\t\t\tmax_stripe_size = 256 * 1024 * 1024;\n\t\tmax_chunk_size = max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS(info->chunk_root);\n\t} else if (type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\tmax_stripe_size = 32 * 1024 * 1024;\n\t\tmax_chunk_size = 2 * max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS_SYS_CHUNK;\n\t} else {\n\t\tbtrfs_err(info, \"invalid chunk type 0x%llx requested\",\n\t\t       type);\n\t\tBUG_ON(1);\n\t}\n\n\t/* we don't want a chunk larger than 10% of writeable space */\n\tmax_chunk_size = min(div_factor(fs_devices->total_rw_bytes, 1),\n\t\t\t     max_chunk_size);\n\n\tdevices_info = kzalloc(sizeof(*devices_info) * fs_devices->rw_devices,\n\t\t\t       GFP_NOFS);\n\tif (!devices_info)\n\t\treturn -ENOMEM;\n\n\tcur = fs_devices->alloc_list.next;\n\n\t/*\n\t * in the first pass through the devices list, we gather information\n\t * about the available holes on each device.\n\t */\n\tndevs = 0;\n\twhile (cur != &fs_devices->alloc_list) {\n\t\tstruct btrfs_device *device;\n\t\tu64 max_avail;\n\t\tu64 dev_offset;\n\n\t\tdevice = list_entry(cur, struct btrfs_device, dev_alloc_list);\n\n\t\tcur = cur->next;\n\n\t\tif (!device->writeable) {\n\t\t\tWARN(1, KERN_ERR\n\t\t\t       \"BTRFS: read-only device in alloc_list\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!device->in_fs_metadata ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tif (device->total_bytes > device->bytes_used)\n\t\t\ttotal_avail = device->total_bytes - device->bytes_used;\n\t\telse\n\t\t\ttotal_avail = 0;\n\n\t\t/* If there is no space on this device, skip it. */\n\t\tif (total_avail == 0)\n\t\t\tcontinue;\n\n\t\tret = find_free_dev_extent(trans, device,\n\t\t\t\t\t   max_stripe_size * dev_stripes,\n\t\t\t\t\t   &dev_offset, &max_avail);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto error;\n\n\t\tif (ret == 0)\n\t\t\tmax_avail = max_stripe_size * dev_stripes;\n\n\t\tif (max_avail < BTRFS_STRIPE_LEN * dev_stripes)\n\t\t\tcontinue;\n\n\t\tif (ndevs == fs_devices->rw_devices) {\n\t\t\tWARN(1, \"%s: found more than %llu devices\\n\",\n\t\t\t     __func__, fs_devices->rw_devices);\n\t\t\tbreak;\n\t\t}\n\t\tdevices_info[ndevs].dev_offset = dev_offset;\n\t\tdevices_info[ndevs].max_avail = max_avail;\n\t\tdevices_info[ndevs].total_avail = total_avail;\n\t\tdevices_info[ndevs].dev = device;\n\t\t++ndevs;\n\t}\n\n\t/*\n\t * now sort the devices by hole size / available space\n\t */\n\tsort(devices_info, ndevs, sizeof(struct btrfs_device_info),\n\t     btrfs_cmp_device_info, NULL);\n\n\t/* round down to number of usable stripes */\n\tndevs -= ndevs % devs_increment;\n\n\tif (ndevs < devs_increment * sub_stripes || ndevs < devs_min) {\n\t\tret = -ENOSPC;\n\t\tgoto error;\n\t}\n\n\tif (devs_max && ndevs > devs_max)\n\t\tndevs = devs_max;\n\t/*\n\t * the primary goal is to maximize the number of stripes, so use as many\n\t * devices as possible, even if the stripes are not maximum sized.\n\t */\n\tstripe_size = devices_info[ndevs-1].max_avail;\n\tnum_stripes = ndevs * dev_stripes;\n\n\t/*\n\t * this will have to be fixed for RAID1 and RAID10 over\n\t * more drives\n\t */\n\tdata_stripes = num_stripes / ncopies;\n\n\tif (type & BTRFS_BLOCK_GROUP_RAID5) {\n\t\traid_stripe_len = find_raid56_stripe_len(ndevs - 1,\n\t\t\t\t btrfs_super_stripesize(info->super_copy));\n\t\tdata_stripes = num_stripes - 1;\n\t}\n\tif (type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\traid_stripe_len = find_raid56_stripe_len(ndevs - 2,\n\t\t\t\t btrfs_super_stripesize(info->super_copy));\n\t\tdata_stripes = num_stripes - 2;\n\t}\n\n\t/*\n\t * Use the number of data stripes to figure out how big this chunk\n\t * is really going to be in terms of logical address space,\n\t * and compare that answer with the max chunk size\n\t */\n\tif (stripe_size * data_stripes > max_chunk_size) {\n\t\tu64 mask = (1ULL << 24) - 1;\n\t\tstripe_size = max_chunk_size;\n\t\tdo_div(stripe_size, data_stripes);\n\n\t\t/* bump the answer up to a 16MB boundary */\n\t\tstripe_size = (stripe_size + mask) & ~mask;\n\n\t\t/* but don't go higher than the limits we found\n\t\t * while searching for free extents\n\t\t */\n\t\tif (stripe_size > devices_info[ndevs-1].max_avail)\n\t\t\tstripe_size = devices_info[ndevs-1].max_avail;\n\t}\n\n\tdo_div(stripe_size, dev_stripes);\n\n\t/* align to BTRFS_STRIPE_LEN */\n\tdo_div(stripe_size, raid_stripe_len);\n\tstripe_size *= raid_stripe_len;\n\n\tmap = kmalloc(map_lookup_size(num_stripes), GFP_NOFS);\n\tif (!map) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tmap->num_stripes = num_stripes;\n\n\tfor (i = 0; i < ndevs; ++i) {\n\t\tfor (j = 0; j < dev_stripes; ++j) {\n\t\t\tint s = i * dev_stripes + j;\n\t\t\tmap->stripes[s].dev = devices_info[i].dev;\n\t\t\tmap->stripes[s].physical = devices_info[i].dev_offset +\n\t\t\t\t\t\t   j * stripe_size;\n\t\t}\n\t}\n\tmap->sector_size = extent_root->sectorsize;\n\tmap->stripe_len = raid_stripe_len;\n\tmap->io_align = raid_stripe_len;\n\tmap->io_width = raid_stripe_len;\n\tmap->type = type;\n\tmap->sub_stripes = sub_stripes;\n\n\tnum_bytes = stripe_size * data_stripes;\n\n\ttrace_btrfs_chunk_alloc(info->chunk_root, map, start, num_bytes);\n\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tkfree(map);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tset_bit(EXTENT_FLAG_FS_MAPPING, &em->flags);\n\tem->bdev = (struct block_device *)map;\n\tem->start = start;\n\tem->len = num_bytes;\n\tem->block_start = 0;\n\tem->block_len = em->len;\n\tem->orig_block_len = stripe_size;\n\n\tem_tree = &extent_root->fs_info->mapping_tree.map_tree;\n\twrite_lock(&em_tree->lock);\n\tret = add_extent_mapping(em_tree, em, 0);\n\tif (!ret) {\n\t\tlist_add_tail(&em->list, &trans->transaction->pending_chunks);\n\t\tatomic_inc(&em->refs);\n\t}\n\twrite_unlock(&em_tree->lock);\n\tif (ret) {\n\t\tfree_extent_map(em);\n\t\tgoto error;\n\t}\n\n\tret = btrfs_make_block_group(trans, extent_root, 0, type,\n\t\t\t\t     BTRFS_FIRST_CHUNK_TREE_OBJECTID,\n\t\t\t\t     start, num_bytes);\n\tif (ret)\n\t\tgoto error_del_extent;\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tnum_bytes = map->stripes[i].dev->bytes_used + stripe_size;\n\t\tbtrfs_device_set_bytes_used(map->stripes[i].dev, num_bytes);\n\t}\n\n\tspin_lock(&extent_root->fs_info->free_chunk_lock);\n\textent_root->fs_info->free_chunk_space -= (stripe_size *\n\t\t\t\t\t\t   map->num_stripes);\n\tspin_unlock(&extent_root->fs_info->free_chunk_lock);\n\n\tfree_extent_map(em);\n\tcheck_raid56_incompat_flag(extent_root->fs_info, type);\n\n\tkfree(devices_info);\n\treturn 0;\n\nerror_del_extent:\n\twrite_lock(&em_tree->lock);\n\tremove_extent_mapping(em_tree, em);\n\twrite_unlock(&em_tree->lock);\n\n\t/* One for our allocation */\n\tfree_extent_map(em);\n\t/* One for the tree reference */\n\tfree_extent_map(em);\n\t/* One for the pending_chunks list reference */\n\tfree_extent_map(em);\nerror:\n\tkfree(devices_info);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_chunk",
          "args": [
            "extent_root->fs_info"
          ],
          "line": 4629
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1364-1381",
          "snippet": "static u64 find_next_chunk(struct btrfs_fs_info *fs_info)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct rb_node *n;\n\tu64 ret = 0;\n\n\tem_tree = &fs_info->mapping_tree.map_tree;\n\tread_lock(&em_tree->lock);\n\tn = rb_last(&em_tree->map);\n\tif (n) {\n\t\tem = rb_entry(n, struct extent_map, rb_node);\n\t\tret = em->start + em->len;\n\t}\n\tread_unlock(&em_tree->lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic u64 find_next_chunk(struct btrfs_fs_info *fs_info)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct rb_node *n;\n\tu64 ret = 0;\n\n\tem_tree = &fs_info->mapping_tree.map_tree;\n\tread_lock(&em_tree->lock);\n\tn = rb_last(&em_tree->map);\n\tif (n) {\n\t\tem = rb_entry(n, struct extent_map, rb_node);\n\t\tret = em->start + em->len;\n\t}\n\tread_unlock(&em_tree->lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_alloc_chunk(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *extent_root, u64 type)\n{\n\tu64 chunk_offset;\n\n\tchunk_offset = find_next_chunk(extent_root->fs_info);\n\treturn __btrfs_alloc_chunk(trans, extent_root, chunk_offset, type);\n}"
  },
  {
    "function_name": "btrfs_finish_chunk_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4513-4615",
    "snippet": "int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *extent_root,\n\t\t\t\tu64 chunk_offset, u64 chunk_size)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *chunk_root = extent_root->fs_info->chunk_root;\n\tstruct btrfs_device *device;\n\tstruct btrfs_chunk *chunk;\n\tstruct btrfs_stripe *stripe;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tsize_t item_size;\n\tu64 dev_offset;\n\tu64 stripe_size;\n\tint i = 0;\n\tint ret;\n\n\tem_tree = &extent_root->fs_info->mapping_tree.map_tree;\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, chunk_offset, chunk_size);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_crit(extent_root->fs_info, \"unable to find logical \"\n\t\t\t   \"%Lu len %Lu\", chunk_offset, chunk_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (em->start != chunk_offset || em->len != chunk_size) {\n\t\tbtrfs_crit(extent_root->fs_info, \"found a bad mapping, wanted\"\n\t\t\t  \" %Lu-%Lu, found %Lu-%Lu\", chunk_offset,\n\t\t\t  chunk_size, em->start, em->len);\n\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\titem_size = btrfs_chunk_item_size(map->num_stripes);\n\tstripe_size = em->orig_block_len;\n\n\tchunk = kzalloc(item_size, GFP_NOFS);\n\tif (!chunk) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tdevice = map->stripes[i].dev;\n\t\tdev_offset = map->stripes[i].physical;\n\n\t\tret = btrfs_update_device(trans, device);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = btrfs_alloc_dev_extent(trans, device,\n\t\t\t\t\t     chunk_root->root_key.objectid,\n\t\t\t\t\t     BTRFS_FIRST_CHUNK_TREE_OBJECTID,\n\t\t\t\t\t     chunk_offset, dev_offset,\n\t\t\t\t\t     stripe_size);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tstripe = &chunk->stripe;\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tdevice = map->stripes[i].dev;\n\t\tdev_offset = map->stripes[i].physical;\n\n\t\tbtrfs_set_stack_stripe_devid(stripe, device->devid);\n\t\tbtrfs_set_stack_stripe_offset(stripe, dev_offset);\n\t\tmemcpy(stripe->dev_uuid, device->uuid, BTRFS_UUID_SIZE);\n\t\tstripe++;\n\t}\n\n\tbtrfs_set_stack_chunk_length(chunk, chunk_size);\n\tbtrfs_set_stack_chunk_owner(chunk, extent_root->root_key.objectid);\n\tbtrfs_set_stack_chunk_stripe_len(chunk, map->stripe_len);\n\tbtrfs_set_stack_chunk_type(chunk, map->type);\n\tbtrfs_set_stack_chunk_num_stripes(chunk, map->num_stripes);\n\tbtrfs_set_stack_chunk_io_align(chunk, map->stripe_len);\n\tbtrfs_set_stack_chunk_io_width(chunk, map->stripe_len);\n\tbtrfs_set_stack_chunk_sector_size(chunk, extent_root->sectorsize);\n\tbtrfs_set_stack_chunk_sub_stripes(chunk, map->sub_stripes);\n\n\tkey.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\tkey.offset = chunk_offset;\n\n\tret = btrfs_insert_item(trans, chunk_root, &key, chunk, item_size);\n\tif (ret == 0 && map->type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\t/*\n\t\t * TODO: Cleanup of inserted chunk root in case of\n\t\t * failure.\n\t\t */\n\t\tret = btrfs_add_system_chunk(chunk_root, &key, chunk,\n\t\t\t\t\t     item_size);\n\t}\n\nout:\n\tkfree(chunk);\n\tfree_extent_map(em);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 4613
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "chunk"
          ],
          "line": 4612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_add_system_chunk",
          "args": [
            "chunk_root",
            "&key",
            "chunk",
            "item_size"
          ],
          "line": 4607
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_system_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4086-4113",
          "snippet": "static int btrfs_add_system_chunk(struct btrfs_root *root,\n\t\t\t   struct btrfs_key *key,\n\t\t\t   struct btrfs_chunk *chunk, int item_size)\n{\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tstruct btrfs_disk_key disk_key;\n\tu32 array_size;\n\tu8 *ptr;\n\n\tlock_chunks(root);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\tif (array_size + item_size + sizeof(disk_key)\n\t\t\t> BTRFS_SYSTEM_CHUNK_ARRAY_SIZE) {\n\t\tunlock_chunks(root);\n\t\treturn -EFBIG;\n\t}\n\n\tptr = super_copy->sys_chunk_array + array_size;\n\tbtrfs_cpu_key_to_disk(&disk_key, key);\n\tmemcpy(ptr, &disk_key, sizeof(disk_key));\n\tptr += sizeof(disk_key);\n\tmemcpy(ptr, chunk, item_size);\n\titem_size += sizeof(disk_key);\n\tbtrfs_set_super_sys_array_size(super_copy, array_size + item_size);\n\tunlock_chunks(root);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_add_system_chunk(struct btrfs_root *root,\n\t\t\t   struct btrfs_key *key,\n\t\t\t   struct btrfs_chunk *chunk, int item_size)\n{\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tstruct btrfs_disk_key disk_key;\n\tu32 array_size;\n\tu8 *ptr;\n\n\tlock_chunks(root);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\tif (array_size + item_size + sizeof(disk_key)\n\t\t\t> BTRFS_SYSTEM_CHUNK_ARRAY_SIZE) {\n\t\tunlock_chunks(root);\n\t\treturn -EFBIG;\n\t}\n\n\tptr = super_copy->sys_chunk_array + array_size;\n\tbtrfs_cpu_key_to_disk(&disk_key, key);\n\tmemcpy(ptr, &disk_key, sizeof(disk_key));\n\tptr += sizeof(disk_key);\n\tmemcpy(ptr, chunk, item_size);\n\titem_size += sizeof(disk_key);\n\tbtrfs_set_super_sys_array_size(super_copy, array_size + item_size);\n\tunlock_chunks(root);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_insert_item",
          "args": [
            "trans",
            "chunk_root",
            "&key",
            "chunk",
            "item_size"
          ],
          "line": 4601
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4829-4850",
          "snippet": "int btrfs_insert_item(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *cpu_key, void *data, u32\n\t\t      data_size)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = btrfs_insert_empty_item(trans, root, path, cpu_key, data_size);\n\tif (!ret) {\n\t\tleaf = path->nodes[0];\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\twrite_extent_buffer(leaf, data, ptr, data_size);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t}\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_insert_item(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *cpu_key, void *data, u32\n\t\t      data_size)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = btrfs_insert_empty_item(trans, root, path, cpu_key, data_size);\n\tif (!ret) {\n\t\tleaf = path->nodes[0];\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\twrite_extent_buffer(leaf, data, ptr, data_size);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t}\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_chunk_sub_stripes",
          "args": [
            "chunk",
            "map->sub_stripes"
          ],
          "line": 4595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_chunk_sector_size",
          "args": [
            "chunk",
            "extent_root->sectorsize"
          ],
          "line": 4594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_chunk_io_width",
          "args": [
            "chunk",
            "map->stripe_len"
          ],
          "line": 4593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_chunk_io_align",
          "args": [
            "chunk",
            "map->stripe_len"
          ],
          "line": 4592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_chunk_num_stripes",
          "args": [
            "chunk",
            "map->num_stripes"
          ],
          "line": 4591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_chunk_type",
          "args": [
            "chunk",
            "map->type"
          ],
          "line": 4590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_chunk_stripe_len",
          "args": [
            "chunk",
            "map->stripe_len"
          ],
          "line": 4589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_chunk_owner",
          "args": [
            "chunk",
            "extent_root->root_key.objectid"
          ],
          "line": 4588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_chunk_length",
          "args": [
            "chunk",
            "chunk_size"
          ],
          "line": 4587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "stripe->dev_uuid",
            "device->uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 4583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_stripe_offset",
          "args": [
            "stripe",
            "dev_offset"
          ],
          "line": 4582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_stripe_devid",
          "args": [
            "stripe",
            "device->devid"
          ],
          "line": 4581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_dev_extent",
          "args": [
            "trans",
            "device",
            "chunk_root->root_key.objectid",
            "BTRFS_FIRST_CHUNK_TREE_OBJECTID",
            "chunk_offset",
            "dev_offset",
            "stripe_size"
          ],
          "line": 4567
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_dev_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1321-1362",
          "snippet": "static int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_device *device,\n\t\t\t\t  u64 chunk_tree, u64 chunk_objectid,\n\t\t\t\t  u64 chunk_offset, u64 start, u64 num_bytes)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *extent;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\tWARN_ON(!device->in_fs_metadata);\n\tWARN_ON(device->is_tgtdev_for_dev_replace);\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = device->devid;\n\tkey.offset = start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(*extent));\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_dev_extent);\n\tbtrfs_set_dev_extent_chunk_tree(leaf, extent, chunk_tree);\n\tbtrfs_set_dev_extent_chunk_objectid(leaf, extent, chunk_objectid);\n\tbtrfs_set_dev_extent_chunk_offset(leaf, extent, chunk_offset);\n\n\twrite_extent_buffer(leaf, root->fs_info->chunk_tree_uuid,\n\t\t    btrfs_dev_extent_chunk_tree_uuid(extent), BTRFS_UUID_SIZE);\n\n\tbtrfs_set_dev_extent_length(leaf, extent, num_bytes);\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_device *device,\n\t\t\t\t  u64 chunk_tree, u64 chunk_objectid,\n\t\t\t\t  u64 chunk_offset, u64 start, u64 num_bytes)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *extent;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\tWARN_ON(!device->in_fs_metadata);\n\tWARN_ON(device->is_tgtdev_for_dev_replace);\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = device->devid;\n\tkey.offset = start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(*extent));\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_dev_extent);\n\tbtrfs_set_dev_extent_chunk_tree(leaf, extent, chunk_tree);\n\tbtrfs_set_dev_extent_chunk_objectid(leaf, extent, chunk_objectid);\n\tbtrfs_set_dev_extent_chunk_offset(leaf, extent, chunk_offset);\n\n\twrite_extent_buffer(leaf, root->fs_info->chunk_tree_uuid,\n\t\t    btrfs_dev_extent_chunk_tree_uuid(extent), BTRFS_UUID_SIZE);\n\n\tbtrfs_set_dev_extent_length(leaf, extent, num_bytes);\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_device",
          "args": [
            "trans",
            "device"
          ],
          "line": 4564
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2403-2449",
          "snippet": "static noinline int btrfs_update_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\troot = device->dev_root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_mark_buffer_dirty(leaf);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline int btrfs_update_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\troot = device->dev_root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_mark_buffer_dirty(leaf);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "item_size",
            "GFP_NOFS"
          ],
          "line": 4554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_item_size",
          "args": [
            "map->num_stripes"
          ],
          "line": 4551
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_chunk_item_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "335-340",
          "snippet": "static inline unsigned long btrfs_chunk_item_size(int num_stripes)\n{\n\tBUG_ON(num_stripes == 0);\n\treturn sizeof(struct btrfs_chunk) +\n\t\tsizeof(struct btrfs_stripe) * (num_stripes - 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_chunk_item_size(int num_stripes)\n{\n\tBUG_ON(num_stripes == 0);\n\treturn sizeof(struct btrfs_chunk) +\n\t\tsizeof(struct btrfs_stripe) * (num_stripes - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "extent_root->fs_info",
            "\"found a bad mapping, wanted\"\n\t\t\t  \" %Lu-%Lu, found %Lu-%Lu\"",
            "chunk_offset",
            "chunk_size",
            "em->start",
            "em->len"
          ],
          "line": 4543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "extent_root->fs_info",
            "\"unable to find logical \"\n\t\t\t   \"%Lu len %Lu\"",
            "chunk_offset",
            "chunk_size"
          ],
          "line": 4537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4534
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "chunk_offset",
            "chunk_size"
          ],
          "line": 4533
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4532
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *extent_root,\n\t\t\t\tu64 chunk_offset, u64 chunk_size)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *chunk_root = extent_root->fs_info->chunk_root;\n\tstruct btrfs_device *device;\n\tstruct btrfs_chunk *chunk;\n\tstruct btrfs_stripe *stripe;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tsize_t item_size;\n\tu64 dev_offset;\n\tu64 stripe_size;\n\tint i = 0;\n\tint ret;\n\n\tem_tree = &extent_root->fs_info->mapping_tree.map_tree;\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, chunk_offset, chunk_size);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_crit(extent_root->fs_info, \"unable to find logical \"\n\t\t\t   \"%Lu len %Lu\", chunk_offset, chunk_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (em->start != chunk_offset || em->len != chunk_size) {\n\t\tbtrfs_crit(extent_root->fs_info, \"found a bad mapping, wanted\"\n\t\t\t  \" %Lu-%Lu, found %Lu-%Lu\", chunk_offset,\n\t\t\t  chunk_size, em->start, em->len);\n\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\titem_size = btrfs_chunk_item_size(map->num_stripes);\n\tstripe_size = em->orig_block_len;\n\n\tchunk = kzalloc(item_size, GFP_NOFS);\n\tif (!chunk) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tdevice = map->stripes[i].dev;\n\t\tdev_offset = map->stripes[i].physical;\n\n\t\tret = btrfs_update_device(trans, device);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = btrfs_alloc_dev_extent(trans, device,\n\t\t\t\t\t     chunk_root->root_key.objectid,\n\t\t\t\t\t     BTRFS_FIRST_CHUNK_TREE_OBJECTID,\n\t\t\t\t\t     chunk_offset, dev_offset,\n\t\t\t\t\t     stripe_size);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tstripe = &chunk->stripe;\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tdevice = map->stripes[i].dev;\n\t\tdev_offset = map->stripes[i].physical;\n\n\t\tbtrfs_set_stack_stripe_devid(stripe, device->devid);\n\t\tbtrfs_set_stack_stripe_offset(stripe, dev_offset);\n\t\tmemcpy(stripe->dev_uuid, device->uuid, BTRFS_UUID_SIZE);\n\t\tstripe++;\n\t}\n\n\tbtrfs_set_stack_chunk_length(chunk, chunk_size);\n\tbtrfs_set_stack_chunk_owner(chunk, extent_root->root_key.objectid);\n\tbtrfs_set_stack_chunk_stripe_len(chunk, map->stripe_len);\n\tbtrfs_set_stack_chunk_type(chunk, map->type);\n\tbtrfs_set_stack_chunk_num_stripes(chunk, map->num_stripes);\n\tbtrfs_set_stack_chunk_io_align(chunk, map->stripe_len);\n\tbtrfs_set_stack_chunk_io_width(chunk, map->stripe_len);\n\tbtrfs_set_stack_chunk_sector_size(chunk, extent_root->sectorsize);\n\tbtrfs_set_stack_chunk_sub_stripes(chunk, map->sub_stripes);\n\n\tkey.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\tkey.offset = chunk_offset;\n\n\tret = btrfs_insert_item(trans, chunk_root, &key, chunk, item_size);\n\tif (ret == 0 && map->type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\t/*\n\t\t * TODO: Cleanup of inserted chunk root in case of\n\t\t * failure.\n\t\t */\n\t\tret = btrfs_add_system_chunk(chunk_root, &key, chunk,\n\t\t\t\t\t     item_size);\n\t}\n\nout:\n\tkfree(chunk);\n\tfree_extent_map(em);\n\treturn ret;\n}"
  },
  {
    "function_name": "__btrfs_alloc_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4217-4511",
    "snippet": "static int __btrfs_alloc_chunk(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *extent_root, u64 start,\n\t\t\t       u64 type)\n{\n\tstruct btrfs_fs_info *info = extent_root->fs_info;\n\tstruct btrfs_fs_devices *fs_devices = info->fs_devices;\n\tstruct list_head *cur;\n\tstruct map_lookup *map = NULL;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_device_info *devices_info = NULL;\n\tu64 total_avail;\n\tint num_stripes;\t/* total number of stripes to allocate */\n\tint data_stripes;\t/* number of stripes that count for\n\t\t\t\t   block group size */\n\tint sub_stripes;\t/* sub_stripes info for map */\n\tint dev_stripes;\t/* stripes per dev */\n\tint devs_max;\t\t/* max devs to use */\n\tint devs_min;\t\t/* min devs needed */\n\tint devs_increment;\t/* ndevs has to be a multiple of this */\n\tint ncopies;\t\t/* how many copies to data has */\n\tint ret;\n\tu64 max_stripe_size;\n\tu64 max_chunk_size;\n\tu64 stripe_size;\n\tu64 num_bytes;\n\tu64 raid_stripe_len = BTRFS_STRIPE_LEN;\n\tint ndevs;\n\tint i;\n\tint j;\n\tint index;\n\n\tBUG_ON(!alloc_profile_is_valid(type, 0));\n\n\tif (list_empty(&fs_devices->alloc_list))\n\t\treturn -ENOSPC;\n\n\tindex = __get_raid_index(type);\n\n\tsub_stripes = btrfs_raid_array[index].sub_stripes;\n\tdev_stripes = btrfs_raid_array[index].dev_stripes;\n\tdevs_max = btrfs_raid_array[index].devs_max;\n\tdevs_min = btrfs_raid_array[index].devs_min;\n\tdevs_increment = btrfs_raid_array[index].devs_increment;\n\tncopies = btrfs_raid_array[index].ncopies;\n\n\tif (type & BTRFS_BLOCK_GROUP_DATA) {\n\t\tmax_stripe_size = 1024 * 1024 * 1024;\n\t\tmax_chunk_size = 10 * max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS(info->chunk_root);\n\t} else if (type & BTRFS_BLOCK_GROUP_METADATA) {\n\t\t/* for larger filesystems, use larger metadata chunks */\n\t\tif (fs_devices->total_rw_bytes > 50ULL * 1024 * 1024 * 1024)\n\t\t\tmax_stripe_size = 1024 * 1024 * 1024;\n\t\telse\n\t\t\tmax_stripe_size = 256 * 1024 * 1024;\n\t\tmax_chunk_size = max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS(info->chunk_root);\n\t} else if (type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\tmax_stripe_size = 32 * 1024 * 1024;\n\t\tmax_chunk_size = 2 * max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS_SYS_CHUNK;\n\t} else {\n\t\tbtrfs_err(info, \"invalid chunk type 0x%llx requested\",\n\t\t       type);\n\t\tBUG_ON(1);\n\t}\n\n\t/* we don't want a chunk larger than 10% of writeable space */\n\tmax_chunk_size = min(div_factor(fs_devices->total_rw_bytes, 1),\n\t\t\t     max_chunk_size);\n\n\tdevices_info = kzalloc(sizeof(*devices_info) * fs_devices->rw_devices,\n\t\t\t       GFP_NOFS);\n\tif (!devices_info)\n\t\treturn -ENOMEM;\n\n\tcur = fs_devices->alloc_list.next;\n\n\t/*\n\t * in the first pass through the devices list, we gather information\n\t * about the available holes on each device.\n\t */\n\tndevs = 0;\n\twhile (cur != &fs_devices->alloc_list) {\n\t\tstruct btrfs_device *device;\n\t\tu64 max_avail;\n\t\tu64 dev_offset;\n\n\t\tdevice = list_entry(cur, struct btrfs_device, dev_alloc_list);\n\n\t\tcur = cur->next;\n\n\t\tif (!device->writeable) {\n\t\t\tWARN(1, KERN_ERR\n\t\t\t       \"BTRFS: read-only device in alloc_list\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!device->in_fs_metadata ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tif (device->total_bytes > device->bytes_used)\n\t\t\ttotal_avail = device->total_bytes - device->bytes_used;\n\t\telse\n\t\t\ttotal_avail = 0;\n\n\t\t/* If there is no space on this device, skip it. */\n\t\tif (total_avail == 0)\n\t\t\tcontinue;\n\n\t\tret = find_free_dev_extent(trans, device,\n\t\t\t\t\t   max_stripe_size * dev_stripes,\n\t\t\t\t\t   &dev_offset, &max_avail);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto error;\n\n\t\tif (ret == 0)\n\t\t\tmax_avail = max_stripe_size * dev_stripes;\n\n\t\tif (max_avail < BTRFS_STRIPE_LEN * dev_stripes)\n\t\t\tcontinue;\n\n\t\tif (ndevs == fs_devices->rw_devices) {\n\t\t\tWARN(1, \"%s: found more than %llu devices\\n\",\n\t\t\t     __func__, fs_devices->rw_devices);\n\t\t\tbreak;\n\t\t}\n\t\tdevices_info[ndevs].dev_offset = dev_offset;\n\t\tdevices_info[ndevs].max_avail = max_avail;\n\t\tdevices_info[ndevs].total_avail = total_avail;\n\t\tdevices_info[ndevs].dev = device;\n\t\t++ndevs;\n\t}\n\n\t/*\n\t * now sort the devices by hole size / available space\n\t */\n\tsort(devices_info, ndevs, sizeof(struct btrfs_device_info),\n\t     btrfs_cmp_device_info, NULL);\n\n\t/* round down to number of usable stripes */\n\tndevs -= ndevs % devs_increment;\n\n\tif (ndevs < devs_increment * sub_stripes || ndevs < devs_min) {\n\t\tret = -ENOSPC;\n\t\tgoto error;\n\t}\n\n\tif (devs_max && ndevs > devs_max)\n\t\tndevs = devs_max;\n\t/*\n\t * the primary goal is to maximize the number of stripes, so use as many\n\t * devices as possible, even if the stripes are not maximum sized.\n\t */\n\tstripe_size = devices_info[ndevs-1].max_avail;\n\tnum_stripes = ndevs * dev_stripes;\n\n\t/*\n\t * this will have to be fixed for RAID1 and RAID10 over\n\t * more drives\n\t */\n\tdata_stripes = num_stripes / ncopies;\n\n\tif (type & BTRFS_BLOCK_GROUP_RAID5) {\n\t\traid_stripe_len = find_raid56_stripe_len(ndevs - 1,\n\t\t\t\t btrfs_super_stripesize(info->super_copy));\n\t\tdata_stripes = num_stripes - 1;\n\t}\n\tif (type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\traid_stripe_len = find_raid56_stripe_len(ndevs - 2,\n\t\t\t\t btrfs_super_stripesize(info->super_copy));\n\t\tdata_stripes = num_stripes - 2;\n\t}\n\n\t/*\n\t * Use the number of data stripes to figure out how big this chunk\n\t * is really going to be in terms of logical address space,\n\t * and compare that answer with the max chunk size\n\t */\n\tif (stripe_size * data_stripes > max_chunk_size) {\n\t\tu64 mask = (1ULL << 24) - 1;\n\t\tstripe_size = max_chunk_size;\n\t\tdo_div(stripe_size, data_stripes);\n\n\t\t/* bump the answer up to a 16MB boundary */\n\t\tstripe_size = (stripe_size + mask) & ~mask;\n\n\t\t/* but don't go higher than the limits we found\n\t\t * while searching for free extents\n\t\t */\n\t\tif (stripe_size > devices_info[ndevs-1].max_avail)\n\t\t\tstripe_size = devices_info[ndevs-1].max_avail;\n\t}\n\n\tdo_div(stripe_size, dev_stripes);\n\n\t/* align to BTRFS_STRIPE_LEN */\n\tdo_div(stripe_size, raid_stripe_len);\n\tstripe_size *= raid_stripe_len;\n\n\tmap = kmalloc(map_lookup_size(num_stripes), GFP_NOFS);\n\tif (!map) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tmap->num_stripes = num_stripes;\n\n\tfor (i = 0; i < ndevs; ++i) {\n\t\tfor (j = 0; j < dev_stripes; ++j) {\n\t\t\tint s = i * dev_stripes + j;\n\t\t\tmap->stripes[s].dev = devices_info[i].dev;\n\t\t\tmap->stripes[s].physical = devices_info[i].dev_offset +\n\t\t\t\t\t\t   j * stripe_size;\n\t\t}\n\t}\n\tmap->sector_size = extent_root->sectorsize;\n\tmap->stripe_len = raid_stripe_len;\n\tmap->io_align = raid_stripe_len;\n\tmap->io_width = raid_stripe_len;\n\tmap->type = type;\n\tmap->sub_stripes = sub_stripes;\n\n\tnum_bytes = stripe_size * data_stripes;\n\n\ttrace_btrfs_chunk_alloc(info->chunk_root, map, start, num_bytes);\n\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tkfree(map);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tset_bit(EXTENT_FLAG_FS_MAPPING, &em->flags);\n\tem->bdev = (struct block_device *)map;\n\tem->start = start;\n\tem->len = num_bytes;\n\tem->block_start = 0;\n\tem->block_len = em->len;\n\tem->orig_block_len = stripe_size;\n\n\tem_tree = &extent_root->fs_info->mapping_tree.map_tree;\n\twrite_lock(&em_tree->lock);\n\tret = add_extent_mapping(em_tree, em, 0);\n\tif (!ret) {\n\t\tlist_add_tail(&em->list, &trans->transaction->pending_chunks);\n\t\tatomic_inc(&em->refs);\n\t}\n\twrite_unlock(&em_tree->lock);\n\tif (ret) {\n\t\tfree_extent_map(em);\n\t\tgoto error;\n\t}\n\n\tret = btrfs_make_block_group(trans, extent_root, 0, type,\n\t\t\t\t     BTRFS_FIRST_CHUNK_TREE_OBJECTID,\n\t\t\t\t     start, num_bytes);\n\tif (ret)\n\t\tgoto error_del_extent;\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tnum_bytes = map->stripes[i].dev->bytes_used + stripe_size;\n\t\tbtrfs_device_set_bytes_used(map->stripes[i].dev, num_bytes);\n\t}\n\n\tspin_lock(&extent_root->fs_info->free_chunk_lock);\n\textent_root->fs_info->free_chunk_space -= (stripe_size *\n\t\t\t\t\t\t   map->num_stripes);\n\tspin_unlock(&extent_root->fs_info->free_chunk_lock);\n\n\tfree_extent_map(em);\n\tcheck_raid56_incompat_flag(extent_root->fs_info, type);\n\n\tkfree(devices_info);\n\treturn 0;\n\nerror_del_extent:\n\twrite_lock(&em_tree->lock);\n\tremove_extent_mapping(em_tree, em);\n\twrite_unlock(&em_tree->lock);\n\n\t/* One for our allocation */\n\tfree_extent_map(em);\n\t/* One for the tree reference */\n\tfree_extent_map(em);\n\t/* One for the pending_chunks list reference */\n\tfree_extent_map(em);\nerror:\n\tkfree(devices_info);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFS_MAX_DEVS_SYS_CHUNK ((BTRFS_SYSTEM_CHUNK_ARRAY_SIZE\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_disk_key)\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_chunk))\t\\\n\t\t\t\t/ sizeof(struct btrfs_stripe) + 1)"
    ],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct",
      "static struct btrfs_raid_attr btrfs_raid_array[BTRFS_NR_RAID_TYPES] = {\n\t[BTRFS_RAID_RAID10] = {\n\t\t.sub_stripes\t= 2,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\t/* 0 == as many as possible */\n\t\t.devs_min\t= 4,\n\t\t.devs_increment\t= 2,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID1] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 2,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 2,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_DUP] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 2,\n\t\t.devs_max\t= 1,\n\t\t.devs_min\t= 1,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID0] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 1,\n\t},\n\t[BTRFS_RAID_SINGLE] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 1,\n\t\t.devs_min\t= 1,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 1,\n\t},\n\t[BTRFS_RAID_RAID5] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID6] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 3,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 3,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "devices_info"
          ],
          "line": 4509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 4507
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4500
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_extent_mapping",
          "args": [
            "em_tree",
            "em"
          ],
          "line": 4499
        },
        "resolved": true,
        "details": {
          "function_name": "remove_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "430-440",
          "snippet": "int remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tint ret = 0;\n\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &em->flags));\n\trb_erase(&em->rb_node, &tree->map);\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &em->flags))\n\t\tlist_del_init(&em->list);\n\tRB_CLEAR_NODE(&em->rb_node);\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tint ret = 0;\n\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &em->flags));\n\trb_erase(&em->rb_node, &tree->map);\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &em->flags))\n\t\tlist_del_init(&em->list);\n\tRB_CLEAR_NODE(&em->rb_node);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4498
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "devices_info"
          ],
          "line": 4494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_raid56_incompat_flag",
          "args": [
            "extent_root->fs_info",
            "type"
          ],
          "line": 4492
        },
        "resolved": true,
        "details": {
          "function_name": "check_raid56_incompat_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4199-4205",
          "snippet": "static void check_raid56_incompat_flag(struct btrfs_fs_info *info, u64 type)\n{\n\tif (!(type & BTRFS_BLOCK_GROUP_RAID56_MASK))\n\t\treturn;\n\n\tbtrfs_set_fs_incompat(info, RAID56);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void check_raid56_incompat_flag(struct btrfs_fs_info *info, u64 type)\n{\n\tif (!(type & BTRFS_BLOCK_GROUP_RAID56_MASK))\n\t\treturn;\n\n\tbtrfs_set_fs_incompat(info, RAID56);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&extent_root->fs_info->free_chunk_lock"
          ],
          "line": 4489
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&extent_root->fs_info->free_chunk_lock"
          ],
          "line": 4486
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_set_bytes_used",
          "args": [
            "map->stripes[i].dev",
            "num_bytes"
          ],
          "line": 4483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_make_block_group",
          "args": [
            "trans",
            "extent_root",
            "0",
            "type",
            "BTRFS_FIRST_CHUNK_TREE_OBJECTID",
            "start",
            "num_bytes"
          ],
          "line": 4475
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_make_block_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9210-9282",
          "snippet": "int btrfs_make_block_group(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, u64 bytes_used,\n\t\t\t   u64 type, u64 chunk_objectid, u64 chunk_offset,\n\t\t\t   u64 size)\n{\n\tint ret;\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_block_group_cache *cache;\n\n\textent_root = root->fs_info->extent_root;\n\n\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\n\tcache = btrfs_create_block_group_cache(root, chunk_offset, size);\n\tif (!cache)\n\t\treturn -ENOMEM;\n\n\tbtrfs_set_block_group_used(&cache->item, bytes_used);\n\tbtrfs_set_block_group_chunk_objectid(&cache->item, chunk_objectid);\n\tbtrfs_set_block_group_flags(&cache->item, type);\n\n\tcache->flags = type;\n\tcache->last_byte_to_unpin = (u64)-1;\n\tcache->cached = BTRFS_CACHE_FINISHED;\n\tret = exclude_super_stripes(root, cache);\n\tif (ret) {\n\t\t/*\n\t\t * We may have excluded something, so call this just in\n\t\t * case.\n\t\t */\n\t\tfree_excluded_extents(root, cache);\n\t\tbtrfs_put_block_group(cache);\n\t\treturn ret;\n\t}\n\n\tadd_new_free_space(cache, root->fs_info, chunk_offset,\n\t\t\t   chunk_offset + size);\n\n\tfree_excluded_extents(root, cache);\n\n\tret = btrfs_add_block_group_cache(root->fs_info, cache);\n\tif (ret) {\n\t\tbtrfs_remove_free_space_cache(cache);\n\t\tbtrfs_put_block_group(cache);\n\t\treturn ret;\n\t}\n\n\tret = update_space_info(root->fs_info, cache->flags, size, bytes_used,\n\t\t\t\t&cache->space_info);\n\tif (ret) {\n\t\tbtrfs_remove_free_space_cache(cache);\n\t\tspin_lock(&root->fs_info->block_group_cache_lock);\n\t\trb_erase(&cache->cache_node,\n\t\t\t &root->fs_info->block_group_cache_tree);\n\t\tRB_CLEAR_NODE(&cache->cache_node);\n\t\tspin_unlock(&root->fs_info->block_group_cache_lock);\n\t\tbtrfs_put_block_group(cache);\n\t\treturn ret;\n\t}\n\tupdate_global_block_rsv(root->fs_info);\n\n\tspin_lock(&cache->space_info->lock);\n\tcache->space_info->bytes_readonly += cache->bytes_super;\n\tspin_unlock(&cache->space_info->lock);\n\n\t__link_block_group(cache->space_info, cache);\n\n\tlist_add_tail(&cache->bg_list, &trans->new_bgs);\n\n\tset_avail_alloc_bits(extent_root->fs_info, type);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_make_block_group(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, u64 bytes_used,\n\t\t\t   u64 type, u64 chunk_objectid, u64 chunk_offset,\n\t\t\t   u64 size)\n{\n\tint ret;\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_block_group_cache *cache;\n\n\textent_root = root->fs_info->extent_root;\n\n\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\n\tcache = btrfs_create_block_group_cache(root, chunk_offset, size);\n\tif (!cache)\n\t\treturn -ENOMEM;\n\n\tbtrfs_set_block_group_used(&cache->item, bytes_used);\n\tbtrfs_set_block_group_chunk_objectid(&cache->item, chunk_objectid);\n\tbtrfs_set_block_group_flags(&cache->item, type);\n\n\tcache->flags = type;\n\tcache->last_byte_to_unpin = (u64)-1;\n\tcache->cached = BTRFS_CACHE_FINISHED;\n\tret = exclude_super_stripes(root, cache);\n\tif (ret) {\n\t\t/*\n\t\t * We may have excluded something, so call this just in\n\t\t * case.\n\t\t */\n\t\tfree_excluded_extents(root, cache);\n\t\tbtrfs_put_block_group(cache);\n\t\treturn ret;\n\t}\n\n\tadd_new_free_space(cache, root->fs_info, chunk_offset,\n\t\t\t   chunk_offset + size);\n\n\tfree_excluded_extents(root, cache);\n\n\tret = btrfs_add_block_group_cache(root->fs_info, cache);\n\tif (ret) {\n\t\tbtrfs_remove_free_space_cache(cache);\n\t\tbtrfs_put_block_group(cache);\n\t\treturn ret;\n\t}\n\n\tret = update_space_info(root->fs_info, cache->flags, size, bytes_used,\n\t\t\t\t&cache->space_info);\n\tif (ret) {\n\t\tbtrfs_remove_free_space_cache(cache);\n\t\tspin_lock(&root->fs_info->block_group_cache_lock);\n\t\trb_erase(&cache->cache_node,\n\t\t\t &root->fs_info->block_group_cache_tree);\n\t\tRB_CLEAR_NODE(&cache->cache_node);\n\t\tspin_unlock(&root->fs_info->block_group_cache_lock);\n\t\tbtrfs_put_block_group(cache);\n\t\treturn ret;\n\t}\n\tupdate_global_block_rsv(root->fs_info);\n\n\tspin_lock(&cache->space_info->lock);\n\tcache->space_info->bytes_readonly += cache->bytes_super;\n\tspin_unlock(&cache->space_info->lock);\n\n\t__link_block_group(cache->space_info, cache);\n\n\tlist_add_tail(&cache->bg_list, &trans->new_bgs);\n\n\tset_avail_alloc_bits(extent_root->fs_info, type);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&em->refs"
          ],
          "line": 4467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&em->list",
            "&trans->transaction->pending_chunks"
          ],
          "line": 4466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_extent_mapping",
          "args": [
            "em_tree",
            "em",
            "0"
          ],
          "line": 4464
        },
        "resolved": true,
        "details": {
          "function_name": "add_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "345-357",
          "snippet": "int add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_FLAG_FS_MAPPING",
            "&em->flags"
          ],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "map"
          ],
          "line": 4450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_extent_map",
          "args": [],
          "line": 4448
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "48-61",
          "snippet": "struct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nstruct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_chunk_alloc",
          "args": [
            "info->chunk_root",
            "map",
            "start",
            "num_bytes"
          ],
          "line": 4446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "map_lookup_size(num_stripes)",
            "GFP_NOFS"
          ],
          "line": 4422
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_lookup_size",
          "args": [
            "num_stripes"
          ],
          "line": 4422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_size",
            "raid_stripe_len"
          ],
          "line": 4419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_size",
            "dev_stripes"
          ],
          "line": 4416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_size",
            "data_stripes"
          ],
          "line": 4404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_raid56_stripe_len",
          "args": [
            "ndevs - 2",
            "btrfs_super_stripesize(info->super_copy)"
          ],
          "line": 4391
        },
        "resolved": true,
        "details": {
          "function_name": "find_raid56_stripe_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4193-4197",
          "snippet": "static u32 find_raid56_stripe_len(u32 data_devices, u32 dev_stripe_target)\n{\n\t/* TODO allow them to set a preferred stripe size */\n\treturn 64 * 1024;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u32 find_raid56_stripe_len(u32 data_devices, u32 dev_stripe_target)\n{\n\t/* TODO allow them to set a preferred stripe size */\n\treturn 64 * 1024;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_stripesize",
          "args": [
            "info->super_copy"
          ],
          "line": 4392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_stripesize",
          "args": [
            "info->super_copy"
          ],
          "line": 4387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "devices_info",
            "ndevs",
            "sizeof(struct btrfs_device_info)",
            "btrfs_cmp_device_info",
            "NULL"
          ],
          "line": 4359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"%s: found more than %llu devices\\n\"",
            "__func__",
            "fs_devices->rw_devices"
          ],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_free_dev_extent",
          "args": [
            "trans",
            "device",
            "max_stripe_size * dev_stripes",
            "&dev_offset",
            "&max_avail"
          ],
          "line": 4332
        },
        "resolved": true,
        "details": {
          "function_name": "find_free_dev_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1111-1261",
          "snippet": "int find_free_dev_extent(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_device *device, u64 num_bytes,\n\t\t\t u64 *start, u64 *len)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_path *path;\n\tu64 hole_size;\n\tu64 max_hole_start;\n\tu64 max_hole_size;\n\tu64 extent_end;\n\tu64 search_start;\n\tu64 search_end = device->total_bytes;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\n\t/* FIXME use last free of some kind */\n\n\t/* we don't want to overwrite the superblock on the drive,\n\t * so we make sure to start at an offset of at least 1MB\n\t */\n\tsearch_start = max(root->fs_info->alloc_start, 1024ull * 1024);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tmax_hole_start = search_start;\n\tmax_hole_size = 0;\n\thole_size = 0;\n\n\tif (search_start >= search_end || device->is_tgtdev_for_dev_replace) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tpath->reada = 2;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tkey.objectid = device->devid;\n\tkey.offset = search_start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = btrfs_previous_item(root, path, key.objectid, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\tif (key.objectid < device->devid)\n\t\t\tgoto next;\n\n\t\tif (key.objectid > device->devid)\n\t\t\tbreak;\n\n\t\tif (key.type != BTRFS_DEV_EXTENT_KEY)\n\t\t\tgoto next;\n\n\t\tif (key.offset > search_start) {\n\t\t\thole_size = key.offset - search_start;\n\n\t\t\t/*\n\t\t\t * Have to check before we set max_hole_start, otherwise\n\t\t\t * we could end up sending back this offset anyway.\n\t\t\t */\n\t\t\tif (contains_pending_extent(trans, device,\n\t\t\t\t\t\t    &search_start,\n\t\t\t\t\t\t    hole_size))\n\t\t\t\thole_size = 0;\n\n\t\t\tif (hole_size > max_hole_size) {\n\t\t\t\tmax_hole_start = search_start;\n\t\t\t\tmax_hole_size = hole_size;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this free space is greater than which we need,\n\t\t\t * it must be the max free space that we have found\n\t\t\t * until now, so max_hole_start must point to the start\n\t\t\t * of this free space and the length of this free space\n\t\t\t * is stored in max_hole_size. Thus, we return\n\t\t\t * max_hole_start and max_hole_size and go back to the\n\t\t\t * caller.\n\t\t\t */\n\t\t\tif (hole_size >= num_bytes) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\textent_end = key.offset + btrfs_dev_extent_length(l,\n\t\t\t\t\t\t\t\t  dev_extent);\n\t\tif (extent_end > search_start)\n\t\t\tsearch_start = extent_end;\nnext:\n\t\tpath->slots[0]++;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * At this point, search_start should be the end of\n\t * allocated dev extents, and when shrinking the device,\n\t * search_end may be smaller than search_start.\n\t */\n\tif (search_end > search_start)\n\t\thole_size = search_end - search_start;\n\n\tif (hole_size > max_hole_size) {\n\t\tmax_hole_start = search_start;\n\t\tmax_hole_size = hole_size;\n\t}\n\n\tif (contains_pending_extent(trans, device, &search_start, hole_size)) {\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t}\n\n\t/* See above. */\n\tif (hole_size < num_bytes)\n\t\tret = -ENOSPC;\n\telse\n\t\tret = 0;\n\nout:\n\tbtrfs_free_path(path);\n\t*start = max_hole_start;\n\tif (len)\n\t\t*len = max_hole_size;\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint find_free_dev_extent(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_device *device, u64 num_bytes,\n\t\t\t u64 *start, u64 *len)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_path *path;\n\tu64 hole_size;\n\tu64 max_hole_start;\n\tu64 max_hole_size;\n\tu64 extent_end;\n\tu64 search_start;\n\tu64 search_end = device->total_bytes;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\n\t/* FIXME use last free of some kind */\n\n\t/* we don't want to overwrite the superblock on the drive,\n\t * so we make sure to start at an offset of at least 1MB\n\t */\n\tsearch_start = max(root->fs_info->alloc_start, 1024ull * 1024);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tmax_hole_start = search_start;\n\tmax_hole_size = 0;\n\thole_size = 0;\n\n\tif (search_start >= search_end || device->is_tgtdev_for_dev_replace) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tpath->reada = 2;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tkey.objectid = device->devid;\n\tkey.offset = search_start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = btrfs_previous_item(root, path, key.objectid, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\tif (key.objectid < device->devid)\n\t\t\tgoto next;\n\n\t\tif (key.objectid > device->devid)\n\t\t\tbreak;\n\n\t\tif (key.type != BTRFS_DEV_EXTENT_KEY)\n\t\t\tgoto next;\n\n\t\tif (key.offset > search_start) {\n\t\t\thole_size = key.offset - search_start;\n\n\t\t\t/*\n\t\t\t * Have to check before we set max_hole_start, otherwise\n\t\t\t * we could end up sending back this offset anyway.\n\t\t\t */\n\t\t\tif (contains_pending_extent(trans, device,\n\t\t\t\t\t\t    &search_start,\n\t\t\t\t\t\t    hole_size))\n\t\t\t\thole_size = 0;\n\n\t\t\tif (hole_size > max_hole_size) {\n\t\t\t\tmax_hole_start = search_start;\n\t\t\t\tmax_hole_size = hole_size;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this free space is greater than which we need,\n\t\t\t * it must be the max free space that we have found\n\t\t\t * until now, so max_hole_start must point to the start\n\t\t\t * of this free space and the length of this free space\n\t\t\t * is stored in max_hole_size. Thus, we return\n\t\t\t * max_hole_start and max_hole_size and go back to the\n\t\t\t * caller.\n\t\t\t */\n\t\t\tif (hole_size >= num_bytes) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\textent_end = key.offset + btrfs_dev_extent_length(l,\n\t\t\t\t\t\t\t\t  dev_extent);\n\t\tif (extent_end > search_start)\n\t\t\tsearch_start = extent_end;\nnext:\n\t\tpath->slots[0]++;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * At this point, search_start should be the end of\n\t * allocated dev extents, and when shrinking the device,\n\t * search_end may be smaller than search_start.\n\t */\n\tif (search_end > search_start)\n\t\thole_size = search_end - search_start;\n\n\tif (hole_size > max_hole_size) {\n\t\tmax_hole_start = search_start;\n\t\tmax_hole_size = hole_size;\n\t}\n\n\tif (contains_pending_extent(trans, device, &search_start, hole_size)) {\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t}\n\n\t/* See above. */\n\tif (hole_size < num_bytes)\n\t\tret = -ENOSPC;\n\telse\n\t\tret = 0;\n\nout:\n\tbtrfs_free_path(path);\n\t*start = max_hole_start;\n\tif (len)\n\t\t*len = max_hole_size;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_ERR\n\t\t\t       \"BTRFS: read-only device in alloc_list\\n\""
          ],
          "line": 4314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cur",
            "structbtrfs_device",
            "dev_alloc_list"
          ],
          "line": 4309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*devices_info) * fs_devices->rw_devices",
            "GFP_NOFS"
          ],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "div_factor(fs_devices->total_rw_bytes, 1)",
            "max_chunk_size"
          ],
          "line": 4289
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_factor",
          "args": [
            "fs_devices->total_rw_bytes",
            "1"
          ],
          "line": 4289
        },
        "resolved": true,
        "details": {
          "function_name": "div_factor_fine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/math.h",
          "lines": "35-42",
          "snippet": "static inline u64 div_factor_fine(u64 num, int factor)\n{\n\tif (factor == 100)\n\t\treturn num;\n\tnum *= factor;\n\tdo_div(num, 100);\n\treturn num;\n}",
          "includes": [
            "#include <asm/div64.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/div64.h>\n\nstatic inline u64 div_factor_fine(u64 num, int factor)\n{\n\tif (factor == 100)\n\t\treturn num;\n\tnum *= factor;\n\tdo_div(num, 100);\n\treturn num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "info",
            "\"invalid chunk type 0x%llx requested\"",
            "type"
          ],
          "line": 4283
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_MAX_DEVS",
          "args": [
            "info->chunk_root"
          ],
          "line": 4276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_MAX_DEVS",
          "args": [
            "info->chunk_root"
          ],
          "line": 4267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_raid_index",
          "args": [
            "type"
          ],
          "line": 4254
        },
        "resolved": true,
        "details": {
          "function_name": "__get_raid_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "6332-6348",
          "snippet": "int __get_raid_index(u64 flags)\n{\n\tif (flags & BTRFS_BLOCK_GROUP_RAID10)\n\t\treturn BTRFS_RAID_RAID10;\n\telse if (flags & BTRFS_BLOCK_GROUP_RAID1)\n\t\treturn BTRFS_RAID_RAID1;\n\telse if (flags & BTRFS_BLOCK_GROUP_DUP)\n\t\treturn BTRFS_RAID_DUP;\n\telse if (flags & BTRFS_BLOCK_GROUP_RAID0)\n\t\treturn BTRFS_RAID_RAID0;\n\telse if (flags & BTRFS_BLOCK_GROUP_RAID5)\n\t\treturn BTRFS_RAID_RAID5;\n\telse if (flags & BTRFS_BLOCK_GROUP_RAID6)\n\t\treturn BTRFS_RAID_RAID6;\n\n\treturn BTRFS_RAID_SINGLE; /* BTRFS_BLOCK_GROUP_SINGLE */\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nint __get_raid_index(u64 flags)\n{\n\tif (flags & BTRFS_BLOCK_GROUP_RAID10)\n\t\treturn BTRFS_RAID_RAID10;\n\telse if (flags & BTRFS_BLOCK_GROUP_RAID1)\n\t\treturn BTRFS_RAID_RAID1;\n\telse if (flags & BTRFS_BLOCK_GROUP_DUP)\n\t\treturn BTRFS_RAID_DUP;\n\telse if (flags & BTRFS_BLOCK_GROUP_RAID0)\n\t\treturn BTRFS_RAID_RAID0;\n\telse if (flags & BTRFS_BLOCK_GROUP_RAID5)\n\t\treturn BTRFS_RAID_RAID5;\n\telse if (flags & BTRFS_BLOCK_GROUP_RAID6)\n\t\treturn BTRFS_RAID_RAID6;\n\n\treturn BTRFS_RAID_SINGLE; /* BTRFS_BLOCK_GROUP_SINGLE */\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fs_devices->alloc_list"
          ],
          "line": 4251
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!alloc_profile_is_valid(type, 0)"
          ],
          "line": 4249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_profile_is_valid",
          "args": [
            "type",
            "0"
          ],
          "line": 4249
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_profile_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3298-3315",
          "snippet": "static int alloc_profile_is_valid(u64 flags, int extended)\n{\n\tu64 mask = (extended ? BTRFS_EXTENDED_PROFILE_MASK :\n\t\t\t       BTRFS_BLOCK_GROUP_PROFILE_MASK);\n\n\tflags &= ~BTRFS_BLOCK_GROUP_TYPE_MASK;\n\n\t/* 1) check that all other bits are zeroed */\n\tif (flags & ~mask)\n\t\treturn 0;\n\n\t/* 2) see if profile is reduced */\n\tif (flags == 0)\n\t\treturn !extended; /* \"0\" is valid for usual profiles */\n\n\t/* true if exactly one bit set */\n\treturn (flags & (flags - 1)) == 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int alloc_profile_is_valid(u64 flags, int extended)\n{\n\tu64 mask = (extended ? BTRFS_EXTENDED_PROFILE_MASK :\n\t\t\t       BTRFS_BLOCK_GROUP_PROFILE_MASK);\n\n\tflags &= ~BTRFS_BLOCK_GROUP_TYPE_MASK;\n\n\t/* 1) check that all other bits are zeroed */\n\tif (flags & ~mask)\n\t\treturn 0;\n\n\t/* 2) see if profile is reduced */\n\tif (flags == 0)\n\t\treturn !extended; /* \"0\" is valid for usual profiles */\n\n\t/* true if exactly one bit set */\n\treturn (flags & (flags - 1)) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\n#define BTRFS_MAX_DEVS_SYS_CHUNK ((BTRFS_SYSTEM_CHUNK_ARRAY_SIZE\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_disk_key)\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_chunk))\t\\\n\t\t\t\t/ sizeof(struct btrfs_stripe) + 1)\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\nstatic struct btrfs_raid_attr btrfs_raid_array[BTRFS_NR_RAID_TYPES] = {\n\t[BTRFS_RAID_RAID10] = {\n\t\t.sub_stripes\t= 2,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\t/* 0 == as many as possible */\n\t\t.devs_min\t= 4,\n\t\t.devs_increment\t= 2,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID1] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 2,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 2,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_DUP] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 2,\n\t\t.devs_max\t= 1,\n\t\t.devs_min\t= 1,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID0] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 1,\n\t},\n\t[BTRFS_RAID_SINGLE] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 1,\n\t\t.devs_min\t= 1,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 1,\n\t},\n\t[BTRFS_RAID_RAID5] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 2,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 2,\n\t},\n\t[BTRFS_RAID_RAID6] = {\n\t\t.sub_stripes\t= 1,\n\t\t.dev_stripes\t= 1,\n\t\t.devs_max\t= 0,\n\t\t.devs_min\t= 3,\n\t\t.devs_increment\t= 1,\n\t\t.ncopies\t= 3,\n\t},\n};\n\nstatic int __btrfs_alloc_chunk(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *extent_root, u64 start,\n\t\t\t       u64 type)\n{\n\tstruct btrfs_fs_info *info = extent_root->fs_info;\n\tstruct btrfs_fs_devices *fs_devices = info->fs_devices;\n\tstruct list_head *cur;\n\tstruct map_lookup *map = NULL;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_device_info *devices_info = NULL;\n\tu64 total_avail;\n\tint num_stripes;\t/* total number of stripes to allocate */\n\tint data_stripes;\t/* number of stripes that count for\n\t\t\t\t   block group size */\n\tint sub_stripes;\t/* sub_stripes info for map */\n\tint dev_stripes;\t/* stripes per dev */\n\tint devs_max;\t\t/* max devs to use */\n\tint devs_min;\t\t/* min devs needed */\n\tint devs_increment;\t/* ndevs has to be a multiple of this */\n\tint ncopies;\t\t/* how many copies to data has */\n\tint ret;\n\tu64 max_stripe_size;\n\tu64 max_chunk_size;\n\tu64 stripe_size;\n\tu64 num_bytes;\n\tu64 raid_stripe_len = BTRFS_STRIPE_LEN;\n\tint ndevs;\n\tint i;\n\tint j;\n\tint index;\n\n\tBUG_ON(!alloc_profile_is_valid(type, 0));\n\n\tif (list_empty(&fs_devices->alloc_list))\n\t\treturn -ENOSPC;\n\n\tindex = __get_raid_index(type);\n\n\tsub_stripes = btrfs_raid_array[index].sub_stripes;\n\tdev_stripes = btrfs_raid_array[index].dev_stripes;\n\tdevs_max = btrfs_raid_array[index].devs_max;\n\tdevs_min = btrfs_raid_array[index].devs_min;\n\tdevs_increment = btrfs_raid_array[index].devs_increment;\n\tncopies = btrfs_raid_array[index].ncopies;\n\n\tif (type & BTRFS_BLOCK_GROUP_DATA) {\n\t\tmax_stripe_size = 1024 * 1024 * 1024;\n\t\tmax_chunk_size = 10 * max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS(info->chunk_root);\n\t} else if (type & BTRFS_BLOCK_GROUP_METADATA) {\n\t\t/* for larger filesystems, use larger metadata chunks */\n\t\tif (fs_devices->total_rw_bytes > 50ULL * 1024 * 1024 * 1024)\n\t\t\tmax_stripe_size = 1024 * 1024 * 1024;\n\t\telse\n\t\t\tmax_stripe_size = 256 * 1024 * 1024;\n\t\tmax_chunk_size = max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS(info->chunk_root);\n\t} else if (type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\tmax_stripe_size = 32 * 1024 * 1024;\n\t\tmax_chunk_size = 2 * max_stripe_size;\n\t\tif (!devs_max)\n\t\t\tdevs_max = BTRFS_MAX_DEVS_SYS_CHUNK;\n\t} else {\n\t\tbtrfs_err(info, \"invalid chunk type 0x%llx requested\",\n\t\t       type);\n\t\tBUG_ON(1);\n\t}\n\n\t/* we don't want a chunk larger than 10% of writeable space */\n\tmax_chunk_size = min(div_factor(fs_devices->total_rw_bytes, 1),\n\t\t\t     max_chunk_size);\n\n\tdevices_info = kzalloc(sizeof(*devices_info) * fs_devices->rw_devices,\n\t\t\t       GFP_NOFS);\n\tif (!devices_info)\n\t\treturn -ENOMEM;\n\n\tcur = fs_devices->alloc_list.next;\n\n\t/*\n\t * in the first pass through the devices list, we gather information\n\t * about the available holes on each device.\n\t */\n\tndevs = 0;\n\twhile (cur != &fs_devices->alloc_list) {\n\t\tstruct btrfs_device *device;\n\t\tu64 max_avail;\n\t\tu64 dev_offset;\n\n\t\tdevice = list_entry(cur, struct btrfs_device, dev_alloc_list);\n\n\t\tcur = cur->next;\n\n\t\tif (!device->writeable) {\n\t\t\tWARN(1, KERN_ERR\n\t\t\t       \"BTRFS: read-only device in alloc_list\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!device->in_fs_metadata ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tif (device->total_bytes > device->bytes_used)\n\t\t\ttotal_avail = device->total_bytes - device->bytes_used;\n\t\telse\n\t\t\ttotal_avail = 0;\n\n\t\t/* If there is no space on this device, skip it. */\n\t\tif (total_avail == 0)\n\t\t\tcontinue;\n\n\t\tret = find_free_dev_extent(trans, device,\n\t\t\t\t\t   max_stripe_size * dev_stripes,\n\t\t\t\t\t   &dev_offset, &max_avail);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto error;\n\n\t\tif (ret == 0)\n\t\t\tmax_avail = max_stripe_size * dev_stripes;\n\n\t\tif (max_avail < BTRFS_STRIPE_LEN * dev_stripes)\n\t\t\tcontinue;\n\n\t\tif (ndevs == fs_devices->rw_devices) {\n\t\t\tWARN(1, \"%s: found more than %llu devices\\n\",\n\t\t\t     __func__, fs_devices->rw_devices);\n\t\t\tbreak;\n\t\t}\n\t\tdevices_info[ndevs].dev_offset = dev_offset;\n\t\tdevices_info[ndevs].max_avail = max_avail;\n\t\tdevices_info[ndevs].total_avail = total_avail;\n\t\tdevices_info[ndevs].dev = device;\n\t\t++ndevs;\n\t}\n\n\t/*\n\t * now sort the devices by hole size / available space\n\t */\n\tsort(devices_info, ndevs, sizeof(struct btrfs_device_info),\n\t     btrfs_cmp_device_info, NULL);\n\n\t/* round down to number of usable stripes */\n\tndevs -= ndevs % devs_increment;\n\n\tif (ndevs < devs_increment * sub_stripes || ndevs < devs_min) {\n\t\tret = -ENOSPC;\n\t\tgoto error;\n\t}\n\n\tif (devs_max && ndevs > devs_max)\n\t\tndevs = devs_max;\n\t/*\n\t * the primary goal is to maximize the number of stripes, so use as many\n\t * devices as possible, even if the stripes are not maximum sized.\n\t */\n\tstripe_size = devices_info[ndevs-1].max_avail;\n\tnum_stripes = ndevs * dev_stripes;\n\n\t/*\n\t * this will have to be fixed for RAID1 and RAID10 over\n\t * more drives\n\t */\n\tdata_stripes = num_stripes / ncopies;\n\n\tif (type & BTRFS_BLOCK_GROUP_RAID5) {\n\t\traid_stripe_len = find_raid56_stripe_len(ndevs - 1,\n\t\t\t\t btrfs_super_stripesize(info->super_copy));\n\t\tdata_stripes = num_stripes - 1;\n\t}\n\tif (type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\traid_stripe_len = find_raid56_stripe_len(ndevs - 2,\n\t\t\t\t btrfs_super_stripesize(info->super_copy));\n\t\tdata_stripes = num_stripes - 2;\n\t}\n\n\t/*\n\t * Use the number of data stripes to figure out how big this chunk\n\t * is really going to be in terms of logical address space,\n\t * and compare that answer with the max chunk size\n\t */\n\tif (stripe_size * data_stripes > max_chunk_size) {\n\t\tu64 mask = (1ULL << 24) - 1;\n\t\tstripe_size = max_chunk_size;\n\t\tdo_div(stripe_size, data_stripes);\n\n\t\t/* bump the answer up to a 16MB boundary */\n\t\tstripe_size = (stripe_size + mask) & ~mask;\n\n\t\t/* but don't go higher than the limits we found\n\t\t * while searching for free extents\n\t\t */\n\t\tif (stripe_size > devices_info[ndevs-1].max_avail)\n\t\t\tstripe_size = devices_info[ndevs-1].max_avail;\n\t}\n\n\tdo_div(stripe_size, dev_stripes);\n\n\t/* align to BTRFS_STRIPE_LEN */\n\tdo_div(stripe_size, raid_stripe_len);\n\tstripe_size *= raid_stripe_len;\n\n\tmap = kmalloc(map_lookup_size(num_stripes), GFP_NOFS);\n\tif (!map) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tmap->num_stripes = num_stripes;\n\n\tfor (i = 0; i < ndevs; ++i) {\n\t\tfor (j = 0; j < dev_stripes; ++j) {\n\t\t\tint s = i * dev_stripes + j;\n\t\t\tmap->stripes[s].dev = devices_info[i].dev;\n\t\t\tmap->stripes[s].physical = devices_info[i].dev_offset +\n\t\t\t\t\t\t   j * stripe_size;\n\t\t}\n\t}\n\tmap->sector_size = extent_root->sectorsize;\n\tmap->stripe_len = raid_stripe_len;\n\tmap->io_align = raid_stripe_len;\n\tmap->io_width = raid_stripe_len;\n\tmap->type = type;\n\tmap->sub_stripes = sub_stripes;\n\n\tnum_bytes = stripe_size * data_stripes;\n\n\ttrace_btrfs_chunk_alloc(info->chunk_root, map, start, num_bytes);\n\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tkfree(map);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tset_bit(EXTENT_FLAG_FS_MAPPING, &em->flags);\n\tem->bdev = (struct block_device *)map;\n\tem->start = start;\n\tem->len = num_bytes;\n\tem->block_start = 0;\n\tem->block_len = em->len;\n\tem->orig_block_len = stripe_size;\n\n\tem_tree = &extent_root->fs_info->mapping_tree.map_tree;\n\twrite_lock(&em_tree->lock);\n\tret = add_extent_mapping(em_tree, em, 0);\n\tif (!ret) {\n\t\tlist_add_tail(&em->list, &trans->transaction->pending_chunks);\n\t\tatomic_inc(&em->refs);\n\t}\n\twrite_unlock(&em_tree->lock);\n\tif (ret) {\n\t\tfree_extent_map(em);\n\t\tgoto error;\n\t}\n\n\tret = btrfs_make_block_group(trans, extent_root, 0, type,\n\t\t\t\t     BTRFS_FIRST_CHUNK_TREE_OBJECTID,\n\t\t\t\t     start, num_bytes);\n\tif (ret)\n\t\tgoto error_del_extent;\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tnum_bytes = map->stripes[i].dev->bytes_used + stripe_size;\n\t\tbtrfs_device_set_bytes_used(map->stripes[i].dev, num_bytes);\n\t}\n\n\tspin_lock(&extent_root->fs_info->free_chunk_lock);\n\textent_root->fs_info->free_chunk_space -= (stripe_size *\n\t\t\t\t\t\t   map->num_stripes);\n\tspin_unlock(&extent_root->fs_info->free_chunk_lock);\n\n\tfree_extent_map(em);\n\tcheck_raid56_incompat_flag(extent_root->fs_info, type);\n\n\tkfree(devices_info);\n\treturn 0;\n\nerror_del_extent:\n\twrite_lock(&em_tree->lock);\n\tremove_extent_mapping(em_tree, em);\n\twrite_unlock(&em_tree->lock);\n\n\t/* One for our allocation */\n\tfree_extent_map(em);\n\t/* One for the tree reference */\n\tfree_extent_map(em);\n\t/* One for the pending_chunks list reference */\n\tfree_extent_map(em);\nerror:\n\tkfree(devices_info);\n\treturn ret;\n}"
  },
  {
    "function_name": "check_raid56_incompat_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4199-4205",
    "snippet": "static void check_raid56_incompat_flag(struct btrfs_fs_info *info, u64 type)\n{\n\tif (!(type & BTRFS_BLOCK_GROUP_RAID56_MASK))\n\t\treturn;\n\n\tbtrfs_set_fs_incompat(info, RAID56);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_set_fs_incompat",
          "args": [
            "info",
            "RAID56"
          ],
          "line": 4204
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_set_fs_incompat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4040-4059",
          "snippet": "static inline void __btrfs_set_fs_incompat(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tu64 features;\n\n\tdisk_super = fs_info->super_copy;\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tif (!(features & flag)) {\n\t\tspin_lock(&fs_info->super_lock);\n\t\tfeatures = btrfs_super_incompat_flags(disk_super);\n\t\tif (!(features & flag)) {\n\t\t\tfeatures |= flag;\n\t\t\tbtrfs_set_super_incompat_flags(disk_super, features);\n\t\t\tbtrfs_info(fs_info, \"setting %llu feature flag\",\n\t\t\t\t\t flag);\n\t\t}\n\t\tspin_unlock(&fs_info->super_lock);\n\t}\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void __btrfs_set_fs_incompat(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tu64 features;\n\n\tdisk_super = fs_info->super_copy;\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tif (!(features & flag)) {\n\t\tspin_lock(&fs_info->super_lock);\n\t\tfeatures = btrfs_super_incompat_flags(disk_super);\n\t\tif (!(features & flag)) {\n\t\t\tfeatures |= flag;\n\t\t\tbtrfs_set_super_incompat_flags(disk_super, features);\n\t\t\tbtrfs_info(fs_info, \"setting %llu feature flag\",\n\t\t\t\t\t flag);\n\t\t}\n\t\tspin_unlock(&fs_info->super_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void check_raid56_incompat_flag(struct btrfs_fs_info *info, u64 type)\n{\n\tif (!(type & BTRFS_BLOCK_GROUP_RAID56_MASK))\n\t\treturn;\n\n\tbtrfs_set_fs_incompat(info, RAID56);\n}"
  },
  {
    "function_name": "find_raid56_stripe_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4193-4197",
    "snippet": "static u32 find_raid56_stripe_len(u32 data_devices, u32 dev_stripe_target)\n{\n\t/* TODO allow them to set a preferred stripe size */\n\treturn 64 * 1024;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u32 find_raid56_stripe_len(u32 data_devices, u32 dev_stripe_target)\n{\n\t/* TODO allow them to set a preferred stripe size */\n\treturn 64 * 1024;\n}"
  },
  {
    "function_name": "btrfs_cmp_device_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4118-4132",
    "snippet": "static int btrfs_cmp_device_info(const void *a, const void *b)\n{\n\tconst struct btrfs_device_info *di_a = a;\n\tconst struct btrfs_device_info *di_b = b;\n\n\tif (di_a->max_avail > di_b->max_avail)\n\t\treturn -1;\n\tif (di_a->max_avail < di_b->max_avail)\n\t\treturn 1;\n\tif (di_a->total_avail > di_b->total_avail)\n\t\treturn -1;\n\tif (di_a->total_avail < di_b->total_avail)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_cmp_device_info(const void *a, const void *b)\n{\n\tconst struct btrfs_device_info *di_a = a;\n\tconst struct btrfs_device_info *di_b = b;\n\n\tif (di_a->max_avail > di_b->max_avail)\n\t\treturn -1;\n\tif (di_a->max_avail < di_b->max_avail)\n\t\treturn 1;\n\tif (di_a->total_avail > di_b->total_avail)\n\t\treturn -1;\n\tif (di_a->total_avail < di_b->total_avail)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_add_system_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "4086-4113",
    "snippet": "static int btrfs_add_system_chunk(struct btrfs_root *root,\n\t\t\t   struct btrfs_key *key,\n\t\t\t   struct btrfs_chunk *chunk, int item_size)\n{\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tstruct btrfs_disk_key disk_key;\n\tu32 array_size;\n\tu8 *ptr;\n\n\tlock_chunks(root);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\tif (array_size + item_size + sizeof(disk_key)\n\t\t\t> BTRFS_SYSTEM_CHUNK_ARRAY_SIZE) {\n\t\tunlock_chunks(root);\n\t\treturn -EFBIG;\n\t}\n\n\tptr = super_copy->sys_chunk_array + array_size;\n\tbtrfs_cpu_key_to_disk(&disk_key, key);\n\tmemcpy(ptr, &disk_key, sizeof(disk_key));\n\tptr += sizeof(disk_key);\n\tmemcpy(ptr, chunk, item_size);\n\titem_size += sizeof(disk_key);\n\tbtrfs_set_super_sys_array_size(super_copy, array_size + item_size);\n\tunlock_chunks(root);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_chunks",
          "args": [
            "root"
          ],
          "line": 4110
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "536-539",
          "snippet": "static inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_sys_array_size",
          "args": [
            "super_copy",
            "array_size + item_size"
          ],
          "line": 4109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "chunk",
            "item_size"
          ],
          "line": 4107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "&disk_key",
            "sizeof(disk_key)"
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_cpu_key_to_disk",
          "args": [
            "&disk_key",
            "key"
          ],
          "line": 4104
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cpu_key_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2739-2745",
          "snippet": "static inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_sys_array_size",
          "args": [
            "super_copy"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_add_system_chunk(struct btrfs_root *root,\n\t\t\t   struct btrfs_key *key,\n\t\t\t   struct btrfs_chunk *chunk, int item_size)\n{\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tstruct btrfs_disk_key disk_key;\n\tu32 array_size;\n\tu8 *ptr;\n\n\tlock_chunks(root);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\tif (array_size + item_size + sizeof(disk_key)\n\t\t\t> BTRFS_SYSTEM_CHUNK_ARRAY_SIZE) {\n\t\tunlock_chunks(root);\n\t\treturn -EFBIG;\n\t}\n\n\tptr = super_copy->sys_chunk_array + array_size;\n\tbtrfs_cpu_key_to_disk(&disk_key, key);\n\tmemcpy(ptr, &disk_key, sizeof(disk_key));\n\tptr += sizeof(disk_key);\n\tmemcpy(ptr, chunk, item_size);\n\titem_size += sizeof(disk_key);\n\tbtrfs_set_super_sys_array_size(super_copy, array_size + item_size);\n\tunlock_chunks(root);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_shrink_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3953-4084",
    "snippet": "int btrfs_shrink_device(struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_path *path;\n\tu64 length;\n\tu64 chunk_tree;\n\tu64 chunk_objectid;\n\tu64 chunk_offset;\n\tint ret;\n\tint slot;\n\tint failed = 0;\n\tbool retried = false;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tu64 old_total = btrfs_super_total_bytes(super_copy);\n\tu64 old_size = btrfs_device_get_total_bytes(device);\n\tu64 diff = old_size - new_size;\n\n\tif (device->is_tgtdev_for_dev_replace)\n\t\treturn -EINVAL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->reada = 2;\n\n\tlock_chunks(root);\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tif (device->writeable) {\n\t\tdevice->fs_devices->total_rw_bytes -= diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space -= diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t}\n\tunlock_chunks(root);\n\nagain:\n\tkey.objectid = device->devid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tdo {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tret = btrfs_previous_item(root, path, 0, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(l, &key, path->slots[0]);\n\n\t\tif (key.objectid != device->devid) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\tlength = btrfs_dev_extent_length(l, dev_extent);\n\n\t\tif (key.offset + length <= new_size) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tchunk_tree = btrfs_dev_extent_chunk_tree(l, dev_extent);\n\t\tchunk_objectid = btrfs_dev_extent_chunk_objectid(l, dev_extent);\n\t\tchunk_offset = btrfs_dev_extent_chunk_offset(l, dev_extent);\n\t\tbtrfs_release_path(path);\n\n\t\tret = btrfs_relocate_chunk(root, chunk_tree, chunk_objectid,\n\t\t\t\t\t   chunk_offset);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto done;\n\t\tif (ret == -ENOSPC)\n\t\t\tfailed++;\n\t} while (key.offset-- > 0);\n\n\tif (failed && !retried) {\n\t\tfailed = 0;\n\t\tretried = true;\n\t\tgoto again;\n\t} else if (failed && retried) {\n\t\tret = -ENOSPC;\n\t\tlock_chunks(root);\n\n\t\tbtrfs_device_set_total_bytes(device, old_size);\n\t\tif (device->writeable)\n\t\t\tdevice->fs_devices->total_rw_bytes += diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space += diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t\tunlock_chunks(root);\n\t\tgoto done;\n\t}\n\n\t/* Shrinking succeeded, else we would be at \"done\". */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto done;\n\t}\n\n\tlock_chunks(root);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &root->fs_info->fs_devices->resized_devices);\n\n\tWARN_ON(diff > old_total);\n\tbtrfs_set_super_total_bytes(super_copy, old_total - diff);\n\tunlock_chunks(root);\n\n\t/* Now btrfs_update_device() will change the on-disk size. */\n\tret = btrfs_update_device(trans, device);\n\tbtrfs_end_transaction(trans, root);\ndone:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4082
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 4080
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_device",
          "args": [
            "trans",
            "device"
          ],
          "line": 4079
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2403-2449",
          "snippet": "static noinline int btrfs_update_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\troot = device->dev_root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_mark_buffer_dirty(leaf);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline int btrfs_update_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\troot = device->dev_root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_mark_buffer_dirty(leaf);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_chunks",
          "args": [
            "root"
          ],
          "line": 4076
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "536-539",
          "snippet": "static inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_total_bytes",
          "args": [
            "super_copy",
            "old_total - diff"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "diff > old_total"
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&device->resized_list",
            "&root->fs_info->fs_devices->resized_devices"
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&device->resized_list"
          ],
          "line": 4070
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_set_disk_total_bytes",
          "args": [
            "device",
            "new_size"
          ],
          "line": 4069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 4064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 4062
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->free_chunk_lock"
          ],
          "line": 4056
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->free_chunk_lock"
          ],
          "line": 4054
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_set_total_bytes",
          "args": [
            "device",
            "old_size"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_relocate_chunk",
          "args": [
            "root",
            "chunk_tree",
            "chunk_objectid",
            "chunk_offset"
          ],
          "line": 4035
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_relocate_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2666-2700",
          "snippet": "static int btrfs_relocate_chunk(struct btrfs_root *root,\n\t\t\t u64 chunk_tree, u64 chunk_objectid,\n\t\t\t u64 chunk_offset)\n{\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\troot = root->fs_info->chunk_root;\n\textent_root = root->fs_info->extent_root;\n\n\tret = btrfs_can_relocate(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn -ENOSPC;\n\n\t/* step one, relocate all the extents inside this chunk */\n\tret = btrfs_relocate_block_group(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * step two, delete the device extents and the\n\t * chunk tree entries\n\t */\n\tret = btrfs_remove_chunk(trans, root, chunk_offset);\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_relocate_chunk(struct btrfs_root *root,\n\t\t\t u64 chunk_tree, u64 chunk_objectid,\n\t\t\t u64 chunk_offset)\n{\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\troot = root->fs_info->chunk_root;\n\textent_root = root->fs_info->extent_root;\n\n\tret = btrfs_can_relocate(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn -ENOSPC;\n\n\t/* step one, relocate all the extents inside this chunk */\n\tret = btrfs_relocate_block_group(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * step two, delete the device extents and the\n\t * chunk tree entries\n\t */\n\tret = btrfs_remove_chunk(trans, root, chunk_offset);\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_extent_chunk_offset",
          "args": [
            "l",
            "dev_extent"
          ],
          "line": 4032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_extent_chunk_objectid",
          "args": [
            "l",
            "dev_extent"
          ],
          "line": 4031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_extent_chunk_tree",
          "args": [
            "l",
            "dev_extent"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_extent_length",
          "args": [
            "l",
            "dev_extent"
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "l",
            "slot",
            "structbtrfs_dev_extent"
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "l",
            "&key",
            "path->slots[0]"
          ],
          "line": 4015
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_previous_item",
          "args": [
            "root",
            "path",
            "0",
            "key.type"
          ],
          "line": 4004
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_previous_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5830-5865",
          "snippet": "int btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 4000
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_set_total_bytes",
          "args": [
            "device",
            "new_size"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 3977
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_total_bytes",
          "args": [
            "device"
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_total_bytes",
          "args": [
            "super_copy"
          ],
          "line": 3970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_shrink_device(struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_path *path;\n\tu64 length;\n\tu64 chunk_tree;\n\tu64 chunk_objectid;\n\tu64 chunk_offset;\n\tint ret;\n\tint slot;\n\tint failed = 0;\n\tbool retried = false;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tu64 old_total = btrfs_super_total_bytes(super_copy);\n\tu64 old_size = btrfs_device_get_total_bytes(device);\n\tu64 diff = old_size - new_size;\n\n\tif (device->is_tgtdev_for_dev_replace)\n\t\treturn -EINVAL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->reada = 2;\n\n\tlock_chunks(root);\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tif (device->writeable) {\n\t\tdevice->fs_devices->total_rw_bytes -= diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space -= diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t}\n\tunlock_chunks(root);\n\nagain:\n\tkey.objectid = device->devid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tdo {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tret = btrfs_previous_item(root, path, 0, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(l, &key, path->slots[0]);\n\n\t\tif (key.objectid != device->devid) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\tlength = btrfs_dev_extent_length(l, dev_extent);\n\n\t\tif (key.offset + length <= new_size) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tchunk_tree = btrfs_dev_extent_chunk_tree(l, dev_extent);\n\t\tchunk_objectid = btrfs_dev_extent_chunk_objectid(l, dev_extent);\n\t\tchunk_offset = btrfs_dev_extent_chunk_offset(l, dev_extent);\n\t\tbtrfs_release_path(path);\n\n\t\tret = btrfs_relocate_chunk(root, chunk_tree, chunk_objectid,\n\t\t\t\t\t   chunk_offset);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto done;\n\t\tif (ret == -ENOSPC)\n\t\t\tfailed++;\n\t} while (key.offset-- > 0);\n\n\tif (failed && !retried) {\n\t\tfailed = 0;\n\t\tretried = true;\n\t\tgoto again;\n\t} else if (failed && retried) {\n\t\tret = -ENOSPC;\n\t\tlock_chunks(root);\n\n\t\tbtrfs_device_set_total_bytes(device, old_size);\n\t\tif (device->writeable)\n\t\t\tdevice->fs_devices->total_rw_bytes += diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space += diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t\tunlock_chunks(root);\n\t\tgoto done;\n\t}\n\n\t/* Shrinking succeeded, else we would be at \"done\". */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto done;\n\t}\n\n\tlock_chunks(root);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &root->fs_info->fs_devices->resized_devices);\n\n\tWARN_ON(diff > old_total);\n\tbtrfs_set_super_total_bytes(super_copy, old_total - diff);\n\tunlock_chunks(root);\n\n\t/* Now btrfs_update_device() will change the on-disk size. */\n\tret = btrfs_update_device(trans, device);\n\tbtrfs_end_transaction(trans, root);\ndone:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_check_uuid_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3932-3946",
    "snippet": "int btrfs_check_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *task;\n\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_rescan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\t/* fs_info->update_uuid_tree_gen remains 0 in all error case */\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_rescan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "task"
          ],
          "line": 3942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up",
          "args": [
            "&fs_info->uuid_tree_rescan_sem"
          ],
          "line": 3941
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_commit_device_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6692-6709",
          "snippet": "void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *curr, *next;\n\n\tif (list_empty(&fs_devices->resized_devices))\n\t\treturn;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlock_chunks(fs_info->dev_root);\n\tlist_for_each_entry_safe(curr, next, &fs_devices->resized_devices,\n\t\t\t\t resized_list) {\n\t\tlist_del_init(&curr->resized_list);\n\t\tcurr->commit_total_bytes = curr->disk_total_bytes;\n\t}\n\tunlock_chunks(fs_info->dev_root);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *curr, *next;\n\n\tif (list_empty(&fs_devices->resized_devices))\n\t\treturn;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlock_chunks(fs_info->dev_root);\n\tlist_for_each_entry_safe(curr, next, &fs_devices->resized_devices,\n\t\t\t\t resized_list) {\n\t\tlist_del_init(&curr->resized_list);\n\t\tcurr->commit_total_bytes = curr->disk_total_bytes;\n\t}\n\tunlock_chunks(fs_info->dev_root);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"failed to start uuid_rescan task\""
          ],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "task"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "btrfs_uuid_rescan_kthread",
            "fs_info",
            "\"btrfs-uuid\""
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down",
          "args": [
            "&fs_info->uuid_tree_rescan_sem"
          ],
          "line": 3936
        },
        "resolved": true,
        "details": {
          "function_name": "follow_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1233-1275",
          "snippet": "int follow_down(struct path *path)\n{\n\tunsigned managed;\n\tint ret;\n\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       unlikely(managed & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held.\n\t\t *\n\t\t * We indicate to the filesystem if someone is trying to mount\n\t\t * something here.  This gives autofs the chance to deny anyone\n\t\t * other than its daemon the right to mount on its\n\t\t * superstructure.\n\t\t *\n\t\t * The filesystem may sleep at this point.\n\t\t */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(\n\t\t\t\tpath->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret == -EISDIR ? 0 : ret;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (!mounted)\n\t\t\t\tbreak;\n\t\t\tdput(path->dentry);\n\t\t\tmntput(path->mnt);\n\t\t\tpath->mnt = mounted;\n\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Don't handle automount points here */\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint follow_down(struct path *path)\n{\n\tunsigned managed;\n\tint ret;\n\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       unlikely(managed & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held.\n\t\t *\n\t\t * We indicate to the filesystem if someone is trying to mount\n\t\t * something here.  This gives autofs the chance to deny anyone\n\t\t * other than its daemon the right to mount on its\n\t\t * superstructure.\n\t\t *\n\t\t * The filesystem may sleep at this point.\n\t\t */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(\n\t\t\t\tpath->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret == -EISDIR ? 0 : ret;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (!mounted)\n\t\t\t\tbreak;\n\t\t\tdput(path->dentry);\n\t\t\tmntput(path->mnt);\n\t\t\tpath->mnt = mounted;\n\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Don't handle automount points here */\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_check_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *task;\n\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_rescan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\t/* fs_info->update_uuid_tree_gen remains 0 in all error case */\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_rescan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_create_uuid_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3890-3930",
    "snippet": "int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct task_struct *task;\n\tint ret;\n\n\t/*\n\t * 1 - root node\n\t * 1 - root item\n\t */\n\ttrans = btrfs_start_transaction(tree_root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tuuid_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t      BTRFS_UUID_TREE_OBJECTID);\n\tif (IS_ERR(uuid_root)) {\n\t\tbtrfs_abort_transaction(trans, tree_root,\n\t\t\t\t\tPTR_ERR(uuid_root));\n\t\treturn PTR_ERR(uuid_root);\n\t}\n\n\tfs_info->uuid_root = uuid_root;\n\n\tret = btrfs_commit_transaction(trans, tree_root);\n\tif (ret)\n\t\treturn ret;\n\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_scan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\t/* fs_info->update_uuid_tree_gen remains 0 in all error case */\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_scan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "task"
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up",
          "args": [
            "&fs_info->uuid_tree_rescan_sem"
          ],
          "line": 3925
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_commit_device_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6692-6709",
          "snippet": "void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *curr, *next;\n\n\tif (list_empty(&fs_devices->resized_devices))\n\t\treturn;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlock_chunks(fs_info->dev_root);\n\tlist_for_each_entry_safe(curr, next, &fs_devices->resized_devices,\n\t\t\t\t resized_list) {\n\t\tlist_del_init(&curr->resized_list);\n\t\tcurr->commit_total_bytes = curr->disk_total_bytes;\n\t}\n\tunlock_chunks(fs_info->dev_root);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *curr, *next;\n\n\tif (list_empty(&fs_devices->resized_devices))\n\t\treturn;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlock_chunks(fs_info->dev_root);\n\tlist_for_each_entry_safe(curr, next, &fs_devices->resized_devices,\n\t\t\t\t resized_list) {\n\t\tlist_del_init(&curr->resized_list);\n\t\tcurr->commit_total_bytes = curr->disk_total_bytes;\n\t}\n\tunlock_chunks(fs_info->dev_root);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"failed to start uuid_scan task\""
          ],
          "line": 3924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "task"
          ],
          "line": 3922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "btrfs_uuid_scan_kthread",
            "fs_info",
            "\"btrfs-uuid\""
          ],
          "line": 3921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down",
          "args": [
            "&fs_info->uuid_tree_rescan_sem"
          ],
          "line": 3920
        },
        "resolved": true,
        "details": {
          "function_name": "follow_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1233-1275",
          "snippet": "int follow_down(struct path *path)\n{\n\tunsigned managed;\n\tint ret;\n\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       unlikely(managed & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held.\n\t\t *\n\t\t * We indicate to the filesystem if someone is trying to mount\n\t\t * something here.  This gives autofs the chance to deny anyone\n\t\t * other than its daemon the right to mount on its\n\t\t * superstructure.\n\t\t *\n\t\t * The filesystem may sleep at this point.\n\t\t */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(\n\t\t\t\tpath->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret == -EISDIR ? 0 : ret;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (!mounted)\n\t\t\t\tbreak;\n\t\t\tdput(path->dentry);\n\t\t\tmntput(path->mnt);\n\t\t\tpath->mnt = mounted;\n\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Don't handle automount points here */\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint follow_down(struct path *path)\n{\n\tunsigned managed;\n\tint ret;\n\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       unlikely(managed & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held.\n\t\t *\n\t\t * We indicate to the filesystem if someone is trying to mount\n\t\t * something here.  This gives autofs the chance to deny anyone\n\t\t * other than its daemon the right to mount on its\n\t\t * superstructure.\n\t\t *\n\t\t * The filesystem may sleep at this point.\n\t\t */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(\n\t\t\t\tpath->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret == -EISDIR ? 0 : ret;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (!mounted)\n\t\t\t\tbreak;\n\t\t\tdput(path->dentry);\n\t\t\tmntput(path->mnt);\n\t\t\tpath->mnt = mounted;\n\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Don't handle automount points here */\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "tree_root"
          ],
          "line": 3916
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "uuid_root"
          ],
          "line": 3911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "tree_root",
            "PTR_ERR(uuid_root)"
          ],
          "line": 3909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "uuid_root"
          ],
          "line": 3910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "uuid_root"
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_create_tree",
          "args": [
            "trans",
            "fs_info",
            "BTRFS_UUID_TREE_OBJECTID"
          ],
          "line": 3906
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_create_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1313-1391",
          "snippet": "struct btrfs_root *btrfs_create_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t     u64 objectid)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tuuid_le uuid;\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\ttree_root->stripesize, root, fs_info, objectid);\n\troot->root_key.objectid = objectid;\n\troot->root_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot->root_key.offset = 0;\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, objectid, NULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tret = PTR_ERR(leaf);\n\t\tleaf = NULL;\n\t\tgoto fail;\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, objectid);\n\troot->node = leaf;\n\n\twrite_extent_buffer(leaf, fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\twrite_extent_buffer(leaf, fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(leaf),\n\t\t\t    BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\troot->commit_root = btrfs_root_node(root);\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state);\n\n\troot->root_item.flags = 0;\n\troot->root_item.byte_limit = 0;\n\tbtrfs_set_root_bytenr(&root->root_item, leaf->start);\n\tbtrfs_set_root_generation(&root->root_item, trans->transid);\n\tbtrfs_set_root_level(&root->root_item, 0);\n\tbtrfs_set_root_refs(&root->root_item, 1);\n\tbtrfs_set_root_used(&root->root_item, leaf->len);\n\tbtrfs_set_root_last_snapshot(&root->root_item, 0);\n\tbtrfs_set_root_dirid(&root->root_item, 0);\n\tuuid_le_gen(&uuid);\n\tmemcpy(root->root_item.uuid, uuid.b, BTRFS_UUID_SIZE);\n\troot->root_item.drop_level = 0;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_insert_root(trans, tree_root, &key, &root->root_item);\n\tif (ret)\n\t\tgoto fail;\n\n\tbtrfs_tree_unlock(leaf);\n\n\treturn root;\n\nfail:\n\tif (leaf) {\n\t\tbtrfs_tree_unlock(leaf);\n\t\tfree_extent_buffer(root->commit_root);\n\t\tfree_extent_buffer(leaf);\n\t}\n\tkfree(root);\n\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct btrfs_root *btrfs_create_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t     u64 objectid)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tuuid_le uuid;\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\ttree_root->stripesize, root, fs_info, objectid);\n\troot->root_key.objectid = objectid;\n\troot->root_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot->root_key.offset = 0;\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, objectid, NULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tret = PTR_ERR(leaf);\n\t\tleaf = NULL;\n\t\tgoto fail;\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, objectid);\n\troot->node = leaf;\n\n\twrite_extent_buffer(leaf, fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\twrite_extent_buffer(leaf, fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(leaf),\n\t\t\t    BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\troot->commit_root = btrfs_root_node(root);\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state);\n\n\troot->root_item.flags = 0;\n\troot->root_item.byte_limit = 0;\n\tbtrfs_set_root_bytenr(&root->root_item, leaf->start);\n\tbtrfs_set_root_generation(&root->root_item, trans->transid);\n\tbtrfs_set_root_level(&root->root_item, 0);\n\tbtrfs_set_root_refs(&root->root_item, 1);\n\tbtrfs_set_root_used(&root->root_item, leaf->len);\n\tbtrfs_set_root_last_snapshot(&root->root_item, 0);\n\tbtrfs_set_root_dirid(&root->root_item, 0);\n\tuuid_le_gen(&uuid);\n\tmemcpy(root->root_item.uuid, uuid.b, BTRFS_UUID_SIZE);\n\troot->root_item.drop_level = 0;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_insert_root(trans, tree_root, &key, &root->root_item);\n\tif (ret)\n\t\tgoto fail;\n\n\tbtrfs_tree_unlock(leaf);\n\n\treturn root;\n\nfail:\n\tif (leaf) {\n\t\tbtrfs_tree_unlock(leaf);\n\t\tfree_extent_buffer(root->commit_root);\n\t\tfree_extent_buffer(leaf);\n\t}\n\tkfree(root);\n\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 3904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 3903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "tree_root",
            "2"
          ],
          "line": 3902
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct task_struct *task;\n\tint ret;\n\n\t/*\n\t * 1 - root node\n\t * 1 - root item\n\t */\n\ttrans = btrfs_start_transaction(tree_root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tuuid_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t      BTRFS_UUID_TREE_OBJECTID);\n\tif (IS_ERR(uuid_root)) {\n\t\tbtrfs_abort_transaction(trans, tree_root,\n\t\t\t\t\tPTR_ERR(uuid_root));\n\t\treturn PTR_ERR(uuid_root);\n\t}\n\n\tfs_info->uuid_root = uuid_root;\n\n\tret = btrfs_commit_transaction(trans, tree_root);\n\tif (ret)\n\t\treturn ret;\n\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_scan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\t/* fs_info->update_uuid_tree_gen remains 0 in all error case */\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_scan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_uuid_rescan_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3871-3888",
    "snippet": "static int btrfs_uuid_rescan_kthread(void *data)\n{\n\tstruct btrfs_fs_info *fs_info = (struct btrfs_fs_info *)data;\n\tint ret;\n\n\t/*\n\t * 1st step is to iterate through the existing UUID tree and\n\t * to delete all entries that contain outdated data.\n\t * 2nd step is to add all missing entries to the UUID tree.\n\t */\n\tret = btrfs_uuid_tree_iterate(fs_info, btrfs_check_uuid_tree_entry);\n\tif (ret < 0) {\n\t\tbtrfs_warn(fs_info, \"iterating uuid_tree failed %d\", ret);\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn ret;\n\t}\n\treturn btrfs_uuid_scan_kthread(data);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_uuid_scan_kthread",
          "args": [
            "data"
          ],
          "line": 3887
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_scan_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3692-3824",
          "snippet": "static int btrfs_uuid_scan_kthread(void *data)\n{\n\tstruct btrfs_fs_info *fs_info = data;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_key max_key;\n\tstruct btrfs_path *path = NULL;\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tstruct btrfs_root_item root_item;\n\tu32 item_size;\n\tstruct btrfs_trans_handle *trans = NULL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = 0;\n\n\tmax_key.objectid = (u64)-1;\n\tmax_key.type = BTRFS_ROOT_ITEM_KEY;\n\tmax_key.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &key, path, 0);\n\t\tif (ret) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key.type != BTRFS_ROOT_ITEM_KEY ||\n\t\t    (key.objectid < BTRFS_FIRST_FREE_OBJECTID &&\n\t\t     key.objectid != BTRFS_FS_TREE_OBJECTID) ||\n\t\t    key.objectid > BTRFS_LAST_FREE_OBJECTID)\n\t\t\tgoto skip;\n\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\titem_size = btrfs_item_size_nr(eb, slot);\n\t\tif (item_size < sizeof(root_item))\n\t\t\tgoto skip;\n\n\t\tread_extent_buffer(eb, &root_item,\n\t\t\t\t   btrfs_item_ptr_offset(eb, slot),\n\t\t\t\t   (int)sizeof(root_item));\n\t\tif (btrfs_root_refs(&root_item) == 0)\n\t\t\tgoto skip;\n\n\t\tif (!btrfs_is_empty_uuid(root_item.uuid) ||\n\t\t    !btrfs_is_empty_uuid(root_item.received_uuid)) {\n\t\t\tif (trans)\n\t\t\t\tgoto update_tree;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\t/*\n\t\t\t * 1 - subvol uuid item\n\t\t\t * 1 - received_subvol uuid item\n\t\t\t */\n\t\t\ttrans = btrfs_start_transaction(fs_info->uuid_root, 2);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tgoto skip;\n\t\t}\nupdate_tree:\n\t\tif (!btrfs_is_empty_uuid(root_item.uuid)) {\n\t\t\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root,\n\t\t\t\t\t\t  root_item.uuid,\n\t\t\t\t\t\t  BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t\t\t  key.objectid);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_warn(fs_info, \"uuid_tree_add failed %d\",\n\t\t\t\t\tret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!btrfs_is_empty_uuid(root_item.received_uuid)) {\n\t\t\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root,\n\t\t\t\t\t\t  root_item.received_uuid,\n\t\t\t\t\t\t BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t\t  key.objectid);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_warn(fs_info, \"uuid_tree_add failed %d\",\n\t\t\t\t\tret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nskip:\n\t\tif (trans) {\n\t\t\tret = btrfs_end_transaction(trans, fs_info->uuid_root);\n\t\t\ttrans = NULL;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_release_path(path);\n\t\tif (key.offset < (u64)-1) {\n\t\t\tkey.offset++;\n\t\t} else if (key.type < BTRFS_ROOT_ITEM_KEY) {\n\t\t\tkey.offset = 0;\n\t\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\t} else if (key.objectid < (u64)-1) {\n\t\t\tkey.offset = 0;\n\t\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tkey.objectid++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tcond_resched();\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tif (trans && !IS_ERR(trans))\n\t\tbtrfs_end_transaction(trans, fs_info->uuid_root);\n\tif (ret)\n\t\tbtrfs_warn(fs_info, \"btrfs_uuid_scan_kthread failed %d\", ret);\n\telse\n\t\tfs_info->update_uuid_tree_gen = 1;\n\tup(&fs_info->uuid_tree_rescan_sem);\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_uuid_scan_kthread(void *data)\n{\n\tstruct btrfs_fs_info *fs_info = data;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_key max_key;\n\tstruct btrfs_path *path = NULL;\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tstruct btrfs_root_item root_item;\n\tu32 item_size;\n\tstruct btrfs_trans_handle *trans = NULL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = 0;\n\n\tmax_key.objectid = (u64)-1;\n\tmax_key.type = BTRFS_ROOT_ITEM_KEY;\n\tmax_key.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &key, path, 0);\n\t\tif (ret) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key.type != BTRFS_ROOT_ITEM_KEY ||\n\t\t    (key.objectid < BTRFS_FIRST_FREE_OBJECTID &&\n\t\t     key.objectid != BTRFS_FS_TREE_OBJECTID) ||\n\t\t    key.objectid > BTRFS_LAST_FREE_OBJECTID)\n\t\t\tgoto skip;\n\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\titem_size = btrfs_item_size_nr(eb, slot);\n\t\tif (item_size < sizeof(root_item))\n\t\t\tgoto skip;\n\n\t\tread_extent_buffer(eb, &root_item,\n\t\t\t\t   btrfs_item_ptr_offset(eb, slot),\n\t\t\t\t   (int)sizeof(root_item));\n\t\tif (btrfs_root_refs(&root_item) == 0)\n\t\t\tgoto skip;\n\n\t\tif (!btrfs_is_empty_uuid(root_item.uuid) ||\n\t\t    !btrfs_is_empty_uuid(root_item.received_uuid)) {\n\t\t\tif (trans)\n\t\t\t\tgoto update_tree;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\t/*\n\t\t\t * 1 - subvol uuid item\n\t\t\t * 1 - received_subvol uuid item\n\t\t\t */\n\t\t\ttrans = btrfs_start_transaction(fs_info->uuid_root, 2);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tgoto skip;\n\t\t}\nupdate_tree:\n\t\tif (!btrfs_is_empty_uuid(root_item.uuid)) {\n\t\t\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root,\n\t\t\t\t\t\t  root_item.uuid,\n\t\t\t\t\t\t  BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t\t\t  key.objectid);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_warn(fs_info, \"uuid_tree_add failed %d\",\n\t\t\t\t\tret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!btrfs_is_empty_uuid(root_item.received_uuid)) {\n\t\t\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root,\n\t\t\t\t\t\t  root_item.received_uuid,\n\t\t\t\t\t\t BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t\t  key.objectid);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_warn(fs_info, \"uuid_tree_add failed %d\",\n\t\t\t\t\tret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nskip:\n\t\tif (trans) {\n\t\t\tret = btrfs_end_transaction(trans, fs_info->uuid_root);\n\t\t\ttrans = NULL;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_release_path(path);\n\t\tif (key.offset < (u64)-1) {\n\t\t\tkey.offset++;\n\t\t} else if (key.type < BTRFS_ROOT_ITEM_KEY) {\n\t\t\tkey.offset = 0;\n\t\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\t} else if (key.objectid < (u64)-1) {\n\t\t\tkey.offset = 0;\n\t\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tkey.objectid++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tcond_resched();\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tif (trans && !IS_ERR(trans))\n\t\tbtrfs_end_transaction(trans, fs_info->uuid_root);\n\tif (ret)\n\t\tbtrfs_warn(fs_info, \"btrfs_uuid_scan_kthread failed %d\", ret);\n\telse\n\t\tfs_info->update_uuid_tree_gen = 1;\n\tup(&fs_info->uuid_tree_rescan_sem);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up",
          "args": [
            "&fs_info->uuid_tree_rescan_sem"
          ],
          "line": 3884
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_commit_device_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6692-6709",
          "snippet": "void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *curr, *next;\n\n\tif (list_empty(&fs_devices->resized_devices))\n\t\treturn;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlock_chunks(fs_info->dev_root);\n\tlist_for_each_entry_safe(curr, next, &fs_devices->resized_devices,\n\t\t\t\t resized_list) {\n\t\tlist_del_init(&curr->resized_list);\n\t\tcurr->commit_total_bytes = curr->disk_total_bytes;\n\t}\n\tunlock_chunks(fs_info->dev_root);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *curr, *next;\n\n\tif (list_empty(&fs_devices->resized_devices))\n\t\treturn;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlock_chunks(fs_info->dev_root);\n\tlist_for_each_entry_safe(curr, next, &fs_devices->resized_devices,\n\t\t\t\t resized_list) {\n\t\tlist_del_init(&curr->resized_list);\n\t\tcurr->commit_total_bytes = curr->disk_total_bytes;\n\t}\n\tunlock_chunks(fs_info->dev_root);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"iterating uuid_tree failed %d\"",
            "ret"
          ],
          "line": 3883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_uuid_tree_iterate",
          "args": [
            "fs_info",
            "btrfs_check_uuid_tree_entry"
          ],
          "line": 3881
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_tree_iterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
          "lines": "258-354",
          "snippet": "int btrfs_uuid_tree_iterate(struct btrfs_fs_info *fs_info,\n\t\t\t    int (*check_func)(struct btrfs_fs_info *, u8 *, u8,\n\t\t\t\t\t      u64))\n{\n\tstruct btrfs_root *root = fs_info->uuid_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tint ret = 0;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tu32 item_size;\n\tunsigned long offset;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = 0;\n\tkey.offset = 0;\n\nagain_search_slot:\n\tret = btrfs_search_forward(root, &key, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tcond_resched();\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\tif (key.type != BTRFS_UUID_KEY_SUBVOL &&\n\t\t    key.type != BTRFS_UUID_KEY_RECEIVED_SUBVOL)\n\t\t\tgoto skip;\n\n\t\toffset = btrfs_item_ptr_offset(leaf, slot);\n\t\titem_size = btrfs_item_size_nr(leaf, slot);\n\t\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\t\tbtrfs_warn(fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t\t(unsigned long)item_size);\n\t\t\tgoto skip;\n\t\t}\n\t\twhile (item_size) {\n\t\t\tu8 uuid[BTRFS_UUID_SIZE];\n\t\t\t__le64 subid_le;\n\t\t\tu64 subid_cpu;\n\n\t\t\tput_unaligned_le64(key.objectid, uuid);\n\t\t\tput_unaligned_le64(key.offset, uuid + sizeof(u64));\n\t\t\tread_extent_buffer(leaf, &subid_le, offset,\n\t\t\t\t\t   sizeof(subid_le));\n\t\t\tsubid_cpu = le64_to_cpu(subid_le);\n\t\t\tret = check_func(fs_info, uuid, key.type, subid_cpu);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = btrfs_uuid_iter_rem(root, uuid, key.type,\n\t\t\t\t\t\t\t  subid_cpu);\n\t\t\t\tif (ret == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this might look inefficient, but the\n\t\t\t\t\t * justification is that it is an\n\t\t\t\t\t * exception that check_func returns 1,\n\t\t\t\t\t * and that in the regular case only one\n\t\t\t\t\t * entry per UUID exists.\n\t\t\t\t\t */\n\t\t\t\t\tgoto again_search_slot;\n\t\t\t\t}\n\t\t\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\titem_size -= sizeof(subid_le);\n\t\t\toffset += sizeof(subid_le);\n\t\t}\n\nskip:\n\t\tret = btrfs_next_item(root, path);\n\t\tif (ret == 0)\n\t\t\tcontinue;\n\t\telse if (ret > 0)\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\tbtrfs_warn(fs_info, \"btrfs_uuid_tree_iterate failed %d\", ret);\n\treturn 0;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/uuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nint btrfs_uuid_tree_iterate(struct btrfs_fs_info *fs_info,\n\t\t\t    int (*check_func)(struct btrfs_fs_info *, u8 *, u8,\n\t\t\t\t\t      u64))\n{\n\tstruct btrfs_root *root = fs_info->uuid_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tint ret = 0;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tu32 item_size;\n\tunsigned long offset;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = 0;\n\tkey.offset = 0;\n\nagain_search_slot:\n\tret = btrfs_search_forward(root, &key, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tcond_resched();\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\tif (key.type != BTRFS_UUID_KEY_SUBVOL &&\n\t\t    key.type != BTRFS_UUID_KEY_RECEIVED_SUBVOL)\n\t\t\tgoto skip;\n\n\t\toffset = btrfs_item_ptr_offset(leaf, slot);\n\t\titem_size = btrfs_item_size_nr(leaf, slot);\n\t\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\t\tbtrfs_warn(fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t\t(unsigned long)item_size);\n\t\t\tgoto skip;\n\t\t}\n\t\twhile (item_size) {\n\t\t\tu8 uuid[BTRFS_UUID_SIZE];\n\t\t\t__le64 subid_le;\n\t\t\tu64 subid_cpu;\n\n\t\t\tput_unaligned_le64(key.objectid, uuid);\n\t\t\tput_unaligned_le64(key.offset, uuid + sizeof(u64));\n\t\t\tread_extent_buffer(leaf, &subid_le, offset,\n\t\t\t\t\t   sizeof(subid_le));\n\t\t\tsubid_cpu = le64_to_cpu(subid_le);\n\t\t\tret = check_func(fs_info, uuid, key.type, subid_cpu);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = btrfs_uuid_iter_rem(root, uuid, key.type,\n\t\t\t\t\t\t\t  subid_cpu);\n\t\t\t\tif (ret == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this might look inefficient, but the\n\t\t\t\t\t * justification is that it is an\n\t\t\t\t\t * exception that check_func returns 1,\n\t\t\t\t\t * and that in the regular case only one\n\t\t\t\t\t * entry per UUID exists.\n\t\t\t\t\t */\n\t\t\t\t\tgoto again_search_slot;\n\t\t\t\t}\n\t\t\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\titem_size -= sizeof(subid_le);\n\t\t\toffset += sizeof(subid_le);\n\t\t}\n\nskip:\n\t\tret = btrfs_next_item(root, path);\n\t\tif (ret == 0)\n\t\t\tcontinue;\n\t\telse if (ret > 0)\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\tbtrfs_warn(fs_info, \"btrfs_uuid_tree_iterate failed %d\", ret);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_uuid_rescan_kthread(void *data)\n{\n\tstruct btrfs_fs_info *fs_info = (struct btrfs_fs_info *)data;\n\tint ret;\n\n\t/*\n\t * 1st step is to iterate through the existing UUID tree and\n\t * to delete all entries that contain outdated data.\n\t * 2nd step is to add all missing entries to the UUID tree.\n\t */\n\tret = btrfs_uuid_tree_iterate(fs_info, btrfs_check_uuid_tree_entry);\n\tif (ret < 0) {\n\t\tbtrfs_warn(fs_info, \"iterating uuid_tree failed %d\", ret);\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn ret;\n\t}\n\treturn btrfs_uuid_scan_kthread(data);\n}"
  },
  {
    "function_name": "btrfs_check_uuid_tree_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3833-3869",
    "snippet": "static int btrfs_check_uuid_tree_entry(struct btrfs_fs_info *fs_info,\n\t\t\t\t       u8 *uuid, u8 type, u64 subid)\n{\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tstruct btrfs_root *subvol_root;\n\n\tif (type != BTRFS_UUID_KEY_SUBVOL &&\n\t    type != BTRFS_UUID_KEY_RECEIVED_SUBVOL)\n\t\tgoto out;\n\n\tkey.objectid = subid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\tsubvol_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\tif (IS_ERR(subvol_root)) {\n\t\tret = PTR_ERR(subvol_root);\n\t\tif (ret == -ENOENT)\n\t\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase BTRFS_UUID_KEY_SUBVOL:\n\t\tif (memcmp(uuid, subvol_root->root_item.uuid, BTRFS_UUID_SIZE))\n\t\t\tret = 1;\n\t\tbreak;\n\tcase BTRFS_UUID_KEY_RECEIVED_SUBVOL:\n\t\tif (memcmp(uuid, subvol_root->root_item.received_uuid,\n\t\t\t   BTRFS_UUID_SIZE))\n\t\t\tret = 1;\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "uuid",
            "subvol_root->root_item.received_uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 3861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "uuid",
            "subvol_root->root_item.uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 3857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "subvol_root"
          ],
          "line": 3849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "subvol_root"
          ],
          "line": 3848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "fs_info",
            "&key"
          ],
          "line": 3847
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_check_uuid_tree_entry(struct btrfs_fs_info *fs_info,\n\t\t\t\t       u8 *uuid, u8 type, u64 subid)\n{\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tstruct btrfs_root *subvol_root;\n\n\tif (type != BTRFS_UUID_KEY_SUBVOL &&\n\t    type != BTRFS_UUID_KEY_RECEIVED_SUBVOL)\n\t\tgoto out;\n\n\tkey.objectid = subid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\tsubvol_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\tif (IS_ERR(subvol_root)) {\n\t\tret = PTR_ERR(subvol_root);\n\t\tif (ret == -ENOENT)\n\t\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase BTRFS_UUID_KEY_SUBVOL:\n\t\tif (memcmp(uuid, subvol_root->root_item.uuid, BTRFS_UUID_SIZE))\n\t\t\tret = 1;\n\t\tbreak;\n\tcase BTRFS_UUID_KEY_RECEIVED_SUBVOL:\n\t\tif (memcmp(uuid, subvol_root->root_item.received_uuid,\n\t\t\t   BTRFS_UUID_SIZE))\n\t\t\tret = 1;\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_uuid_scan_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3692-3824",
    "snippet": "static int btrfs_uuid_scan_kthread(void *data)\n{\n\tstruct btrfs_fs_info *fs_info = data;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_key max_key;\n\tstruct btrfs_path *path = NULL;\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tstruct btrfs_root_item root_item;\n\tu32 item_size;\n\tstruct btrfs_trans_handle *trans = NULL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = 0;\n\n\tmax_key.objectid = (u64)-1;\n\tmax_key.type = BTRFS_ROOT_ITEM_KEY;\n\tmax_key.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &key, path, 0);\n\t\tif (ret) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key.type != BTRFS_ROOT_ITEM_KEY ||\n\t\t    (key.objectid < BTRFS_FIRST_FREE_OBJECTID &&\n\t\t     key.objectid != BTRFS_FS_TREE_OBJECTID) ||\n\t\t    key.objectid > BTRFS_LAST_FREE_OBJECTID)\n\t\t\tgoto skip;\n\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\titem_size = btrfs_item_size_nr(eb, slot);\n\t\tif (item_size < sizeof(root_item))\n\t\t\tgoto skip;\n\n\t\tread_extent_buffer(eb, &root_item,\n\t\t\t\t   btrfs_item_ptr_offset(eb, slot),\n\t\t\t\t   (int)sizeof(root_item));\n\t\tif (btrfs_root_refs(&root_item) == 0)\n\t\t\tgoto skip;\n\n\t\tif (!btrfs_is_empty_uuid(root_item.uuid) ||\n\t\t    !btrfs_is_empty_uuid(root_item.received_uuid)) {\n\t\t\tif (trans)\n\t\t\t\tgoto update_tree;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\t/*\n\t\t\t * 1 - subvol uuid item\n\t\t\t * 1 - received_subvol uuid item\n\t\t\t */\n\t\t\ttrans = btrfs_start_transaction(fs_info->uuid_root, 2);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tgoto skip;\n\t\t}\nupdate_tree:\n\t\tif (!btrfs_is_empty_uuid(root_item.uuid)) {\n\t\t\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root,\n\t\t\t\t\t\t  root_item.uuid,\n\t\t\t\t\t\t  BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t\t\t  key.objectid);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_warn(fs_info, \"uuid_tree_add failed %d\",\n\t\t\t\t\tret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!btrfs_is_empty_uuid(root_item.received_uuid)) {\n\t\t\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root,\n\t\t\t\t\t\t  root_item.received_uuid,\n\t\t\t\t\t\t BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t\t  key.objectid);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_warn(fs_info, \"uuid_tree_add failed %d\",\n\t\t\t\t\tret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nskip:\n\t\tif (trans) {\n\t\t\tret = btrfs_end_transaction(trans, fs_info->uuid_root);\n\t\t\ttrans = NULL;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_release_path(path);\n\t\tif (key.offset < (u64)-1) {\n\t\t\tkey.offset++;\n\t\t} else if (key.type < BTRFS_ROOT_ITEM_KEY) {\n\t\t\tkey.offset = 0;\n\t\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\t} else if (key.objectid < (u64)-1) {\n\t\t\tkey.offset = 0;\n\t\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tkey.objectid++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tcond_resched();\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tif (trans && !IS_ERR(trans))\n\t\tbtrfs_end_transaction(trans, fs_info->uuid_root);\n\tif (ret)\n\t\tbtrfs_warn(fs_info, \"btrfs_uuid_scan_kthread failed %d\", ret);\n\telse\n\t\tfs_info->update_uuid_tree_gen = 1;\n\tup(&fs_info->uuid_tree_rescan_sem);\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up",
          "args": [
            "&fs_info->uuid_tree_rescan_sem"
          ],
          "line": 3822
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_commit_device_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6692-6709",
          "snippet": "void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *curr, *next;\n\n\tif (list_empty(&fs_devices->resized_devices))\n\t\treturn;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlock_chunks(fs_info->dev_root);\n\tlist_for_each_entry_safe(curr, next, &fs_devices->resized_devices,\n\t\t\t\t resized_list) {\n\t\tlist_del_init(&curr->resized_list);\n\t\tcurr->commit_total_bytes = curr->disk_total_bytes;\n\t}\n\tunlock_chunks(fs_info->dev_root);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *curr, *next;\n\n\tif (list_empty(&fs_devices->resized_devices))\n\t\treturn;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlock_chunks(fs_info->dev_root);\n\tlist_for_each_entry_safe(curr, next, &fs_devices->resized_devices,\n\t\t\t\t resized_list) {\n\t\tlist_del_init(&curr->resized_list);\n\t\tcurr->commit_total_bytes = curr->disk_total_bytes;\n\t}\n\tunlock_chunks(fs_info->dev_root);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"btrfs_uuid_scan_kthread failed %d\"",
            "ret"
          ],
          "line": 3819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "fs_info->uuid_root"
          ],
          "line": 3817
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 3816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 3815
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3798
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"uuid_tree_add failed %d\"",
            "ret"
          ],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_uuid_tree_add",
          "args": [
            "trans",
            "fs_info->uuid_root",
            "root_item.received_uuid",
            "BTRFS_UUID_KEY_RECEIVED_SUBVOL",
            "key.objectid"
          ],
          "line": 3779
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_tree_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
          "lines": "93-155",
          "snippet": "int btrfs_uuid_tree_add(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid_cpu)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\t__le64 subid_le;\n\n\tret = btrfs_uuid_tree_lookup(uuid_root, uuid, type, subid_cpu);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_insert_empty_item(trans, uuid_root, path, &key,\n\t\t\t\t      sizeof(subid_le));\n\tif (ret >= 0) {\n\t\t/* Add an item for the type for the first time */\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t} else if (ret == -EEXIST) {\n\t\t/*\n\t\t * An item with that type already exists.\n\t\t * Extend the item and store the new subid at the end.\n\t\t */\n\t\tbtrfs_extend_item(uuid_root, path, sizeof(subid_le));\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t\toffset += btrfs_item_size_nr(eb, slot) - sizeof(subid_le);\n\t} else if (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"insert uuid item failed %d \"\n\t\t\t\"(0x%016llx, 0x%016llx) type %u!\",\n\t\t\tret, (unsigned long long)key.objectid,\n\t\t\t(unsigned long long)key.offset, type);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tsubid_le = cpu_to_le64(subid_cpu);\n\twrite_extent_buffer(eb, &subid_le, offset, sizeof(subid_le));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/uuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nint btrfs_uuid_tree_add(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid_cpu)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\t__le64 subid_le;\n\n\tret = btrfs_uuid_tree_lookup(uuid_root, uuid, type, subid_cpu);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_insert_empty_item(trans, uuid_root, path, &key,\n\t\t\t\t      sizeof(subid_le));\n\tif (ret >= 0) {\n\t\t/* Add an item for the type for the first time */\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t} else if (ret == -EEXIST) {\n\t\t/*\n\t\t * An item with that type already exists.\n\t\t * Extend the item and store the new subid at the end.\n\t\t */\n\t\tbtrfs_extend_item(uuid_root, path, sizeof(subid_le));\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t\toffset += btrfs_item_size_nr(eb, slot) - sizeof(subid_le);\n\t} else if (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"insert uuid item failed %d \"\n\t\t\t\"(0x%016llx, 0x%016llx) type %u!\",\n\t\t\tret, (unsigned long long)key.objectid,\n\t\t\t(unsigned long long)key.offset, type);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tsubid_le = cpu_to_le64(subid_cpu);\n\twrite_extent_buffer(eb, &subid_le, offset, sizeof(subid_le));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_is_empty_uuid",
          "args": [
            "root_item.received_uuid"
          ],
          "line": 3778
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_is_empty_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "420-429",
          "snippet": "int btrfs_is_empty_uuid(u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_UUID_SIZE; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_is_empty_uuid(u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_UUID_SIZE; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"uuid_tree_add failed %d\"",
            "ret"
          ],
          "line": 3772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 3758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 3757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "fs_info->uuid_root",
            "2"
          ],
          "line": 3756
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_refs",
          "args": [
            "&root_item"
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "&root_item",
            "btrfs_item_ptr_offset(eb, slot)",
            "(int)sizeof(root_item)"
          ],
          "line": 3740
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "slot"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "eb",
            "slot"
          ],
          "line": 3736
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_forward",
          "args": [
            "root",
            "&key",
            "path",
            "0"
          ],
          "line": 3721
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5113-5211",
          "snippet": "int btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 3706
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_uuid_scan_kthread(void *data)\n{\n\tstruct btrfs_fs_info *fs_info = data;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_key max_key;\n\tstruct btrfs_path *path = NULL;\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tstruct btrfs_root_item root_item;\n\tu32 item_size;\n\tstruct btrfs_trans_handle *trans = NULL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = 0;\n\n\tmax_key.objectid = (u64)-1;\n\tmax_key.type = BTRFS_ROOT_ITEM_KEY;\n\tmax_key.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &key, path, 0);\n\t\tif (ret) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key.type != BTRFS_ROOT_ITEM_KEY ||\n\t\t    (key.objectid < BTRFS_FIRST_FREE_OBJECTID &&\n\t\t     key.objectid != BTRFS_FS_TREE_OBJECTID) ||\n\t\t    key.objectid > BTRFS_LAST_FREE_OBJECTID)\n\t\t\tgoto skip;\n\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\titem_size = btrfs_item_size_nr(eb, slot);\n\t\tif (item_size < sizeof(root_item))\n\t\t\tgoto skip;\n\n\t\tread_extent_buffer(eb, &root_item,\n\t\t\t\t   btrfs_item_ptr_offset(eb, slot),\n\t\t\t\t   (int)sizeof(root_item));\n\t\tif (btrfs_root_refs(&root_item) == 0)\n\t\t\tgoto skip;\n\n\t\tif (!btrfs_is_empty_uuid(root_item.uuid) ||\n\t\t    !btrfs_is_empty_uuid(root_item.received_uuid)) {\n\t\t\tif (trans)\n\t\t\t\tgoto update_tree;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\t/*\n\t\t\t * 1 - subvol uuid item\n\t\t\t * 1 - received_subvol uuid item\n\t\t\t */\n\t\t\ttrans = btrfs_start_transaction(fs_info->uuid_root, 2);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tgoto skip;\n\t\t}\nupdate_tree:\n\t\tif (!btrfs_is_empty_uuid(root_item.uuid)) {\n\t\t\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root,\n\t\t\t\t\t\t  root_item.uuid,\n\t\t\t\t\t\t  BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t\t\t  key.objectid);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_warn(fs_info, \"uuid_tree_add failed %d\",\n\t\t\t\t\tret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!btrfs_is_empty_uuid(root_item.received_uuid)) {\n\t\t\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root,\n\t\t\t\t\t\t  root_item.received_uuid,\n\t\t\t\t\t\t BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t\t  key.objectid);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_warn(fs_info, \"uuid_tree_add failed %d\",\n\t\t\t\t\tret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nskip:\n\t\tif (trans) {\n\t\t\tret = btrfs_end_transaction(trans, fs_info->uuid_root);\n\t\t\ttrans = NULL;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_release_path(path);\n\t\tif (key.offset < (u64)-1) {\n\t\t\tkey.offset++;\n\t\t} else if (key.type < BTRFS_ROOT_ITEM_KEY) {\n\t\t\tkey.offset = 0;\n\t\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\t} else if (key.objectid < (u64)-1) {\n\t\t\tkey.offset = 0;\n\t\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tkey.objectid++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tcond_resched();\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tif (trans && !IS_ERR(trans))\n\t\tbtrfs_end_transaction(trans, fs_info->uuid_root);\n\tif (ret)\n\t\tbtrfs_warn(fs_info, \"btrfs_uuid_scan_kthread failed %d\", ret);\n\telse\n\t\tfs_info->update_uuid_tree_gen = 1;\n\tup(&fs_info->uuid_tree_rescan_sem);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_cancel_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3653-3690",
    "snippet": "int btrfs_cancel_balance(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->balance_cancel_req);\n\t/*\n\t * if we are running just wait and return, balance item is\n\t * deleted in btrfs_balance in this case\n\t */\n\tif (atomic_read(&fs_info->balance_running)) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\twait_event(fs_info->balance_wait_q,\n\t\t\t   atomic_read(&fs_info->balance_running) == 0);\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t} else {\n\t\t/* __cancel_balance needs volume_mutex */\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\tmutex_lock(&fs_info->volume_mutex);\n\t\tmutex_lock(&fs_info->balance_mutex);\n\n\t\tif (fs_info->balance_ctl)\n\t\t\t__cancel_balance(fs_info);\n\n\t\tmutex_unlock(&fs_info->volume_mutex);\n\t}\n\n\tBUG_ON(fs_info->balance_ctl || atomic_read(&fs_info->balance_running));\n\tatomic_dec(&fs_info->balance_cancel_req);\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&fs_info->balance_cancel_req"
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fs_info->balance_ctl || atomic_read(&fs_info->balance_running)"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_running"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 3683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cancel_balance",
          "args": [
            "fs_info"
          ],
          "line": 3681
        },
        "resolved": true,
        "details": {
          "function_name": "__cancel_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3325-3335",
          "snippet": "static void __cancel_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\n\tunset_balance_control(fs_info);\n\tret = del_balance_item(fs_info->tree_root);\n\tif (ret)\n\t\tbtrfs_std_error(fs_info, ret);\n\n\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void __cancel_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\n\tunset_balance_control(fs_info);\n\tret = del_balance_item(fs_info->tree_root);\n\tif (ret)\n\t\tbtrfs_std_error(fs_info, ret);\n\n\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fs_info->balance_wait_q",
            "atomic_read(&fs_info->balance_running) == 0"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_running"
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_running"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fs_info->balance_cancel_req"
          ],
          "line": 3664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_cancel_balance(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->balance_cancel_req);\n\t/*\n\t * if we are running just wait and return, balance item is\n\t * deleted in btrfs_balance in this case\n\t */\n\tif (atomic_read(&fs_info->balance_running)) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\twait_event(fs_info->balance_wait_q,\n\t\t\t   atomic_read(&fs_info->balance_running) == 0);\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t} else {\n\t\t/* __cancel_balance needs volume_mutex */\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\tmutex_lock(&fs_info->volume_mutex);\n\t\tmutex_lock(&fs_info->balance_mutex);\n\n\t\tif (fs_info->balance_ctl)\n\t\t\t__cancel_balance(fs_info);\n\n\t\tmutex_unlock(&fs_info->volume_mutex);\n\t}\n\n\tBUG_ON(fs_info->balance_ctl || atomic_read(&fs_info->balance_running));\n\tatomic_dec(&fs_info->balance_cancel_req);\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_pause_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3624-3651",
    "snippet": "int btrfs_pause_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\treturn -ENOTCONN;\n\t}\n\n\tif (atomic_read(&fs_info->balance_running)) {\n\t\tatomic_inc(&fs_info->balance_pause_req);\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\n\t\twait_event(fs_info->balance_wait_q,\n\t\t\t   atomic_read(&fs_info->balance_running) == 0);\n\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t\t/* we are good with balance_ctl ripped off from under us */\n\t\tBUG_ON(atomic_read(&fs_info->balance_running));\n\t\tatomic_dec(&fs_info->balance_pause_req);\n\t} else {\n\t\tret = -ENOTCONN;\n\t}\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&fs_info->balance_pause_req"
          ],
          "line": 3644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&fs_info->balance_running)"
          ],
          "line": 3643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_running"
          ],
          "line": 3643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fs_info->balance_wait_q",
            "atomic_read(&fs_info->balance_running) == 0"
          ],
          "line": 3638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_running"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fs_info->balance_pause_req"
          ],
          "line": 3635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_running"
          ],
          "line": 3634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_pause_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\treturn -ENOTCONN;\n\t}\n\n\tif (atomic_read(&fs_info->balance_running)) {\n\t\tatomic_inc(&fs_info->balance_pause_req);\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\n\t\twait_event(fs_info->balance_wait_q,\n\t\t\t   atomic_read(&fs_info->balance_running) == 0);\n\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t\t/* we are good with balance_ctl ripped off from under us */\n\t\tBUG_ON(atomic_read(&fs_info->balance_running));\n\t\tatomic_dec(&fs_info->balance_pause_req);\n\t} else {\n\t\tret = -ENOTCONN;\n\t}\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_recover_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3564-3622",
    "snippet": "int btrfs_recover_balance(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl;\n\tstruct btrfs_balance_item *item;\n\tstruct btrfs_disk_balance_args disk_bargs;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_BALANCE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, fs_info->tree_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) { /* ret = -ENOENT; */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tbctl = kzalloc(sizeof(*bctl), GFP_NOFS);\n\tif (!bctl) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_balance_item);\n\n\tbctl->fs_info = fs_info;\n\tbctl->flags = btrfs_balance_flags(leaf, item);\n\tbctl->flags |= BTRFS_BALANCE_RESUME;\n\n\tbtrfs_balance_data(leaf, item, &disk_bargs);\n\tbtrfs_disk_balance_args_to_cpu(&bctl->data, &disk_bargs);\n\tbtrfs_balance_meta(leaf, item, &disk_bargs);\n\tbtrfs_disk_balance_args_to_cpu(&bctl->meta, &disk_bargs);\n\tbtrfs_balance_sys(leaf, item, &disk_bargs);\n\tbtrfs_disk_balance_args_to_cpu(&bctl->sys, &disk_bargs);\n\n\tWARN_ON(atomic_xchg(&fs_info->mutually_exclusive_operation_running, 1));\n\n\tmutex_lock(&fs_info->volume_mutex);\n\tmutex_lock(&fs_info->balance_mutex);\n\n\tset_balance_control(bctl);\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\tmutex_unlock(&fs_info->volume_mutex);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 3620
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_balance_control",
          "args": [
            "bctl"
          ],
          "line": 3615
        },
        "resolved": true,
        "details": {
          "function_name": "unset_balance_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2920-2931",
          "snippet": "static void unset_balance_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tBUG_ON(!fs_info->balance_ctl);\n\n\tspin_lock(&fs_info->balance_lock);\n\tfs_info->balance_ctl = NULL;\n\tspin_unlock(&fs_info->balance_lock);\n\n\tkfree(bctl);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void unset_balance_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tBUG_ON(!fs_info->balance_ctl);\n\n\tspin_lock(&fs_info->balance_lock);\n\tfs_info->balance_ctl = NULL;\n\tspin_unlock(&fs_info->balance_lock);\n\n\tkfree(bctl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_xchg(&fs_info->mutually_exclusive_operation_running, 1)"
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&fs_info->mutually_exclusive_operation_running",
            "1"
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_disk_balance_args_to_cpu",
          "args": [
            "&bctl->sys",
            "&disk_bargs"
          ],
          "line": 3608
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_disk_balance_args_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2980-2996",
          "snippet": "static inline void\nbtrfs_disk_balance_args_to_cpu(struct btrfs_balance_args *cpu,\n\t\t\t       struct btrfs_disk_balance_args *disk)\n{\n\tmemset(cpu, 0, sizeof(*cpu));\n\n\tcpu->profiles = le64_to_cpu(disk->profiles);\n\tcpu->usage = le64_to_cpu(disk->usage);\n\tcpu->devid = le64_to_cpu(disk->devid);\n\tcpu->pstart = le64_to_cpu(disk->pstart);\n\tcpu->pend = le64_to_cpu(disk->pend);\n\tcpu->vstart = le64_to_cpu(disk->vstart);\n\tcpu->vend = le64_to_cpu(disk->vend);\n\tcpu->target = le64_to_cpu(disk->target);\n\tcpu->flags = le64_to_cpu(disk->flags);\n\tcpu->limit = le64_to_cpu(disk->limit);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void\nbtrfs_disk_balance_args_to_cpu(struct btrfs_balance_args *cpu,\n\t\t\t       struct btrfs_disk_balance_args *disk)\n{\n\tmemset(cpu, 0, sizeof(*cpu));\n\n\tcpu->profiles = le64_to_cpu(disk->profiles);\n\tcpu->usage = le64_to_cpu(disk->usage);\n\tcpu->devid = le64_to_cpu(disk->devid);\n\tcpu->pstart = le64_to_cpu(disk->pstart);\n\tcpu->pend = le64_to_cpu(disk->pend);\n\tcpu->vstart = le64_to_cpu(disk->vstart);\n\tcpu->vend = le64_to_cpu(disk->vend);\n\tcpu->target = le64_to_cpu(disk->target);\n\tcpu->flags = le64_to_cpu(disk->flags);\n\tcpu->limit = le64_to_cpu(disk->limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_balance_sys",
          "args": [
            "leaf",
            "item",
            "&disk_bargs"
          ],
          "line": 3607
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_balance_sys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2966-2971",
          "snippet": "static inline void btrfs_balance_sys(struct extent_buffer *eb,\n\t\t\t\t     struct btrfs_balance_item *bi,\n\t\t\t\t     struct btrfs_disk_balance_args *ba)\n{\n\tread_eb_member(eb, bi, struct btrfs_balance_item, sys, ba);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_balance_sys(struct extent_buffer *eb,\n\t\t\t\t     struct btrfs_balance_item *bi,\n\t\t\t\t     struct btrfs_disk_balance_args *ba)\n{\n\tread_eb_member(eb, bi, struct btrfs_balance_item, sys, ba);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_balance_meta",
          "args": [
            "leaf",
            "item",
            "&disk_bargs"
          ],
          "line": 3605
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_balance_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2952-2957",
          "snippet": "static inline void btrfs_balance_meta(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_balance_item *bi,\n\t\t\t\t      struct btrfs_disk_balance_args *ba)\n{\n\tread_eb_member(eb, bi, struct btrfs_balance_item, meta, ba);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_balance_meta(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_balance_item *bi,\n\t\t\t\t      struct btrfs_disk_balance_args *ba)\n{\n\tread_eb_member(eb, bi, struct btrfs_balance_item, meta, ba);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_balance_data",
          "args": [
            "leaf",
            "item",
            "&disk_bargs"
          ],
          "line": 3603
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_balance_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2938-2943",
          "snippet": "static inline void btrfs_balance_data(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_balance_item *bi,\n\t\t\t\t      struct btrfs_disk_balance_args *ba)\n{\n\tread_eb_member(eb, bi, struct btrfs_balance_item, data, ba);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_balance_data(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_balance_item *bi,\n\t\t\t\t      struct btrfs_disk_balance_args *ba)\n{\n\tread_eb_member(eb, bi, struct btrfs_balance_item, data, ba);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_balance_flags",
          "args": [
            "leaf",
            "item"
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_balance_item"
          ],
          "line": 3597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*bctl)",
            "GFP_NOFS"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "fs_info->tree_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 3582
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 3574
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_recover_balance(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl;\n\tstruct btrfs_balance_item *item;\n\tstruct btrfs_disk_balance_args disk_bargs;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_BALANCE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, fs_info->tree_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) { /* ret = -ENOENT; */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tbctl = kzalloc(sizeof(*bctl), GFP_NOFS);\n\tif (!bctl) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_balance_item);\n\n\tbctl->fs_info = fs_info;\n\tbctl->flags = btrfs_balance_flags(leaf, item);\n\tbctl->flags |= BTRFS_BALANCE_RESUME;\n\n\tbtrfs_balance_data(leaf, item, &disk_bargs);\n\tbtrfs_disk_balance_args_to_cpu(&bctl->data, &disk_bargs);\n\tbtrfs_balance_meta(leaf, item, &disk_bargs);\n\tbtrfs_disk_balance_args_to_cpu(&bctl->meta, &disk_bargs);\n\tbtrfs_balance_sys(leaf, item, &disk_bargs);\n\tbtrfs_disk_balance_args_to_cpu(&bctl->sys, &disk_bargs);\n\n\tWARN_ON(atomic_xchg(&fs_info->mutually_exclusive_operation_running, 1));\n\n\tmutex_lock(&fs_info->volume_mutex);\n\tmutex_lock(&fs_info->balance_mutex);\n\n\tset_balance_control(bctl);\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\tmutex_unlock(&fs_info->volume_mutex);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_resume_balance_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3544-3562",
    "snippet": "int btrfs_resume_balance_async(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *tsk;\n\n\tspin_lock(&fs_info->balance_lock);\n\tif (!fs_info->balance_ctl) {\n\t\tspin_unlock(&fs_info->balance_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fs_info->balance_lock);\n\n\tif (btrfs_test_opt(fs_info->tree_root, SKIP_BALANCE)) {\n\t\tbtrfs_info(fs_info, \"force skipping balance\");\n\t\treturn 0;\n\t}\n\n\ttsk = kthread_run(balance_kthread, fs_info, \"btrfs-balance\");\n\treturn PTR_ERR_OR_ZERO(tsk);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR_OR_ZERO",
          "args": [
            "tsk"
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "balance_kthread",
            "fs_info",
            "\"btrfs-balance\""
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "fs_info",
            "\"force skipping balance\""
          ],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "fs_info->tree_root",
            "SKIP_BALANCE"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 3553
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 3548
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_resume_balance_async(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *tsk;\n\n\tspin_lock(&fs_info->balance_lock);\n\tif (!fs_info->balance_ctl) {\n\t\tspin_unlock(&fs_info->balance_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fs_info->balance_lock);\n\n\tif (btrfs_test_opt(fs_info->tree_root, SKIP_BALANCE)) {\n\t\tbtrfs_info(fs_info, \"force skipping balance\");\n\t\treturn 0;\n\t}\n\n\ttsk = kthread_run(balance_kthread, fs_info, \"btrfs-balance\");\n\treturn PTR_ERR_OR_ZERO(tsk);\n}"
  },
  {
    "function_name": "balance_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3525-3542",
    "snippet": "static int balance_kthread(void *data)\n{\n\tstruct btrfs_fs_info *fs_info = data;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->volume_mutex);\n\tmutex_lock(&fs_info->balance_mutex);\n\n\tif (fs_info->balance_ctl) {\n\t\tbtrfs_info(fs_info, \"continuing balance\");\n\t\tret = btrfs_balance(fs_info->balance_ctl, NULL);\n\t}\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\tmutex_unlock(&fs_info->volume_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 3539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_balance",
          "args": [
            "fs_info->balance_ctl",
            "NULL"
          ],
          "line": 3535
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3340-3523",
          "snippet": "int btrfs_balance(struct btrfs_balance_control *bctl,\n\t\t  struct btrfs_ioctl_balance_args *bargs)\n{\n\tstruct btrfs_fs_info *fs_info = bctl->fs_info;\n\tu64 allowed;\n\tint mixed = 0;\n\tint ret;\n\tu64 num_devices;\n\tunsigned seq;\n\n\tif (btrfs_fs_closing(fs_info) ||\n\t    atomic_read(&fs_info->balance_pause_req) ||\n\t    atomic_read(&fs_info->balance_cancel_req)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tallowed = btrfs_super_incompat_flags(fs_info->super_copy);\n\tif (allowed & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS)\n\t\tmixed = 1;\n\n\t/*\n\t * In case of mixed groups both data and meta should be picked,\n\t * and identical options should be given for both of them.\n\t */\n\tallowed = BTRFS_BALANCE_DATA | BTRFS_BALANCE_METADATA;\n\tif (mixed && (bctl->flags & allowed)) {\n\t\tif (!(bctl->flags & BTRFS_BALANCE_DATA) ||\n\t\t    !(bctl->flags & BTRFS_BALANCE_METADATA) ||\n\t\t    memcmp(&bctl->data, &bctl->meta, sizeof(bctl->data))) {\n\t\t\tbtrfs_err(fs_info, \"with mixed groups data and \"\n\t\t\t\t   \"metadata balance options must be the same\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnum_devices = fs_info->fs_devices->num_devices;\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace)) {\n\t\tBUG_ON(num_devices < 1);\n\t\tnum_devices--;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\tallowed = BTRFS_AVAIL_ALLOC_BIT_SINGLE;\n\tif (num_devices == 1)\n\t\tallowed |= BTRFS_BLOCK_GROUP_DUP;\n\telse if (num_devices > 1)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID1);\n\tif (num_devices > 2)\n\t\tallowed |= BTRFS_BLOCK_GROUP_RAID5;\n\tif (num_devices > 3)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t    BTRFS_BLOCK_GROUP_RAID6);\n\tif ((bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->data.target, 1) ||\n\t     (bctl->data.target & ~allowed))) {\n\t\tbtrfs_err(fs_info, \"unable to start balance with target \"\n\t\t\t   \"data profile %llu\",\n\t\t       bctl->data.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->meta.target, 1) ||\n\t     (bctl->meta.target & ~allowed))) {\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"unable to start balance with target metadata profile %llu\",\n\t\t       bctl->meta.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->sys.target, 1) ||\n\t     (bctl->sys.target & ~allowed))) {\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"unable to start balance with target system profile %llu\",\n\t\t       bctl->sys.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* allow dup'ed data chunks only in mixed mode */\n\tif (!mixed && (bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (bctl->data.target & BTRFS_BLOCK_GROUP_DUP)) {\n\t\tbtrfs_err(fs_info, \"dup for data is not allowed\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* allow to reduce meta or sys integrity only if force set */\n\tallowed = BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID10 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID5 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID6;\n\tdo {\n\t\tseq = read_seqbegin(&fs_info->profiles_lock);\n\n\t\tif (((bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_system_alloc_bits & allowed) &&\n\t\t     !(bctl->sys.target & allowed)) ||\n\t\t    ((bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_metadata_alloc_bits & allowed) &&\n\t\t     !(bctl->meta.target & allowed))) {\n\t\t\tif (bctl->flags & BTRFS_BALANCE_FORCE) {\n\t\t\t\tbtrfs_info(fs_info, \"force reducing metadata integrity\");\n\t\t\t} else {\n\t\t\t\tbtrfs_err(fs_info, \"balance will reduce metadata \"\n\t\t\t\t\t   \"integrity, use force if you want this\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} while (read_seqretry(&fs_info->profiles_lock, seq));\n\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\tint num_tolerated_disk_barrier_failures;\n\t\tu64 target = bctl->sys.target;\n\n\t\tnum_tolerated_disk_barrier_failures =\n\t\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t    (target &\n\t\t     (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID0 |\n\t\t      BTRFS_AVAIL_ALLOC_BIT_SINGLE)))\n\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\telse if (num_tolerated_disk_barrier_failures > 1 &&\n\t\t\t (target &\n\t\t\t  (BTRFS_BLOCK_GROUP_RAID1 | BTRFS_BLOCK_GROUP_RAID10)))\n\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\n\t\tfs_info->num_tolerated_disk_barrier_failures =\n\t\t\tnum_tolerated_disk_barrier_failures;\n\t}\n\n\tret = insert_balance_item(fs_info->tree_root, bctl);\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tif (!(bctl->flags & BTRFS_BALANCE_RESUME)) {\n\t\tBUG_ON(ret == -EEXIST);\n\t\tset_balance_control(bctl);\n\t} else {\n\t\tBUG_ON(ret != -EEXIST);\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tupdate_balance_args(bctl);\n\t\tspin_unlock(&fs_info->balance_lock);\n\t}\n\n\tatomic_inc(&fs_info->balance_running);\n\tmutex_unlock(&fs_info->balance_mutex);\n\n\tret = __btrfs_balance(fs_info);\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tatomic_dec(&fs_info->balance_running);\n\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\tfs_info->num_tolerated_disk_barrier_failures =\n\t\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\t}\n\n\tif (bargs) {\n\t\tmemset(bargs, 0, sizeof(*bargs));\n\t\tupdate_ioctl_balance_args(fs_info, 0, bargs);\n\t}\n\n\tif ((ret && ret != -ECANCELED && ret != -ENOSPC) ||\n\t    balance_need_close(fs_info)) {\n\t\t__cancel_balance(fs_info);\n\t}\n\n\twake_up(&fs_info->balance_wait_q);\n\n\treturn ret;\nout:\n\tif (bctl->flags & BTRFS_BALANCE_RESUME)\n\t\t__cancel_balance(fs_info);\n\telse {\n\t\tkfree(bctl);\n\t\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_balance(struct btrfs_balance_control *bctl,\n\t\t  struct btrfs_ioctl_balance_args *bargs)\n{\n\tstruct btrfs_fs_info *fs_info = bctl->fs_info;\n\tu64 allowed;\n\tint mixed = 0;\n\tint ret;\n\tu64 num_devices;\n\tunsigned seq;\n\n\tif (btrfs_fs_closing(fs_info) ||\n\t    atomic_read(&fs_info->balance_pause_req) ||\n\t    atomic_read(&fs_info->balance_cancel_req)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tallowed = btrfs_super_incompat_flags(fs_info->super_copy);\n\tif (allowed & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS)\n\t\tmixed = 1;\n\n\t/*\n\t * In case of mixed groups both data and meta should be picked,\n\t * and identical options should be given for both of them.\n\t */\n\tallowed = BTRFS_BALANCE_DATA | BTRFS_BALANCE_METADATA;\n\tif (mixed && (bctl->flags & allowed)) {\n\t\tif (!(bctl->flags & BTRFS_BALANCE_DATA) ||\n\t\t    !(bctl->flags & BTRFS_BALANCE_METADATA) ||\n\t\t    memcmp(&bctl->data, &bctl->meta, sizeof(bctl->data))) {\n\t\t\tbtrfs_err(fs_info, \"with mixed groups data and \"\n\t\t\t\t   \"metadata balance options must be the same\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnum_devices = fs_info->fs_devices->num_devices;\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace)) {\n\t\tBUG_ON(num_devices < 1);\n\t\tnum_devices--;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\tallowed = BTRFS_AVAIL_ALLOC_BIT_SINGLE;\n\tif (num_devices == 1)\n\t\tallowed |= BTRFS_BLOCK_GROUP_DUP;\n\telse if (num_devices > 1)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID1);\n\tif (num_devices > 2)\n\t\tallowed |= BTRFS_BLOCK_GROUP_RAID5;\n\tif (num_devices > 3)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t    BTRFS_BLOCK_GROUP_RAID6);\n\tif ((bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->data.target, 1) ||\n\t     (bctl->data.target & ~allowed))) {\n\t\tbtrfs_err(fs_info, \"unable to start balance with target \"\n\t\t\t   \"data profile %llu\",\n\t\t       bctl->data.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->meta.target, 1) ||\n\t     (bctl->meta.target & ~allowed))) {\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"unable to start balance with target metadata profile %llu\",\n\t\t       bctl->meta.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->sys.target, 1) ||\n\t     (bctl->sys.target & ~allowed))) {\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"unable to start balance with target system profile %llu\",\n\t\t       bctl->sys.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* allow dup'ed data chunks only in mixed mode */\n\tif (!mixed && (bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (bctl->data.target & BTRFS_BLOCK_GROUP_DUP)) {\n\t\tbtrfs_err(fs_info, \"dup for data is not allowed\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* allow to reduce meta or sys integrity only if force set */\n\tallowed = BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID10 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID5 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID6;\n\tdo {\n\t\tseq = read_seqbegin(&fs_info->profiles_lock);\n\n\t\tif (((bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_system_alloc_bits & allowed) &&\n\t\t     !(bctl->sys.target & allowed)) ||\n\t\t    ((bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_metadata_alloc_bits & allowed) &&\n\t\t     !(bctl->meta.target & allowed))) {\n\t\t\tif (bctl->flags & BTRFS_BALANCE_FORCE) {\n\t\t\t\tbtrfs_info(fs_info, \"force reducing metadata integrity\");\n\t\t\t} else {\n\t\t\t\tbtrfs_err(fs_info, \"balance will reduce metadata \"\n\t\t\t\t\t   \"integrity, use force if you want this\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} while (read_seqretry(&fs_info->profiles_lock, seq));\n\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\tint num_tolerated_disk_barrier_failures;\n\t\tu64 target = bctl->sys.target;\n\n\t\tnum_tolerated_disk_barrier_failures =\n\t\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t    (target &\n\t\t     (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID0 |\n\t\t      BTRFS_AVAIL_ALLOC_BIT_SINGLE)))\n\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\telse if (num_tolerated_disk_barrier_failures > 1 &&\n\t\t\t (target &\n\t\t\t  (BTRFS_BLOCK_GROUP_RAID1 | BTRFS_BLOCK_GROUP_RAID10)))\n\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\n\t\tfs_info->num_tolerated_disk_barrier_failures =\n\t\t\tnum_tolerated_disk_barrier_failures;\n\t}\n\n\tret = insert_balance_item(fs_info->tree_root, bctl);\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tif (!(bctl->flags & BTRFS_BALANCE_RESUME)) {\n\t\tBUG_ON(ret == -EEXIST);\n\t\tset_balance_control(bctl);\n\t} else {\n\t\tBUG_ON(ret != -EEXIST);\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tupdate_balance_args(bctl);\n\t\tspin_unlock(&fs_info->balance_lock);\n\t}\n\n\tatomic_inc(&fs_info->balance_running);\n\tmutex_unlock(&fs_info->balance_mutex);\n\n\tret = __btrfs_balance(fs_info);\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tatomic_dec(&fs_info->balance_running);\n\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\tfs_info->num_tolerated_disk_barrier_failures =\n\t\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\t}\n\n\tif (bargs) {\n\t\tmemset(bargs, 0, sizeof(*bargs));\n\t\tupdate_ioctl_balance_args(fs_info, 0, bargs);\n\t}\n\n\tif ((ret && ret != -ECANCELED && ret != -ENOSPC) ||\n\t    balance_need_close(fs_info)) {\n\t\t__cancel_balance(fs_info);\n\t}\n\n\twake_up(&fs_info->balance_wait_q);\n\n\treturn ret;\nout:\n\tif (bctl->flags & BTRFS_BALANCE_RESUME)\n\t\t__cancel_balance(fs_info);\n\telse {\n\t\tkfree(bctl);\n\t\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "fs_info",
            "\"continuing balance\""
          ],
          "line": 3534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int balance_kthread(void *data)\n{\n\tstruct btrfs_fs_info *fs_info = data;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->volume_mutex);\n\tmutex_lock(&fs_info->balance_mutex);\n\n\tif (fs_info->balance_ctl) {\n\t\tbtrfs_info(fs_info, \"continuing balance\");\n\t\tret = btrfs_balance(fs_info->balance_ctl, NULL);\n\t}\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\tmutex_unlock(&fs_info->volume_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3340-3523",
    "snippet": "int btrfs_balance(struct btrfs_balance_control *bctl,\n\t\t  struct btrfs_ioctl_balance_args *bargs)\n{\n\tstruct btrfs_fs_info *fs_info = bctl->fs_info;\n\tu64 allowed;\n\tint mixed = 0;\n\tint ret;\n\tu64 num_devices;\n\tunsigned seq;\n\n\tif (btrfs_fs_closing(fs_info) ||\n\t    atomic_read(&fs_info->balance_pause_req) ||\n\t    atomic_read(&fs_info->balance_cancel_req)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tallowed = btrfs_super_incompat_flags(fs_info->super_copy);\n\tif (allowed & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS)\n\t\tmixed = 1;\n\n\t/*\n\t * In case of mixed groups both data and meta should be picked,\n\t * and identical options should be given for both of them.\n\t */\n\tallowed = BTRFS_BALANCE_DATA | BTRFS_BALANCE_METADATA;\n\tif (mixed && (bctl->flags & allowed)) {\n\t\tif (!(bctl->flags & BTRFS_BALANCE_DATA) ||\n\t\t    !(bctl->flags & BTRFS_BALANCE_METADATA) ||\n\t\t    memcmp(&bctl->data, &bctl->meta, sizeof(bctl->data))) {\n\t\t\tbtrfs_err(fs_info, \"with mixed groups data and \"\n\t\t\t\t   \"metadata balance options must be the same\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnum_devices = fs_info->fs_devices->num_devices;\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace)) {\n\t\tBUG_ON(num_devices < 1);\n\t\tnum_devices--;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\tallowed = BTRFS_AVAIL_ALLOC_BIT_SINGLE;\n\tif (num_devices == 1)\n\t\tallowed |= BTRFS_BLOCK_GROUP_DUP;\n\telse if (num_devices > 1)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID1);\n\tif (num_devices > 2)\n\t\tallowed |= BTRFS_BLOCK_GROUP_RAID5;\n\tif (num_devices > 3)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t    BTRFS_BLOCK_GROUP_RAID6);\n\tif ((bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->data.target, 1) ||\n\t     (bctl->data.target & ~allowed))) {\n\t\tbtrfs_err(fs_info, \"unable to start balance with target \"\n\t\t\t   \"data profile %llu\",\n\t\t       bctl->data.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->meta.target, 1) ||\n\t     (bctl->meta.target & ~allowed))) {\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"unable to start balance with target metadata profile %llu\",\n\t\t       bctl->meta.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->sys.target, 1) ||\n\t     (bctl->sys.target & ~allowed))) {\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"unable to start balance with target system profile %llu\",\n\t\t       bctl->sys.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* allow dup'ed data chunks only in mixed mode */\n\tif (!mixed && (bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (bctl->data.target & BTRFS_BLOCK_GROUP_DUP)) {\n\t\tbtrfs_err(fs_info, \"dup for data is not allowed\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* allow to reduce meta or sys integrity only if force set */\n\tallowed = BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID10 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID5 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID6;\n\tdo {\n\t\tseq = read_seqbegin(&fs_info->profiles_lock);\n\n\t\tif (((bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_system_alloc_bits & allowed) &&\n\t\t     !(bctl->sys.target & allowed)) ||\n\t\t    ((bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_metadata_alloc_bits & allowed) &&\n\t\t     !(bctl->meta.target & allowed))) {\n\t\t\tif (bctl->flags & BTRFS_BALANCE_FORCE) {\n\t\t\t\tbtrfs_info(fs_info, \"force reducing metadata integrity\");\n\t\t\t} else {\n\t\t\t\tbtrfs_err(fs_info, \"balance will reduce metadata \"\n\t\t\t\t\t   \"integrity, use force if you want this\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} while (read_seqretry(&fs_info->profiles_lock, seq));\n\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\tint num_tolerated_disk_barrier_failures;\n\t\tu64 target = bctl->sys.target;\n\n\t\tnum_tolerated_disk_barrier_failures =\n\t\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t    (target &\n\t\t     (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID0 |\n\t\t      BTRFS_AVAIL_ALLOC_BIT_SINGLE)))\n\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\telse if (num_tolerated_disk_barrier_failures > 1 &&\n\t\t\t (target &\n\t\t\t  (BTRFS_BLOCK_GROUP_RAID1 | BTRFS_BLOCK_GROUP_RAID10)))\n\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\n\t\tfs_info->num_tolerated_disk_barrier_failures =\n\t\t\tnum_tolerated_disk_barrier_failures;\n\t}\n\n\tret = insert_balance_item(fs_info->tree_root, bctl);\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tif (!(bctl->flags & BTRFS_BALANCE_RESUME)) {\n\t\tBUG_ON(ret == -EEXIST);\n\t\tset_balance_control(bctl);\n\t} else {\n\t\tBUG_ON(ret != -EEXIST);\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tupdate_balance_args(bctl);\n\t\tspin_unlock(&fs_info->balance_lock);\n\t}\n\n\tatomic_inc(&fs_info->balance_running);\n\tmutex_unlock(&fs_info->balance_mutex);\n\n\tret = __btrfs_balance(fs_info);\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tatomic_dec(&fs_info->balance_running);\n\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\tfs_info->num_tolerated_disk_barrier_failures =\n\t\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\t}\n\n\tif (bargs) {\n\t\tmemset(bargs, 0, sizeof(*bargs));\n\t\tupdate_ioctl_balance_args(fs_info, 0, bargs);\n\t}\n\n\tif ((ret && ret != -ECANCELED && ret != -ENOSPC) ||\n\t    balance_need_close(fs_info)) {\n\t\t__cancel_balance(fs_info);\n\t}\n\n\twake_up(&fs_info->balance_wait_q);\n\n\treturn ret;\nout:\n\tif (bctl->flags & BTRFS_BALANCE_RESUME)\n\t\t__cancel_balance(fs_info);\n\telse {\n\t\tkfree(bctl);\n\t\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->mutually_exclusive_operation_running",
            "0"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bctl"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cancel_balance",
          "args": [
            "fs_info"
          ],
          "line": 3517
        },
        "resolved": true,
        "details": {
          "function_name": "__cancel_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3325-3335",
          "snippet": "static void __cancel_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\n\tunset_balance_control(fs_info);\n\tret = del_balance_item(fs_info->tree_root);\n\tif (ret)\n\t\tbtrfs_std_error(fs_info, ret);\n\n\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void __cancel_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\n\tunset_balance_control(fs_info);\n\tret = del_balance_item(fs_info->tree_root);\n\tif (ret)\n\t\tbtrfs_std_error(fs_info, ret);\n\n\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fs_info->balance_wait_q"
          ],
          "line": 3512
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_need_close",
          "args": [
            "fs_info"
          ],
          "line": 3508
        },
        "resolved": true,
        "details": {
          "function_name": "balance_need_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3317-3323",
          "snippet": "static inline int balance_need_close(struct btrfs_fs_info *fs_info)\n{\n\t/* cancel requested || normal exit path */\n\treturn atomic_read(&fs_info->balance_cancel_req) ||\n\t\t(atomic_read(&fs_info->balance_pause_req) == 0 &&\n\t\t atomic_read(&fs_info->balance_cancel_req) == 0);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic inline int balance_need_close(struct btrfs_fs_info *fs_info)\n{\n\t/* cancel requested || normal exit path */\n\treturn atomic_read(&fs_info->balance_cancel_req) ||\n\t\t(atomic_read(&fs_info->balance_pause_req) == 0 &&\n\t\t atomic_read(&fs_info->balance_cancel_req) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_ioctl_balance_args",
          "args": [
            "fs_info",
            "0",
            "bargs"
          ],
          "line": 3504
        },
        "resolved": true,
        "details": {
          "function_name": "update_ioctl_balance_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4324-4349",
          "snippet": "void update_ioctl_balance_args(struct btrfs_fs_info *fs_info, int lock,\n\t\t\t       struct btrfs_ioctl_balance_args *bargs)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tbargs->flags = bctl->flags;\n\n\tif (atomic_read(&fs_info->balance_running))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_RUNNING;\n\tif (atomic_read(&fs_info->balance_pause_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_PAUSE_REQ;\n\tif (atomic_read(&fs_info->balance_cancel_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_CANCEL_REQ;\n\n\tmemcpy(&bargs->data, &bctl->data, sizeof(bargs->data));\n\tmemcpy(&bargs->meta, &bctl->meta, sizeof(bargs->meta));\n\tmemcpy(&bargs->sys, &bctl->sys, sizeof(bargs->sys));\n\n\tif (lock) {\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tmemcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));\n\t\tspin_unlock(&fs_info->balance_lock);\n\t} else {\n\t\tmemcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid update_ioctl_balance_args(struct btrfs_fs_info *fs_info, int lock,\n\t\t\t       struct btrfs_ioctl_balance_args *bargs)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tbargs->flags = bctl->flags;\n\n\tif (atomic_read(&fs_info->balance_running))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_RUNNING;\n\tif (atomic_read(&fs_info->balance_pause_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_PAUSE_REQ;\n\tif (atomic_read(&fs_info->balance_cancel_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_CANCEL_REQ;\n\n\tmemcpy(&bargs->data, &bctl->data, sizeof(bargs->data));\n\tmemcpy(&bargs->meta, &bctl->meta, sizeof(bargs->meta));\n\tmemcpy(&bargs->sys, &bctl->sys, sizeof(bargs->sys));\n\n\tif (lock) {\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tmemcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));\n\t\tspin_unlock(&fs_info->balance_lock);\n\t} else {\n\t\tmemcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bargs",
            "0",
            "sizeof(*bargs)"
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_calc_num_tolerated_disk_barrier_failures",
          "args": [
            "fs_info"
          ],
          "line": 3499
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_calc_num_tolerated_disk_barrier_failures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3348-3424",
          "snippet": "int btrfs_calc_num_tolerated_disk_barrier_failures(\n\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_space_info *sinfo;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint i;\n\tint c;\n\tint num_tolerated_disk_barrier_failures =\n\t\t(int)fs_info->fs_devices->num_devices;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tsinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &fs_info->space_info, list) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tsinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!sinfo)\n\t\t\tcontinue;\n\n\t\tdown_read(&sinfo->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&sinfo->block_groups[c])) {\n\t\t\t\tu64 flags;\n\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&sinfo->block_groups[c], &space);\n\t\t\t\tif (space.total_bytes == 0 ||\n\t\t\t\t    space.used_bytes == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tflags = space.flags;\n\t\t\t\t/*\n\t\t\t\t * return\n\t\t\t\t * 0: if dup, single or RAID0 is configured for\n\t\t\t\t *    any of metadata, system or data, else\n\t\t\t\t * 1: if RAID5 is configured, or if RAID1 or\n\t\t\t\t *    RAID10 is configured and only two mirrors\n\t\t\t\t *    are used, else\n\t\t\t\t * 2: if RAID6 is configured, else\n\t\t\t\t * num_mirrors - 1: if RAID1 or RAID10 is\n\t\t\t\t *                  configured and more than\n\t\t\t\t *                  2 mirrors are used.\n\t\t\t\t */\n\t\t\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t\t\t    ((flags & (BTRFS_BLOCK_GROUP_DUP |\n\t\t\t\t\t       BTRFS_BLOCK_GROUP_RAID0)) ||\n\t\t\t\t     ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK)\n\t\t\t\t      == 0)))\n\t\t\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\t\t\telse if (num_tolerated_disk_barrier_failures > 1) {\n\t\t\t\t\tif (flags & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\t\t\t\t\t} else if (flags &\n\t\t\t\t\t\t   BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tup_read(&sinfo->groups_sem);\n\t}\n\n\treturn num_tolerated_disk_barrier_failures;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_calc_num_tolerated_disk_barrier_failures(\n\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_space_info *sinfo;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint i;\n\tint c;\n\tint num_tolerated_disk_barrier_failures =\n\t\t(int)fs_info->fs_devices->num_devices;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tsinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &fs_info->space_info, list) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tsinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!sinfo)\n\t\t\tcontinue;\n\n\t\tdown_read(&sinfo->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&sinfo->block_groups[c])) {\n\t\t\t\tu64 flags;\n\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&sinfo->block_groups[c], &space);\n\t\t\t\tif (space.total_bytes == 0 ||\n\t\t\t\t    space.used_bytes == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tflags = space.flags;\n\t\t\t\t/*\n\t\t\t\t * return\n\t\t\t\t * 0: if dup, single or RAID0 is configured for\n\t\t\t\t *    any of metadata, system or data, else\n\t\t\t\t * 1: if RAID5 is configured, or if RAID1 or\n\t\t\t\t *    RAID10 is configured and only two mirrors\n\t\t\t\t *    are used, else\n\t\t\t\t * 2: if RAID6 is configured, else\n\t\t\t\t * num_mirrors - 1: if RAID1 or RAID10 is\n\t\t\t\t *                  configured and more than\n\t\t\t\t *                  2 mirrors are used.\n\t\t\t\t */\n\t\t\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t\t\t    ((flags & (BTRFS_BLOCK_GROUP_DUP |\n\t\t\t\t\t       BTRFS_BLOCK_GROUP_RAID0)) ||\n\t\t\t\t     ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK)\n\t\t\t\t      == 0)))\n\t\t\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\t\t\telse if (num_tolerated_disk_barrier_failures > 1) {\n\t\t\t\t\tif (flags & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\t\t\t\t\t} else if (flags &\n\t\t\t\t\t\t   BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tup_read(&sinfo->groups_sem);\n\t}\n\n\treturn num_tolerated_disk_barrier_failures;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&fs_info->balance_running"
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_balance",
          "args": [
            "fs_info"
          ],
          "line": 3492
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3134-3291",
          "snippet": "static int __btrfs_balance(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\tstruct btrfs_root *chunk_root = fs_info->chunk_root;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct list_head *devices;\n\tstruct btrfs_device *device;\n\tu64 old_size;\n\tu64 size_to_free;\n\tstruct btrfs_chunk *chunk;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tint ret;\n\tint enospc_errors = 0;\n\tbool counting = true;\n\tu64 limit_data = bctl->data.limit;\n\tu64 limit_meta = bctl->meta.limit;\n\tu64 limit_sys = bctl->sys.limit;\n\n\t/* step one make some room on all the devices */\n\tdevices = &fs_info->fs_devices->devices;\n\tlist_for_each_entry(device, devices, dev_list) {\n\t\told_size = btrfs_device_get_total_bytes(device);\n\t\tsize_to_free = div_factor(old_size, 1);\n\t\tsize_to_free = min(size_to_free, (u64)1 * 1024 * 1024);\n\t\tif (!device->writeable ||\n\t\t    btrfs_device_get_total_bytes(device) -\n\t\t    btrfs_device_get_bytes_used(device) > size_to_free ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tret = btrfs_shrink_device(device, old_size - size_to_free);\n\t\tif (ret == -ENOSPC)\n\t\t\tbreak;\n\t\tBUG_ON(ret);\n\n\t\ttrans = btrfs_start_transaction(dev_root, 0);\n\t\tBUG_ON(IS_ERR(trans));\n\n\t\tret = btrfs_grow_device(trans, device, old_size);\n\t\tBUG_ON(ret);\n\n\t\tbtrfs_end_transaction(trans, dev_root);\n\t}\n\n\t/* step two, relocate all the chunks */\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t/* zero out stat counters */\n\tspin_lock(&fs_info->balance_lock);\n\tmemset(&bctl->stat, 0, sizeof(bctl->stat));\n\tspin_unlock(&fs_info->balance_lock);\nagain:\n\tif (!counting) {\n\t\tbctl->data.limit = limit_data;\n\t\tbctl->meta.limit = limit_meta;\n\t\tbctl->sys.limit = limit_sys;\n\t}\n\tkey.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\n\twhile (1) {\n\t\tif ((!counting && atomic_read(&fs_info->balance_pause_req)) ||\n\t\t    atomic_read(&fs_info->balance_cancel_req)) {\n\t\t\tret = -ECANCELED;\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = btrfs_search_slot(NULL, chunk_root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\t/*\n\t\t * this shouldn't happen, it means the last relocate\n\t\t * failed\n\t\t */\n\t\tif (ret == 0)\n\t\t\tBUG(); /* FIXME break ? */\n\n\t\tret = btrfs_previous_item(chunk_root, path, 0,\n\t\t\t\t\t  BTRFS_CHUNK_ITEM_KEY);\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid)\n\t\t\tbreak;\n\n\t\tchunk = btrfs_item_ptr(leaf, slot, struct btrfs_chunk);\n\n\t\tif (!counting) {\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->stat.considered++;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\t\t}\n\n\t\tret = should_balance_chunk(chunk_root, leaf, chunk,\n\t\t\t\t\t   found_key.offset);\n\t\tbtrfs_release_path(path);\n\t\tif (!ret)\n\t\t\tgoto loop;\n\n\t\tif (counting) {\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->stat.expected++;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\t\t\tgoto loop;\n\t\t}\n\n\t\tret = btrfs_relocate_chunk(chunk_root,\n\t\t\t\t\t   chunk_root->root_key.objectid,\n\t\t\t\t\t   found_key.objectid,\n\t\t\t\t\t   found_key.offset);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto error;\n\t\tif (ret == -ENOSPC) {\n\t\t\tenospc_errors++;\n\t\t} else {\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->stat.completed++;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\t\t}\nloop:\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t\tkey.offset = found_key.offset - 1;\n\t}\n\n\tif (counting) {\n\t\tbtrfs_release_path(path);\n\t\tcounting = false;\n\t\tgoto again;\n\t}\nerror:\n\tbtrfs_free_path(path);\n\tif (enospc_errors) {\n\t\tbtrfs_info(fs_info, \"%d enospc errors during balance\",\n\t\t       enospc_errors);\n\t\tif (!ret)\n\t\t\tret = -ENOSPC;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_balance(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\tstruct btrfs_root *chunk_root = fs_info->chunk_root;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct list_head *devices;\n\tstruct btrfs_device *device;\n\tu64 old_size;\n\tu64 size_to_free;\n\tstruct btrfs_chunk *chunk;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tint ret;\n\tint enospc_errors = 0;\n\tbool counting = true;\n\tu64 limit_data = bctl->data.limit;\n\tu64 limit_meta = bctl->meta.limit;\n\tu64 limit_sys = bctl->sys.limit;\n\n\t/* step one make some room on all the devices */\n\tdevices = &fs_info->fs_devices->devices;\n\tlist_for_each_entry(device, devices, dev_list) {\n\t\told_size = btrfs_device_get_total_bytes(device);\n\t\tsize_to_free = div_factor(old_size, 1);\n\t\tsize_to_free = min(size_to_free, (u64)1 * 1024 * 1024);\n\t\tif (!device->writeable ||\n\t\t    btrfs_device_get_total_bytes(device) -\n\t\t    btrfs_device_get_bytes_used(device) > size_to_free ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tret = btrfs_shrink_device(device, old_size - size_to_free);\n\t\tif (ret == -ENOSPC)\n\t\t\tbreak;\n\t\tBUG_ON(ret);\n\n\t\ttrans = btrfs_start_transaction(dev_root, 0);\n\t\tBUG_ON(IS_ERR(trans));\n\n\t\tret = btrfs_grow_device(trans, device, old_size);\n\t\tBUG_ON(ret);\n\n\t\tbtrfs_end_transaction(trans, dev_root);\n\t}\n\n\t/* step two, relocate all the chunks */\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t/* zero out stat counters */\n\tspin_lock(&fs_info->balance_lock);\n\tmemset(&bctl->stat, 0, sizeof(bctl->stat));\n\tspin_unlock(&fs_info->balance_lock);\nagain:\n\tif (!counting) {\n\t\tbctl->data.limit = limit_data;\n\t\tbctl->meta.limit = limit_meta;\n\t\tbctl->sys.limit = limit_sys;\n\t}\n\tkey.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\n\twhile (1) {\n\t\tif ((!counting && atomic_read(&fs_info->balance_pause_req)) ||\n\t\t    atomic_read(&fs_info->balance_cancel_req)) {\n\t\t\tret = -ECANCELED;\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = btrfs_search_slot(NULL, chunk_root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\t/*\n\t\t * this shouldn't happen, it means the last relocate\n\t\t * failed\n\t\t */\n\t\tif (ret == 0)\n\t\t\tBUG(); /* FIXME break ? */\n\n\t\tret = btrfs_previous_item(chunk_root, path, 0,\n\t\t\t\t\t  BTRFS_CHUNK_ITEM_KEY);\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid)\n\t\t\tbreak;\n\n\t\tchunk = btrfs_item_ptr(leaf, slot, struct btrfs_chunk);\n\n\t\tif (!counting) {\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->stat.considered++;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\t\t}\n\n\t\tret = should_balance_chunk(chunk_root, leaf, chunk,\n\t\t\t\t\t   found_key.offset);\n\t\tbtrfs_release_path(path);\n\t\tif (!ret)\n\t\t\tgoto loop;\n\n\t\tif (counting) {\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->stat.expected++;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\t\t\tgoto loop;\n\t\t}\n\n\t\tret = btrfs_relocate_chunk(chunk_root,\n\t\t\t\t\t   chunk_root->root_key.objectid,\n\t\t\t\t\t   found_key.objectid,\n\t\t\t\t\t   found_key.offset);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto error;\n\t\tif (ret == -ENOSPC) {\n\t\t\tenospc_errors++;\n\t\t} else {\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->stat.completed++;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\t\t}\nloop:\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t\tkey.offset = found_key.offset - 1;\n\t}\n\n\tif (counting) {\n\t\tbtrfs_release_path(path);\n\t\tcounting = false;\n\t\tgoto again;\n\t}\nerror:\n\tbtrfs_free_path(path);\n\tif (enospc_errors) {\n\t\tbtrfs_info(fs_info, \"%d enospc errors during balance\",\n\t\t       enospc_errors);\n\t\tif (!ret)\n\t\t\tret = -ENOSPC;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 3490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fs_info->balance_running"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 3486
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_balance_args",
          "args": [
            "bctl"
          ],
          "line": 3485
        },
        "resolved": true,
        "details": {
          "function_name": "update_balance_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2868-2902",
          "snippet": "static void update_balance_args(struct btrfs_balance_control *bctl)\n{\n\t/*\n\t * Turn on soft mode for chunk types that were being converted.\n\t */\n\tif (bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT)\n\t\tbctl->data.flags |= BTRFS_BALANCE_ARGS_SOFT;\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT)\n\t\tbctl->sys.flags |= BTRFS_BALANCE_ARGS_SOFT;\n\tif (bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT)\n\t\tbctl->meta.flags |= BTRFS_BALANCE_ARGS_SOFT;\n\n\t/*\n\t * Turn on usage filter if is not already used.  The idea is\n\t * that chunks that we have already balanced should be\n\t * reasonably full.  Don't do it for chunks that are being\n\t * converted - that will keep us from relocating unconverted\n\t * (albeit full) chunks.\n\t */\n\tif (!(bctl->data.flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    !(bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT)) {\n\t\tbctl->data.flags |= BTRFS_BALANCE_ARGS_USAGE;\n\t\tbctl->data.usage = 90;\n\t}\n\tif (!(bctl->sys.flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    !(bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT)) {\n\t\tbctl->sys.flags |= BTRFS_BALANCE_ARGS_USAGE;\n\t\tbctl->sys.usage = 90;\n\t}\n\tif (!(bctl->meta.flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    !(bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT)) {\n\t\tbctl->meta.flags |= BTRFS_BALANCE_ARGS_USAGE;\n\t\tbctl->meta.usage = 90;\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void update_balance_args(struct btrfs_balance_control *bctl)\n{\n\t/*\n\t * Turn on soft mode for chunk types that were being converted.\n\t */\n\tif (bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT)\n\t\tbctl->data.flags |= BTRFS_BALANCE_ARGS_SOFT;\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT)\n\t\tbctl->sys.flags |= BTRFS_BALANCE_ARGS_SOFT;\n\tif (bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT)\n\t\tbctl->meta.flags |= BTRFS_BALANCE_ARGS_SOFT;\n\n\t/*\n\t * Turn on usage filter if is not already used.  The idea is\n\t * that chunks that we have already balanced should be\n\t * reasonably full.  Don't do it for chunks that are being\n\t * converted - that will keep us from relocating unconverted\n\t * (albeit full) chunks.\n\t */\n\tif (!(bctl->data.flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    !(bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT)) {\n\t\tbctl->data.flags |= BTRFS_BALANCE_ARGS_USAGE;\n\t\tbctl->data.usage = 90;\n\t}\n\tif (!(bctl->sys.flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    !(bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT)) {\n\t\tbctl->sys.flags |= BTRFS_BALANCE_ARGS_USAGE;\n\t\tbctl->sys.usage = 90;\n\t}\n\tif (!(bctl->meta.flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    !(bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT)) {\n\t\tbctl->meta.flags |= BTRFS_BALANCE_ARGS_USAGE;\n\t\tbctl->meta.usage = 90;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 3484
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret != -EEXIST"
          ],
          "line": 3483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_balance_control",
          "args": [
            "bctl"
          ],
          "line": 3481
        },
        "resolved": true,
        "details": {
          "function_name": "unset_balance_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2920-2931",
          "snippet": "static void unset_balance_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tBUG_ON(!fs_info->balance_ctl);\n\n\tspin_lock(&fs_info->balance_lock);\n\tfs_info->balance_ctl = NULL;\n\tspin_unlock(&fs_info->balance_lock);\n\n\tkfree(bctl);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void unset_balance_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tBUG_ON(!fs_info->balance_ctl);\n\n\tspin_lock(&fs_info->balance_lock);\n\tfs_info->balance_ctl = NULL;\n\tspin_unlock(&fs_info->balance_lock);\n\n\tkfree(bctl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == -EEXIST"
          ],
          "line": 3480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_balance_item",
          "args": [
            "fs_info->tree_root",
            "bctl"
          ],
          "line": 3475
        },
        "resolved": true,
        "details": {
          "function_name": "insert_balance_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2773-2824",
          "snippet": "static int insert_balance_item(struct btrfs_root *root,\n\t\t\t       struct btrfs_balance_control *bctl)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_balance_item *item;\n\tstruct btrfs_disk_balance_args disk_bargs;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tint ret, err;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_BALANCE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(*item));\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_balance_item);\n\n\tmemset_extent_buffer(leaf, 0, (unsigned long)item, sizeof(*item));\n\n\tbtrfs_cpu_balance_args_to_disk(&disk_bargs, &bctl->data);\n\tbtrfs_set_balance_data(leaf, item, &disk_bargs);\n\tbtrfs_cpu_balance_args_to_disk(&disk_bargs, &bctl->meta);\n\tbtrfs_set_balance_meta(leaf, item, &disk_bargs);\n\tbtrfs_cpu_balance_args_to_disk(&disk_bargs, &bctl->sys);\n\tbtrfs_set_balance_sys(leaf, item, &disk_bargs);\n\n\tbtrfs_set_balance_flags(leaf, item, bctl->flags);\n\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\terr = btrfs_commit_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int insert_balance_item(struct btrfs_root *root,\n\t\t\t       struct btrfs_balance_control *bctl)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_balance_item *item;\n\tstruct btrfs_disk_balance_args disk_bargs;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tint ret, err;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_BALANCE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(*item));\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_balance_item);\n\n\tmemset_extent_buffer(leaf, 0, (unsigned long)item, sizeof(*item));\n\n\tbtrfs_cpu_balance_args_to_disk(&disk_bargs, &bctl->data);\n\tbtrfs_set_balance_data(leaf, item, &disk_bargs);\n\tbtrfs_cpu_balance_args_to_disk(&disk_bargs, &bctl->meta);\n\tbtrfs_set_balance_meta(leaf, item, &disk_bargs);\n\tbtrfs_cpu_balance_args_to_disk(&disk_bargs, &bctl->sys);\n\tbtrfs_set_balance_sys(leaf, item, &disk_bargs);\n\n\tbtrfs_set_balance_flags(leaf, item, bctl->flags);\n\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\terr = btrfs_commit_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&fs_info->profiles_lock",
            "seq"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"balance will reduce metadata \"\n\t\t\t\t\t   \"integrity, use force if you want this\""
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "fs_info",
            "\"force reducing metadata integrity\""
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&fs_info->profiles_lock"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"dup for data is not allowed\""
          ],
          "line": 3425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"unable to start balance with target system profile %llu\"",
            "bctl->sys.target"
          ],
          "line": 3415
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_profile_is_valid",
          "args": [
            "bctl->sys.target",
            "1"
          ],
          "line": 3413
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_profile_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3298-3315",
          "snippet": "static int alloc_profile_is_valid(u64 flags, int extended)\n{\n\tu64 mask = (extended ? BTRFS_EXTENDED_PROFILE_MASK :\n\t\t\t       BTRFS_BLOCK_GROUP_PROFILE_MASK);\n\n\tflags &= ~BTRFS_BLOCK_GROUP_TYPE_MASK;\n\n\t/* 1) check that all other bits are zeroed */\n\tif (flags & ~mask)\n\t\treturn 0;\n\n\t/* 2) see if profile is reduced */\n\tif (flags == 0)\n\t\treturn !extended; /* \"0\" is valid for usual profiles */\n\n\t/* true if exactly one bit set */\n\treturn (flags & (flags - 1)) == 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int alloc_profile_is_valid(u64 flags, int extended)\n{\n\tu64 mask = (extended ? BTRFS_EXTENDED_PROFILE_MASK :\n\t\t\t       BTRFS_BLOCK_GROUP_PROFILE_MASK);\n\n\tflags &= ~BTRFS_BLOCK_GROUP_TYPE_MASK;\n\n\t/* 1) check that all other bits are zeroed */\n\tif (flags & ~mask)\n\t\treturn 0;\n\n\t/* 2) see if profile is reduced */\n\tif (flags == 0)\n\t\treturn !extended; /* \"0\" is valid for usual profiles */\n\n\t/* true if exactly one bit set */\n\treturn (flags & (flags - 1)) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_unlock",
          "args": [
            "&fs_info->dev_replace"
          ],
          "line": 3383
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "895-909",
          "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "num_devices < 1"
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_is_ongoing",
          "args": [
            "&fs_info->dev_replace"
          ],
          "line": 3379
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_is_ongoing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "840-865",
          "snippet": "int btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\n\nint btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_lock",
          "args": [
            "&fs_info->dev_replace"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "867-893",
          "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"with mixed groups data and \"\n\t\t\t\t   \"metadata balance options must be the same\""
          ],
          "line": 3370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&bctl->data",
            "&bctl->meta",
            "sizeof(bctl->data)"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_incompat_flags",
          "args": [
            "fs_info->super_copy"
          ],
          "line": 3357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_cancel_req"
          ],
          "line": 3352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_pause_req"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_fs_closing",
          "args": [
            "fs_info"
          ],
          "line": 3350
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_fs_closing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3612-3619",
          "snippet": "static inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_balance(struct btrfs_balance_control *bctl,\n\t\t  struct btrfs_ioctl_balance_args *bargs)\n{\n\tstruct btrfs_fs_info *fs_info = bctl->fs_info;\n\tu64 allowed;\n\tint mixed = 0;\n\tint ret;\n\tu64 num_devices;\n\tunsigned seq;\n\n\tif (btrfs_fs_closing(fs_info) ||\n\t    atomic_read(&fs_info->balance_pause_req) ||\n\t    atomic_read(&fs_info->balance_cancel_req)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tallowed = btrfs_super_incompat_flags(fs_info->super_copy);\n\tif (allowed & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS)\n\t\tmixed = 1;\n\n\t/*\n\t * In case of mixed groups both data and meta should be picked,\n\t * and identical options should be given for both of them.\n\t */\n\tallowed = BTRFS_BALANCE_DATA | BTRFS_BALANCE_METADATA;\n\tif (mixed && (bctl->flags & allowed)) {\n\t\tif (!(bctl->flags & BTRFS_BALANCE_DATA) ||\n\t\t    !(bctl->flags & BTRFS_BALANCE_METADATA) ||\n\t\t    memcmp(&bctl->data, &bctl->meta, sizeof(bctl->data))) {\n\t\t\tbtrfs_err(fs_info, \"with mixed groups data and \"\n\t\t\t\t   \"metadata balance options must be the same\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnum_devices = fs_info->fs_devices->num_devices;\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace)) {\n\t\tBUG_ON(num_devices < 1);\n\t\tnum_devices--;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\tallowed = BTRFS_AVAIL_ALLOC_BIT_SINGLE;\n\tif (num_devices == 1)\n\t\tallowed |= BTRFS_BLOCK_GROUP_DUP;\n\telse if (num_devices > 1)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID1);\n\tif (num_devices > 2)\n\t\tallowed |= BTRFS_BLOCK_GROUP_RAID5;\n\tif (num_devices > 3)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t    BTRFS_BLOCK_GROUP_RAID6);\n\tif ((bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->data.target, 1) ||\n\t     (bctl->data.target & ~allowed))) {\n\t\tbtrfs_err(fs_info, \"unable to start balance with target \"\n\t\t\t   \"data profile %llu\",\n\t\t       bctl->data.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->meta.target, 1) ||\n\t     (bctl->meta.target & ~allowed))) {\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"unable to start balance with target metadata profile %llu\",\n\t\t       bctl->meta.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->sys.target, 1) ||\n\t     (bctl->sys.target & ~allowed))) {\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"unable to start balance with target system profile %llu\",\n\t\t       bctl->sys.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* allow dup'ed data chunks only in mixed mode */\n\tif (!mixed && (bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (bctl->data.target & BTRFS_BLOCK_GROUP_DUP)) {\n\t\tbtrfs_err(fs_info, \"dup for data is not allowed\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* allow to reduce meta or sys integrity only if force set */\n\tallowed = BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID10 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID5 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID6;\n\tdo {\n\t\tseq = read_seqbegin(&fs_info->profiles_lock);\n\n\t\tif (((bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_system_alloc_bits & allowed) &&\n\t\t     !(bctl->sys.target & allowed)) ||\n\t\t    ((bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_metadata_alloc_bits & allowed) &&\n\t\t     !(bctl->meta.target & allowed))) {\n\t\t\tif (bctl->flags & BTRFS_BALANCE_FORCE) {\n\t\t\t\tbtrfs_info(fs_info, \"force reducing metadata integrity\");\n\t\t\t} else {\n\t\t\t\tbtrfs_err(fs_info, \"balance will reduce metadata \"\n\t\t\t\t\t   \"integrity, use force if you want this\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} while (read_seqretry(&fs_info->profiles_lock, seq));\n\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\tint num_tolerated_disk_barrier_failures;\n\t\tu64 target = bctl->sys.target;\n\n\t\tnum_tolerated_disk_barrier_failures =\n\t\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t    (target &\n\t\t     (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID0 |\n\t\t      BTRFS_AVAIL_ALLOC_BIT_SINGLE)))\n\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\telse if (num_tolerated_disk_barrier_failures > 1 &&\n\t\t\t (target &\n\t\t\t  (BTRFS_BLOCK_GROUP_RAID1 | BTRFS_BLOCK_GROUP_RAID10)))\n\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\n\t\tfs_info->num_tolerated_disk_barrier_failures =\n\t\t\tnum_tolerated_disk_barrier_failures;\n\t}\n\n\tret = insert_balance_item(fs_info->tree_root, bctl);\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tif (!(bctl->flags & BTRFS_BALANCE_RESUME)) {\n\t\tBUG_ON(ret == -EEXIST);\n\t\tset_balance_control(bctl);\n\t} else {\n\t\tBUG_ON(ret != -EEXIST);\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tupdate_balance_args(bctl);\n\t\tspin_unlock(&fs_info->balance_lock);\n\t}\n\n\tatomic_inc(&fs_info->balance_running);\n\tmutex_unlock(&fs_info->balance_mutex);\n\n\tret = __btrfs_balance(fs_info);\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tatomic_dec(&fs_info->balance_running);\n\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\tfs_info->num_tolerated_disk_barrier_failures =\n\t\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\t}\n\n\tif (bargs) {\n\t\tmemset(bargs, 0, sizeof(*bargs));\n\t\tupdate_ioctl_balance_args(fs_info, 0, bargs);\n\t}\n\n\tif ((ret && ret != -ECANCELED && ret != -ENOSPC) ||\n\t    balance_need_close(fs_info)) {\n\t\t__cancel_balance(fs_info);\n\t}\n\n\twake_up(&fs_info->balance_wait_q);\n\n\treturn ret;\nout:\n\tif (bctl->flags & BTRFS_BALANCE_RESUME)\n\t\t__cancel_balance(fs_info);\n\telse {\n\t\tkfree(bctl);\n\t\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__cancel_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3325-3335",
    "snippet": "static void __cancel_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\n\tunset_balance_control(fs_info);\n\tret = del_balance_item(fs_info->tree_root);\n\tif (ret)\n\t\tbtrfs_std_error(fs_info, ret);\n\n\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->mutually_exclusive_operation_running",
            "0"
          ],
          "line": 3334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_std_error",
          "args": [
            "fs_info",
            "ret"
          ],
          "line": 3332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_balance_item",
          "args": [
            "fs_info->tree_root"
          ],
          "line": 3330
        },
        "resolved": true,
        "details": {
          "function_name": "del_balance_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2826-2862",
          "snippet": "static int del_balance_item(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret, err;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_BALANCE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tbtrfs_free_path(path);\n\terr = btrfs_commit_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int del_balance_item(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret, err;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_BALANCE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tbtrfs_free_path(path);\n\terr = btrfs_commit_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unset_balance_control",
          "args": [
            "fs_info"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "unset_balance_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2920-2931",
          "snippet": "static void unset_balance_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tBUG_ON(!fs_info->balance_ctl);\n\n\tspin_lock(&fs_info->balance_lock);\n\tfs_info->balance_ctl = NULL;\n\tspin_unlock(&fs_info->balance_lock);\n\n\tkfree(bctl);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void unset_balance_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tBUG_ON(!fs_info->balance_ctl);\n\n\tspin_lock(&fs_info->balance_lock);\n\tfs_info->balance_ctl = NULL;\n\tspin_unlock(&fs_info->balance_lock);\n\n\tkfree(bctl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void __cancel_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\n\tunset_balance_control(fs_info);\n\tret = del_balance_item(fs_info->tree_root);\n\tif (ret)\n\t\tbtrfs_std_error(fs_info, ret);\n\n\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n}"
  },
  {
    "function_name": "balance_need_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3317-3323",
    "snippet": "static inline int balance_need_close(struct btrfs_fs_info *fs_info)\n{\n\t/* cancel requested || normal exit path */\n\treturn atomic_read(&fs_info->balance_cancel_req) ||\n\t\t(atomic_read(&fs_info->balance_pause_req) == 0 &&\n\t\t atomic_read(&fs_info->balance_cancel_req) == 0);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_cancel_req"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_pause_req"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_cancel_req"
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic inline int balance_need_close(struct btrfs_fs_info *fs_info)\n{\n\t/* cancel requested || normal exit path */\n\treturn atomic_read(&fs_info->balance_cancel_req) ||\n\t\t(atomic_read(&fs_info->balance_pause_req) == 0 &&\n\t\t atomic_read(&fs_info->balance_cancel_req) == 0);\n}"
  },
  {
    "function_name": "alloc_profile_is_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3298-3315",
    "snippet": "static int alloc_profile_is_valid(u64 flags, int extended)\n{\n\tu64 mask = (extended ? BTRFS_EXTENDED_PROFILE_MASK :\n\t\t\t       BTRFS_BLOCK_GROUP_PROFILE_MASK);\n\n\tflags &= ~BTRFS_BLOCK_GROUP_TYPE_MASK;\n\n\t/* 1) check that all other bits are zeroed */\n\tif (flags & ~mask)\n\t\treturn 0;\n\n\t/* 2) see if profile is reduced */\n\tif (flags == 0)\n\t\treturn !extended; /* \"0\" is valid for usual profiles */\n\n\t/* true if exactly one bit set */\n\treturn (flags & (flags - 1)) == 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int alloc_profile_is_valid(u64 flags, int extended)\n{\n\tu64 mask = (extended ? BTRFS_EXTENDED_PROFILE_MASK :\n\t\t\t       BTRFS_BLOCK_GROUP_PROFILE_MASK);\n\n\tflags &= ~BTRFS_BLOCK_GROUP_TYPE_MASK;\n\n\t/* 1) check that all other bits are zeroed */\n\tif (flags & ~mask)\n\t\treturn 0;\n\n\t/* 2) see if profile is reduced */\n\tif (flags == 0)\n\t\treturn !extended; /* \"0\" is valid for usual profiles */\n\n\t/* true if exactly one bit set */\n\treturn (flags & (flags - 1)) == 0;\n}"
  },
  {
    "function_name": "__btrfs_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3134-3291",
    "snippet": "static int __btrfs_balance(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\tstruct btrfs_root *chunk_root = fs_info->chunk_root;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct list_head *devices;\n\tstruct btrfs_device *device;\n\tu64 old_size;\n\tu64 size_to_free;\n\tstruct btrfs_chunk *chunk;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tint ret;\n\tint enospc_errors = 0;\n\tbool counting = true;\n\tu64 limit_data = bctl->data.limit;\n\tu64 limit_meta = bctl->meta.limit;\n\tu64 limit_sys = bctl->sys.limit;\n\n\t/* step one make some room on all the devices */\n\tdevices = &fs_info->fs_devices->devices;\n\tlist_for_each_entry(device, devices, dev_list) {\n\t\told_size = btrfs_device_get_total_bytes(device);\n\t\tsize_to_free = div_factor(old_size, 1);\n\t\tsize_to_free = min(size_to_free, (u64)1 * 1024 * 1024);\n\t\tif (!device->writeable ||\n\t\t    btrfs_device_get_total_bytes(device) -\n\t\t    btrfs_device_get_bytes_used(device) > size_to_free ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tret = btrfs_shrink_device(device, old_size - size_to_free);\n\t\tif (ret == -ENOSPC)\n\t\t\tbreak;\n\t\tBUG_ON(ret);\n\n\t\ttrans = btrfs_start_transaction(dev_root, 0);\n\t\tBUG_ON(IS_ERR(trans));\n\n\t\tret = btrfs_grow_device(trans, device, old_size);\n\t\tBUG_ON(ret);\n\n\t\tbtrfs_end_transaction(trans, dev_root);\n\t}\n\n\t/* step two, relocate all the chunks */\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t/* zero out stat counters */\n\tspin_lock(&fs_info->balance_lock);\n\tmemset(&bctl->stat, 0, sizeof(bctl->stat));\n\tspin_unlock(&fs_info->balance_lock);\nagain:\n\tif (!counting) {\n\t\tbctl->data.limit = limit_data;\n\t\tbctl->meta.limit = limit_meta;\n\t\tbctl->sys.limit = limit_sys;\n\t}\n\tkey.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\n\twhile (1) {\n\t\tif ((!counting && atomic_read(&fs_info->balance_pause_req)) ||\n\t\t    atomic_read(&fs_info->balance_cancel_req)) {\n\t\t\tret = -ECANCELED;\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = btrfs_search_slot(NULL, chunk_root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\t/*\n\t\t * this shouldn't happen, it means the last relocate\n\t\t * failed\n\t\t */\n\t\tif (ret == 0)\n\t\t\tBUG(); /* FIXME break ? */\n\n\t\tret = btrfs_previous_item(chunk_root, path, 0,\n\t\t\t\t\t  BTRFS_CHUNK_ITEM_KEY);\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid)\n\t\t\tbreak;\n\n\t\tchunk = btrfs_item_ptr(leaf, slot, struct btrfs_chunk);\n\n\t\tif (!counting) {\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->stat.considered++;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\t\t}\n\n\t\tret = should_balance_chunk(chunk_root, leaf, chunk,\n\t\t\t\t\t   found_key.offset);\n\t\tbtrfs_release_path(path);\n\t\tif (!ret)\n\t\t\tgoto loop;\n\n\t\tif (counting) {\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->stat.expected++;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\t\t\tgoto loop;\n\t\t}\n\n\t\tret = btrfs_relocate_chunk(chunk_root,\n\t\t\t\t\t   chunk_root->root_key.objectid,\n\t\t\t\t\t   found_key.objectid,\n\t\t\t\t\t   found_key.offset);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto error;\n\t\tif (ret == -ENOSPC) {\n\t\t\tenospc_errors++;\n\t\t} else {\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->stat.completed++;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\t\t}\nloop:\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t\tkey.offset = found_key.offset - 1;\n\t}\n\n\tif (counting) {\n\t\tbtrfs_release_path(path);\n\t\tcounting = false;\n\t\tgoto again;\n\t}\nerror:\n\tbtrfs_free_path(path);\n\tif (enospc_errors) {\n\t\tbtrfs_info(fs_info, \"%d enospc errors during balance\",\n\t\t       enospc_errors);\n\t\tif (!ret)\n\t\t\tret = -ENOSPC;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "fs_info",
            "\"%d enospc errors during balance\"",
            "enospc_errors"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 3282
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3277
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 3268
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_relocate_chunk",
          "args": [
            "chunk_root",
            "chunk_root->root_key.objectid",
            "found_key.objectid",
            "found_key.offset"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_relocate_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2666-2700",
          "snippet": "static int btrfs_relocate_chunk(struct btrfs_root *root,\n\t\t\t u64 chunk_tree, u64 chunk_objectid,\n\t\t\t u64 chunk_offset)\n{\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\troot = root->fs_info->chunk_root;\n\textent_root = root->fs_info->extent_root;\n\n\tret = btrfs_can_relocate(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn -ENOSPC;\n\n\t/* step one, relocate all the extents inside this chunk */\n\tret = btrfs_relocate_block_group(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * step two, delete the device extents and the\n\t * chunk tree entries\n\t */\n\tret = btrfs_remove_chunk(trans, root, chunk_offset);\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_relocate_chunk(struct btrfs_root *root,\n\t\t\t u64 chunk_tree, u64 chunk_objectid,\n\t\t\t u64 chunk_offset)\n{\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\troot = root->fs_info->chunk_root;\n\textent_root = root->fs_info->extent_root;\n\n\tret = btrfs_can_relocate(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn -ENOSPC;\n\n\t/* step one, relocate all the extents inside this chunk */\n\tret = btrfs_relocate_block_group(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * step two, delete the device extents and the\n\t * chunk tree entries\n\t */\n\tret = btrfs_remove_chunk(trans, root, chunk_offset);\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "should_balance_chunk",
          "args": [
            "chunk_root",
            "leaf",
            "chunk",
            "found_key.offset"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "should_balance_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3064-3132",
          "snippet": "static int should_balance_chunk(struct btrfs_root *root,\n\t\t\t\tstruct extent_buffer *leaf,\n\t\t\t\tstruct btrfs_chunk *chunk, u64 chunk_offset)\n{\n\tstruct btrfs_balance_control *bctl = root->fs_info->balance_ctl;\n\tstruct btrfs_balance_args *bargs = NULL;\n\tu64 chunk_type = btrfs_chunk_type(leaf, chunk);\n\n\t/* type filter */\n\tif (!((chunk_type & BTRFS_BLOCK_GROUP_TYPE_MASK) &\n\t      (bctl->flags & BTRFS_BALANCE_TYPE_MASK))) {\n\t\treturn 0;\n\t}\n\n\tif (chunk_type & BTRFS_BLOCK_GROUP_DATA)\n\t\tbargs = &bctl->data;\n\telse if (chunk_type & BTRFS_BLOCK_GROUP_SYSTEM)\n\t\tbargs = &bctl->sys;\n\telse if (chunk_type & BTRFS_BLOCK_GROUP_METADATA)\n\t\tbargs = &bctl->meta;\n\n\t/* profiles filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_PROFILES) &&\n\t    chunk_profiles_filter(chunk_type, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* usage filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    chunk_usage_filter(bctl->fs_info, chunk_offset, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* devid filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_DEVID) &&\n\t    chunk_devid_filter(leaf, chunk, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* drange filter, makes sense only with devid filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_DRANGE) &&\n\t    chunk_drange_filter(leaf, chunk, chunk_offset, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* vrange filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_VRANGE) &&\n\t    chunk_vrange_filter(leaf, chunk, chunk_offset, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* soft profile changing mode */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_SOFT) &&\n\t    chunk_soft_convert_filter(chunk_type, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * limited by count, must be the last filter\n\t */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_LIMIT)) {\n\t\tif (bargs->limit == 0)\n\t\t\treturn 0;\n\t\telse\n\t\t\tbargs->limit--;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int should_balance_chunk(struct btrfs_root *root,\n\t\t\t\tstruct extent_buffer *leaf,\n\t\t\t\tstruct btrfs_chunk *chunk, u64 chunk_offset)\n{\n\tstruct btrfs_balance_control *bctl = root->fs_info->balance_ctl;\n\tstruct btrfs_balance_args *bargs = NULL;\n\tu64 chunk_type = btrfs_chunk_type(leaf, chunk);\n\n\t/* type filter */\n\tif (!((chunk_type & BTRFS_BLOCK_GROUP_TYPE_MASK) &\n\t      (bctl->flags & BTRFS_BALANCE_TYPE_MASK))) {\n\t\treturn 0;\n\t}\n\n\tif (chunk_type & BTRFS_BLOCK_GROUP_DATA)\n\t\tbargs = &bctl->data;\n\telse if (chunk_type & BTRFS_BLOCK_GROUP_SYSTEM)\n\t\tbargs = &bctl->sys;\n\telse if (chunk_type & BTRFS_BLOCK_GROUP_METADATA)\n\t\tbargs = &bctl->meta;\n\n\t/* profiles filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_PROFILES) &&\n\t    chunk_profiles_filter(chunk_type, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* usage filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    chunk_usage_filter(bctl->fs_info, chunk_offset, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* devid filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_DEVID) &&\n\t    chunk_devid_filter(leaf, chunk, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* drange filter, makes sense only with devid filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_DRANGE) &&\n\t    chunk_drange_filter(leaf, chunk, chunk_offset, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* vrange filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_VRANGE) &&\n\t    chunk_vrange_filter(leaf, chunk, chunk_offset, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* soft profile changing mode */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_SOFT) &&\n\t    chunk_soft_convert_filter(chunk_type, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * limited by count, must be the last filter\n\t */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_LIMIT)) {\n\t\tif (bargs->limit == 0)\n\t\t\treturn 0;\n\t\telse\n\t\t\tbargs->limit--;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_chunk"
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&found_key",
            "slot"
          ],
          "line": 3231
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_previous_item",
          "args": [
            "chunk_root",
            "path",
            "0",
            "BTRFS_CHUNK_ITEM_KEY"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_previous_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5830-5865",
          "snippet": "int btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "chunk_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 3211
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_cancel_req"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_pause_req"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&bctl->stat",
            "0",
            "sizeof(bctl->stat)"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 3184
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "dev_root"
          ],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_grow_device",
          "args": [
            "trans",
            "device",
            "old_size"
          ],
          "line": 3177
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_grow_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2451-2487",
          "snippet": "int btrfs_grow_device(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_super_block *super_copy =\n\t\tdevice->dev_root->fs_info->super_copy;\n\tstruct btrfs_fs_devices *fs_devices;\n\tu64 old_total;\n\tu64 diff;\n\n\tif (!device->writeable)\n\t\treturn -EACCES;\n\n\tlock_chunks(device->dev_root);\n\told_total = btrfs_super_total_bytes(super_copy);\n\tdiff = new_size - device->total_bytes;\n\n\tif (new_size <= device->total_bytes ||\n\t    device->is_tgtdev_for_dev_replace) {\n\t\tunlock_chunks(device->dev_root);\n\t\treturn -EINVAL;\n\t}\n\n\tfs_devices = device->dev_root->fs_info->fs_devices;\n\n\tbtrfs_set_super_total_bytes(super_copy, old_total + diff);\n\tdevice->fs_devices->total_rw_bytes += diff;\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tbtrfs_clear_space_info_full(device->dev_root->fs_info);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &fs_devices->resized_devices);\n\tunlock_chunks(device->dev_root);\n\n\treturn btrfs_update_device(trans, device);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_grow_device(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_super_block *super_copy =\n\t\tdevice->dev_root->fs_info->super_copy;\n\tstruct btrfs_fs_devices *fs_devices;\n\tu64 old_total;\n\tu64 diff;\n\n\tif (!device->writeable)\n\t\treturn -EACCES;\n\n\tlock_chunks(device->dev_root);\n\told_total = btrfs_super_total_bytes(super_copy);\n\tdiff = new_size - device->total_bytes;\n\n\tif (new_size <= device->total_bytes ||\n\t    device->is_tgtdev_for_dev_replace) {\n\t\tunlock_chunks(device->dev_root);\n\t\treturn -EINVAL;\n\t}\n\n\tfs_devices = device->dev_root->fs_info->fs_devices;\n\n\tbtrfs_set_super_total_bytes(super_copy, old_total + diff);\n\tdevice->fs_devices->total_rw_bytes += diff;\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tbtrfs_clear_space_info_full(device->dev_root->fs_info);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &fs_devices->resized_devices);\n\tunlock_chunks(device->dev_root);\n\n\treturn btrfs_update_device(trans, device);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(trans)"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "dev_root",
            "0"
          ],
          "line": 3174
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_shrink_device",
          "args": [
            "device",
            "old_size - size_to_free"
          ],
          "line": 3169
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_shrink_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3953-4084",
          "snippet": "int btrfs_shrink_device(struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_path *path;\n\tu64 length;\n\tu64 chunk_tree;\n\tu64 chunk_objectid;\n\tu64 chunk_offset;\n\tint ret;\n\tint slot;\n\tint failed = 0;\n\tbool retried = false;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tu64 old_total = btrfs_super_total_bytes(super_copy);\n\tu64 old_size = btrfs_device_get_total_bytes(device);\n\tu64 diff = old_size - new_size;\n\n\tif (device->is_tgtdev_for_dev_replace)\n\t\treturn -EINVAL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->reada = 2;\n\n\tlock_chunks(root);\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tif (device->writeable) {\n\t\tdevice->fs_devices->total_rw_bytes -= diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space -= diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t}\n\tunlock_chunks(root);\n\nagain:\n\tkey.objectid = device->devid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tdo {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tret = btrfs_previous_item(root, path, 0, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(l, &key, path->slots[0]);\n\n\t\tif (key.objectid != device->devid) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\tlength = btrfs_dev_extent_length(l, dev_extent);\n\n\t\tif (key.offset + length <= new_size) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tchunk_tree = btrfs_dev_extent_chunk_tree(l, dev_extent);\n\t\tchunk_objectid = btrfs_dev_extent_chunk_objectid(l, dev_extent);\n\t\tchunk_offset = btrfs_dev_extent_chunk_offset(l, dev_extent);\n\t\tbtrfs_release_path(path);\n\n\t\tret = btrfs_relocate_chunk(root, chunk_tree, chunk_objectid,\n\t\t\t\t\t   chunk_offset);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto done;\n\t\tif (ret == -ENOSPC)\n\t\t\tfailed++;\n\t} while (key.offset-- > 0);\n\n\tif (failed && !retried) {\n\t\tfailed = 0;\n\t\tretried = true;\n\t\tgoto again;\n\t} else if (failed && retried) {\n\t\tret = -ENOSPC;\n\t\tlock_chunks(root);\n\n\t\tbtrfs_device_set_total_bytes(device, old_size);\n\t\tif (device->writeable)\n\t\t\tdevice->fs_devices->total_rw_bytes += diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space += diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t\tunlock_chunks(root);\n\t\tgoto done;\n\t}\n\n\t/* Shrinking succeeded, else we would be at \"done\". */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto done;\n\t}\n\n\tlock_chunks(root);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &root->fs_info->fs_devices->resized_devices);\n\n\tWARN_ON(diff > old_total);\n\tbtrfs_set_super_total_bytes(super_copy, old_total - diff);\n\tunlock_chunks(root);\n\n\t/* Now btrfs_update_device() will change the on-disk size. */\n\tret = btrfs_update_device(trans, device);\n\tbtrfs_end_transaction(trans, root);\ndone:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_shrink_device(struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_path *path;\n\tu64 length;\n\tu64 chunk_tree;\n\tu64 chunk_objectid;\n\tu64 chunk_offset;\n\tint ret;\n\tint slot;\n\tint failed = 0;\n\tbool retried = false;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tu64 old_total = btrfs_super_total_bytes(super_copy);\n\tu64 old_size = btrfs_device_get_total_bytes(device);\n\tu64 diff = old_size - new_size;\n\n\tif (device->is_tgtdev_for_dev_replace)\n\t\treturn -EINVAL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->reada = 2;\n\n\tlock_chunks(root);\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tif (device->writeable) {\n\t\tdevice->fs_devices->total_rw_bytes -= diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space -= diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t}\n\tunlock_chunks(root);\n\nagain:\n\tkey.objectid = device->devid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tdo {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tret = btrfs_previous_item(root, path, 0, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(l, &key, path->slots[0]);\n\n\t\tif (key.objectid != device->devid) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\tlength = btrfs_dev_extent_length(l, dev_extent);\n\n\t\tif (key.offset + length <= new_size) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tchunk_tree = btrfs_dev_extent_chunk_tree(l, dev_extent);\n\t\tchunk_objectid = btrfs_dev_extent_chunk_objectid(l, dev_extent);\n\t\tchunk_offset = btrfs_dev_extent_chunk_offset(l, dev_extent);\n\t\tbtrfs_release_path(path);\n\n\t\tret = btrfs_relocate_chunk(root, chunk_tree, chunk_objectid,\n\t\t\t\t\t   chunk_offset);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto done;\n\t\tif (ret == -ENOSPC)\n\t\t\tfailed++;\n\t} while (key.offset-- > 0);\n\n\tif (failed && !retried) {\n\t\tfailed = 0;\n\t\tretried = true;\n\t\tgoto again;\n\t} else if (failed && retried) {\n\t\tret = -ENOSPC;\n\t\tlock_chunks(root);\n\n\t\tbtrfs_device_set_total_bytes(device, old_size);\n\t\tif (device->writeable)\n\t\t\tdevice->fs_devices->total_rw_bytes += diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space += diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t\tunlock_chunks(root);\n\t\tgoto done;\n\t}\n\n\t/* Shrinking succeeded, else we would be at \"done\". */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto done;\n\t}\n\n\tlock_chunks(root);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &root->fs_info->fs_devices->resized_devices);\n\n\tWARN_ON(diff > old_total);\n\tbtrfs_set_super_total_bytes(super_copy, old_total - diff);\n\tunlock_chunks(root);\n\n\t/* Now btrfs_update_device() will change the on-disk size. */\n\tret = btrfs_update_device(trans, device);\n\tbtrfs_end_transaction(trans, root);\ndone:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_bytes_used",
          "args": [
            "device"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_total_bytes",
          "args": [
            "device"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "size_to_free",
            "(u64)1 * 1024 * 1024"
          ],
          "line": 3162
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_factor",
          "args": [
            "old_size",
            "1"
          ],
          "line": 3161
        },
        "resolved": true,
        "details": {
          "function_name": "div_factor_fine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/math.h",
          "lines": "35-42",
          "snippet": "static inline u64 div_factor_fine(u64 num, int factor)\n{\n\tif (factor == 100)\n\t\treturn num;\n\tnum *= factor;\n\tdo_div(num, 100);\n\treturn num;\n}",
          "includes": [
            "#include <asm/div64.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/div64.h>\n\nstatic inline u64 div_factor_fine(u64 num, int factor)\n{\n\tif (factor == 100)\n\t\treturn num;\n\tnum *= factor;\n\tdo_div(num, 100);\n\treturn num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_total_bytes",
          "args": [
            "device"
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "devices",
            "dev_list"
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_balance(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\tstruct btrfs_root *chunk_root = fs_info->chunk_root;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct list_head *devices;\n\tstruct btrfs_device *device;\n\tu64 old_size;\n\tu64 size_to_free;\n\tstruct btrfs_chunk *chunk;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tint ret;\n\tint enospc_errors = 0;\n\tbool counting = true;\n\tu64 limit_data = bctl->data.limit;\n\tu64 limit_meta = bctl->meta.limit;\n\tu64 limit_sys = bctl->sys.limit;\n\n\t/* step one make some room on all the devices */\n\tdevices = &fs_info->fs_devices->devices;\n\tlist_for_each_entry(device, devices, dev_list) {\n\t\told_size = btrfs_device_get_total_bytes(device);\n\t\tsize_to_free = div_factor(old_size, 1);\n\t\tsize_to_free = min(size_to_free, (u64)1 * 1024 * 1024);\n\t\tif (!device->writeable ||\n\t\t    btrfs_device_get_total_bytes(device) -\n\t\t    btrfs_device_get_bytes_used(device) > size_to_free ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tret = btrfs_shrink_device(device, old_size - size_to_free);\n\t\tif (ret == -ENOSPC)\n\t\t\tbreak;\n\t\tBUG_ON(ret);\n\n\t\ttrans = btrfs_start_transaction(dev_root, 0);\n\t\tBUG_ON(IS_ERR(trans));\n\n\t\tret = btrfs_grow_device(trans, device, old_size);\n\t\tBUG_ON(ret);\n\n\t\tbtrfs_end_transaction(trans, dev_root);\n\t}\n\n\t/* step two, relocate all the chunks */\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t/* zero out stat counters */\n\tspin_lock(&fs_info->balance_lock);\n\tmemset(&bctl->stat, 0, sizeof(bctl->stat));\n\tspin_unlock(&fs_info->balance_lock);\nagain:\n\tif (!counting) {\n\t\tbctl->data.limit = limit_data;\n\t\tbctl->meta.limit = limit_meta;\n\t\tbctl->sys.limit = limit_sys;\n\t}\n\tkey.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\n\twhile (1) {\n\t\tif ((!counting && atomic_read(&fs_info->balance_pause_req)) ||\n\t\t    atomic_read(&fs_info->balance_cancel_req)) {\n\t\t\tret = -ECANCELED;\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = btrfs_search_slot(NULL, chunk_root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\t/*\n\t\t * this shouldn't happen, it means the last relocate\n\t\t * failed\n\t\t */\n\t\tif (ret == 0)\n\t\t\tBUG(); /* FIXME break ? */\n\n\t\tret = btrfs_previous_item(chunk_root, path, 0,\n\t\t\t\t\t  BTRFS_CHUNK_ITEM_KEY);\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid)\n\t\t\tbreak;\n\n\t\tchunk = btrfs_item_ptr(leaf, slot, struct btrfs_chunk);\n\n\t\tif (!counting) {\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->stat.considered++;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\t\t}\n\n\t\tret = should_balance_chunk(chunk_root, leaf, chunk,\n\t\t\t\t\t   found_key.offset);\n\t\tbtrfs_release_path(path);\n\t\tif (!ret)\n\t\t\tgoto loop;\n\n\t\tif (counting) {\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->stat.expected++;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\t\t\tgoto loop;\n\t\t}\n\n\t\tret = btrfs_relocate_chunk(chunk_root,\n\t\t\t\t\t   chunk_root->root_key.objectid,\n\t\t\t\t\t   found_key.objectid,\n\t\t\t\t\t   found_key.offset);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto error;\n\t\tif (ret == -ENOSPC) {\n\t\t\tenospc_errors++;\n\t\t} else {\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->stat.completed++;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\t\t}\nloop:\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t\tkey.offset = found_key.offset - 1;\n\t}\n\n\tif (counting) {\n\t\tbtrfs_release_path(path);\n\t\tcounting = false;\n\t\tgoto again;\n\t}\nerror:\n\tbtrfs_free_path(path);\n\tif (enospc_errors) {\n\t\tbtrfs_info(fs_info, \"%d enospc errors during balance\",\n\t\t       enospc_errors);\n\t\tif (!ret)\n\t\t\tret = -ENOSPC;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "should_balance_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3064-3132",
    "snippet": "static int should_balance_chunk(struct btrfs_root *root,\n\t\t\t\tstruct extent_buffer *leaf,\n\t\t\t\tstruct btrfs_chunk *chunk, u64 chunk_offset)\n{\n\tstruct btrfs_balance_control *bctl = root->fs_info->balance_ctl;\n\tstruct btrfs_balance_args *bargs = NULL;\n\tu64 chunk_type = btrfs_chunk_type(leaf, chunk);\n\n\t/* type filter */\n\tif (!((chunk_type & BTRFS_BLOCK_GROUP_TYPE_MASK) &\n\t      (bctl->flags & BTRFS_BALANCE_TYPE_MASK))) {\n\t\treturn 0;\n\t}\n\n\tif (chunk_type & BTRFS_BLOCK_GROUP_DATA)\n\t\tbargs = &bctl->data;\n\telse if (chunk_type & BTRFS_BLOCK_GROUP_SYSTEM)\n\t\tbargs = &bctl->sys;\n\telse if (chunk_type & BTRFS_BLOCK_GROUP_METADATA)\n\t\tbargs = &bctl->meta;\n\n\t/* profiles filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_PROFILES) &&\n\t    chunk_profiles_filter(chunk_type, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* usage filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    chunk_usage_filter(bctl->fs_info, chunk_offset, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* devid filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_DEVID) &&\n\t    chunk_devid_filter(leaf, chunk, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* drange filter, makes sense only with devid filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_DRANGE) &&\n\t    chunk_drange_filter(leaf, chunk, chunk_offset, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* vrange filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_VRANGE) &&\n\t    chunk_vrange_filter(leaf, chunk, chunk_offset, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* soft profile changing mode */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_SOFT) &&\n\t    chunk_soft_convert_filter(chunk_type, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * limited by count, must be the last filter\n\t */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_LIMIT)) {\n\t\tif (bargs->limit == 0)\n\t\t\treturn 0;\n\t\telse\n\t\t\tbargs->limit--;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chunk_soft_convert_filter",
          "args": [
            "chunk_type",
            "bargs"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_soft_convert_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3049-3062",
          "snippet": "static int chunk_soft_convert_filter(u64 chunk_type,\n\t\t\t\t     struct btrfs_balance_args *bargs)\n{\n\tif (!(bargs->flags & BTRFS_BALANCE_ARGS_CONVERT))\n\t\treturn 0;\n\n\tchunk_type = chunk_to_extended(chunk_type) &\n\t\t\t\tBTRFS_EXTENDED_PROFILE_MASK;\n\n\tif (bargs->target == chunk_type)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int chunk_soft_convert_filter(u64 chunk_type,\n\t\t\t\t     struct btrfs_balance_args *bargs)\n{\n\tif (!(bargs->flags & BTRFS_BALANCE_ARGS_CONVERT))\n\t\treturn 0;\n\n\tchunk_type = chunk_to_extended(chunk_type) &\n\t\t\t\tBTRFS_EXTENDED_PROFILE_MASK;\n\n\tif (bargs->target == chunk_type)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chunk_vrange_filter",
          "args": [
            "leaf",
            "chunk",
            "chunk_offset",
            "bargs"
          ],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_vrange_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3036-3047",
          "snippet": "static int chunk_vrange_filter(struct extent_buffer *leaf,\n\t\t\t       struct btrfs_chunk *chunk,\n\t\t\t       u64 chunk_offset,\n\t\t\t       struct btrfs_balance_args *bargs)\n{\n\tif (chunk_offset < bargs->vend &&\n\t    chunk_offset + btrfs_chunk_length(leaf, chunk) > bargs->vstart)\n\t\t/* at least part of the chunk is inside this vrange */\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int chunk_vrange_filter(struct extent_buffer *leaf,\n\t\t\t       struct btrfs_chunk *chunk,\n\t\t\t       u64 chunk_offset,\n\t\t\t       struct btrfs_balance_args *bargs)\n{\n\tif (chunk_offset < bargs->vend &&\n\t    chunk_offset + btrfs_chunk_length(leaf, chunk) > bargs->vstart)\n\t\t/* at least part of the chunk is inside this vrange */\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chunk_drange_filter",
          "args": [
            "leaf",
            "chunk",
            "chunk_offset",
            "bargs"
          ],
          "line": 3105
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_drange_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2992-3033",
          "snippet": "static int chunk_drange_filter(struct extent_buffer *leaf,\n\t\t\t       struct btrfs_chunk *chunk,\n\t\t\t       u64 chunk_offset,\n\t\t\t       struct btrfs_balance_args *bargs)\n{\n\tstruct btrfs_stripe *stripe;\n\tint num_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tu64 stripe_offset;\n\tu64 stripe_length;\n\tint factor;\n\tint i;\n\n\tif (!(bargs->flags & BTRFS_BALANCE_ARGS_DEVID))\n\t\treturn 0;\n\n\tif (btrfs_chunk_type(leaf, chunk) & (BTRFS_BLOCK_GROUP_DUP |\n\t     BTRFS_BLOCK_GROUP_RAID1 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\tfactor = num_stripes / 2;\n\t} else if (btrfs_chunk_type(leaf, chunk) & BTRFS_BLOCK_GROUP_RAID5) {\n\t\tfactor = num_stripes - 1;\n\t} else if (btrfs_chunk_type(leaf, chunk) & BTRFS_BLOCK_GROUP_RAID6) {\n\t\tfactor = num_stripes - 2;\n\t} else {\n\t\tfactor = num_stripes;\n\t}\n\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tstripe = btrfs_stripe_nr(chunk, i);\n\t\tif (btrfs_stripe_devid(leaf, stripe) != bargs->devid)\n\t\t\tcontinue;\n\n\t\tstripe_offset = btrfs_stripe_offset(leaf, stripe);\n\t\tstripe_length = btrfs_chunk_length(leaf, chunk);\n\t\tdo_div(stripe_length, factor);\n\n\t\tif (stripe_offset < bargs->pend &&\n\t\t    stripe_offset + stripe_length > bargs->pstart)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int chunk_drange_filter(struct extent_buffer *leaf,\n\t\t\t       struct btrfs_chunk *chunk,\n\t\t\t       u64 chunk_offset,\n\t\t\t       struct btrfs_balance_args *bargs)\n{\n\tstruct btrfs_stripe *stripe;\n\tint num_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tu64 stripe_offset;\n\tu64 stripe_length;\n\tint factor;\n\tint i;\n\n\tif (!(bargs->flags & BTRFS_BALANCE_ARGS_DEVID))\n\t\treturn 0;\n\n\tif (btrfs_chunk_type(leaf, chunk) & (BTRFS_BLOCK_GROUP_DUP |\n\t     BTRFS_BLOCK_GROUP_RAID1 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\tfactor = num_stripes / 2;\n\t} else if (btrfs_chunk_type(leaf, chunk) & BTRFS_BLOCK_GROUP_RAID5) {\n\t\tfactor = num_stripes - 1;\n\t} else if (btrfs_chunk_type(leaf, chunk) & BTRFS_BLOCK_GROUP_RAID6) {\n\t\tfactor = num_stripes - 2;\n\t} else {\n\t\tfactor = num_stripes;\n\t}\n\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tstripe = btrfs_stripe_nr(chunk, i);\n\t\tif (btrfs_stripe_devid(leaf, stripe) != bargs->devid)\n\t\t\tcontinue;\n\n\t\tstripe_offset = btrfs_stripe_offset(leaf, stripe);\n\t\tstripe_length = btrfs_chunk_length(leaf, chunk);\n\t\tdo_div(stripe_length, factor);\n\n\t\tif (stripe_offset < bargs->pend &&\n\t\t    stripe_offset + stripe_length > bargs->pstart)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chunk_devid_filter",
          "args": [
            "leaf",
            "chunk",
            "bargs"
          ],
          "line": 3099
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_devid_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2974-2989",
          "snippet": "static int chunk_devid_filter(struct extent_buffer *leaf,\n\t\t\t      struct btrfs_chunk *chunk,\n\t\t\t      struct btrfs_balance_args *bargs)\n{\n\tstruct btrfs_stripe *stripe;\n\tint num_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tint i;\n\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tstripe = btrfs_stripe_nr(chunk, i);\n\t\tif (btrfs_stripe_devid(leaf, stripe) == bargs->devid)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int chunk_devid_filter(struct extent_buffer *leaf,\n\t\t\t      struct btrfs_chunk *chunk,\n\t\t\t      struct btrfs_balance_args *bargs)\n{\n\tstruct btrfs_stripe *stripe;\n\tint num_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tint i;\n\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tstripe = btrfs_stripe_nr(chunk, i);\n\t\tif (btrfs_stripe_devid(leaf, stripe) == bargs->devid)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chunk_usage_filter",
          "args": [
            "bctl->fs_info",
            "chunk_offset",
            "bargs"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_usage_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2949-2972",
          "snippet": "static int chunk_usage_filter(struct btrfs_fs_info *fs_info, u64 chunk_offset,\n\t\t\t      struct btrfs_balance_args *bargs)\n{\n\tstruct btrfs_block_group_cache *cache;\n\tu64 chunk_used, user_thresh;\n\tint ret = 1;\n\n\tcache = btrfs_lookup_block_group(fs_info, chunk_offset);\n\tchunk_used = btrfs_block_group_used(&cache->item);\n\n\tif (bargs->usage == 0)\n\t\tuser_thresh = 1;\n\telse if (bargs->usage > 100)\n\t\tuser_thresh = cache->key.offset;\n\telse\n\t\tuser_thresh = div_factor_fine(cache->key.offset,\n\t\t\t\t\t      bargs->usage);\n\n\tif (chunk_used < user_thresh)\n\t\tret = 0;\n\n\tbtrfs_put_block_group(cache);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int chunk_usage_filter(struct btrfs_fs_info *fs_info, u64 chunk_offset,\n\t\t\t      struct btrfs_balance_args *bargs)\n{\n\tstruct btrfs_block_group_cache *cache;\n\tu64 chunk_used, user_thresh;\n\tint ret = 1;\n\n\tcache = btrfs_lookup_block_group(fs_info, chunk_offset);\n\tchunk_used = btrfs_block_group_used(&cache->item);\n\n\tif (bargs->usage == 0)\n\t\tuser_thresh = 1;\n\telse if (bargs->usage > 100)\n\t\tuser_thresh = cache->key.offset;\n\telse\n\t\tuser_thresh = div_factor_fine(cache->key.offset,\n\t\t\t\t\t      bargs->usage);\n\n\tif (chunk_used < user_thresh)\n\t\tret = 0;\n\n\tbtrfs_put_block_group(cache);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chunk_profiles_filter",
          "args": [
            "chunk_type",
            "bargs"
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_profiles_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2937-2947",
          "snippet": "static int chunk_profiles_filter(u64 chunk_type,\n\t\t\t\t struct btrfs_balance_args *bargs)\n{\n\tchunk_type = chunk_to_extended(chunk_type) &\n\t\t\t\tBTRFS_EXTENDED_PROFILE_MASK;\n\n\tif (bargs->profiles & chunk_type)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int chunk_profiles_filter(u64 chunk_type,\n\t\t\t\t struct btrfs_balance_args *bargs)\n{\n\tchunk_type = chunk_to_extended(chunk_type) &\n\t\t\t\tBTRFS_EXTENDED_PROFILE_MASK;\n\n\tif (bargs->profiles & chunk_type)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_type",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int should_balance_chunk(struct btrfs_root *root,\n\t\t\t\tstruct extent_buffer *leaf,\n\t\t\t\tstruct btrfs_chunk *chunk, u64 chunk_offset)\n{\n\tstruct btrfs_balance_control *bctl = root->fs_info->balance_ctl;\n\tstruct btrfs_balance_args *bargs = NULL;\n\tu64 chunk_type = btrfs_chunk_type(leaf, chunk);\n\n\t/* type filter */\n\tif (!((chunk_type & BTRFS_BLOCK_GROUP_TYPE_MASK) &\n\t      (bctl->flags & BTRFS_BALANCE_TYPE_MASK))) {\n\t\treturn 0;\n\t}\n\n\tif (chunk_type & BTRFS_BLOCK_GROUP_DATA)\n\t\tbargs = &bctl->data;\n\telse if (chunk_type & BTRFS_BLOCK_GROUP_SYSTEM)\n\t\tbargs = &bctl->sys;\n\telse if (chunk_type & BTRFS_BLOCK_GROUP_METADATA)\n\t\tbargs = &bctl->meta;\n\n\t/* profiles filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_PROFILES) &&\n\t    chunk_profiles_filter(chunk_type, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* usage filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    chunk_usage_filter(bctl->fs_info, chunk_offset, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* devid filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_DEVID) &&\n\t    chunk_devid_filter(leaf, chunk, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* drange filter, makes sense only with devid filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_DRANGE) &&\n\t    chunk_drange_filter(leaf, chunk, chunk_offset, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* vrange filter */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_VRANGE) &&\n\t    chunk_vrange_filter(leaf, chunk, chunk_offset, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/* soft profile changing mode */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_SOFT) &&\n\t    chunk_soft_convert_filter(chunk_type, bargs)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * limited by count, must be the last filter\n\t */\n\tif ((bargs->flags & BTRFS_BALANCE_ARGS_LIMIT)) {\n\t\tif (bargs->limit == 0)\n\t\t\treturn 0;\n\t\telse\n\t\t\tbargs->limit--;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "chunk_soft_convert_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3049-3062",
    "snippet": "static int chunk_soft_convert_filter(u64 chunk_type,\n\t\t\t\t     struct btrfs_balance_args *bargs)\n{\n\tif (!(bargs->flags & BTRFS_BALANCE_ARGS_CONVERT))\n\t\treturn 0;\n\n\tchunk_type = chunk_to_extended(chunk_type) &\n\t\t\t\tBTRFS_EXTENDED_PROFILE_MASK;\n\n\tif (bargs->target == chunk_type)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chunk_to_extended",
          "args": [
            "chunk_type"
          ],
          "line": 3055
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_to_extended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "1046-1052",
          "snippet": "static inline u64 chunk_to_extended(u64 flags)\n{\n\tif ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK) == 0)\n\t\tflags |= BTRFS_AVAIL_ALLOC_BIT_SINGLE;\n\n\treturn flags;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_AVAIL_ALLOC_BIT_SINGLE\t(1ULL << 48)",
            "#define BTRFS_BLOCK_GROUP_PROFILE_MASK\t(BTRFS_BLOCK_GROUP_RAID0 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID1 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID5 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID6 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_DUP |     \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID10)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_AVAIL_ALLOC_BIT_SINGLE\t(1ULL << 48)\n#define BTRFS_BLOCK_GROUP_PROFILE_MASK\t(BTRFS_BLOCK_GROUP_RAID0 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID1 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID5 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID6 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_DUP |     \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID10)\n\nstatic inline u64 chunk_to_extended(u64 flags)\n{\n\tif ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK) == 0)\n\t\tflags |= BTRFS_AVAIL_ALLOC_BIT_SINGLE;\n\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int chunk_soft_convert_filter(u64 chunk_type,\n\t\t\t\t     struct btrfs_balance_args *bargs)\n{\n\tif (!(bargs->flags & BTRFS_BALANCE_ARGS_CONVERT))\n\t\treturn 0;\n\n\tchunk_type = chunk_to_extended(chunk_type) &\n\t\t\t\tBTRFS_EXTENDED_PROFILE_MASK;\n\n\tif (bargs->target == chunk_type)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "chunk_vrange_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "3036-3047",
    "snippet": "static int chunk_vrange_filter(struct extent_buffer *leaf,\n\t\t\t       struct btrfs_chunk *chunk,\n\t\t\t       u64 chunk_offset,\n\t\t\t       struct btrfs_balance_args *bargs)\n{\n\tif (chunk_offset < bargs->vend &&\n\t    chunk_offset + btrfs_chunk_length(leaf, chunk) > bargs->vstart)\n\t\t/* at least part of the chunk is inside this vrange */\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_chunk_length",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int chunk_vrange_filter(struct extent_buffer *leaf,\n\t\t\t       struct btrfs_chunk *chunk,\n\t\t\t       u64 chunk_offset,\n\t\t\t       struct btrfs_balance_args *bargs)\n{\n\tif (chunk_offset < bargs->vend &&\n\t    chunk_offset + btrfs_chunk_length(leaf, chunk) > bargs->vstart)\n\t\t/* at least part of the chunk is inside this vrange */\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "chunk_drange_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2992-3033",
    "snippet": "static int chunk_drange_filter(struct extent_buffer *leaf,\n\t\t\t       struct btrfs_chunk *chunk,\n\t\t\t       u64 chunk_offset,\n\t\t\t       struct btrfs_balance_args *bargs)\n{\n\tstruct btrfs_stripe *stripe;\n\tint num_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tu64 stripe_offset;\n\tu64 stripe_length;\n\tint factor;\n\tint i;\n\n\tif (!(bargs->flags & BTRFS_BALANCE_ARGS_DEVID))\n\t\treturn 0;\n\n\tif (btrfs_chunk_type(leaf, chunk) & (BTRFS_BLOCK_GROUP_DUP |\n\t     BTRFS_BLOCK_GROUP_RAID1 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\tfactor = num_stripes / 2;\n\t} else if (btrfs_chunk_type(leaf, chunk) & BTRFS_BLOCK_GROUP_RAID5) {\n\t\tfactor = num_stripes - 1;\n\t} else if (btrfs_chunk_type(leaf, chunk) & BTRFS_BLOCK_GROUP_RAID6) {\n\t\tfactor = num_stripes - 2;\n\t} else {\n\t\tfactor = num_stripes;\n\t}\n\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tstripe = btrfs_stripe_nr(chunk, i);\n\t\tif (btrfs_stripe_devid(leaf, stripe) != bargs->devid)\n\t\t\tcontinue;\n\n\t\tstripe_offset = btrfs_stripe_offset(leaf, stripe);\n\t\tstripe_length = btrfs_chunk_length(leaf, chunk);\n\t\tdo_div(stripe_length, factor);\n\n\t\tif (stripe_offset < bargs->pend &&\n\t\t    stripe_offset + stripe_length > bargs->pstart)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stripe_length",
            "factor"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_length",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stripe_offset",
          "args": [
            "leaf",
            "stripe"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stripe_devid",
          "args": [
            "leaf",
            "stripe"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stripe_nr",
          "args": [
            "chunk",
            "i"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_stripe_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2392-2399",
          "snippet": "static inline struct btrfs_stripe *btrfs_stripe_nr(struct btrfs_chunk *c,\n\t\t\t\t\t\t   int nr)\n{\n\tunsigned long offset = (unsigned long)c;\n\toffset += offsetof(struct btrfs_chunk, stripe);\n\toffset += nr * sizeof(struct btrfs_stripe);\n\treturn (struct btrfs_stripe *)offset;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_stripe *btrfs_stripe_nr(struct btrfs_chunk *c,\n\t\t\t\t\t\t   int nr)\n{\n\tunsigned long offset = (unsigned long)c;\n\toffset += offsetof(struct btrfs_chunk, stripe);\n\toffset += nr * sizeof(struct btrfs_stripe);\n\treturn (struct btrfs_stripe *)offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_type",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_type",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_type",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_num_stripes",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int chunk_drange_filter(struct extent_buffer *leaf,\n\t\t\t       struct btrfs_chunk *chunk,\n\t\t\t       u64 chunk_offset,\n\t\t\t       struct btrfs_balance_args *bargs)\n{\n\tstruct btrfs_stripe *stripe;\n\tint num_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tu64 stripe_offset;\n\tu64 stripe_length;\n\tint factor;\n\tint i;\n\n\tif (!(bargs->flags & BTRFS_BALANCE_ARGS_DEVID))\n\t\treturn 0;\n\n\tif (btrfs_chunk_type(leaf, chunk) & (BTRFS_BLOCK_GROUP_DUP |\n\t     BTRFS_BLOCK_GROUP_RAID1 | BTRFS_BLOCK_GROUP_RAID10)) {\n\t\tfactor = num_stripes / 2;\n\t} else if (btrfs_chunk_type(leaf, chunk) & BTRFS_BLOCK_GROUP_RAID5) {\n\t\tfactor = num_stripes - 1;\n\t} else if (btrfs_chunk_type(leaf, chunk) & BTRFS_BLOCK_GROUP_RAID6) {\n\t\tfactor = num_stripes - 2;\n\t} else {\n\t\tfactor = num_stripes;\n\t}\n\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tstripe = btrfs_stripe_nr(chunk, i);\n\t\tif (btrfs_stripe_devid(leaf, stripe) != bargs->devid)\n\t\t\tcontinue;\n\n\t\tstripe_offset = btrfs_stripe_offset(leaf, stripe);\n\t\tstripe_length = btrfs_chunk_length(leaf, chunk);\n\t\tdo_div(stripe_length, factor);\n\n\t\tif (stripe_offset < bargs->pend &&\n\t\t    stripe_offset + stripe_length > bargs->pstart)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "chunk_devid_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2974-2989",
    "snippet": "static int chunk_devid_filter(struct extent_buffer *leaf,\n\t\t\t      struct btrfs_chunk *chunk,\n\t\t\t      struct btrfs_balance_args *bargs)\n{\n\tstruct btrfs_stripe *stripe;\n\tint num_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tint i;\n\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tstripe = btrfs_stripe_nr(chunk, i);\n\t\tif (btrfs_stripe_devid(leaf, stripe) == bargs->devid)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_stripe_devid",
          "args": [
            "leaf",
            "stripe"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stripe_nr",
          "args": [
            "chunk",
            "i"
          ],
          "line": 2983
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_stripe_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2392-2399",
          "snippet": "static inline struct btrfs_stripe *btrfs_stripe_nr(struct btrfs_chunk *c,\n\t\t\t\t\t\t   int nr)\n{\n\tunsigned long offset = (unsigned long)c;\n\toffset += offsetof(struct btrfs_chunk, stripe);\n\toffset += nr * sizeof(struct btrfs_stripe);\n\treturn (struct btrfs_stripe *)offset;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_stripe *btrfs_stripe_nr(struct btrfs_chunk *c,\n\t\t\t\t\t\t   int nr)\n{\n\tunsigned long offset = (unsigned long)c;\n\toffset += offsetof(struct btrfs_chunk, stripe);\n\toffset += nr * sizeof(struct btrfs_stripe);\n\treturn (struct btrfs_stripe *)offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_num_stripes",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int chunk_devid_filter(struct extent_buffer *leaf,\n\t\t\t      struct btrfs_chunk *chunk,\n\t\t\t      struct btrfs_balance_args *bargs)\n{\n\tstruct btrfs_stripe *stripe;\n\tint num_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tint i;\n\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tstripe = btrfs_stripe_nr(chunk, i);\n\t\tif (btrfs_stripe_devid(leaf, stripe) == bargs->devid)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "chunk_usage_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2949-2972",
    "snippet": "static int chunk_usage_filter(struct btrfs_fs_info *fs_info, u64 chunk_offset,\n\t\t\t      struct btrfs_balance_args *bargs)\n{\n\tstruct btrfs_block_group_cache *cache;\n\tu64 chunk_used, user_thresh;\n\tint ret = 1;\n\n\tcache = btrfs_lookup_block_group(fs_info, chunk_offset);\n\tchunk_used = btrfs_block_group_used(&cache->item);\n\n\tif (bargs->usage == 0)\n\t\tuser_thresh = 1;\n\telse if (bargs->usage > 100)\n\t\tuser_thresh = cache->key.offset;\n\telse\n\t\tuser_thresh = div_factor_fine(cache->key.offset,\n\t\t\t\t\t      bargs->usage);\n\n\tif (chunk_used < user_thresh)\n\t\tret = 0;\n\n\tbtrfs_put_block_group(cache);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_block_group",
          "args": [
            "cache"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_block_group_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8797-8829",
          "snippet": "void btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nvoid btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_factor_fine",
          "args": [
            "cache->key.offset",
            "bargs->usage"
          ],
          "line": 2964
        },
        "resolved": true,
        "details": {
          "function_name": "div_factor_fine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/math.h",
          "lines": "35-42",
          "snippet": "static inline u64 div_factor_fine(u64 num, int factor)\n{\n\tif (factor == 100)\n\t\treturn num;\n\tnum *= factor;\n\tdo_div(num, 100);\n\treturn num;\n}",
          "includes": [
            "#include <asm/div64.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/div64.h>\n\nstatic inline u64 div_factor_fine(u64 num, int factor)\n{\n\tif (factor == 100)\n\t\treturn num;\n\tnum *= factor;\n\tdo_div(num, 100);\n\treturn num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_block_group_used",
          "args": [
            "&cache->item"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_block_group",
          "args": [
            "fs_info",
            "chunk_offset"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_block_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "669-678",
          "snippet": "struct btrfs_block_group_cache *btrfs_lookup_block_group(\n\t\t\t\t\t\t struct btrfs_fs_info *info,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = block_group_cache_tree_search(info, bytenr, 1);\n\n\treturn cache;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_block_group_cache *btrfs_lookup_block_group(\n\t\t\t\t\t\t struct btrfs_fs_info *info,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = block_group_cache_tree_search(info, bytenr, 1);\n\n\treturn cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int chunk_usage_filter(struct btrfs_fs_info *fs_info, u64 chunk_offset,\n\t\t\t      struct btrfs_balance_args *bargs)\n{\n\tstruct btrfs_block_group_cache *cache;\n\tu64 chunk_used, user_thresh;\n\tint ret = 1;\n\n\tcache = btrfs_lookup_block_group(fs_info, chunk_offset);\n\tchunk_used = btrfs_block_group_used(&cache->item);\n\n\tif (bargs->usage == 0)\n\t\tuser_thresh = 1;\n\telse if (bargs->usage > 100)\n\t\tuser_thresh = cache->key.offset;\n\telse\n\t\tuser_thresh = div_factor_fine(cache->key.offset,\n\t\t\t\t\t      bargs->usage);\n\n\tif (chunk_used < user_thresh)\n\t\tret = 0;\n\n\tbtrfs_put_block_group(cache);\n\treturn ret;\n}"
  },
  {
    "function_name": "chunk_profiles_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2937-2947",
    "snippet": "static int chunk_profiles_filter(u64 chunk_type,\n\t\t\t\t struct btrfs_balance_args *bargs)\n{\n\tchunk_type = chunk_to_extended(chunk_type) &\n\t\t\t\tBTRFS_EXTENDED_PROFILE_MASK;\n\n\tif (bargs->profiles & chunk_type)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chunk_to_extended",
          "args": [
            "chunk_type"
          ],
          "line": 2940
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_to_extended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "1046-1052",
          "snippet": "static inline u64 chunk_to_extended(u64 flags)\n{\n\tif ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK) == 0)\n\t\tflags |= BTRFS_AVAIL_ALLOC_BIT_SINGLE;\n\n\treturn flags;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_AVAIL_ALLOC_BIT_SINGLE\t(1ULL << 48)",
            "#define BTRFS_BLOCK_GROUP_PROFILE_MASK\t(BTRFS_BLOCK_GROUP_RAID0 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID1 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID5 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID6 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_DUP |     \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID10)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_AVAIL_ALLOC_BIT_SINGLE\t(1ULL << 48)\n#define BTRFS_BLOCK_GROUP_PROFILE_MASK\t(BTRFS_BLOCK_GROUP_RAID0 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID1 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID5 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID6 |   \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_DUP |     \\\n\t\t\t\t\t BTRFS_BLOCK_GROUP_RAID10)\n\nstatic inline u64 chunk_to_extended(u64 flags)\n{\n\tif ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK) == 0)\n\t\tflags |= BTRFS_AVAIL_ALLOC_BIT_SINGLE;\n\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int chunk_profiles_filter(u64 chunk_type,\n\t\t\t\t struct btrfs_balance_args *bargs)\n{\n\tchunk_type = chunk_to_extended(chunk_type) &\n\t\t\t\tBTRFS_EXTENDED_PROFILE_MASK;\n\n\tif (bargs->profiles & chunk_type)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "unset_balance_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2920-2931",
    "snippet": "static void unset_balance_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tBUG_ON(!fs_info->balance_ctl);\n\n\tspin_lock(&fs_info->balance_lock);\n\tfs_info->balance_ctl = NULL;\n\tspin_unlock(&fs_info->balance_lock);\n\n\tkfree(bctl);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bctl"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 2928
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!fs_info->balance_ctl"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void unset_balance_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tBUG_ON(!fs_info->balance_ctl);\n\n\tspin_lock(&fs_info->balance_lock);\n\tfs_info->balance_ctl = NULL;\n\tspin_unlock(&fs_info->balance_lock);\n\n\tkfree(bctl);\n}"
  },
  {
    "function_name": "set_balance_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2909-2918",
    "snippet": "static void set_balance_control(struct btrfs_balance_control *bctl)\n{\n\tstruct btrfs_fs_info *fs_info = bctl->fs_info;\n\n\tBUG_ON(fs_info->balance_ctl);\n\n\tspin_lock(&fs_info->balance_lock);\n\tfs_info->balance_ctl = bctl;\n\tspin_unlock(&fs_info->balance_lock);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fs_info->balance_ctl"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void set_balance_control(struct btrfs_balance_control *bctl)\n{\n\tstruct btrfs_fs_info *fs_info = bctl->fs_info;\n\n\tBUG_ON(fs_info->balance_ctl);\n\n\tspin_lock(&fs_info->balance_lock);\n\tfs_info->balance_ctl = bctl;\n\tspin_unlock(&fs_info->balance_lock);\n}"
  },
  {
    "function_name": "update_balance_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2868-2902",
    "snippet": "static void update_balance_args(struct btrfs_balance_control *bctl)\n{\n\t/*\n\t * Turn on soft mode for chunk types that were being converted.\n\t */\n\tif (bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT)\n\t\tbctl->data.flags |= BTRFS_BALANCE_ARGS_SOFT;\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT)\n\t\tbctl->sys.flags |= BTRFS_BALANCE_ARGS_SOFT;\n\tif (bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT)\n\t\tbctl->meta.flags |= BTRFS_BALANCE_ARGS_SOFT;\n\n\t/*\n\t * Turn on usage filter if is not already used.  The idea is\n\t * that chunks that we have already balanced should be\n\t * reasonably full.  Don't do it for chunks that are being\n\t * converted - that will keep us from relocating unconverted\n\t * (albeit full) chunks.\n\t */\n\tif (!(bctl->data.flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    !(bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT)) {\n\t\tbctl->data.flags |= BTRFS_BALANCE_ARGS_USAGE;\n\t\tbctl->data.usage = 90;\n\t}\n\tif (!(bctl->sys.flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    !(bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT)) {\n\t\tbctl->sys.flags |= BTRFS_BALANCE_ARGS_USAGE;\n\t\tbctl->sys.usage = 90;\n\t}\n\tif (!(bctl->meta.flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    !(bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT)) {\n\t\tbctl->meta.flags |= BTRFS_BALANCE_ARGS_USAGE;\n\t\tbctl->meta.usage = 90;\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void update_balance_args(struct btrfs_balance_control *bctl)\n{\n\t/*\n\t * Turn on soft mode for chunk types that were being converted.\n\t */\n\tif (bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT)\n\t\tbctl->data.flags |= BTRFS_BALANCE_ARGS_SOFT;\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT)\n\t\tbctl->sys.flags |= BTRFS_BALANCE_ARGS_SOFT;\n\tif (bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT)\n\t\tbctl->meta.flags |= BTRFS_BALANCE_ARGS_SOFT;\n\n\t/*\n\t * Turn on usage filter if is not already used.  The idea is\n\t * that chunks that we have already balanced should be\n\t * reasonably full.  Don't do it for chunks that are being\n\t * converted - that will keep us from relocating unconverted\n\t * (albeit full) chunks.\n\t */\n\tif (!(bctl->data.flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    !(bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT)) {\n\t\tbctl->data.flags |= BTRFS_BALANCE_ARGS_USAGE;\n\t\tbctl->data.usage = 90;\n\t}\n\tif (!(bctl->sys.flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    !(bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT)) {\n\t\tbctl->sys.flags |= BTRFS_BALANCE_ARGS_USAGE;\n\t\tbctl->sys.usage = 90;\n\t}\n\tif (!(bctl->meta.flags & BTRFS_BALANCE_ARGS_USAGE) &&\n\t    !(bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT)) {\n\t\tbctl->meta.flags |= BTRFS_BALANCE_ARGS_USAGE;\n\t\tbctl->meta.usage = 90;\n\t}\n}"
  },
  {
    "function_name": "del_balance_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2826-2862",
    "snippet": "static int del_balance_item(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret, err;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_BALANCE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tbtrfs_free_path(path);\n\terr = btrfs_commit_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "trans",
            "root",
            "path"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 2837
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2833
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int del_balance_item(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret, err;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_BALANCE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tbtrfs_free_path(path);\n\terr = btrfs_commit_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\treturn ret;\n}"
  },
  {
    "function_name": "insert_balance_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2773-2824",
    "snippet": "static int insert_balance_item(struct btrfs_root *root,\n\t\t\t       struct btrfs_balance_control *bctl)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_balance_item *item;\n\tstruct btrfs_disk_balance_args disk_bargs;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tint ret, err;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_BALANCE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(*item));\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_balance_item);\n\n\tmemset_extent_buffer(leaf, 0, (unsigned long)item, sizeof(*item));\n\n\tbtrfs_cpu_balance_args_to_disk(&disk_bargs, &bctl->data);\n\tbtrfs_set_balance_data(leaf, item, &disk_bargs);\n\tbtrfs_cpu_balance_args_to_disk(&disk_bargs, &bctl->meta);\n\tbtrfs_set_balance_meta(leaf, item, &disk_bargs);\n\tbtrfs_cpu_balance_args_to_disk(&disk_bargs, &bctl->sys);\n\tbtrfs_set_balance_sys(leaf, item, &disk_bargs);\n\n\tbtrfs_set_balance_flags(leaf, item, bctl->flags);\n\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\terr = btrfs_commit_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 2820
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_balance_flags",
          "args": [
            "leaf",
            "item",
            "bctl->flags"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_balance_sys",
          "args": [
            "leaf",
            "item",
            "&disk_bargs"
          ],
          "line": 2813
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_balance_sys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2973-2978",
          "snippet": "static inline void btrfs_set_balance_sys(struct extent_buffer *eb,\n\t\t\t\t\t struct btrfs_balance_item *bi,\n\t\t\t\t\t struct btrfs_disk_balance_args *ba)\n{\n\twrite_eb_member(eb, bi, struct btrfs_balance_item, sys, ba);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_balance_sys(struct extent_buffer *eb,\n\t\t\t\t\t struct btrfs_balance_item *bi,\n\t\t\t\t\t struct btrfs_disk_balance_args *ba)\n{\n\twrite_eb_member(eb, bi, struct btrfs_balance_item, sys, ba);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cpu_balance_args_to_disk",
          "args": [
            "&disk_bargs",
            "&bctl->sys"
          ],
          "line": 2812
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cpu_balance_args_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2998-3014",
          "snippet": "static inline void\nbtrfs_cpu_balance_args_to_disk(struct btrfs_disk_balance_args *disk,\n\t\t\t       struct btrfs_balance_args *cpu)\n{\n\tmemset(disk, 0, sizeof(*disk));\n\n\tdisk->profiles = cpu_to_le64(cpu->profiles);\n\tdisk->usage = cpu_to_le64(cpu->usage);\n\tdisk->devid = cpu_to_le64(cpu->devid);\n\tdisk->pstart = cpu_to_le64(cpu->pstart);\n\tdisk->pend = cpu_to_le64(cpu->pend);\n\tdisk->vstart = cpu_to_le64(cpu->vstart);\n\tdisk->vend = cpu_to_le64(cpu->vend);\n\tdisk->target = cpu_to_le64(cpu->target);\n\tdisk->flags = cpu_to_le64(cpu->flags);\n\tdisk->limit = cpu_to_le64(cpu->limit);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void\nbtrfs_cpu_balance_args_to_disk(struct btrfs_disk_balance_args *disk,\n\t\t\t       struct btrfs_balance_args *cpu)\n{\n\tmemset(disk, 0, sizeof(*disk));\n\n\tdisk->profiles = cpu_to_le64(cpu->profiles);\n\tdisk->usage = cpu_to_le64(cpu->usage);\n\tdisk->devid = cpu_to_le64(cpu->devid);\n\tdisk->pstart = cpu_to_le64(cpu->pstart);\n\tdisk->pend = cpu_to_le64(cpu->pend);\n\tdisk->vstart = cpu_to_le64(cpu->vstart);\n\tdisk->vend = cpu_to_le64(cpu->vend);\n\tdisk->target = cpu_to_le64(cpu->target);\n\tdisk->flags = cpu_to_le64(cpu->flags);\n\tdisk->limit = cpu_to_le64(cpu->limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_balance_meta",
          "args": [
            "leaf",
            "item",
            "&disk_bargs"
          ],
          "line": 2811
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_balance_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2959-2964",
          "snippet": "static inline void btrfs_set_balance_meta(struct extent_buffer *eb,\n\t\t\t\t\t  struct btrfs_balance_item *bi,\n\t\t\t\t\t  struct btrfs_disk_balance_args *ba)\n{\n\twrite_eb_member(eb, bi, struct btrfs_balance_item, meta, ba);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_balance_meta(struct extent_buffer *eb,\n\t\t\t\t\t  struct btrfs_balance_item *bi,\n\t\t\t\t\t  struct btrfs_disk_balance_args *ba)\n{\n\twrite_eb_member(eb, bi, struct btrfs_balance_item, meta, ba);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_balance_data",
          "args": [
            "leaf",
            "item",
            "&disk_bargs"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_balance_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2945-2950",
          "snippet": "static inline void btrfs_set_balance_data(struct extent_buffer *eb,\n\t\t\t\t\t  struct btrfs_balance_item *bi,\n\t\t\t\t\t  struct btrfs_disk_balance_args *ba)\n{\n\twrite_eb_member(eb, bi, struct btrfs_balance_item, data, ba);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_balance_data(struct extent_buffer *eb,\n\t\t\t\t\t  struct btrfs_balance_item *bi,\n\t\t\t\t\t  struct btrfs_disk_balance_args *ba)\n{\n\twrite_eb_member(eb, bi, struct btrfs_balance_item, data, ba);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset_extent_buffer",
          "args": [
            "leaf",
            "0",
            "(unsigned long)item",
            "sizeof(*item)"
          ],
          "line": 2806
        },
        "resolved": true,
        "details": {
          "function_name": "memset_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5387-5414",
          "snippet": "void memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_balance_item"
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "root",
            "path",
            "&key",
            "sizeof(*item)"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2784
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int insert_balance_item(struct btrfs_root *root,\n\t\t\t       struct btrfs_balance_control *bctl)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_balance_item *item;\n\tstruct btrfs_disk_balance_args disk_bargs;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tint ret, err;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_BALANCE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(*item));\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_balance_item);\n\n\tmemset_extent_buffer(leaf, 0, (unsigned long)item, sizeof(*item));\n\n\tbtrfs_cpu_balance_args_to_disk(&disk_bargs, &bctl->data);\n\tbtrfs_set_balance_data(leaf, item, &disk_bargs);\n\tbtrfs_cpu_balance_args_to_disk(&disk_bargs, &bctl->meta);\n\tbtrfs_set_balance_meta(leaf, item, &disk_bargs);\n\tbtrfs_cpu_balance_args_to_disk(&disk_bargs, &bctl->sys);\n\tbtrfs_set_balance_sys(leaf, item, &disk_bargs);\n\n\tbtrfs_set_balance_flags(leaf, item, bctl->flags);\n\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\terr = btrfs_commit_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_relocate_sys_chunks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2702-2771",
    "snippet": "static int btrfs_relocate_sys_chunks(struct btrfs_root *root)\n{\n\tstruct btrfs_root *chunk_root = root->fs_info->chunk_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_chunk *chunk;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tu64 chunk_tree = chunk_root->root_key.objectid;\n\tu64 chunk_type;\n\tbool retried = false;\n\tint failed = 0;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\nagain:\n\tkey.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, chunk_root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tBUG_ON(ret == 0); /* Corruption */\n\n\t\tret = btrfs_previous_item(chunk_root, path, key.objectid,\n\t\t\t\t\t  key.type);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\tchunk = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t       struct btrfs_chunk);\n\t\tchunk_type = btrfs_chunk_type(leaf, chunk);\n\t\tbtrfs_release_path(path);\n\n\t\tif (chunk_type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\t\tret = btrfs_relocate_chunk(chunk_root, chunk_tree,\n\t\t\t\t\t\t   found_key.objectid,\n\t\t\t\t\t\t   found_key.offset);\n\t\t\tif (ret == -ENOSPC)\n\t\t\t\tfailed++;\n\t\t\telse\n\t\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t\tkey.offset = found_key.offset - 1;\n\t}\n\tret = 0;\n\tif (failed && !retried) {\n\t\tfailed = 0;\n\t\tretried = true;\n\t\tgoto again;\n\t} else if (WARN_ON(failed && retried)) {\n\t\tret = -ENOSPC;\n\t}\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "failed && retried"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_relocate_chunk",
          "args": [
            "chunk_root",
            "chunk_tree",
            "found_key.objectid",
            "found_key.offset"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_relocate_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2666-2700",
          "snippet": "static int btrfs_relocate_chunk(struct btrfs_root *root,\n\t\t\t u64 chunk_tree, u64 chunk_objectid,\n\t\t\t u64 chunk_offset)\n{\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\troot = root->fs_info->chunk_root;\n\textent_root = root->fs_info->extent_root;\n\n\tret = btrfs_can_relocate(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn -ENOSPC;\n\n\t/* step one, relocate all the extents inside this chunk */\n\tret = btrfs_relocate_block_group(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * step two, delete the device extents and the\n\t * chunk tree entries\n\t */\n\tret = btrfs_remove_chunk(trans, root, chunk_offset);\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_relocate_chunk(struct btrfs_root *root,\n\t\t\t u64 chunk_tree, u64 chunk_objectid,\n\t\t\t u64 chunk_offset)\n{\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\troot = root->fs_info->chunk_root;\n\textent_root = root->fs_info->extent_root;\n\n\tret = btrfs_can_relocate(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn -ENOSPC;\n\n\t/* step one, relocate all the extents inside this chunk */\n\tret = btrfs_relocate_block_group(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * step two, delete the device extents and the\n\t * chunk tree entries\n\t */\n\tret = btrfs_remove_chunk(trans, root, chunk_offset);\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_type",
          "args": [
            "leaf",
            "chunk"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_chunk"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_previous_item",
          "args": [
            "chunk_root",
            "path",
            "key.objectid",
            "key.type"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_previous_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5830-5865",
          "snippet": "int btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == 0"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "chunk_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 2726
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root)\n{\n\tstruct btrfs_root *chunk_root = root->fs_info->chunk_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_chunk *chunk;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tu64 chunk_tree = chunk_root->root_key.objectid;\n\tu64 chunk_type;\n\tbool retried = false;\n\tint failed = 0;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\nagain:\n\tkey.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, chunk_root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tBUG_ON(ret == 0); /* Corruption */\n\n\t\tret = btrfs_previous_item(chunk_root, path, key.objectid,\n\t\t\t\t\t  key.type);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\tchunk = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t       struct btrfs_chunk);\n\t\tchunk_type = btrfs_chunk_type(leaf, chunk);\n\t\tbtrfs_release_path(path);\n\n\t\tif (chunk_type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\t\tret = btrfs_relocate_chunk(chunk_root, chunk_tree,\n\t\t\t\t\t\t   found_key.objectid,\n\t\t\t\t\t\t   found_key.offset);\n\t\t\tif (ret == -ENOSPC)\n\t\t\t\tfailed++;\n\t\t\telse\n\t\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t\tkey.offset = found_key.offset - 1;\n\t}\n\tret = 0;\n\tif (failed && !retried) {\n\t\tfailed = 0;\n\t\tretried = true;\n\t\tgoto again;\n\t} else if (WARN_ON(failed && retried)) {\n\t\tret = -ENOSPC;\n\t}\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_relocate_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2666-2700",
    "snippet": "static int btrfs_relocate_chunk(struct btrfs_root *root,\n\t\t\t u64 chunk_tree, u64 chunk_objectid,\n\t\t\t u64 chunk_offset)\n{\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\troot = root->fs_info->chunk_root;\n\textent_root = root->fs_info->extent_root;\n\n\tret = btrfs_can_relocate(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn -ENOSPC;\n\n\t/* step one, relocate all the extents inside this chunk */\n\tret = btrfs_relocate_block_group(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * step two, delete the device extents and the\n\t * chunk tree entries\n\t */\n\tret = btrfs_remove_chunk(trans, root, chunk_offset);\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_remove_chunk",
          "args": [
            "trans",
            "root",
            "chunk_offset"
          ],
          "line": 2697
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_remove_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2574-2664",
          "snippet": "int btrfs_remove_chunk(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, u64 chunk_offset)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_root *extent_root = root->fs_info->extent_root;\n\tstruct map_lookup *map;\n\tu64 dev_extent_len = 0;\n\tu64 chunk_objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tu64 chunk_tree = root->fs_info->chunk_root->objectid;\n\tint i, ret = 0;\n\n\t/* Just in case */\n\troot = root->fs_info->chunk_root;\n\tem_tree = &root->fs_info->mapping_tree.map_tree;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, chunk_offset, 1);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em || em->start > chunk_offset ||\n\t    em->start + em->len < chunk_offset) {\n\t\t/*\n\t\t * This is a logic error, but we don't want to just rely on the\n\t\t * user having built with ASSERT enabled, so if ASSERT doens't\n\t\t * do anything we still error out.\n\t\t */\n\t\tASSERT(0);\n\t\tif (em)\n\t\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\tmap = (struct map_lookup *)em->bdev;\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tstruct btrfs_device *device = map->stripes[i].dev;\n\t\tret = btrfs_free_dev_extent(trans, device,\n\t\t\t\t\t    map->stripes[i].physical,\n\t\t\t\t\t    &dev_extent_len);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (device->bytes_used > 0) {\n\t\t\tlock_chunks(root);\n\t\t\tbtrfs_device_set_bytes_used(device,\n\t\t\t\t\tdevice->bytes_used - dev_extent_len);\n\t\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\t\troot->fs_info->free_chunk_space += dev_extent_len;\n\t\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t\t\tbtrfs_clear_space_info_full(root->fs_info);\n\t\t\tunlock_chunks(root);\n\t\t}\n\n\t\tif (map->stripes[i].dev) {\n\t\t\tret = btrfs_update_device(trans, map->stripes[i].dev);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tret = btrfs_free_chunk(trans, root, chunk_tree, chunk_objectid,\n\t\t\t       chunk_offset);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\ttrace_btrfs_chunk_free(root, map, chunk_offset, em->len);\n\n\tif (map->type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\tret = btrfs_del_sys_chunk(root, chunk_objectid, chunk_offset);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = btrfs_remove_block_group(trans, extent_root, chunk_offset, em);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, extent_root, ret);\n\t\tgoto out;\n\t}\n\nout:\n\t/* once for us */\n\tfree_extent_map(em);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_remove_chunk(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, u64 chunk_offset)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_root *extent_root = root->fs_info->extent_root;\n\tstruct map_lookup *map;\n\tu64 dev_extent_len = 0;\n\tu64 chunk_objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tu64 chunk_tree = root->fs_info->chunk_root->objectid;\n\tint i, ret = 0;\n\n\t/* Just in case */\n\troot = root->fs_info->chunk_root;\n\tem_tree = &root->fs_info->mapping_tree.map_tree;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, chunk_offset, 1);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em || em->start > chunk_offset ||\n\t    em->start + em->len < chunk_offset) {\n\t\t/*\n\t\t * This is a logic error, but we don't want to just rely on the\n\t\t * user having built with ASSERT enabled, so if ASSERT doens't\n\t\t * do anything we still error out.\n\t\t */\n\t\tASSERT(0);\n\t\tif (em)\n\t\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\tmap = (struct map_lookup *)em->bdev;\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tstruct btrfs_device *device = map->stripes[i].dev;\n\t\tret = btrfs_free_dev_extent(trans, device,\n\t\t\t\t\t    map->stripes[i].physical,\n\t\t\t\t\t    &dev_extent_len);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (device->bytes_used > 0) {\n\t\t\tlock_chunks(root);\n\t\t\tbtrfs_device_set_bytes_used(device,\n\t\t\t\t\tdevice->bytes_used - dev_extent_len);\n\t\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\t\troot->fs_info->free_chunk_space += dev_extent_len;\n\t\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t\t\tbtrfs_clear_space_info_full(root->fs_info);\n\t\t\tunlock_chunks(root);\n\t\t}\n\n\t\tif (map->stripes[i].dev) {\n\t\t\tret = btrfs_update_device(trans, map->stripes[i].dev);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tret = btrfs_free_chunk(trans, root, chunk_tree, chunk_objectid,\n\t\t\t       chunk_offset);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\ttrace_btrfs_chunk_free(root, map, chunk_offset, em->len);\n\n\tif (map->type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\tret = btrfs_del_sys_chunk(root, chunk_objectid, chunk_offset);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = btrfs_remove_block_group(trans, extent_root, chunk_offset, em);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, extent_root, ret);\n\t\tgoto out;\n\t}\n\nout:\n\t/* once for us */\n\tfree_extent_map(em);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_std_error",
          "args": [
            "root->fs_info",
            "ret"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_relocate_block_group",
          "args": [
            "extent_root",
            "chunk_offset"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_relocate_block_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "4187-4290",
          "snippet": "int btrfs_relocate_block_group(struct btrfs_root *extent_root, u64 group_start)\n{\n\tstruct btrfs_fs_info *fs_info = extent_root->fs_info;\n\tstruct reloc_control *rc;\n\tstruct inode *inode;\n\tstruct btrfs_path *path;\n\tint ret;\n\tint rw = 0;\n\tint err = 0;\n\n\trc = alloc_reloc_control(fs_info);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\n\trc->extent_root = extent_root;\n\n\trc->block_group = btrfs_lookup_block_group(fs_info, group_start);\n\tBUG_ON(!rc->block_group);\n\n\tif (!rc->block_group->ro) {\n\t\tret = btrfs_set_block_group_ro(extent_root, rc->block_group);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\trw = 1;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tinode = lookup_free_space_inode(fs_info->tree_root, rc->block_group,\n\t\t\t\t\tpath);\n\tbtrfs_free_path(path);\n\n\tif (!IS_ERR(inode))\n\t\tret = delete_block_group_cache(fs_info, inode, 0);\n\telse\n\t\tret = PTR_ERR(inode);\n\n\tif (ret && ret != -ENOENT) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\trc->data_inode = create_reloc_inode(fs_info, rc->block_group);\n\tif (IS_ERR(rc->data_inode)) {\n\t\terr = PTR_ERR(rc->data_inode);\n\t\trc->data_inode = NULL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_info(extent_root->fs_info, \"relocating block group %llu flags %llu\",\n\t       rc->block_group->key.objectid, rc->block_group->flags);\n\n\tret = btrfs_start_delalloc_roots(fs_info, 0, -1);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\tbtrfs_wait_ordered_roots(fs_info, -1);\n\n\twhile (1) {\n\t\tmutex_lock(&fs_info->cleaner_mutex);\n\t\tret = relocate_block_group(rc);\n\t\tmutex_unlock(&fs_info->cleaner_mutex);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (rc->extents_found == 0)\n\t\t\tbreak;\n\n\t\tbtrfs_info(extent_root->fs_info, \"found %llu extents\",\n\t\t\trc->extents_found);\n\n\t\tif (rc->stage == MOVE_DATA_EXTENTS && rc->found_file_extent) {\n\t\t\tret = btrfs_wait_ordered_range(rc->data_inode, 0,\n\t\t\t\t\t\t       (u64)-1);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinvalidate_mapping_pages(rc->data_inode->i_mapping,\n\t\t\t\t\t\t 0, -1);\n\t\t\trc->stage = UPDATE_DATA_PTRS;\n\t\t}\n\t}\n\n\tWARN_ON(rc->block_group->pinned > 0);\n\tWARN_ON(rc->block_group->reserved > 0);\n\tWARN_ON(btrfs_block_group_used(&rc->block_group->item) > 0);\nout:\n\tif (err && rw)\n\t\tbtrfs_set_block_group_rw(extent_root, rc->block_group);\n\tiput(rc->data_inode);\n\tbtrfs_put_block_group(rc->block_group);\n\tkfree(rc);\n\treturn err;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPDATE_DATA_PTRS\t1",
            "#define MOVE_DATA_EXTENTS\t0"
          ],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPDATE_DATA_PTRS\t1\n#define MOVE_DATA_EXTENTS\t0\n\nstatic noinline_for_stack\nstruct;\n\nint btrfs_relocate_block_group(struct btrfs_root *extent_root, u64 group_start)\n{\n\tstruct btrfs_fs_info *fs_info = extent_root->fs_info;\n\tstruct reloc_control *rc;\n\tstruct inode *inode;\n\tstruct btrfs_path *path;\n\tint ret;\n\tint rw = 0;\n\tint err = 0;\n\n\trc = alloc_reloc_control(fs_info);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\n\trc->extent_root = extent_root;\n\n\trc->block_group = btrfs_lookup_block_group(fs_info, group_start);\n\tBUG_ON(!rc->block_group);\n\n\tif (!rc->block_group->ro) {\n\t\tret = btrfs_set_block_group_ro(extent_root, rc->block_group);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\trw = 1;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tinode = lookup_free_space_inode(fs_info->tree_root, rc->block_group,\n\t\t\t\t\tpath);\n\tbtrfs_free_path(path);\n\n\tif (!IS_ERR(inode))\n\t\tret = delete_block_group_cache(fs_info, inode, 0);\n\telse\n\t\tret = PTR_ERR(inode);\n\n\tif (ret && ret != -ENOENT) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\trc->data_inode = create_reloc_inode(fs_info, rc->block_group);\n\tif (IS_ERR(rc->data_inode)) {\n\t\terr = PTR_ERR(rc->data_inode);\n\t\trc->data_inode = NULL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_info(extent_root->fs_info, \"relocating block group %llu flags %llu\",\n\t       rc->block_group->key.objectid, rc->block_group->flags);\n\n\tret = btrfs_start_delalloc_roots(fs_info, 0, -1);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\tbtrfs_wait_ordered_roots(fs_info, -1);\n\n\twhile (1) {\n\t\tmutex_lock(&fs_info->cleaner_mutex);\n\t\tret = relocate_block_group(rc);\n\t\tmutex_unlock(&fs_info->cleaner_mutex);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (rc->extents_found == 0)\n\t\t\tbreak;\n\n\t\tbtrfs_info(extent_root->fs_info, \"found %llu extents\",\n\t\t\trc->extents_found);\n\n\t\tif (rc->stage == MOVE_DATA_EXTENTS && rc->found_file_extent) {\n\t\t\tret = btrfs_wait_ordered_range(rc->data_inode, 0,\n\t\t\t\t\t\t       (u64)-1);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinvalidate_mapping_pages(rc->data_inode->i_mapping,\n\t\t\t\t\t\t 0, -1);\n\t\t\trc->stage = UPDATE_DATA_PTRS;\n\t\t}\n\t}\n\n\tWARN_ON(rc->block_group->pinned > 0);\n\tWARN_ON(rc->block_group->reserved > 0);\n\tWARN_ON(btrfs_block_group_used(&rc->block_group->item) > 0);\nout:\n\tif (err && rw)\n\t\tbtrfs_set_block_group_rw(extent_root, rc->block_group);\n\tiput(rc->data_inode);\n\tbtrfs_put_block_group(rc->block_group);\n\tkfree(rc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_can_relocate",
          "args": [
            "extent_root",
            "chunk_offset"
          ],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_can_relocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8633-8759",
          "snippet": "int btrfs_can_relocate(struct btrfs_root *root, u64 bytenr)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_trans_handle *trans;\n\tu64 min_free;\n\tu64 dev_min = 1;\n\tu64 dev_nr = 0;\n\tu64 target;\n\tint index;\n\tint full = 0;\n\tint ret = 0;\n\n\tblock_group = btrfs_lookup_block_group(root->fs_info, bytenr);\n\n\t/* odd, couldn't find the block group, leave it alone */\n\tif (!block_group)\n\t\treturn -1;\n\n\tmin_free = btrfs_block_group_used(&block_group->item);\n\n\t/* no bytes used, we're good */\n\tif (!min_free)\n\t\tgoto out;\n\n\tspace_info = block_group->space_info;\n\tspin_lock(&space_info->lock);\n\n\tfull = space_info->full;\n\n\t/*\n\t * if this is the last block group we have in this space, we can't\n\t * relocate it unless we're able to allocate a new chunk below.\n\t *\n\t * Otherwise, we need to make sure we have room in the space to handle\n\t * all of the extents from this block group.  If we can, we're good\n\t */\n\tif ((space_info->total_bytes != block_group->key.offset) &&\n\t    (space_info->bytes_used + space_info->bytes_reserved +\n\t     space_info->bytes_pinned + space_info->bytes_readonly +\n\t     min_free < space_info->total_bytes)) {\n\t\tspin_unlock(&space_info->lock);\n\t\tgoto out;\n\t}\n\tspin_unlock(&space_info->lock);\n\n\t/*\n\t * ok we don't have enough space, but maybe we have free space on our\n\t * devices to allocate new chunks for relocation, so loop through our\n\t * alloc devices and guess if we have enough space.  if this block\n\t * group is going to be restriped, run checks against the target\n\t * profile instead of the current one.\n\t */\n\tret = -1;\n\n\t/*\n\t * index:\n\t *      0: raid10\n\t *      1: raid1\n\t *      2: dup\n\t *      3: raid0\n\t *      4: single\n\t */\n\ttarget = get_restripe_target(root->fs_info, block_group->flags);\n\tif (target) {\n\t\tindex = __get_raid_index(extended_to_chunk(target));\n\t} else {\n\t\t/*\n\t\t * this is just a balance, so if we were marked as full\n\t\t * we know there is no space for a new chunk\n\t\t */\n\t\tif (full)\n\t\t\tgoto out;\n\n\t\tindex = get_block_group_index(block_group);\n\t}\n\n\tif (index == BTRFS_RAID_RAID10) {\n\t\tdev_min = 4;\n\t\t/* Divide by 2 */\n\t\tmin_free >>= 1;\n\t} else if (index == BTRFS_RAID_RAID1) {\n\t\tdev_min = 2;\n\t} else if (index == BTRFS_RAID_DUP) {\n\t\t/* Multiply by 2 */\n\t\tmin_free <<= 1;\n\t} else if (index == BTRFS_RAID_RAID0) {\n\t\tdev_min = fs_devices->rw_devices;\n\t\tdo_div(min_free, dev_min);\n\t}\n\n\t/* We need to do this so that we can look at pending chunks */\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&root->fs_info->chunk_mutex);\n\tlist_for_each_entry(device, &fs_devices->alloc_list, dev_alloc_list) {\n\t\tu64 dev_offset;\n\n\t\t/*\n\t\t * check to make sure we can actually find a chunk with enough\n\t\t * space to fit our block group in.\n\t\t */\n\t\tif (device->total_bytes > device->bytes_used + min_free &&\n\t\t    !device->is_tgtdev_for_dev_replace) {\n\t\t\tret = find_free_dev_extent(trans, device, min_free,\n\t\t\t\t\t\t   &dev_offset, NULL);\n\t\t\tif (!ret)\n\t\t\t\tdev_nr++;\n\n\t\t\tif (dev_nr >= dev_min)\n\t\t\t\tbreak;\n\n\t\t\tret = -1;\n\t\t}\n\t}\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n\tbtrfs_end_transaction(trans, root);\nout:\n\tbtrfs_put_block_group(block_group);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int update_block_group(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 bytenr,\n\t\t\t      u64 num_bytes, int alloc);",
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int update_block_group(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 bytenr,\n\t\t\t      u64 num_bytes, int alloc);\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nint btrfs_can_relocate(struct btrfs_root *root, u64 bytenr)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_trans_handle *trans;\n\tu64 min_free;\n\tu64 dev_min = 1;\n\tu64 dev_nr = 0;\n\tu64 target;\n\tint index;\n\tint full = 0;\n\tint ret = 0;\n\n\tblock_group = btrfs_lookup_block_group(root->fs_info, bytenr);\n\n\t/* odd, couldn't find the block group, leave it alone */\n\tif (!block_group)\n\t\treturn -1;\n\n\tmin_free = btrfs_block_group_used(&block_group->item);\n\n\t/* no bytes used, we're good */\n\tif (!min_free)\n\t\tgoto out;\n\n\tspace_info = block_group->space_info;\n\tspin_lock(&space_info->lock);\n\n\tfull = space_info->full;\n\n\t/*\n\t * if this is the last block group we have in this space, we can't\n\t * relocate it unless we're able to allocate a new chunk below.\n\t *\n\t * Otherwise, we need to make sure we have room in the space to handle\n\t * all of the extents from this block group.  If we can, we're good\n\t */\n\tif ((space_info->total_bytes != block_group->key.offset) &&\n\t    (space_info->bytes_used + space_info->bytes_reserved +\n\t     space_info->bytes_pinned + space_info->bytes_readonly +\n\t     min_free < space_info->total_bytes)) {\n\t\tspin_unlock(&space_info->lock);\n\t\tgoto out;\n\t}\n\tspin_unlock(&space_info->lock);\n\n\t/*\n\t * ok we don't have enough space, but maybe we have free space on our\n\t * devices to allocate new chunks for relocation, so loop through our\n\t * alloc devices and guess if we have enough space.  if this block\n\t * group is going to be restriped, run checks against the target\n\t * profile instead of the current one.\n\t */\n\tret = -1;\n\n\t/*\n\t * index:\n\t *      0: raid10\n\t *      1: raid1\n\t *      2: dup\n\t *      3: raid0\n\t *      4: single\n\t */\n\ttarget = get_restripe_target(root->fs_info, block_group->flags);\n\tif (target) {\n\t\tindex = __get_raid_index(extended_to_chunk(target));\n\t} else {\n\t\t/*\n\t\t * this is just a balance, so if we were marked as full\n\t\t * we know there is no space for a new chunk\n\t\t */\n\t\tif (full)\n\t\t\tgoto out;\n\n\t\tindex = get_block_group_index(block_group);\n\t}\n\n\tif (index == BTRFS_RAID_RAID10) {\n\t\tdev_min = 4;\n\t\t/* Divide by 2 */\n\t\tmin_free >>= 1;\n\t} else if (index == BTRFS_RAID_RAID1) {\n\t\tdev_min = 2;\n\t} else if (index == BTRFS_RAID_DUP) {\n\t\t/* Multiply by 2 */\n\t\tmin_free <<= 1;\n\t} else if (index == BTRFS_RAID_RAID0) {\n\t\tdev_min = fs_devices->rw_devices;\n\t\tdo_div(min_free, dev_min);\n\t}\n\n\t/* We need to do this so that we can look at pending chunks */\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&root->fs_info->chunk_mutex);\n\tlist_for_each_entry(device, &fs_devices->alloc_list, dev_alloc_list) {\n\t\tu64 dev_offset;\n\n\t\t/*\n\t\t * check to make sure we can actually find a chunk with enough\n\t\t * space to fit our block group in.\n\t\t */\n\t\tif (device->total_bytes > device->bytes_used + min_free &&\n\t\t    !device->is_tgtdev_for_dev_replace) {\n\t\t\tret = find_free_dev_extent(trans, device, min_free,\n\t\t\t\t\t\t   &dev_offset, NULL);\n\t\t\tif (!ret)\n\t\t\t\tdev_nr++;\n\n\t\t\tif (dev_nr >= dev_min)\n\t\t\t\tbreak;\n\n\t\t\tret = -1;\n\t\t}\n\t}\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n\tbtrfs_end_transaction(trans, root);\nout:\n\tbtrfs_put_block_group(block_group);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_relocate_chunk(struct btrfs_root *root,\n\t\t\t u64 chunk_tree, u64 chunk_objectid,\n\t\t\t u64 chunk_offset)\n{\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\troot = root->fs_info->chunk_root;\n\textent_root = root->fs_info->extent_root;\n\n\tret = btrfs_can_relocate(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn -ENOSPC;\n\n\t/* step one, relocate all the extents inside this chunk */\n\tret = btrfs_relocate_block_group(extent_root, chunk_offset);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * step two, delete the device extents and the\n\t * chunk tree entries\n\t */\n\tret = btrfs_remove_chunk(trans, root, chunk_offset);\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_remove_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2574-2664",
    "snippet": "int btrfs_remove_chunk(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, u64 chunk_offset)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_root *extent_root = root->fs_info->extent_root;\n\tstruct map_lookup *map;\n\tu64 dev_extent_len = 0;\n\tu64 chunk_objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tu64 chunk_tree = root->fs_info->chunk_root->objectid;\n\tint i, ret = 0;\n\n\t/* Just in case */\n\troot = root->fs_info->chunk_root;\n\tem_tree = &root->fs_info->mapping_tree.map_tree;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, chunk_offset, 1);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em || em->start > chunk_offset ||\n\t    em->start + em->len < chunk_offset) {\n\t\t/*\n\t\t * This is a logic error, but we don't want to just rely on the\n\t\t * user having built with ASSERT enabled, so if ASSERT doens't\n\t\t * do anything we still error out.\n\t\t */\n\t\tASSERT(0);\n\t\tif (em)\n\t\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\tmap = (struct map_lookup *)em->bdev;\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tstruct btrfs_device *device = map->stripes[i].dev;\n\t\tret = btrfs_free_dev_extent(trans, device,\n\t\t\t\t\t    map->stripes[i].physical,\n\t\t\t\t\t    &dev_extent_len);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (device->bytes_used > 0) {\n\t\t\tlock_chunks(root);\n\t\t\tbtrfs_device_set_bytes_used(device,\n\t\t\t\t\tdevice->bytes_used - dev_extent_len);\n\t\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\t\troot->fs_info->free_chunk_space += dev_extent_len;\n\t\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t\t\tbtrfs_clear_space_info_full(root->fs_info);\n\t\t\tunlock_chunks(root);\n\t\t}\n\n\t\tif (map->stripes[i].dev) {\n\t\t\tret = btrfs_update_device(trans, map->stripes[i].dev);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tret = btrfs_free_chunk(trans, root, chunk_tree, chunk_objectid,\n\t\t\t       chunk_offset);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\ttrace_btrfs_chunk_free(root, map, chunk_offset, em->len);\n\n\tif (map->type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\tret = btrfs_del_sys_chunk(root, chunk_objectid, chunk_offset);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = btrfs_remove_block_group(trans, extent_root, chunk_offset, em);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, extent_root, ret);\n\t\tgoto out;\n\t}\n\nout:\n\t/* once for us */\n\tfree_extent_map(em);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "extent_root",
            "ret"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_remove_block_group",
          "args": [
            "trans",
            "extent_root",
            "chunk_offset",
            "em"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_remove_block_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9299-9545",
          "snippet": "int btrfs_remove_block_group(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root, u64 group_start,\n\t\t\t     struct extent_map *em)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_group_cache *block_group;\n\tstruct btrfs_free_cluster *cluster;\n\tstruct btrfs_root *tree_root = root->fs_info->tree_root;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\tstruct kobject *kobj = NULL;\n\tint ret;\n\tint index;\n\tint factor;\n\tstruct btrfs_caching_control *caching_ctl = NULL;\n\tbool remove_em;\n\n\troot = root->fs_info->extent_root;\n\n\tblock_group = btrfs_lookup_block_group(root->fs_info, group_start);\n\tBUG_ON(!block_group);\n\tBUG_ON(!block_group->ro);\n\n\t/*\n\t * Free the reserved super bytes from this block group before\n\t * remove it.\n\t */\n\tfree_excluded_extents(root, block_group);\n\n\tmemcpy(&key, &block_group->key, sizeof(key));\n\tindex = get_block_group_index(block_group);\n\tif (block_group->flags & (BTRFS_BLOCK_GROUP_DUP |\n\t\t\t\t  BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t  BTRFS_BLOCK_GROUP_RAID10))\n\t\tfactor = 2;\n\telse\n\t\tfactor = 1;\n\n\t/* make sure this block group isn't part of an allocation cluster */\n\tcluster = &root->fs_info->data_alloc_cluster;\n\tspin_lock(&cluster->refill_lock);\n\tbtrfs_return_cluster_to_free_space(block_group, cluster);\n\tspin_unlock(&cluster->refill_lock);\n\n\t/*\n\t * make sure this block group isn't part of a metadata\n\t * allocation cluster\n\t */\n\tcluster = &root->fs_info->meta_alloc_cluster;\n\tspin_lock(&cluster->refill_lock);\n\tbtrfs_return_cluster_to_free_space(block_group, cluster);\n\tspin_unlock(&cluster->refill_lock);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tinode = lookup_free_space_inode(tree_root, block_group, path);\n\tif (!IS_ERR(inode)) {\n\t\tret = btrfs_orphan_add(trans, inode);\n\t\tif (ret) {\n\t\t\tbtrfs_add_delayed_iput(inode);\n\t\t\tgoto out;\n\t\t}\n\t\tclear_nlink(inode);\n\t\t/* One for the block groups ref */\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->iref) {\n\t\t\tblock_group->iref = 0;\n\t\t\tblock_group->inode = NULL;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tiput(inode);\n\t\t} else {\n\t\t\tspin_unlock(&block_group->lock);\n\t\t}\n\t\t/* One for our lookup ref */\n\t\tbtrfs_add_delayed_iput(inode);\n\t}\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = block_group->key.objectid;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(trans, tree_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0)\n\t\tbtrfs_release_path(path);\n\tif (ret == 0) {\n\t\tret = btrfs_del_item(trans, tree_root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n\t}\n\n\tspin_lock(&root->fs_info->block_group_cache_lock);\n\trb_erase(&block_group->cache_node,\n\t\t &root->fs_info->block_group_cache_tree);\n\tRB_CLEAR_NODE(&block_group->cache_node);\n\n\tif (root->fs_info->first_logical_byte == block_group->key.objectid)\n\t\troot->fs_info->first_logical_byte = (u64)-1;\n\tspin_unlock(&root->fs_info->block_group_cache_lock);\n\n\tdown_write(&block_group->space_info->groups_sem);\n\t/*\n\t * we must use list_del_init so people can check to see if they\n\t * are still on the list after taking the semaphore\n\t */\n\tlist_del_init(&block_group->list);\n\tif (list_empty(&block_group->space_info->block_groups[index])) {\n\t\tkobj = block_group->space_info->block_group_kobjs[index];\n\t\tblock_group->space_info->block_group_kobjs[index] = NULL;\n\t\tclear_avail_alloc_bits(root->fs_info, block_group->flags);\n\t}\n\tup_write(&block_group->space_info->groups_sem);\n\tif (kobj) {\n\t\tkobject_del(kobj);\n\t\tkobject_put(kobj);\n\t}\n\n\tif (block_group->has_caching_ctl)\n\t\tcaching_ctl = get_caching_control(block_group);\n\tif (block_group->cached == BTRFS_CACHE_STARTED)\n\t\twait_block_group_cache_done(block_group);\n\tif (block_group->has_caching_ctl) {\n\t\tdown_write(&root->fs_info->commit_root_sem);\n\t\tif (!caching_ctl) {\n\t\t\tstruct btrfs_caching_control *ctl;\n\n\t\t\tlist_for_each_entry(ctl,\n\t\t\t\t    &root->fs_info->caching_block_groups, list)\n\t\t\t\tif (ctl->block_group == block_group) {\n\t\t\t\t\tcaching_ctl = ctl;\n\t\t\t\t\tatomic_inc(&caching_ctl->count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif (caching_ctl)\n\t\t\tlist_del_init(&caching_ctl->list);\n\t\tup_write(&root->fs_info->commit_root_sem);\n\t\tif (caching_ctl) {\n\t\t\t/* Once for the caching bgs list and once for us. */\n\t\t\tput_caching_control(caching_ctl);\n\t\t\tput_caching_control(caching_ctl);\n\t\t}\n\t}\n\n\tspin_lock(&trans->transaction->dirty_bgs_lock);\n\tif (!list_empty(&block_group->dirty_list)) {\n\t\tlist_del_init(&block_group->dirty_list);\n\t\tbtrfs_put_block_group(block_group);\n\t}\n\tspin_unlock(&trans->transaction->dirty_bgs_lock);\n\n\tbtrfs_remove_free_space_cache(block_group);\n\n\tspin_lock(&block_group->space_info->lock);\n\tlist_del_init(&block_group->ro_list);\n\tblock_group->space_info->total_bytes -= block_group->key.offset;\n\tblock_group->space_info->bytes_readonly -= block_group->key.offset;\n\tblock_group->space_info->disk_total -= block_group->key.offset * factor;\n\tspin_unlock(&block_group->space_info->lock);\n\n\tmemcpy(&key, &block_group->key, sizeof(key));\n\n\tlock_chunks(root);\n\tif (!list_empty(&em->list)) {\n\t\t/* We're in the transaction->pending_chunks list. */\n\t\tfree_extent_map(em);\n\t}\n\tspin_lock(&block_group->lock);\n\tblock_group->removed = 1;\n\t/*\n\t * At this point trimming can't start on this block group, because we\n\t * removed the block group from the tree fs_info->block_group_cache_tree\n\t * so no one can't find it anymore and even if someone already got this\n\t * block group before we removed it from the rbtree, they have already\n\t * incremented block_group->trimming - if they didn't, they won't find\n\t * any free space entries because we already removed them all when we\n\t * called btrfs_remove_free_space_cache().\n\t *\n\t * And we must not remove the extent map from the fs_info->mapping_tree\n\t * to prevent the same logical address range and physical device space\n\t * ranges from being reused for a new block group. This is because our\n\t * fs trim operation (btrfs_trim_fs() / btrfs_ioctl_fitrim()) is\n\t * completely transactionless, so while it is trimming a range the\n\t * currently running transaction might finish and a new one start,\n\t * allowing for new block groups to be created that can reuse the same\n\t * physical device locations unless we take this special care.\n\t */\n\tremove_em = (atomic_read(&block_group->trimming) == 0);\n\t/*\n\t * Make sure a trimmer task always sees the em in the pinned_chunks list\n\t * if it sees block_group->removed == 1 (needs to lock block_group->lock\n\t * before checking block_group->removed).\n\t */\n\tif (!remove_em) {\n\t\t/*\n\t\t * Our em might be in trans->transaction->pending_chunks which\n\t\t * is protected by fs_info->chunk_mutex ([lock|unlock]_chunks),\n\t\t * and so is the fs_info->pinned_chunks list.\n\t\t *\n\t\t * So at this point we must be holding the chunk_mutex to avoid\n\t\t * any races with chunk allocation (more specifically at\n\t\t * volumes.c:contains_pending_extent()), to ensure it always\n\t\t * sees the em, either in the pending_chunks list or in the\n\t\t * pinned_chunks list.\n\t\t */\n\t\tlist_move_tail(&em->list, &root->fs_info->pinned_chunks);\n\t}\n\tspin_unlock(&block_group->lock);\n\n\tif (remove_em) {\n\t\tstruct extent_map_tree *em_tree;\n\n\t\tem_tree = &root->fs_info->mapping_tree.map_tree;\n\t\twrite_lock(&em_tree->lock);\n\t\t/*\n\t\t * The em might be in the pending_chunks list, so make sure the\n\t\t * chunk mutex is locked, since remove_extent_mapping() will\n\t\t * delete us from that list.\n\t\t */\n\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\t\t/* once for the tree */\n\t\tfree_extent_map(em);\n\t}\n\n\tunlock_chunks(root);\n\n\tbtrfs_put_block_group(block_group);\n\tbtrfs_put_block_group(block_group);\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret > 0)\n\t\tret = -EIO;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "int btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nint btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);\nstatic noinline struct;\n\nint btrfs_remove_block_group(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root, u64 group_start,\n\t\t\t     struct extent_map *em)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_group_cache *block_group;\n\tstruct btrfs_free_cluster *cluster;\n\tstruct btrfs_root *tree_root = root->fs_info->tree_root;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\tstruct kobject *kobj = NULL;\n\tint ret;\n\tint index;\n\tint factor;\n\tstruct btrfs_caching_control *caching_ctl = NULL;\n\tbool remove_em;\n\n\troot = root->fs_info->extent_root;\n\n\tblock_group = btrfs_lookup_block_group(root->fs_info, group_start);\n\tBUG_ON(!block_group);\n\tBUG_ON(!block_group->ro);\n\n\t/*\n\t * Free the reserved super bytes from this block group before\n\t * remove it.\n\t */\n\tfree_excluded_extents(root, block_group);\n\n\tmemcpy(&key, &block_group->key, sizeof(key));\n\tindex = get_block_group_index(block_group);\n\tif (block_group->flags & (BTRFS_BLOCK_GROUP_DUP |\n\t\t\t\t  BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t  BTRFS_BLOCK_GROUP_RAID10))\n\t\tfactor = 2;\n\telse\n\t\tfactor = 1;\n\n\t/* make sure this block group isn't part of an allocation cluster */\n\tcluster = &root->fs_info->data_alloc_cluster;\n\tspin_lock(&cluster->refill_lock);\n\tbtrfs_return_cluster_to_free_space(block_group, cluster);\n\tspin_unlock(&cluster->refill_lock);\n\n\t/*\n\t * make sure this block group isn't part of a metadata\n\t * allocation cluster\n\t */\n\tcluster = &root->fs_info->meta_alloc_cluster;\n\tspin_lock(&cluster->refill_lock);\n\tbtrfs_return_cluster_to_free_space(block_group, cluster);\n\tspin_unlock(&cluster->refill_lock);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tinode = lookup_free_space_inode(tree_root, block_group, path);\n\tif (!IS_ERR(inode)) {\n\t\tret = btrfs_orphan_add(trans, inode);\n\t\tif (ret) {\n\t\t\tbtrfs_add_delayed_iput(inode);\n\t\t\tgoto out;\n\t\t}\n\t\tclear_nlink(inode);\n\t\t/* One for the block groups ref */\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->iref) {\n\t\t\tblock_group->iref = 0;\n\t\t\tblock_group->inode = NULL;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tiput(inode);\n\t\t} else {\n\t\t\tspin_unlock(&block_group->lock);\n\t\t}\n\t\t/* One for our lookup ref */\n\t\tbtrfs_add_delayed_iput(inode);\n\t}\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = block_group->key.objectid;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(trans, tree_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0)\n\t\tbtrfs_release_path(path);\n\tif (ret == 0) {\n\t\tret = btrfs_del_item(trans, tree_root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n\t}\n\n\tspin_lock(&root->fs_info->block_group_cache_lock);\n\trb_erase(&block_group->cache_node,\n\t\t &root->fs_info->block_group_cache_tree);\n\tRB_CLEAR_NODE(&block_group->cache_node);\n\n\tif (root->fs_info->first_logical_byte == block_group->key.objectid)\n\t\troot->fs_info->first_logical_byte = (u64)-1;\n\tspin_unlock(&root->fs_info->block_group_cache_lock);\n\n\tdown_write(&block_group->space_info->groups_sem);\n\t/*\n\t * we must use list_del_init so people can check to see if they\n\t * are still on the list after taking the semaphore\n\t */\n\tlist_del_init(&block_group->list);\n\tif (list_empty(&block_group->space_info->block_groups[index])) {\n\t\tkobj = block_group->space_info->block_group_kobjs[index];\n\t\tblock_group->space_info->block_group_kobjs[index] = NULL;\n\t\tclear_avail_alloc_bits(root->fs_info, block_group->flags);\n\t}\n\tup_write(&block_group->space_info->groups_sem);\n\tif (kobj) {\n\t\tkobject_del(kobj);\n\t\tkobject_put(kobj);\n\t}\n\n\tif (block_group->has_caching_ctl)\n\t\tcaching_ctl = get_caching_control(block_group);\n\tif (block_group->cached == BTRFS_CACHE_STARTED)\n\t\twait_block_group_cache_done(block_group);\n\tif (block_group->has_caching_ctl) {\n\t\tdown_write(&root->fs_info->commit_root_sem);\n\t\tif (!caching_ctl) {\n\t\t\tstruct btrfs_caching_control *ctl;\n\n\t\t\tlist_for_each_entry(ctl,\n\t\t\t\t    &root->fs_info->caching_block_groups, list)\n\t\t\t\tif (ctl->block_group == block_group) {\n\t\t\t\t\tcaching_ctl = ctl;\n\t\t\t\t\tatomic_inc(&caching_ctl->count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif (caching_ctl)\n\t\t\tlist_del_init(&caching_ctl->list);\n\t\tup_write(&root->fs_info->commit_root_sem);\n\t\tif (caching_ctl) {\n\t\t\t/* Once for the caching bgs list and once for us. */\n\t\t\tput_caching_control(caching_ctl);\n\t\t\tput_caching_control(caching_ctl);\n\t\t}\n\t}\n\n\tspin_lock(&trans->transaction->dirty_bgs_lock);\n\tif (!list_empty(&block_group->dirty_list)) {\n\t\tlist_del_init(&block_group->dirty_list);\n\t\tbtrfs_put_block_group(block_group);\n\t}\n\tspin_unlock(&trans->transaction->dirty_bgs_lock);\n\n\tbtrfs_remove_free_space_cache(block_group);\n\n\tspin_lock(&block_group->space_info->lock);\n\tlist_del_init(&block_group->ro_list);\n\tblock_group->space_info->total_bytes -= block_group->key.offset;\n\tblock_group->space_info->bytes_readonly -= block_group->key.offset;\n\tblock_group->space_info->disk_total -= block_group->key.offset * factor;\n\tspin_unlock(&block_group->space_info->lock);\n\n\tmemcpy(&key, &block_group->key, sizeof(key));\n\n\tlock_chunks(root);\n\tif (!list_empty(&em->list)) {\n\t\t/* We're in the transaction->pending_chunks list. */\n\t\tfree_extent_map(em);\n\t}\n\tspin_lock(&block_group->lock);\n\tblock_group->removed = 1;\n\t/*\n\t * At this point trimming can't start on this block group, because we\n\t * removed the block group from the tree fs_info->block_group_cache_tree\n\t * so no one can't find it anymore and even if someone already got this\n\t * block group before we removed it from the rbtree, they have already\n\t * incremented block_group->trimming - if they didn't, they won't find\n\t * any free space entries because we already removed them all when we\n\t * called btrfs_remove_free_space_cache().\n\t *\n\t * And we must not remove the extent map from the fs_info->mapping_tree\n\t * to prevent the same logical address range and physical device space\n\t * ranges from being reused for a new block group. This is because our\n\t * fs trim operation (btrfs_trim_fs() / btrfs_ioctl_fitrim()) is\n\t * completely transactionless, so while it is trimming a range the\n\t * currently running transaction might finish and a new one start,\n\t * allowing for new block groups to be created that can reuse the same\n\t * physical device locations unless we take this special care.\n\t */\n\tremove_em = (atomic_read(&block_group->trimming) == 0);\n\t/*\n\t * Make sure a trimmer task always sees the em in the pinned_chunks list\n\t * if it sees block_group->removed == 1 (needs to lock block_group->lock\n\t * before checking block_group->removed).\n\t */\n\tif (!remove_em) {\n\t\t/*\n\t\t * Our em might be in trans->transaction->pending_chunks which\n\t\t * is protected by fs_info->chunk_mutex ([lock|unlock]_chunks),\n\t\t * and so is the fs_info->pinned_chunks list.\n\t\t *\n\t\t * So at this point we must be holding the chunk_mutex to avoid\n\t\t * any races with chunk allocation (more specifically at\n\t\t * volumes.c:contains_pending_extent()), to ensure it always\n\t\t * sees the em, either in the pending_chunks list or in the\n\t\t * pinned_chunks list.\n\t\t */\n\t\tlist_move_tail(&em->list, &root->fs_info->pinned_chunks);\n\t}\n\tspin_unlock(&block_group->lock);\n\n\tif (remove_em) {\n\t\tstruct extent_map_tree *em_tree;\n\n\t\tem_tree = &root->fs_info->mapping_tree.map_tree;\n\t\twrite_lock(&em_tree->lock);\n\t\t/*\n\t\t * The em might be in the pending_chunks list, so make sure the\n\t\t * chunk mutex is locked, since remove_extent_mapping() will\n\t\t * delete us from that list.\n\t\t */\n\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\t\t/* once for the tree */\n\t\tfree_extent_map(em);\n\t}\n\n\tunlock_chunks(root);\n\n\tbtrfs_put_block_group(block_group);\n\tbtrfs_put_block_group(block_group);\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret > 0)\n\t\tret = -EIO;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_del_sys_chunk",
          "args": [
            "root",
            "chunk_objectid",
            "chunk_offset"
          ],
          "line": 2647
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_sys_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2526-2572",
          "snippet": "static int btrfs_del_sys_chunk(struct btrfs_root *root, u64 chunk_objectid, u64\n\t\t\tchunk_offset)\n{\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tstruct btrfs_disk_key *disk_key;\n\tstruct btrfs_chunk *chunk;\n\tu8 *ptr;\n\tint ret = 0;\n\tu32 num_stripes;\n\tu32 array_size;\n\tu32 len = 0;\n\tu32 cur;\n\tstruct btrfs_key key;\n\n\tlock_chunks(root);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\n\tptr = super_copy->sys_chunk_array;\n\tcur = 0;\n\n\twhile (cur < array_size) {\n\t\tdisk_key = (struct btrfs_disk_key *)ptr;\n\t\tbtrfs_disk_key_to_cpu(&key, disk_key);\n\n\t\tlen = sizeof(*disk_key);\n\n\t\tif (key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tchunk = (struct btrfs_chunk *)(ptr + len);\n\t\t\tnum_stripes = btrfs_stack_chunk_num_stripes(chunk);\n\t\t\tlen += btrfs_chunk_item_size(num_stripes);\n\t\t} else {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (key.objectid == chunk_objectid &&\n\t\t    key.offset == chunk_offset) {\n\t\t\tmemmove(ptr, ptr + len, array_size - (cur + len));\n\t\t\tarray_size -= len;\n\t\t\tbtrfs_set_super_sys_array_size(super_copy, array_size);\n\t\t} else {\n\t\t\tptr += len;\n\t\t\tcur += len;\n\t\t}\n\t}\n\tunlock_chunks(root);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_del_sys_chunk(struct btrfs_root *root, u64 chunk_objectid, u64\n\t\t\tchunk_offset)\n{\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tstruct btrfs_disk_key *disk_key;\n\tstruct btrfs_chunk *chunk;\n\tu8 *ptr;\n\tint ret = 0;\n\tu32 num_stripes;\n\tu32 array_size;\n\tu32 len = 0;\n\tu32 cur;\n\tstruct btrfs_key key;\n\n\tlock_chunks(root);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\n\tptr = super_copy->sys_chunk_array;\n\tcur = 0;\n\n\twhile (cur < array_size) {\n\t\tdisk_key = (struct btrfs_disk_key *)ptr;\n\t\tbtrfs_disk_key_to_cpu(&key, disk_key);\n\n\t\tlen = sizeof(*disk_key);\n\n\t\tif (key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tchunk = (struct btrfs_chunk *)(ptr + len);\n\t\t\tnum_stripes = btrfs_stack_chunk_num_stripes(chunk);\n\t\t\tlen += btrfs_chunk_item_size(num_stripes);\n\t\t} else {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (key.objectid == chunk_objectid &&\n\t\t    key.offset == chunk_offset) {\n\t\t\tmemmove(ptr, ptr + len, array_size - (cur + len));\n\t\t\tarray_size -= len;\n\t\t\tbtrfs_set_super_sys_array_size(super_copy, array_size);\n\t\t} else {\n\t\t\tptr += len;\n\t\t\tcur += len;\n\t\t}\n\t}\n\tunlock_chunks(root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_chunk_free",
          "args": [
            "root",
            "map",
            "chunk_offset",
            "em->len"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_chunk",
          "args": [
            "trans",
            "root",
            "chunk_tree",
            "chunk_objectid",
            "chunk_offset"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2489-2524",
          "snippet": "static int btrfs_free_chunk(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    u64 chunk_tree, u64 chunk_objectid,\n\t\t\t    u64 chunk_offset)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\troot = root->fs_info->chunk_root;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = chunk_objectid;\n\tkey.offset = chunk_offset;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\telse if (ret > 0) { /* Logic error or corruption */\n\t\tbtrfs_error(root->fs_info, -ENOENT,\n\t\t\t    \"Failed lookup while freeing chunk.\");\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, root, path);\n\tif (ret < 0)\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Failed to delete chunk item.\");\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_free_chunk(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    u64 chunk_tree, u64 chunk_objectid,\n\t\t\t    u64 chunk_offset)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\troot = root->fs_info->chunk_root;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = chunk_objectid;\n\tkey.offset = chunk_offset;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\telse if (ret > 0) { /* Logic error or corruption */\n\t\tbtrfs_error(root->fs_info, -ENOENT,\n\t\t\t    \"Failed lookup while freeing chunk.\");\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, root, path);\n\tif (ret < 0)\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Failed to delete chunk item.\");\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_update_device",
          "args": [
            "trans",
            "map->stripes[i].dev"
          ],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2403-2449",
          "snippet": "static noinline int btrfs_update_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\troot = device->dev_root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_mark_buffer_dirty(leaf);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline int btrfs_update_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\troot = device->dev_root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_mark_buffer_dirty(leaf);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_chunks",
          "args": [
            "root"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "536-539",
          "snippet": "static inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clear_space_info_full",
          "args": [
            "root->fs_info"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_space_info_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "703-712",
          "snippet": "void btrfs_clear_space_info_full(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head = &info->space_info;\n\tstruct btrfs_space_info *found;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(found, head, list)\n\t\tfound->full = 0;\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_clear_space_info_full(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head = &info->space_info;\n\tstruct btrfs_space_info *found;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(found, head, list)\n\t\tfound->full = 0;\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->free_chunk_lock"
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->free_chunk_lock"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_set_bytes_used",
          "args": [
            "device",
            "device->bytes_used - dev_extent_len"
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_dev_extent",
          "args": [
            "trans",
            "device",
            "map->stripes[i].physical",
            "&dev_extent_len"
          ],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_dev_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1263-1319",
          "snippet": "static int btrfs_free_dev_extent(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_device *device,\n\t\t\t  u64 start, u64 *dev_extent_len)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf = NULL;\n\tstruct btrfs_dev_extent *extent = NULL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = device->devid;\n\tkey.offset = start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\nagain:\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret > 0) {\n\t\tret = btrfs_previous_item(root, path, key.objectid,\n\t\t\t\t\t  BTRFS_DEV_EXTENT_KEY);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\tstruct btrfs_dev_extent);\n\t\tBUG_ON(found_key.offset > start || found_key.offset +\n\t\t       btrfs_dev_extent_length(leaf, extent) < start);\n\t\tkey = found_key;\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t} else if (ret == 0) {\n\t\tleaf = path->nodes[0];\n\t\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\tstruct btrfs_dev_extent);\n\t} else {\n\t\tbtrfs_error(root->fs_info, ret, \"Slot search failed\");\n\t\tgoto out;\n\t}\n\n\t*dev_extent_len = btrfs_dev_extent_length(leaf, extent);\n\n\tret = btrfs_del_item(trans, root, path);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Failed to remove dev extent item\");\n\t} else {\n\t\ttrans->transaction->have_free_bgs = 1;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_free_dev_extent(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_device *device,\n\t\t\t  u64 start, u64 *dev_extent_len)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf = NULL;\n\tstruct btrfs_dev_extent *extent = NULL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = device->devid;\n\tkey.offset = start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\nagain:\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret > 0) {\n\t\tret = btrfs_previous_item(root, path, key.objectid,\n\t\t\t\t\t  BTRFS_DEV_EXTENT_KEY);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\tstruct btrfs_dev_extent);\n\t\tBUG_ON(found_key.offset > start || found_key.offset +\n\t\t       btrfs_dev_extent_length(leaf, extent) < start);\n\t\tkey = found_key;\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t} else if (ret == 0) {\n\t\tleaf = path->nodes[0];\n\t\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\tstruct btrfs_dev_extent);\n\t} else {\n\t\tbtrfs_error(root->fs_info, ret, \"Slot search failed\");\n\t\tgoto out;\n\t}\n\n\t*dev_extent_len = btrfs_dev_extent_length(leaf, extent);\n\n\tret = btrfs_del_item(trans, root, path);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Failed to remove dev extent item\");\n\t} else {\n\t\ttrans->transaction->have_free_bgs = 1;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "chunk_offset",
            "1"
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_remove_chunk(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, u64 chunk_offset)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_root *extent_root = root->fs_info->extent_root;\n\tstruct map_lookup *map;\n\tu64 dev_extent_len = 0;\n\tu64 chunk_objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tu64 chunk_tree = root->fs_info->chunk_root->objectid;\n\tint i, ret = 0;\n\n\t/* Just in case */\n\troot = root->fs_info->chunk_root;\n\tem_tree = &root->fs_info->mapping_tree.map_tree;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, chunk_offset, 1);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em || em->start > chunk_offset ||\n\t    em->start + em->len < chunk_offset) {\n\t\t/*\n\t\t * This is a logic error, but we don't want to just rely on the\n\t\t * user having built with ASSERT enabled, so if ASSERT doens't\n\t\t * do anything we still error out.\n\t\t */\n\t\tASSERT(0);\n\t\tif (em)\n\t\t\tfree_extent_map(em);\n\t\treturn -EINVAL;\n\t}\n\tmap = (struct map_lookup *)em->bdev;\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tstruct btrfs_device *device = map->stripes[i].dev;\n\t\tret = btrfs_free_dev_extent(trans, device,\n\t\t\t\t\t    map->stripes[i].physical,\n\t\t\t\t\t    &dev_extent_len);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (device->bytes_used > 0) {\n\t\t\tlock_chunks(root);\n\t\t\tbtrfs_device_set_bytes_used(device,\n\t\t\t\t\tdevice->bytes_used - dev_extent_len);\n\t\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\t\troot->fs_info->free_chunk_space += dev_extent_len;\n\t\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t\t\tbtrfs_clear_space_info_full(root->fs_info);\n\t\t\tunlock_chunks(root);\n\t\t}\n\n\t\tif (map->stripes[i].dev) {\n\t\t\tret = btrfs_update_device(trans, map->stripes[i].dev);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tret = btrfs_free_chunk(trans, root, chunk_tree, chunk_objectid,\n\t\t\t       chunk_offset);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\ttrace_btrfs_chunk_free(root, map, chunk_offset, em->len);\n\n\tif (map->type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\tret = btrfs_del_sys_chunk(root, chunk_objectid, chunk_offset);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = btrfs_remove_block_group(trans, extent_root, chunk_offset, em);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, extent_root, ret);\n\t\tgoto out;\n\t}\n\nout:\n\t/* once for us */\n\tfree_extent_map(em);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_del_sys_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2526-2572",
    "snippet": "static int btrfs_del_sys_chunk(struct btrfs_root *root, u64 chunk_objectid, u64\n\t\t\tchunk_offset)\n{\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tstruct btrfs_disk_key *disk_key;\n\tstruct btrfs_chunk *chunk;\n\tu8 *ptr;\n\tint ret = 0;\n\tu32 num_stripes;\n\tu32 array_size;\n\tu32 len = 0;\n\tu32 cur;\n\tstruct btrfs_key key;\n\n\tlock_chunks(root);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\n\tptr = super_copy->sys_chunk_array;\n\tcur = 0;\n\n\twhile (cur < array_size) {\n\t\tdisk_key = (struct btrfs_disk_key *)ptr;\n\t\tbtrfs_disk_key_to_cpu(&key, disk_key);\n\n\t\tlen = sizeof(*disk_key);\n\n\t\tif (key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tchunk = (struct btrfs_chunk *)(ptr + len);\n\t\t\tnum_stripes = btrfs_stack_chunk_num_stripes(chunk);\n\t\t\tlen += btrfs_chunk_item_size(num_stripes);\n\t\t} else {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (key.objectid == chunk_objectid &&\n\t\t    key.offset == chunk_offset) {\n\t\t\tmemmove(ptr, ptr + len, array_size - (cur + len));\n\t\t\tarray_size -= len;\n\t\t\tbtrfs_set_super_sys_array_size(super_copy, array_size);\n\t\t} else {\n\t\t\tptr += len;\n\t\t\tcur += len;\n\t\t}\n\t}\n\tunlock_chunks(root);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_chunks",
          "args": [
            "root"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "536-539",
          "snippet": "static inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_sys_array_size",
          "args": [
            "super_copy",
            "array_size"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ptr",
            "ptr + len",
            "array_size - (cur + len)"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_chunk_item_size",
          "args": [
            "num_stripes"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_chunk_item_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "335-340",
          "snippet": "static inline unsigned long btrfs_chunk_item_size(int num_stripes)\n{\n\tBUG_ON(num_stripes == 0);\n\treturn sizeof(struct btrfs_chunk) +\n\t\tsizeof(struct btrfs_stripe) * (num_stripes - 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_chunk_item_size(int num_stripes)\n{\n\tBUG_ON(num_stripes == 0);\n\treturn sizeof(struct btrfs_chunk) +\n\t\tsizeof(struct btrfs_stripe) * (num_stripes - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_chunk_num_stripes",
          "args": [
            "chunk"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_to_cpu",
          "args": [
            "&key",
            "disk_key"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_disk_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2731-2737",
          "snippet": "static inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_sys_array_size",
          "args": [
            "super_copy"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_del_sys_chunk(struct btrfs_root *root, u64 chunk_objectid, u64\n\t\t\tchunk_offset)\n{\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tstruct btrfs_disk_key *disk_key;\n\tstruct btrfs_chunk *chunk;\n\tu8 *ptr;\n\tint ret = 0;\n\tu32 num_stripes;\n\tu32 array_size;\n\tu32 len = 0;\n\tu32 cur;\n\tstruct btrfs_key key;\n\n\tlock_chunks(root);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\n\tptr = super_copy->sys_chunk_array;\n\tcur = 0;\n\n\twhile (cur < array_size) {\n\t\tdisk_key = (struct btrfs_disk_key *)ptr;\n\t\tbtrfs_disk_key_to_cpu(&key, disk_key);\n\n\t\tlen = sizeof(*disk_key);\n\n\t\tif (key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tchunk = (struct btrfs_chunk *)(ptr + len);\n\t\t\tnum_stripes = btrfs_stack_chunk_num_stripes(chunk);\n\t\t\tlen += btrfs_chunk_item_size(num_stripes);\n\t\t} else {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (key.objectid == chunk_objectid &&\n\t\t    key.offset == chunk_offset) {\n\t\t\tmemmove(ptr, ptr + len, array_size - (cur + len));\n\t\t\tarray_size -= len;\n\t\t\tbtrfs_set_super_sys_array_size(super_copy, array_size);\n\t\t} else {\n\t\t\tptr += len;\n\t\t\tcur += len;\n\t\t}\n\t}\n\tunlock_chunks(root);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_free_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2489-2524",
    "snippet": "static int btrfs_free_chunk(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    u64 chunk_tree, u64 chunk_objectid,\n\t\t\t    u64 chunk_offset)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\troot = root->fs_info->chunk_root;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = chunk_objectid;\n\tkey.offset = chunk_offset;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\telse if (ret > 0) { /* Logic error or corruption */\n\t\tbtrfs_error(root->fs_info, -ENOENT,\n\t\t\t    \"Failed lookup while freeing chunk.\");\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, root, path);\n\tif (ret < 0)\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Failed to delete chunk item.\");\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_error",
          "args": [
            "root->fs_info",
            "ret",
            "\"Failed to delete chunk item.\""
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "trans",
            "root",
            "path"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_free_chunk(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    u64 chunk_tree, u64 chunk_objectid,\n\t\t\t    u64 chunk_offset)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\troot = root->fs_info->chunk_root;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = chunk_objectid;\n\tkey.offset = chunk_offset;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\telse if (ret > 0) { /* Logic error or corruption */\n\t\tbtrfs_error(root->fs_info, -ENOENT,\n\t\t\t    \"Failed lookup while freeing chunk.\");\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, root, path);\n\tif (ret < 0)\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Failed to delete chunk item.\");\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_grow_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2451-2487",
    "snippet": "int btrfs_grow_device(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_super_block *super_copy =\n\t\tdevice->dev_root->fs_info->super_copy;\n\tstruct btrfs_fs_devices *fs_devices;\n\tu64 old_total;\n\tu64 diff;\n\n\tif (!device->writeable)\n\t\treturn -EACCES;\n\n\tlock_chunks(device->dev_root);\n\told_total = btrfs_super_total_bytes(super_copy);\n\tdiff = new_size - device->total_bytes;\n\n\tif (new_size <= device->total_bytes ||\n\t    device->is_tgtdev_for_dev_replace) {\n\t\tunlock_chunks(device->dev_root);\n\t\treturn -EINVAL;\n\t}\n\n\tfs_devices = device->dev_root->fs_info->fs_devices;\n\n\tbtrfs_set_super_total_bytes(super_copy, old_total + diff);\n\tdevice->fs_devices->total_rw_bytes += diff;\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tbtrfs_clear_space_info_full(device->dev_root->fs_info);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &fs_devices->resized_devices);\n\tunlock_chunks(device->dev_root);\n\n\treturn btrfs_update_device(trans, device);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_update_device",
          "args": [
            "trans",
            "device"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2403-2449",
          "snippet": "static noinline int btrfs_update_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\troot = device->dev_root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_mark_buffer_dirty(leaf);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline int btrfs_update_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\troot = device->dev_root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_mark_buffer_dirty(leaf);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_chunks",
          "args": [
            "device->dev_root"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "536-539",
          "snippet": "static inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&device->resized_list",
            "&fs_devices->resized_devices"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&device->resized_list"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clear_space_info_full",
          "args": [
            "device->dev_root->fs_info"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_space_info_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "703-712",
          "snippet": "void btrfs_clear_space_info_full(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head = &info->space_info;\n\tstruct btrfs_space_info *found;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(found, head, list)\n\t\tfound->full = 0;\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_clear_space_info_full(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head = &info->space_info;\n\tstruct btrfs_space_info *found;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(found, head, list)\n\t\tfound->full = 0;\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_set_disk_total_bytes",
          "args": [
            "device",
            "new_size"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_set_total_bytes",
          "args": [
            "device",
            "new_size"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_total_bytes",
          "args": [
            "super_copy",
            "old_total + diff"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_total_bytes",
          "args": [
            "super_copy"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_grow_device(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_super_block *super_copy =\n\t\tdevice->dev_root->fs_info->super_copy;\n\tstruct btrfs_fs_devices *fs_devices;\n\tu64 old_total;\n\tu64 diff;\n\n\tif (!device->writeable)\n\t\treturn -EACCES;\n\n\tlock_chunks(device->dev_root);\n\told_total = btrfs_super_total_bytes(super_copy);\n\tdiff = new_size - device->total_bytes;\n\n\tif (new_size <= device->total_bytes ||\n\t    device->is_tgtdev_for_dev_replace) {\n\t\tunlock_chunks(device->dev_root);\n\t\treturn -EINVAL;\n\t}\n\n\tfs_devices = device->dev_root->fs_info->fs_devices;\n\n\tbtrfs_set_super_total_bytes(super_copy, old_total + diff);\n\tdevice->fs_devices->total_rw_bytes += diff;\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tbtrfs_clear_space_info_full(device->dev_root->fs_info);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &fs_devices->resized_devices);\n\tunlock_chunks(device->dev_root);\n\n\treturn btrfs_update_device(trans, device);\n}"
  },
  {
    "function_name": "btrfs_update_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2403-2449",
    "snippet": "static noinline int btrfs_update_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\troot = device->dev_root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_mark_buffer_dirty(leaf);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_bytes_used",
          "args": [
            "leaf",
            "dev_item",
            "btrfs_device_get_bytes_used(device)"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_bytes_used",
          "args": [
            "device"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_total_bytes",
          "args": [
            "leaf",
            "dev_item",
            "btrfs_device_get_disk_total_bytes(device)"
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_disk_total_bytes",
          "args": [
            "device"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_sector_size",
          "args": [
            "leaf",
            "dev_item",
            "device->sector_size"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_io_width",
          "args": [
            "leaf",
            "dev_item",
            "device->io_width"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_io_align",
          "args": [
            "leaf",
            "dev_item",
            "device->io_align"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_type",
          "args": [
            "leaf",
            "dev_item",
            "device->type"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_id",
          "args": [
            "leaf",
            "dev_item",
            "device->devid"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_dev_item"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "0",
            "1"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline int btrfs_update_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\troot = device->dev_root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_mark_buffer_dirty(leaf);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_init_dev_replace_tgtdev_for_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2392-2401",
    "snippet": "void btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t      struct btrfs_device *tgtdev)\n{\n\tWARN_ON(fs_info->fs_devices->rw_devices == 0);\n\ttgtdev->io_width = fs_info->dev_root->sectorsize;\n\ttgtdev->io_align = fs_info->dev_root->sectorsize;\n\ttgtdev->sector_size = fs_info->dev_root->sectorsize;\n\ttgtdev->dev_root = fs_info->dev_root;\n\ttgtdev->in_fs_metadata = 1;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "fs_info->fs_devices->rw_devices == 0"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t      struct btrfs_device *tgtdev)\n{\n\tWARN_ON(fs_info->fs_devices->rw_devices == 0);\n\ttgtdev->io_width = fs_info->dev_root->sectorsize;\n\ttgtdev->io_align = fs_info->dev_root->sectorsize;\n\ttgtdev->sector_size = fs_info->dev_root->sectorsize;\n\ttgtdev->dev_root = fs_info->dev_root;\n\ttgtdev->in_fs_metadata = 1;\n}"
  },
  {
    "function_name": "btrfs_init_dev_replace_tgtdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2296-2390",
    "snippet": "int btrfs_init_dev_replace_tgtdev(struct btrfs_root *root, char *device_path,\n\t\t\t\t  struct btrfs_device *srcdev,\n\t\t\t\t  struct btrfs_device **device_out)\n{\n\tstruct request_queue *q;\n\tstruct btrfs_device *device;\n\tstruct block_device *bdev;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head *devices;\n\tstruct rcu_string *name;\n\tu64 devid = BTRFS_DEV_REPLACE_DEVID;\n\tint ret = 0;\n\n\t*device_out = NULL;\n\tif (fs_info->fs_devices->seeding) {\n\t\tbtrfs_err(fs_info, \"the filesystem is a seed filesystem!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = blkdev_get_by_path(device_path, FMODE_WRITE | FMODE_EXCL,\n\t\t\t\t  fs_info->bdev_holder);\n\tif (IS_ERR(bdev)) {\n\t\tbtrfs_err(fs_info, \"target device %s is invalid!\", device_path);\n\t\treturn PTR_ERR(bdev);\n\t}\n\n\tfilemap_write_and_wait(bdev->bd_inode->i_mapping);\n\n\tdevices = &fs_info->fs_devices->devices;\n\tlist_for_each_entry(device, devices, dev_list) {\n\t\tif (device->bdev == bdev) {\n\t\t\tbtrfs_err(fs_info, \"target device is in the filesystem!\");\n\t\t\tret = -EEXIST;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\n\tif (i_size_read(bdev->bd_inode) <\n\t    btrfs_device_get_total_bytes(srcdev)) {\n\t\tbtrfs_err(fs_info, \"target device is smaller than source device!\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\n\tdevice = btrfs_alloc_device(NULL, &devid, NULL);\n\tif (IS_ERR(device)) {\n\t\tret = PTR_ERR(device);\n\t\tgoto error;\n\t}\n\n\tname = rcu_string_strdup(device_path, GFP_NOFS);\n\tif (!name) {\n\t\tkfree(device);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\trcu_assign_pointer(device->name, name);\n\n\tq = bdev_get_queue(bdev);\n\tif (blk_queue_discard(q))\n\t\tdevice->can_discard = 1;\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tdevice->writeable = 1;\n\tdevice->generation = 0;\n\tdevice->io_width = root->sectorsize;\n\tdevice->io_align = root->sectorsize;\n\tdevice->sector_size = root->sectorsize;\n\tdevice->total_bytes = btrfs_device_get_total_bytes(srcdev);\n\tdevice->disk_total_bytes = btrfs_device_get_disk_total_bytes(srcdev);\n\tdevice->bytes_used = btrfs_device_get_bytes_used(srcdev);\n\tASSERT(list_empty(&srcdev->resized_list));\n\tdevice->commit_total_bytes = srcdev->commit_total_bytes;\n\tdevice->commit_bytes_used = device->bytes_used;\n\tdevice->dev_root = fs_info->dev_root;\n\tdevice->bdev = bdev;\n\tdevice->in_fs_metadata = 1;\n\tdevice->is_tgtdev_for_dev_replace = 1;\n\tdevice->mode = FMODE_EXCL;\n\tdevice->dev_stats_valid = 1;\n\tset_blocksize(device->bdev, 4096);\n\tdevice->fs_devices = fs_info->fs_devices;\n\tlist_add(&device->dev_list, &fs_info->fs_devices->devices);\n\tfs_info->fs_devices->num_devices++;\n\tfs_info->fs_devices->open_devices++;\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\t*device_out = device;\n\treturn ret;\n\nerror:\n\tblkdev_put(bdev, FMODE_EXCL);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "FMODE_EXCL"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&device->dev_list",
            "&fs_info->fs_devices->devices"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "device->bdev",
            "4096"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&srcdev->resized_list)"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&srcdev->resized_list"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_bytes_used",
          "args": [
            "srcdev"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_disk_total_bytes",
          "args": [
            "srcdev"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_total_bytes",
          "args": [
            "srcdev"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "bdev"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "device->name",
            "name"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "device"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_string_strdup",
          "args": [
            "device_path",
            "GFP_NOFS"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_string_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/rcu-string.h",
          "lines": "24-33",
          "snippet": "static inline struct rcu_string *rcu_string_strdup(const char *src, gfp_t mask)\n{\n\tsize_t len = strlen(src) + 1;\n\tstruct rcu_string *ret = kzalloc(sizeof(struct rcu_string) +\n\t\t\t\t\t (len * sizeof(char)), mask);\n\tif (!ret)\n\t\treturn ret;\n\tstrncpy(ret->str, src, len);\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct rcu_string *rcu_string_strdup(const char *src, gfp_t mask)\n{\n\tsize_t len = strlen(src) + 1;\n\tstruct rcu_string *ret = kzalloc(sizeof(struct rcu_string) +\n\t\t\t\t\t (len * sizeof(char)), mask);\n\tif (!ret)\n\t\treturn ret;\n\tstrncpy(ret->str, src, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "device"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "device"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_device",
          "args": [
            "NULL",
            "&devid",
            "NULL"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5971-6007",
          "snippet": "struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"target device is smaller than source device!\""
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_total_bytes",
          "args": [
            "srcdev"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"target device is in the filesystem!\""
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "devices",
            "dev_list"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "bdev->bd_inode->i_mapping"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bdev"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"target device %s is invalid!\"",
            "device_path"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bdev"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_path",
          "args": [
            "device_path",
            "FMODE_WRITE | FMODE_EXCL",
            "fs_info->bdev_holder"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1387-1407",
          "snippet": "struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"the filesystem is a seed filesystem!\""
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_init_dev_replace_tgtdev(struct btrfs_root *root, char *device_path,\n\t\t\t\t  struct btrfs_device *srcdev,\n\t\t\t\t  struct btrfs_device **device_out)\n{\n\tstruct request_queue *q;\n\tstruct btrfs_device *device;\n\tstruct block_device *bdev;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head *devices;\n\tstruct rcu_string *name;\n\tu64 devid = BTRFS_DEV_REPLACE_DEVID;\n\tint ret = 0;\n\n\t*device_out = NULL;\n\tif (fs_info->fs_devices->seeding) {\n\t\tbtrfs_err(fs_info, \"the filesystem is a seed filesystem!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = blkdev_get_by_path(device_path, FMODE_WRITE | FMODE_EXCL,\n\t\t\t\t  fs_info->bdev_holder);\n\tif (IS_ERR(bdev)) {\n\t\tbtrfs_err(fs_info, \"target device %s is invalid!\", device_path);\n\t\treturn PTR_ERR(bdev);\n\t}\n\n\tfilemap_write_and_wait(bdev->bd_inode->i_mapping);\n\n\tdevices = &fs_info->fs_devices->devices;\n\tlist_for_each_entry(device, devices, dev_list) {\n\t\tif (device->bdev == bdev) {\n\t\t\tbtrfs_err(fs_info, \"target device is in the filesystem!\");\n\t\t\tret = -EEXIST;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\n\tif (i_size_read(bdev->bd_inode) <\n\t    btrfs_device_get_total_bytes(srcdev)) {\n\t\tbtrfs_err(fs_info, \"target device is smaller than source device!\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\n\tdevice = btrfs_alloc_device(NULL, &devid, NULL);\n\tif (IS_ERR(device)) {\n\t\tret = PTR_ERR(device);\n\t\tgoto error;\n\t}\n\n\tname = rcu_string_strdup(device_path, GFP_NOFS);\n\tif (!name) {\n\t\tkfree(device);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\trcu_assign_pointer(device->name, name);\n\n\tq = bdev_get_queue(bdev);\n\tif (blk_queue_discard(q))\n\t\tdevice->can_discard = 1;\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tdevice->writeable = 1;\n\tdevice->generation = 0;\n\tdevice->io_width = root->sectorsize;\n\tdevice->io_align = root->sectorsize;\n\tdevice->sector_size = root->sectorsize;\n\tdevice->total_bytes = btrfs_device_get_total_bytes(srcdev);\n\tdevice->disk_total_bytes = btrfs_device_get_disk_total_bytes(srcdev);\n\tdevice->bytes_used = btrfs_device_get_bytes_used(srcdev);\n\tASSERT(list_empty(&srcdev->resized_list));\n\tdevice->commit_total_bytes = srcdev->commit_total_bytes;\n\tdevice->commit_bytes_used = device->bytes_used;\n\tdevice->dev_root = fs_info->dev_root;\n\tdevice->bdev = bdev;\n\tdevice->in_fs_metadata = 1;\n\tdevice->is_tgtdev_for_dev_replace = 1;\n\tdevice->mode = FMODE_EXCL;\n\tdevice->dev_stats_valid = 1;\n\tset_blocksize(device->bdev, 4096);\n\tdevice->fs_devices = fs_info->fs_devices;\n\tlist_add(&device->dev_list, &fs_info->fs_devices->devices);\n\tfs_info->fs_devices->num_devices++;\n\tfs_info->fs_devices->open_devices++;\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\t*device_out = device;\n\treturn ret;\n\nerror:\n\tblkdev_put(bdev, FMODE_EXCL);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_init_new_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2088-2294",
    "snippet": "int btrfs_init_new_device(struct btrfs_root *root, char *device_path)\n{\n\tstruct request_queue *q;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_device *device;\n\tstruct block_device *bdev;\n\tstruct list_head *devices;\n\tstruct super_block *sb = root->fs_info->sb;\n\tstruct rcu_string *name;\n\tu64 tmp;\n\tint seeding_dev = 0;\n\tint ret = 0;\n\n\tif ((sb->s_flags & MS_RDONLY) && !root->fs_info->fs_devices->seeding)\n\t\treturn -EROFS;\n\n\tbdev = blkdev_get_by_path(device_path, FMODE_WRITE | FMODE_EXCL,\n\t\t\t\t  root->fs_info->bdev_holder);\n\tif (IS_ERR(bdev))\n\t\treturn PTR_ERR(bdev);\n\n\tif (root->fs_info->fs_devices->seeding) {\n\t\tseeding_dev = 1;\n\t\tdown_write(&sb->s_umount);\n\t\tmutex_lock(&uuid_mutex);\n\t}\n\n\tfilemap_write_and_wait(bdev->bd_inode->i_mapping);\n\n\tdevices = &root->fs_info->fs_devices->devices;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, devices, dev_list) {\n\t\tif (device->bdev == bdev) {\n\t\t\tret = -EEXIST;\n\t\t\tmutex_unlock(\n\t\t\t\t&root->fs_info->fs_devices->device_list_mutex);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tdevice = btrfs_alloc_device(root->fs_info, NULL, NULL);\n\tif (IS_ERR(device)) {\n\t\t/* we can safely leave the fs_devices entry around */\n\t\tret = PTR_ERR(device);\n\t\tgoto error;\n\t}\n\n\tname = rcu_string_strdup(device_path, GFP_NOFS);\n\tif (!name) {\n\t\tkfree(device);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\trcu_assign_pointer(device->name, name);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t\tret = PTR_ERR(trans);\n\t\tgoto error;\n\t}\n\n\tq = bdev_get_queue(bdev);\n\tif (blk_queue_discard(q))\n\t\tdevice->can_discard = 1;\n\tdevice->writeable = 1;\n\tdevice->generation = trans->transid;\n\tdevice->io_width = root->sectorsize;\n\tdevice->io_align = root->sectorsize;\n\tdevice->sector_size = root->sectorsize;\n\tdevice->total_bytes = i_size_read(bdev->bd_inode);\n\tdevice->disk_total_bytes = device->total_bytes;\n\tdevice->commit_total_bytes = device->total_bytes;\n\tdevice->dev_root = root->fs_info->dev_root;\n\tdevice->bdev = bdev;\n\tdevice->in_fs_metadata = 1;\n\tdevice->is_tgtdev_for_dev_replace = 0;\n\tdevice->mode = FMODE_EXCL;\n\tdevice->dev_stats_valid = 1;\n\tset_blocksize(device->bdev, 4096);\n\n\tif (seeding_dev) {\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t\tret = btrfs_prepare_sprout(root);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tdevice->fs_devices = root->fs_info->fs_devices;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlock_chunks(root);\n\tlist_add_rcu(&device->dev_list, &root->fs_info->fs_devices->devices);\n\tlist_add(&device->dev_alloc_list,\n\t\t &root->fs_info->fs_devices->alloc_list);\n\troot->fs_info->fs_devices->num_devices++;\n\troot->fs_info->fs_devices->open_devices++;\n\troot->fs_info->fs_devices->rw_devices++;\n\troot->fs_info->fs_devices->total_devices++;\n\troot->fs_info->fs_devices->total_rw_bytes += device->total_bytes;\n\n\tspin_lock(&root->fs_info->free_chunk_lock);\n\troot->fs_info->free_chunk_space += device->total_bytes;\n\tspin_unlock(&root->fs_info->free_chunk_lock);\n\n\tif (!blk_queue_nonrot(bdev_get_queue(bdev)))\n\t\troot->fs_info->fs_devices->rotating = 1;\n\n\ttmp = btrfs_super_total_bytes(root->fs_info->super_copy);\n\tbtrfs_set_super_total_bytes(root->fs_info->super_copy,\n\t\t\t\t    tmp + device->total_bytes);\n\n\ttmp = btrfs_super_num_devices(root->fs_info->super_copy);\n\tbtrfs_set_super_num_devices(root->fs_info->super_copy,\n\t\t\t\t    tmp + 1);\n\n\t/* add sysfs device entry */\n\tbtrfs_kobj_add_device(root->fs_info, device);\n\n\t/*\n\t * we've got more storage, clear any full flags on the space\n\t * infos\n\t */\n\tbtrfs_clear_space_info_full(root->fs_info);\n\n\tunlock_chunks(root);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tif (seeding_dev) {\n\t\tlock_chunks(root);\n\t\tret = init_first_rw_device(trans, root, device);\n\t\tunlock_chunks(root);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto error_trans;\n\t\t}\n\t}\n\n\tret = btrfs_add_device(trans, root, device);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto error_trans;\n\t}\n\n\tif (seeding_dev) {\n\t\tchar fsid_buf[BTRFS_UUID_UNPARSED_SIZE];\n\n\t\tret = btrfs_finish_sprout(trans, root);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto error_trans;\n\t\t}\n\n\t\t/* Sprouting would change fsid of the mounted root,\n\t\t * so rename the fsid on the sysfs\n\t\t */\n\t\tsnprintf(fsid_buf, BTRFS_UUID_UNPARSED_SIZE, \"%pU\",\n\t\t\t\t\t\troot->fs_info->fsid);\n\t\tif (kobject_rename(&root->fs_info->super_kobj, fsid_buf))\n\t\t\tgoto error_trans;\n\t}\n\n\troot->fs_info->num_tolerated_disk_barrier_failures =\n\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(root->fs_info);\n\tret = btrfs_commit_transaction(trans, root);\n\n\tif (seeding_dev) {\n\t\tmutex_unlock(&uuid_mutex);\n\t\tup_write(&sb->s_umount);\n\n\t\tif (ret) /* transaction commit */\n\t\t\treturn ret;\n\n\t\tret = btrfs_relocate_sys_chunks(root);\n\t\tif (ret < 0)\n\t\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t\t    \"Failed to relocate sys chunks after \"\n\t\t\t\t    \"device initialization. This can be fixed \"\n\t\t\t\t    \"using the \\\"btrfs balance\\\" command.\");\n\t\ttrans = btrfs_attach_transaction(root);\n\t\tif (IS_ERR(trans)) {\n\t\t\tif (PTR_ERR(trans) == -ENOENT)\n\t\t\t\treturn 0;\n\t\t\treturn PTR_ERR(trans);\n\t\t}\n\t\tret = btrfs_commit_transaction(trans, root);\n\t}\n\n\t/* Update ctime/mtime for libblkid */\n\tupdate_dev_time(device_path);\n\treturn ret;\n\nerror_trans:\n\tbtrfs_end_transaction(trans, root);\n\trcu_string_free(device->name);\n\tbtrfs_kobj_rm_device(root->fs_info, device);\n\tkfree(device);\nerror:\n\tblkdev_put(bdev, FMODE_EXCL);\n\tif (seeding_dev) {\n\t\tmutex_unlock(&uuid_mutex);\n\t\tup_write(&sb->s_umount);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "FMODE_EXCL"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "device"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_kobj_rm_device",
          "args": [
            "root->fs_info",
            "device"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kobj_rm_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/sysfs.c",
          "lines": "605-623",
          "snippet": "int btrfs_kobj_rm_device(struct btrfs_fs_info *fs_info,\n\t\tstruct btrfs_device *one_device)\n{\n\tstruct hd_struct *disk;\n\tstruct kobject *disk_kobj;\n\n\tif (!fs_info->device_dir_kobj)\n\t\treturn -EINVAL;\n\n\tif (one_device && one_device->bdev) {\n\t\tdisk = one_device->bdev->bd_part;\n\t\tdisk_kobj = &part_to_dev(disk)->kobj;\n\n\t\tsysfs_remove_link(fs_info->device_dir_kobj,\n\t\t\t\t\t\tdisk_kobj->name);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"sysfs.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bug.h>",
            "#include <linux/kobject.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"sysfs.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/debugfs.h>\n#include <linux/genhd.h>\n#include <linux/bug.h>\n#include <linux/kobject.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);\n\nint btrfs_kobj_rm_device(struct btrfs_fs_info *fs_info,\n\t\tstruct btrfs_device *one_device)\n{\n\tstruct hd_struct *disk;\n\tstruct kobject *disk_kobj;\n\n\tif (!fs_info->device_dir_kobj)\n\t\treturn -EINVAL;\n\n\tif (one_device && one_device->bdev) {\n\t\tdisk = one_device->bdev->bd_part;\n\t\tdisk_kobj = &part_to_dev(disk)->kobj;\n\n\t\tsysfs_remove_link(fs_info->device_dir_kobj,\n\t\t\t\t\t\tdisk_kobj->name);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_string_free",
          "args": [
            "device->name"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_string_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/rcu-string.h",
          "lines": "35-39",
          "snippet": "static inline void rcu_string_free(struct rcu_string *str)\n{\n\tif (str)\n\t\tkfree_rcu(str, rcu);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void rcu_string_free(struct rcu_string *str)\n{\n\tif (str)\n\t\tkfree_rcu(str, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dev_time",
          "args": [
            "device_path"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "update_dev_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1485-1495",
          "snippet": "static void update_dev_time(char *path_name)\n{\n\tstruct file *filp;\n\n\tfilp = filp_open(path_name, O_RDWR, 0);\n\tif (IS_ERR(filp))\n\t\treturn;\n\tfile_update_time(filp);\n\tfilp_close(filp, NULL);\n\treturn;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void update_dev_time(char *path_name)\n{\n\tstruct file *filp;\n\n\tfilp = filp_open(path_name, O_RDWR, 0);\n\tif (IS_ERR(filp))\n\t\treturn;\n\tfile_update_time(filp);\n\tfilp_close(filp, NULL);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_attach_transaction",
          "args": [
            "root"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_attach_transaction_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "616-626",
          "snippet": "struct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_error",
          "args": [
            "root->fs_info",
            "ret",
            "\"Failed to relocate sys chunks after \"\n\t\t\t\t    \"device initialization. This can be fixed \"\n\t\t\t\t    \"using the \\\"btrfs balance\\\" command.\""
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_relocate_sys_chunks",
          "args": [
            "root"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_relocate_sys_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2702-2771",
          "snippet": "static int btrfs_relocate_sys_chunks(struct btrfs_root *root)\n{\n\tstruct btrfs_root *chunk_root = root->fs_info->chunk_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_chunk *chunk;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tu64 chunk_tree = chunk_root->root_key.objectid;\n\tu64 chunk_type;\n\tbool retried = false;\n\tint failed = 0;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\nagain:\n\tkey.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, chunk_root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tBUG_ON(ret == 0); /* Corruption */\n\n\t\tret = btrfs_previous_item(chunk_root, path, key.objectid,\n\t\t\t\t\t  key.type);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\tchunk = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t       struct btrfs_chunk);\n\t\tchunk_type = btrfs_chunk_type(leaf, chunk);\n\t\tbtrfs_release_path(path);\n\n\t\tif (chunk_type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\t\tret = btrfs_relocate_chunk(chunk_root, chunk_tree,\n\t\t\t\t\t\t   found_key.objectid,\n\t\t\t\t\t\t   found_key.offset);\n\t\t\tif (ret == -ENOSPC)\n\t\t\t\tfailed++;\n\t\t\telse\n\t\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t\tkey.offset = found_key.offset - 1;\n\t}\n\tret = 0;\n\tif (failed && !retried) {\n\t\tfailed = 0;\n\t\tretried = true;\n\t\tgoto again;\n\t} else if (WARN_ON(failed && retried)) {\n\t\tret = -ENOSPC;\n\t}\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root)\n{\n\tstruct btrfs_root *chunk_root = root->fs_info->chunk_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_chunk *chunk;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tu64 chunk_tree = chunk_root->root_key.objectid;\n\tu64 chunk_type;\n\tbool retried = false;\n\tint failed = 0;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\nagain:\n\tkey.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, chunk_root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tBUG_ON(ret == 0); /* Corruption */\n\n\t\tret = btrfs_previous_item(chunk_root, path, key.objectid,\n\t\t\t\t\t  key.type);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\tchunk = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t       struct btrfs_chunk);\n\t\tchunk_type = btrfs_chunk_type(leaf, chunk);\n\t\tbtrfs_release_path(path);\n\n\t\tif (chunk_type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\t\tret = btrfs_relocate_chunk(chunk_root, chunk_tree,\n\t\t\t\t\t\t   found_key.objectid,\n\t\t\t\t\t\t   found_key.offset);\n\t\t\tif (ret == -ENOSPC)\n\t\t\t\tfailed++;\n\t\t\telse\n\t\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t\tkey.offset = found_key.offset - 1;\n\t}\n\tret = 0;\n\tif (failed && !retried) {\n\t\tfailed = 0;\n\t\tretried = true;\n\t\tgoto again;\n\t} else if (WARN_ON(failed && retried)) {\n\t\tret = -ENOSPC;\n\t}\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_calc_num_tolerated_disk_barrier_failures",
          "args": [
            "root->fs_info"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_calc_num_tolerated_disk_barrier_failures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3348-3424",
          "snippet": "int btrfs_calc_num_tolerated_disk_barrier_failures(\n\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_space_info *sinfo;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint i;\n\tint c;\n\tint num_tolerated_disk_barrier_failures =\n\t\t(int)fs_info->fs_devices->num_devices;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tsinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &fs_info->space_info, list) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tsinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!sinfo)\n\t\t\tcontinue;\n\n\t\tdown_read(&sinfo->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&sinfo->block_groups[c])) {\n\t\t\t\tu64 flags;\n\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&sinfo->block_groups[c], &space);\n\t\t\t\tif (space.total_bytes == 0 ||\n\t\t\t\t    space.used_bytes == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tflags = space.flags;\n\t\t\t\t/*\n\t\t\t\t * return\n\t\t\t\t * 0: if dup, single or RAID0 is configured for\n\t\t\t\t *    any of metadata, system or data, else\n\t\t\t\t * 1: if RAID5 is configured, or if RAID1 or\n\t\t\t\t *    RAID10 is configured and only two mirrors\n\t\t\t\t *    are used, else\n\t\t\t\t * 2: if RAID6 is configured, else\n\t\t\t\t * num_mirrors - 1: if RAID1 or RAID10 is\n\t\t\t\t *                  configured and more than\n\t\t\t\t *                  2 mirrors are used.\n\t\t\t\t */\n\t\t\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t\t\t    ((flags & (BTRFS_BLOCK_GROUP_DUP |\n\t\t\t\t\t       BTRFS_BLOCK_GROUP_RAID0)) ||\n\t\t\t\t     ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK)\n\t\t\t\t      == 0)))\n\t\t\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\t\t\telse if (num_tolerated_disk_barrier_failures > 1) {\n\t\t\t\t\tif (flags & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\t\t\t\t\t} else if (flags &\n\t\t\t\t\t\t   BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tup_read(&sinfo->groups_sem);\n\t}\n\n\treturn num_tolerated_disk_barrier_failures;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_calc_num_tolerated_disk_barrier_failures(\n\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_space_info *sinfo;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint i;\n\tint c;\n\tint num_tolerated_disk_barrier_failures =\n\t\t(int)fs_info->fs_devices->num_devices;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tsinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &fs_info->space_info, list) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tsinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!sinfo)\n\t\t\tcontinue;\n\n\t\tdown_read(&sinfo->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&sinfo->block_groups[c])) {\n\t\t\t\tu64 flags;\n\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&sinfo->block_groups[c], &space);\n\t\t\t\tif (space.total_bytes == 0 ||\n\t\t\t\t    space.used_bytes == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tflags = space.flags;\n\t\t\t\t/*\n\t\t\t\t * return\n\t\t\t\t * 0: if dup, single or RAID0 is configured for\n\t\t\t\t *    any of metadata, system or data, else\n\t\t\t\t * 1: if RAID5 is configured, or if RAID1 or\n\t\t\t\t *    RAID10 is configured and only two mirrors\n\t\t\t\t *    are used, else\n\t\t\t\t * 2: if RAID6 is configured, else\n\t\t\t\t * num_mirrors - 1: if RAID1 or RAID10 is\n\t\t\t\t *                  configured and more than\n\t\t\t\t *                  2 mirrors are used.\n\t\t\t\t */\n\t\t\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t\t\t    ((flags & (BTRFS_BLOCK_GROUP_DUP |\n\t\t\t\t\t       BTRFS_BLOCK_GROUP_RAID0)) ||\n\t\t\t\t     ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK)\n\t\t\t\t      == 0)))\n\t\t\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\t\t\telse if (num_tolerated_disk_barrier_failures > 1) {\n\t\t\t\t\tif (flags & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\t\t\t\t\t} else if (flags &\n\t\t\t\t\t\t   BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tup_read(&sinfo->groups_sem);\n\t}\n\n\treturn num_tolerated_disk_barrier_failures;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_rename",
          "args": [
            "&root->fs_info->super_kobj",
            "fsid_buf"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fsid_buf",
            "BTRFS_UUID_UNPARSED_SIZE",
            "\"%pU\"",
            "root->fs_info->fsid"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_finish_sprout",
          "args": [
            "trans",
            "root"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_finish_sprout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2016-2086",
          "snippet": "static int btrfs_finish_sprout(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct btrfs_device *device;\n\tstruct btrfs_key key;\n\tu8 fs_uuid[BTRFS_UUID_SIZE];\n\tu8 dev_uuid[BTRFS_UUID_SIZE];\n\tu64 devid;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\troot = root->fs_info->chunk_root;\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tleaf = path->nodes[0];\nnext_slot:\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_DEV_ITEMS_OBJECTID ||\n\t\t    key.type != BTRFS_DEV_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tdev_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_dev_item);\n\t\tdevid = btrfs_device_id(leaf, dev_item);\n\t\tread_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tread_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tdevice = btrfs_find_device(root->fs_info, devid, dev_uuid,\n\t\t\t\t\t   fs_uuid);\n\t\tBUG_ON(!device); /* Logic error */\n\n\t\tif (device->fs_devices->seeding) {\n\t\t\tbtrfs_set_device_generation(leaf, dev_item,\n\t\t\t\t\t\t    device->generation);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\n\t\tpath->slots[0]++;\n\t\tgoto next_slot;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_finish_sprout(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct btrfs_device *device;\n\tstruct btrfs_key key;\n\tu8 fs_uuid[BTRFS_UUID_SIZE];\n\tu8 dev_uuid[BTRFS_UUID_SIZE];\n\tu64 devid;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\troot = root->fs_info->chunk_root;\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tleaf = path->nodes[0];\nnext_slot:\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_DEV_ITEMS_OBJECTID ||\n\t\t    key.type != BTRFS_DEV_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tdev_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_dev_item);\n\t\tdevid = btrfs_device_id(leaf, dev_item);\n\t\tread_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tread_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tdevice = btrfs_find_device(root->fs_info, devid, dev_uuid,\n\t\t\t\t\t   fs_uuid);\n\t\tBUG_ON(!device); /* Logic error */\n\n\t\tif (device->fs_devices->seeding) {\n\t\t\tbtrfs_set_device_generation(leaf, dev_item,\n\t\t\t\t\t\t    device->generation);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\n\t\tpath->slots[0]++;\n\t\tgoto next_slot;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_add_device",
          "args": [
            "trans",
            "root",
            "device"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1425-1479",
          "snippet": "static int btrfs_add_device(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tunsigned long ptr;\n\n\troot = root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(*dev_item));\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_generation(leaf, dev_item, 0);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_set_device_group(leaf, dev_item, 0);\n\tbtrfs_set_device_seek_speed(leaf, dev_item, 0);\n\tbtrfs_set_device_bandwidth(leaf, dev_item, 0);\n\tbtrfs_set_device_start_offset(leaf, dev_item, 0);\n\n\tptr = btrfs_device_uuid(dev_item);\n\twrite_extent_buffer(leaf, device->uuid, ptr, BTRFS_UUID_SIZE);\n\tptr = btrfs_device_fsid(dev_item);\n\twrite_extent_buffer(leaf, root->fs_info->fsid, ptr, BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_add_device(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tunsigned long ptr;\n\n\troot = root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(*dev_item));\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_generation(leaf, dev_item, 0);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_set_device_group(leaf, dev_item, 0);\n\tbtrfs_set_device_seek_speed(leaf, dev_item, 0);\n\tbtrfs_set_device_bandwidth(leaf, dev_item, 0);\n\tbtrfs_set_device_start_offset(leaf, dev_item, 0);\n\n\tptr = btrfs_device_uuid(dev_item);\n\twrite_extent_buffer(leaf, device->uuid, ptr, BTRFS_UUID_SIZE);\n\tptr = btrfs_device_fsid(dev_item);\n\twrite_extent_buffer(leaf, root->fs_info->fsid, ptr, BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_chunks",
          "args": [
            "root"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "536-539",
          "snippet": "static inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_first_rw_device",
          "args": [
            "trans",
            "root",
            "device"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "init_first_rw_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4633-4656",
          "snippet": "static noinline int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_device *device)\n{\n\tu64 chunk_offset;\n\tu64 sys_chunk_offset;\n\tu64 alloc_profile;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *extent_root = fs_info->extent_root;\n\tint ret;\n\n\tchunk_offset = find_next_chunk(fs_info);\n\talloc_profile = btrfs_get_alloc_profile(extent_root, 0);\n\tret = __btrfs_alloc_chunk(trans, extent_root, chunk_offset,\n\t\t\t\t  alloc_profile);\n\tif (ret)\n\t\treturn ret;\n\n\tsys_chunk_offset = find_next_chunk(root->fs_info);\n\talloc_profile = btrfs_get_alloc_profile(fs_info->chunk_root, 0);\n\tret = __btrfs_alloc_chunk(trans, extent_root, sys_chunk_offset,\n\t\t\t\t  alloc_profile);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_device *device)\n{\n\tu64 chunk_offset;\n\tu64 sys_chunk_offset;\n\tu64 alloc_profile;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *extent_root = fs_info->extent_root;\n\tint ret;\n\n\tchunk_offset = find_next_chunk(fs_info);\n\talloc_profile = btrfs_get_alloc_profile(extent_root, 0);\n\tret = __btrfs_alloc_chunk(trans, extent_root, chunk_offset,\n\t\t\t\t  alloc_profile);\n\tif (ret)\n\t\treturn ret;\n\n\tsys_chunk_offset = find_next_chunk(root->fs_info);\n\talloc_profile = btrfs_get_alloc_profile(fs_info->chunk_root, 0);\n\tret = __btrfs_alloc_chunk(trans, extent_root, sys_chunk_offset,\n\t\t\t\t  alloc_profile);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_space_info_full",
          "args": [
            "root->fs_info"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_space_info_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "703-712",
          "snippet": "void btrfs_clear_space_info_full(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head = &info->space_info;\n\tstruct btrfs_space_info *found;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(found, head, list)\n\t\tfound->full = 0;\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_clear_space_info_full(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head = &info->space_info;\n\tstruct btrfs_space_info *found;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(found, head, list)\n\t\tfound->full = 0;\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_kobj_add_device",
          "args": [
            "root->fs_info",
            "device"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kobj_add_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/sysfs.c",
          "lines": "625-659",
          "snippet": "int btrfs_kobj_add_device(struct btrfs_fs_info *fs_info,\n\t\tstruct btrfs_device *one_device)\n{\n\tint error = 0;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *dev;\n\n\tif (!fs_info->device_dir_kobj)\n\t\tfs_info->device_dir_kobj = kobject_create_and_add(\"devices\",\n\t\t\t\t\t\t&fs_info->super_kobj);\n\n\tif (!fs_info->device_dir_kobj)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tstruct hd_struct *disk;\n\t\tstruct kobject *disk_kobj;\n\n\t\tif (!dev->bdev)\n\t\t\tcontinue;\n\n\t\tif (one_device && one_device != dev)\n\t\t\tcontinue;\n\n\t\tdisk = dev->bdev->bd_part;\n\t\tdisk_kobj = &part_to_dev(disk)->kobj;\n\n\t\terror = sysfs_create_link(fs_info->device_dir_kobj,\n\t\t\t\t\t  disk_kobj, disk_kobj->name);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"sysfs.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bug.h>",
            "#include <linux/kobject.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"sysfs.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/debugfs.h>\n#include <linux/genhd.h>\n#include <linux/bug.h>\n#include <linux/kobject.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);\n\nint btrfs_kobj_add_device(struct btrfs_fs_info *fs_info,\n\t\tstruct btrfs_device *one_device)\n{\n\tint error = 0;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *dev;\n\n\tif (!fs_info->device_dir_kobj)\n\t\tfs_info->device_dir_kobj = kobject_create_and_add(\"devices\",\n\t\t\t\t\t\t&fs_info->super_kobj);\n\n\tif (!fs_info->device_dir_kobj)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tstruct hd_struct *disk;\n\t\tstruct kobject *disk_kobj;\n\n\t\tif (!dev->bdev)\n\t\t\tcontinue;\n\n\t\tif (one_device && one_device != dev)\n\t\t\tcontinue;\n\n\t\tdisk = dev->bdev->bd_part;\n\t\tdisk_kobj = &part_to_dev(disk)->kobj;\n\n\t\terror = sysfs_create_link(fs_info->device_dir_kobj,\n\t\t\t\t\t  disk_kobj, disk_kobj->name);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_num_devices",
          "args": [
            "root->fs_info->super_copy",
            "tmp + 1"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_num_devices",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_total_bytes",
          "args": [
            "root->fs_info->super_copy",
            "tmp + device->total_bytes"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_total_bytes",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_queue_nonrot",
          "args": [
            "bdev_get_queue(bdev)"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "bdev"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->free_chunk_lock"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->free_chunk_lock"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&device->dev_alloc_list",
            "&root->fs_info->fs_devices->alloc_list"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&device->dev_list",
            "&root->fs_info->fs_devices->devices"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_prepare_sprout",
          "args": [
            "root"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_prepare_sprout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1953-2011",
          "snippet": "static int btrfs_prepare_sprout(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tstruct btrfs_fs_devices *old_devices;\n\tstruct btrfs_fs_devices *seed_devices;\n\tstruct btrfs_super_block *disk_super = root->fs_info->super_copy;\n\tstruct btrfs_device *device;\n\tu64 super_flags;\n\n\tBUG_ON(!mutex_is_locked(&uuid_mutex));\n\tif (!fs_devices->seeding)\n\t\treturn -EINVAL;\n\n\tseed_devices = __alloc_fs_devices();\n\tif (IS_ERR(seed_devices))\n\t\treturn PTR_ERR(seed_devices);\n\n\told_devices = clone_fs_devices(fs_devices);\n\tif (IS_ERR(old_devices)) {\n\t\tkfree(seed_devices);\n\t\treturn PTR_ERR(old_devices);\n\t}\n\n\tlist_add(&old_devices->list, &fs_uuids);\n\n\tmemcpy(seed_devices, fs_devices, sizeof(*seed_devices));\n\tseed_devices->opened = 1;\n\tINIT_LIST_HEAD(&seed_devices->devices);\n\tINIT_LIST_HEAD(&seed_devices->alloc_list);\n\tmutex_init(&seed_devices->device_list_mutex);\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlist_splice_init_rcu(&fs_devices->devices, &seed_devices->devices,\n\t\t\t      synchronize_rcu);\n\tlist_for_each_entry(device, &seed_devices->devices, dev_list)\n\t\tdevice->fs_devices = seed_devices;\n\n\tlock_chunks(root);\n\tlist_splice_init(&fs_devices->alloc_list, &seed_devices->alloc_list);\n\tunlock_chunks(root);\n\n\tfs_devices->seeding = 0;\n\tfs_devices->num_devices = 0;\n\tfs_devices->open_devices = 0;\n\tfs_devices->missing_devices = 0;\n\tfs_devices->rotating = 0;\n\tfs_devices->seed = seed_devices;\n\n\tgenerate_random_uuid(fs_devices->fsid);\n\tmemcpy(root->fs_info->fsid, fs_devices->fsid, BTRFS_FSID_SIZE);\n\tmemcpy(disk_super->fsid, fs_devices->fsid, BTRFS_FSID_SIZE);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tsuper_flags = btrfs_super_flags(disk_super) &\n\t\t      ~BTRFS_SUPER_FLAG_SEEDING;\n\tbtrfs_set_super_flags(disk_super, super_flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_prepare_sprout(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tstruct btrfs_fs_devices *old_devices;\n\tstruct btrfs_fs_devices *seed_devices;\n\tstruct btrfs_super_block *disk_super = root->fs_info->super_copy;\n\tstruct btrfs_device *device;\n\tu64 super_flags;\n\n\tBUG_ON(!mutex_is_locked(&uuid_mutex));\n\tif (!fs_devices->seeding)\n\t\treturn -EINVAL;\n\n\tseed_devices = __alloc_fs_devices();\n\tif (IS_ERR(seed_devices))\n\t\treturn PTR_ERR(seed_devices);\n\n\told_devices = clone_fs_devices(fs_devices);\n\tif (IS_ERR(old_devices)) {\n\t\tkfree(seed_devices);\n\t\treturn PTR_ERR(old_devices);\n\t}\n\n\tlist_add(&old_devices->list, &fs_uuids);\n\n\tmemcpy(seed_devices, fs_devices, sizeof(*seed_devices));\n\tseed_devices->opened = 1;\n\tINIT_LIST_HEAD(&seed_devices->devices);\n\tINIT_LIST_HEAD(&seed_devices->alloc_list);\n\tmutex_init(&seed_devices->device_list_mutex);\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlist_splice_init_rcu(&fs_devices->devices, &seed_devices->devices,\n\t\t\t      synchronize_rcu);\n\tlist_for_each_entry(device, &seed_devices->devices, dev_list)\n\t\tdevice->fs_devices = seed_devices;\n\n\tlock_chunks(root);\n\tlist_splice_init(&fs_devices->alloc_list, &seed_devices->alloc_list);\n\tunlock_chunks(root);\n\n\tfs_devices->seeding = 0;\n\tfs_devices->num_devices = 0;\n\tfs_devices->open_devices = 0;\n\tfs_devices->missing_devices = 0;\n\tfs_devices->rotating = 0;\n\tfs_devices->seed = seed_devices;\n\n\tgenerate_random_uuid(fs_devices->fsid);\n\tmemcpy(root->fs_info->fsid, fs_devices->fsid, BTRFS_FSID_SIZE);\n\tmemcpy(disk_super->fsid, fs_devices->fsid, BTRFS_FSID_SIZE);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tsuper_flags = btrfs_super_flags(disk_super) &\n\t\t      ~BTRFS_SUPER_FLAG_SEEDING;\n\tbtrfs_set_super_flags(disk_super, super_flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "device->bdev",
            "4096"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "bdev"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "device"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "device->name",
            "name"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "device"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_string_strdup",
          "args": [
            "device_path",
            "GFP_NOFS"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_string_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/rcu-string.h",
          "lines": "24-33",
          "snippet": "static inline struct rcu_string *rcu_string_strdup(const char *src, gfp_t mask)\n{\n\tsize_t len = strlen(src) + 1;\n\tstruct rcu_string *ret = kzalloc(sizeof(struct rcu_string) +\n\t\t\t\t\t (len * sizeof(char)), mask);\n\tif (!ret)\n\t\treturn ret;\n\tstrncpy(ret->str, src, len);\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct rcu_string *rcu_string_strdup(const char *src, gfp_t mask)\n{\n\tsize_t len = strlen(src) + 1;\n\tstruct rcu_string *ret = kzalloc(sizeof(struct rcu_string) +\n\t\t\t\t\t (len * sizeof(char)), mask);\n\tif (!ret)\n\t\treturn ret;\n\tstrncpy(ret->str, src, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "device"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "device"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_device",
          "args": [
            "root->fs_info",
            "NULL",
            "NULL"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5971-6007",
          "snippet": "struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "devices",
            "dev_list"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "bdev->bd_inode->i_mapping"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bdev"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bdev"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_path",
          "args": [
            "device_path",
            "FMODE_WRITE | FMODE_EXCL",
            "root->fs_info->bdev_holder"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1387-1407",
          "snippet": "struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_init_new_device(struct btrfs_root *root, char *device_path)\n{\n\tstruct request_queue *q;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_device *device;\n\tstruct block_device *bdev;\n\tstruct list_head *devices;\n\tstruct super_block *sb = root->fs_info->sb;\n\tstruct rcu_string *name;\n\tu64 tmp;\n\tint seeding_dev = 0;\n\tint ret = 0;\n\n\tif ((sb->s_flags & MS_RDONLY) && !root->fs_info->fs_devices->seeding)\n\t\treturn -EROFS;\n\n\tbdev = blkdev_get_by_path(device_path, FMODE_WRITE | FMODE_EXCL,\n\t\t\t\t  root->fs_info->bdev_holder);\n\tif (IS_ERR(bdev))\n\t\treturn PTR_ERR(bdev);\n\n\tif (root->fs_info->fs_devices->seeding) {\n\t\tseeding_dev = 1;\n\t\tdown_write(&sb->s_umount);\n\t\tmutex_lock(&uuid_mutex);\n\t}\n\n\tfilemap_write_and_wait(bdev->bd_inode->i_mapping);\n\n\tdevices = &root->fs_info->fs_devices->devices;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, devices, dev_list) {\n\t\tif (device->bdev == bdev) {\n\t\t\tret = -EEXIST;\n\t\t\tmutex_unlock(\n\t\t\t\t&root->fs_info->fs_devices->device_list_mutex);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tdevice = btrfs_alloc_device(root->fs_info, NULL, NULL);\n\tif (IS_ERR(device)) {\n\t\t/* we can safely leave the fs_devices entry around */\n\t\tret = PTR_ERR(device);\n\t\tgoto error;\n\t}\n\n\tname = rcu_string_strdup(device_path, GFP_NOFS);\n\tif (!name) {\n\t\tkfree(device);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\trcu_assign_pointer(device->name, name);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t\tret = PTR_ERR(trans);\n\t\tgoto error;\n\t}\n\n\tq = bdev_get_queue(bdev);\n\tif (blk_queue_discard(q))\n\t\tdevice->can_discard = 1;\n\tdevice->writeable = 1;\n\tdevice->generation = trans->transid;\n\tdevice->io_width = root->sectorsize;\n\tdevice->io_align = root->sectorsize;\n\tdevice->sector_size = root->sectorsize;\n\tdevice->total_bytes = i_size_read(bdev->bd_inode);\n\tdevice->disk_total_bytes = device->total_bytes;\n\tdevice->commit_total_bytes = device->total_bytes;\n\tdevice->dev_root = root->fs_info->dev_root;\n\tdevice->bdev = bdev;\n\tdevice->in_fs_metadata = 1;\n\tdevice->is_tgtdev_for_dev_replace = 0;\n\tdevice->mode = FMODE_EXCL;\n\tdevice->dev_stats_valid = 1;\n\tset_blocksize(device->bdev, 4096);\n\n\tif (seeding_dev) {\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t\tret = btrfs_prepare_sprout(root);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tdevice->fs_devices = root->fs_info->fs_devices;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlock_chunks(root);\n\tlist_add_rcu(&device->dev_list, &root->fs_info->fs_devices->devices);\n\tlist_add(&device->dev_alloc_list,\n\t\t &root->fs_info->fs_devices->alloc_list);\n\troot->fs_info->fs_devices->num_devices++;\n\troot->fs_info->fs_devices->open_devices++;\n\troot->fs_info->fs_devices->rw_devices++;\n\troot->fs_info->fs_devices->total_devices++;\n\troot->fs_info->fs_devices->total_rw_bytes += device->total_bytes;\n\n\tspin_lock(&root->fs_info->free_chunk_lock);\n\troot->fs_info->free_chunk_space += device->total_bytes;\n\tspin_unlock(&root->fs_info->free_chunk_lock);\n\n\tif (!blk_queue_nonrot(bdev_get_queue(bdev)))\n\t\troot->fs_info->fs_devices->rotating = 1;\n\n\ttmp = btrfs_super_total_bytes(root->fs_info->super_copy);\n\tbtrfs_set_super_total_bytes(root->fs_info->super_copy,\n\t\t\t\t    tmp + device->total_bytes);\n\n\ttmp = btrfs_super_num_devices(root->fs_info->super_copy);\n\tbtrfs_set_super_num_devices(root->fs_info->super_copy,\n\t\t\t\t    tmp + 1);\n\n\t/* add sysfs device entry */\n\tbtrfs_kobj_add_device(root->fs_info, device);\n\n\t/*\n\t * we've got more storage, clear any full flags on the space\n\t * infos\n\t */\n\tbtrfs_clear_space_info_full(root->fs_info);\n\n\tunlock_chunks(root);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tif (seeding_dev) {\n\t\tlock_chunks(root);\n\t\tret = init_first_rw_device(trans, root, device);\n\t\tunlock_chunks(root);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto error_trans;\n\t\t}\n\t}\n\n\tret = btrfs_add_device(trans, root, device);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto error_trans;\n\t}\n\n\tif (seeding_dev) {\n\t\tchar fsid_buf[BTRFS_UUID_UNPARSED_SIZE];\n\n\t\tret = btrfs_finish_sprout(trans, root);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto error_trans;\n\t\t}\n\n\t\t/* Sprouting would change fsid of the mounted root,\n\t\t * so rename the fsid on the sysfs\n\t\t */\n\t\tsnprintf(fsid_buf, BTRFS_UUID_UNPARSED_SIZE, \"%pU\",\n\t\t\t\t\t\troot->fs_info->fsid);\n\t\tif (kobject_rename(&root->fs_info->super_kobj, fsid_buf))\n\t\t\tgoto error_trans;\n\t}\n\n\troot->fs_info->num_tolerated_disk_barrier_failures =\n\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(root->fs_info);\n\tret = btrfs_commit_transaction(trans, root);\n\n\tif (seeding_dev) {\n\t\tmutex_unlock(&uuid_mutex);\n\t\tup_write(&sb->s_umount);\n\n\t\tif (ret) /* transaction commit */\n\t\t\treturn ret;\n\n\t\tret = btrfs_relocate_sys_chunks(root);\n\t\tif (ret < 0)\n\t\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t\t    \"Failed to relocate sys chunks after \"\n\t\t\t\t    \"device initialization. This can be fixed \"\n\t\t\t\t    \"using the \\\"btrfs balance\\\" command.\");\n\t\ttrans = btrfs_attach_transaction(root);\n\t\tif (IS_ERR(trans)) {\n\t\t\tif (PTR_ERR(trans) == -ENOENT)\n\t\t\t\treturn 0;\n\t\t\treturn PTR_ERR(trans);\n\t\t}\n\t\tret = btrfs_commit_transaction(trans, root);\n\t}\n\n\t/* Update ctime/mtime for libblkid */\n\tupdate_dev_time(device_path);\n\treturn ret;\n\nerror_trans:\n\tbtrfs_end_transaction(trans, root);\n\trcu_string_free(device->name);\n\tbtrfs_kobj_rm_device(root->fs_info, device);\n\tkfree(device);\nerror:\n\tblkdev_put(bdev, FMODE_EXCL);\n\tif (seeding_dev) {\n\t\tmutex_unlock(&uuid_mutex);\n\t\tup_write(&sb->s_umount);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_finish_sprout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "2016-2086",
    "snippet": "static int btrfs_finish_sprout(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct btrfs_device *device;\n\tstruct btrfs_key key;\n\tu8 fs_uuid[BTRFS_UUID_SIZE];\n\tu8 dev_uuid[BTRFS_UUID_SIZE];\n\tu64 devid;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\troot = root->fs_info->chunk_root;\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tleaf = path->nodes[0];\nnext_slot:\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_DEV_ITEMS_OBJECTID ||\n\t\t    key.type != BTRFS_DEV_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tdev_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_dev_item);\n\t\tdevid = btrfs_device_id(leaf, dev_item);\n\t\tread_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tread_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tdevice = btrfs_find_device(root->fs_info, devid, dev_uuid,\n\t\t\t\t\t   fs_uuid);\n\t\tBUG_ON(!device); /* Logic error */\n\n\t\tif (device->fs_devices->seeding) {\n\t\t\tbtrfs_set_device_generation(leaf, dev_item,\n\t\t\t\t\t\t    device->generation);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\n\t\tpath->slots[0]++;\n\t\tgoto next_slot;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_generation",
          "args": [
            "leaf",
            "dev_item",
            "device->generation"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!device"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_device",
          "args": [
            "root->fs_info",
            "devid",
            "dev_uuid",
            "fs_uuid"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5918-5936",
          "snippet": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "fs_uuid",
            "btrfs_device_fsid(dev_item)",
            "BTRFS_UUID_SIZE"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_fsid",
          "args": [
            "dev_item"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_device_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2352-2355",
          "snippet": "static inline unsigned long btrfs_device_fsid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, fsid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_device_fsid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, fsid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_uuid",
          "args": [
            "dev_item"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_device_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2347-2350",
          "snippet": "static inline unsigned long btrfs_device_uuid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, uuid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_device_uuid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, uuid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_id",
          "args": [
            "leaf",
            "dev_item"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_dev_item"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "path->slots[0]"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "0",
            "1"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_finish_sprout(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct btrfs_device *device;\n\tstruct btrfs_key key;\n\tu8 fs_uuid[BTRFS_UUID_SIZE];\n\tu8 dev_uuid[BTRFS_UUID_SIZE];\n\tu64 devid;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\troot = root->fs_info->chunk_root;\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tleaf = path->nodes[0];\nnext_slot:\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_DEV_ITEMS_OBJECTID ||\n\t\t    key.type != BTRFS_DEV_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tdev_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_dev_item);\n\t\tdevid = btrfs_device_id(leaf, dev_item);\n\t\tread_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tread_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tdevice = btrfs_find_device(root->fs_info, devid, dev_uuid,\n\t\t\t\t\t   fs_uuid);\n\t\tBUG_ON(!device); /* Logic error */\n\n\t\tif (device->fs_devices->seeding) {\n\t\t\tbtrfs_set_device_generation(leaf, dev_item,\n\t\t\t\t\t\t    device->generation);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\n\t\tpath->slots[0]++;\n\t\tgoto next_slot;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_prepare_sprout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1953-2011",
    "snippet": "static int btrfs_prepare_sprout(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tstruct btrfs_fs_devices *old_devices;\n\tstruct btrfs_fs_devices *seed_devices;\n\tstruct btrfs_super_block *disk_super = root->fs_info->super_copy;\n\tstruct btrfs_device *device;\n\tu64 super_flags;\n\n\tBUG_ON(!mutex_is_locked(&uuid_mutex));\n\tif (!fs_devices->seeding)\n\t\treturn -EINVAL;\n\n\tseed_devices = __alloc_fs_devices();\n\tif (IS_ERR(seed_devices))\n\t\treturn PTR_ERR(seed_devices);\n\n\told_devices = clone_fs_devices(fs_devices);\n\tif (IS_ERR(old_devices)) {\n\t\tkfree(seed_devices);\n\t\treturn PTR_ERR(old_devices);\n\t}\n\n\tlist_add(&old_devices->list, &fs_uuids);\n\n\tmemcpy(seed_devices, fs_devices, sizeof(*seed_devices));\n\tseed_devices->opened = 1;\n\tINIT_LIST_HEAD(&seed_devices->devices);\n\tINIT_LIST_HEAD(&seed_devices->alloc_list);\n\tmutex_init(&seed_devices->device_list_mutex);\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlist_splice_init_rcu(&fs_devices->devices, &seed_devices->devices,\n\t\t\t      synchronize_rcu);\n\tlist_for_each_entry(device, &seed_devices->devices, dev_list)\n\t\tdevice->fs_devices = seed_devices;\n\n\tlock_chunks(root);\n\tlist_splice_init(&fs_devices->alloc_list, &seed_devices->alloc_list);\n\tunlock_chunks(root);\n\n\tfs_devices->seeding = 0;\n\tfs_devices->num_devices = 0;\n\tfs_devices->open_devices = 0;\n\tfs_devices->missing_devices = 0;\n\tfs_devices->rotating = 0;\n\tfs_devices->seed = seed_devices;\n\n\tgenerate_random_uuid(fs_devices->fsid);\n\tmemcpy(root->fs_info->fsid, fs_devices->fsid, BTRFS_FSID_SIZE);\n\tmemcpy(disk_super->fsid, fs_devices->fsid, BTRFS_FSID_SIZE);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tsuper_flags = btrfs_super_flags(disk_super) &\n\t\t      ~BTRFS_SUPER_FLAG_SEEDING;\n\tbtrfs_set_super_flags(disk_super, super_flags);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static LIST_HEAD(fs_uuids);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_set_super_flags",
          "args": [
            "disk_super",
            "super_flags"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_flags",
          "args": [
            "disk_super"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "disk_super->fsid",
            "fs_devices->fsid",
            "BTRFS_FSID_SIZE"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "root->fs_info->fsid",
            "fs_devices->fsid",
            "BTRFS_FSID_SIZE"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generate_random_uuid",
          "args": [
            "fs_devices->fsid"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_chunks",
          "args": [
            "root"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "536-539",
          "snippet": "static inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&fs_devices->alloc_list",
            "&seed_devices->alloc_list"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "&seed_devices->devices",
            "dev_list"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init_rcu",
          "args": [
            "&fs_devices->devices",
            "&seed_devices->devices",
            "synchronize_rcu"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&seed_devices->device_list_mutex"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&seed_devices->alloc_list"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&seed_devices->devices"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "seed_devices",
            "fs_devices",
            "sizeof(*seed_devices)"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&old_devices->list",
            "&fs_uuids"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old_devices"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "seed_devices"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old_devices"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone_fs_devices",
          "args": [
            "fs_devices"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "clone_fs_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "565-610",
          "snippet": "static struct btrfs_fs_devices *clone_fs_devices(struct btrfs_fs_devices *orig)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *orig_dev;\n\n\tfs_devices = alloc_fs_devices(orig->fsid);\n\tif (IS_ERR(fs_devices))\n\t\treturn fs_devices;\n\n\tmutex_lock(&orig->device_list_mutex);\n\tfs_devices->total_devices = orig->total_devices;\n\n\t/* We have held the volume lock, it is safe to get the devices. */\n\tlist_for_each_entry(orig_dev, &orig->devices, dev_list) {\n\t\tstruct rcu_string *name;\n\n\t\tdevice = btrfs_alloc_device(NULL, &orig_dev->devid,\n\t\t\t\t\t    orig_dev->uuid);\n\t\tif (IS_ERR(device))\n\t\t\tgoto error;\n\n\t\t/*\n\t\t * This is ok to do without rcu read locked because we hold the\n\t\t * uuid mutex so nothing we touch in here is going to disappear.\n\t\t */\n\t\tif (orig_dev->name) {\n\t\t\tname = rcu_string_strdup(orig_dev->name->str, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\tkfree(device);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\trcu_assign_pointer(device->name, name);\n\t\t}\n\n\t\tlist_add(&device->dev_list, &fs_devices->devices);\n\t\tdevice->fs_devices = fs_devices;\n\t\tfs_devices->num_devices++;\n\t}\n\tmutex_unlock(&orig->device_list_mutex);\n\treturn fs_devices;\nerror:\n\tmutex_unlock(&orig->device_list_mutex);\n\tfree_fs_devices(fs_devices);\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_fs_devices *clone_fs_devices(struct btrfs_fs_devices *orig)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *orig_dev;\n\n\tfs_devices = alloc_fs_devices(orig->fsid);\n\tif (IS_ERR(fs_devices))\n\t\treturn fs_devices;\n\n\tmutex_lock(&orig->device_list_mutex);\n\tfs_devices->total_devices = orig->total_devices;\n\n\t/* We have held the volume lock, it is safe to get the devices. */\n\tlist_for_each_entry(orig_dev, &orig->devices, dev_list) {\n\t\tstruct rcu_string *name;\n\n\t\tdevice = btrfs_alloc_device(NULL, &orig_dev->devid,\n\t\t\t\t\t    orig_dev->uuid);\n\t\tif (IS_ERR(device))\n\t\t\tgoto error;\n\n\t\t/*\n\t\t * This is ok to do without rcu read locked because we hold the\n\t\t * uuid mutex so nothing we touch in here is going to disappear.\n\t\t */\n\t\tif (orig_dev->name) {\n\t\t\tname = rcu_string_strdup(orig_dev->name->str, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\tkfree(device);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\trcu_assign_pointer(device->name, name);\n\t\t}\n\n\t\tlist_add(&device->dev_list, &fs_devices->devices);\n\t\tdevice->fs_devices = fs_devices;\n\t\tfs_devices->num_devices++;\n\t}\n\tmutex_unlock(&orig->device_list_mutex);\n\treturn fs_devices;\nerror:\n\tmutex_unlock(&orig->device_list_mutex);\n\tfree_fs_devices(fs_devices);\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "seed_devices"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "seed_devices"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_fs_devices",
          "args": [],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_fs_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "56-72",
          "snippet": "static struct btrfs_fs_devices *__alloc_fs_devices(void)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = kzalloc(sizeof(*fs_devs), GFP_NOFS);\n\tif (!fs_devs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&fs_devs->device_list_mutex);\n\n\tINIT_LIST_HEAD(&fs_devs->devices);\n\tINIT_LIST_HEAD(&fs_devs->resized_devices);\n\tINIT_LIST_HEAD(&fs_devs->alloc_list);\n\tINIT_LIST_HEAD(&fs_devs->list);\n\n\treturn fs_devs;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_fs_devices *__alloc_fs_devices(void)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = kzalloc(sizeof(*fs_devs), GFP_NOFS);\n\tif (!fs_devs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&fs_devs->device_list_mutex);\n\n\tINIT_LIST_HEAD(&fs_devs->devices);\n\tINIT_LIST_HEAD(&fs_devs->resized_devices);\n\tINIT_LIST_HEAD(&fs_devs->alloc_list);\n\tINIT_LIST_HEAD(&fs_devs->list);\n\n\treturn fs_devs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&uuid_mutex)"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&uuid_mutex"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_prepare_sprout(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tstruct btrfs_fs_devices *old_devices;\n\tstruct btrfs_fs_devices *seed_devices;\n\tstruct btrfs_super_block *disk_super = root->fs_info->super_copy;\n\tstruct btrfs_device *device;\n\tu64 super_flags;\n\n\tBUG_ON(!mutex_is_locked(&uuid_mutex));\n\tif (!fs_devices->seeding)\n\t\treturn -EINVAL;\n\n\tseed_devices = __alloc_fs_devices();\n\tif (IS_ERR(seed_devices))\n\t\treturn PTR_ERR(seed_devices);\n\n\told_devices = clone_fs_devices(fs_devices);\n\tif (IS_ERR(old_devices)) {\n\t\tkfree(seed_devices);\n\t\treturn PTR_ERR(old_devices);\n\t}\n\n\tlist_add(&old_devices->list, &fs_uuids);\n\n\tmemcpy(seed_devices, fs_devices, sizeof(*seed_devices));\n\tseed_devices->opened = 1;\n\tINIT_LIST_HEAD(&seed_devices->devices);\n\tINIT_LIST_HEAD(&seed_devices->alloc_list);\n\tmutex_init(&seed_devices->device_list_mutex);\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlist_splice_init_rcu(&fs_devices->devices, &seed_devices->devices,\n\t\t\t      synchronize_rcu);\n\tlist_for_each_entry(device, &seed_devices->devices, dev_list)\n\t\tdevice->fs_devices = seed_devices;\n\n\tlock_chunks(root);\n\tlist_splice_init(&fs_devices->alloc_list, &seed_devices->alloc_list);\n\tunlock_chunks(root);\n\n\tfs_devices->seeding = 0;\n\tfs_devices->num_devices = 0;\n\tfs_devices->open_devices = 0;\n\tfs_devices->missing_devices = 0;\n\tfs_devices->rotating = 0;\n\tfs_devices->seed = seed_devices;\n\n\tgenerate_random_uuid(fs_devices->fsid);\n\tmemcpy(root->fs_info->fsid, fs_devices->fsid, BTRFS_FSID_SIZE);\n\tmemcpy(disk_super->fsid, fs_devices->fsid, BTRFS_FSID_SIZE);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tsuper_flags = btrfs_super_flags(disk_super) &\n\t\t      ~BTRFS_SUPER_FLAG_SEEDING;\n\tbtrfs_set_super_flags(disk_super, super_flags);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_find_device_missing_or_by_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1918-1948",
    "snippet": "int btrfs_find_device_missing_or_by_path(struct btrfs_root *root,\n\t\t\t\t\t char *device_path,\n\t\t\t\t\t struct btrfs_device **device)\n{\n\t*device = NULL;\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tstruct list_head *devices;\n\t\tstruct btrfs_device *tmp;\n\n\t\tdevices = &root->fs_info->fs_devices->devices;\n\t\t/*\n\t\t * It is safe to read the devices since the volume_mutex\n\t\t * is held by the caller.\n\t\t */\n\t\tlist_for_each_entry(tmp, devices, dev_list) {\n\t\t\tif (tmp->in_fs_metadata && !tmp->bdev) {\n\t\t\t\t*device = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!*device) {\n\t\t\tbtrfs_err(root->fs_info, \"no missing device found\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\treturn 0;\n\t} else {\n\t\treturn btrfs_find_device_by_path(root, device_path, device);\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_find_device_by_path",
          "args": [
            "root",
            "device_path",
            "device"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1891-1916",
          "snippet": "static int btrfs_find_device_by_path(struct btrfs_root *root, char *device_path,\n\t\t\t\t     struct btrfs_device **device)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tu8 *dev_uuid;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh;\n\n\t*device = NULL;\n\tret = btrfs_get_bdev_and_sb(device_path, FMODE_READ,\n\t\t\t\t    root->fs_info->bdev_holder, 0, &bdev, &bh);\n\tif (ret)\n\t\treturn ret;\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\tdev_uuid = disk_super->dev_item.uuid;\n\t*device = btrfs_find_device(root->fs_info, devid, dev_uuid,\n\t\t\t\t    disk_super->fsid);\n\tbrelse(bh);\n\tif (!*device)\n\t\tret = -ENOENT;\n\tblkdev_put(bdev, FMODE_READ);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_find_device_by_path(struct btrfs_root *root, char *device_path,\n\t\t\t\t     struct btrfs_device **device)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tu8 *dev_uuid;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh;\n\n\t*device = NULL;\n\tret = btrfs_get_bdev_and_sb(device_path, FMODE_READ,\n\t\t\t\t    root->fs_info->bdev_holder, 0, &bdev, &bh);\n\tif (ret)\n\t\treturn ret;\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\tdev_uuid = disk_super->dev_item.uuid;\n\t*device = btrfs_find_device(root->fs_info, devid, dev_uuid,\n\t\t\t\t    disk_super->fsid);\n\tbrelse(bh);\n\tif (!*device)\n\t\tret = -ENOENT;\n\tblkdev_put(bdev, FMODE_READ);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"no missing device found\""
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "devices",
            "dev_list"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "device_path",
            "\"missing\""
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_find_device_missing_or_by_path(struct btrfs_root *root,\n\t\t\t\t\t char *device_path,\n\t\t\t\t\t struct btrfs_device **device)\n{\n\t*device = NULL;\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tstruct list_head *devices;\n\t\tstruct btrfs_device *tmp;\n\n\t\tdevices = &root->fs_info->fs_devices->devices;\n\t\t/*\n\t\t * It is safe to read the devices since the volume_mutex\n\t\t * is held by the caller.\n\t\t */\n\t\tlist_for_each_entry(tmp, devices, dev_list) {\n\t\t\tif (tmp->in_fs_metadata && !tmp->bdev) {\n\t\t\t\t*device = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!*device) {\n\t\t\tbtrfs_err(root->fs_info, \"no missing device found\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\treturn 0;\n\t} else {\n\t\treturn btrfs_find_device_by_path(root, device_path, device);\n\t}\n}"
  },
  {
    "function_name": "btrfs_find_device_by_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1891-1916",
    "snippet": "static int btrfs_find_device_by_path(struct btrfs_root *root, char *device_path,\n\t\t\t\t     struct btrfs_device **device)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tu8 *dev_uuid;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh;\n\n\t*device = NULL;\n\tret = btrfs_get_bdev_and_sb(device_path, FMODE_READ,\n\t\t\t\t    root->fs_info->bdev_holder, 0, &bdev, &bh);\n\tif (ret)\n\t\treturn ret;\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\tdev_uuid = disk_super->dev_item.uuid;\n\t*device = btrfs_find_device(root->fs_info, devid, dev_uuid,\n\t\t\t\t    disk_super->fsid);\n\tbrelse(bh);\n\tif (!*device)\n\t\tret = -ENOENT;\n\tblkdev_put(bdev, FMODE_READ);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "FMODE_READ"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_device",
          "args": [
            "root->fs_info",
            "devid",
            "dev_uuid",
            "disk_super->fsid"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5918-5936",
          "snippet": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_device_id",
          "args": [
            "&disk_super->dev_item"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_bdev_and_sb",
          "args": [
            "device_path",
            "FMODE_READ",
            "root->fs_info->bdev_holder",
            "0",
            "&bdev",
            "&bh"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_bdev_and_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "186-222",
          "snippet": "static int\nbtrfs_get_bdev_and_sb(const char *device_path, fmode_t flags, void *holder,\n\t\t      int flush, struct block_device **bdev,\n\t\t      struct buffer_head **bh)\n{\n\tint ret;\n\n\t*bdev = blkdev_get_by_path(device_path, flags, holder);\n\n\tif (IS_ERR(*bdev)) {\n\t\tret = PTR_ERR(*bdev);\n\t\tprintk(KERN_INFO \"BTRFS: open %s failed\\n\", device_path);\n\t\tgoto error;\n\t}\n\n\tif (flush)\n\t\tfilemap_write_and_wait((*bdev)->bd_inode->i_mapping);\n\tret = set_blocksize(*bdev, 4096);\n\tif (ret) {\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\tinvalidate_bdev(*bdev);\n\t*bh = btrfs_read_dev_super(*bdev);\n\tif (!*bh) {\n\t\tret = -EINVAL;\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\t*bdev = NULL;\n\t*bh = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int\nbtrfs_get_bdev_and_sb(const char *device_path, fmode_t flags, void *holder,\n\t\t      int flush, struct block_device **bdev,\n\t\t      struct buffer_head **bh)\n{\n\tint ret;\n\n\t*bdev = blkdev_get_by_path(device_path, flags, holder);\n\n\tif (IS_ERR(*bdev)) {\n\t\tret = PTR_ERR(*bdev);\n\t\tprintk(KERN_INFO \"BTRFS: open %s failed\\n\", device_path);\n\t\tgoto error;\n\t}\n\n\tif (flush)\n\t\tfilemap_write_and_wait((*bdev)->bd_inode->i_mapping);\n\tret = set_blocksize(*bdev, 4096);\n\tif (ret) {\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\tinvalidate_bdev(*bdev);\n\t*bh = btrfs_read_dev_super(*bdev);\n\tif (!*bh) {\n\t\tret = -EINVAL;\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\t*bdev = NULL;\n\t*bh = NULL;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_find_device_by_path(struct btrfs_root *root, char *device_path,\n\t\t\t\t     struct btrfs_device **device)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tu8 *dev_uuid;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh;\n\n\t*device = NULL;\n\tret = btrfs_get_bdev_and_sb(device_path, FMODE_READ,\n\t\t\t\t    root->fs_info->bdev_holder, 0, &bdev, &bh);\n\tif (ret)\n\t\treturn ret;\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\tdev_uuid = disk_super->dev_item.uuid;\n\t*device = btrfs_find_device(root->fs_info, devid, dev_uuid,\n\t\t\t\t    disk_super->fsid);\n\tbrelse(bh);\n\tif (!*device)\n\t\tret = -ENOENT;\n\tblkdev_put(bdev, FMODE_READ);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_destroy_dev_replace_tgtdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1863-1889",
    "snippet": "void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct btrfs_device *tgtdev)\n{\n\tstruct btrfs_device *next_device;\n\n\tmutex_lock(&uuid_mutex);\n\tWARN_ON(!tgtdev);\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tif (tgtdev->bdev) {\n\t\tbtrfs_scratch_superblock(tgtdev);\n\t\tfs_info->fs_devices->open_devices--;\n\t}\n\tfs_info->fs_devices->num_devices--;\n\n\tnext_device = list_entry(fs_info->fs_devices->devices.next,\n\t\t\t\t struct btrfs_device, dev_list);\n\tif (tgtdev->bdev == fs_info->sb->s_bdev)\n\t\tfs_info->sb->s_bdev = next_device->bdev;\n\tif (tgtdev->bdev == fs_info->fs_devices->latest_bdev)\n\t\tfs_info->fs_devices->latest_bdev = next_device->bdev;\n\tlist_del_rcu(&tgtdev->dev_list);\n\n\tcall_rcu(&tgtdev->rcu, free_device);\n\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&tgtdev->rcu",
            "free_device"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&tgtdev->dev_list"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "fs_info->fs_devices->devices.next",
            "structbtrfs_device",
            "dev_list"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_scratch_superblock",
          "args": [
            "tgtdev"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scratch_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6670-6686",
          "snippet": "int btrfs_scratch_superblock(struct btrfs_device *device)\n{\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\n\tbh = btrfs_read_dev_super(device->bdev);\n\tif (!bh)\n\t\treturn -EINVAL;\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\n\tmemset(&disk_super->magic, 0, sizeof(disk_super->magic));\n\tset_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_scratch_superblock(struct btrfs_device *device)\n{\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\n\tbh = btrfs_read_dev_super(device->bdev);\n\tif (!bh)\n\t\treturn -EINVAL;\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\n\tmemset(&disk_super->magic, 0, sizeof(disk_super->magic));\n\tset_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!tgtdev"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct btrfs_device *tgtdev)\n{\n\tstruct btrfs_device *next_device;\n\n\tmutex_lock(&uuid_mutex);\n\tWARN_ON(!tgtdev);\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tif (tgtdev->bdev) {\n\t\tbtrfs_scratch_superblock(tgtdev);\n\t\tfs_info->fs_devices->open_devices--;\n\t}\n\tfs_info->fs_devices->num_devices--;\n\n\tnext_device = list_entry(fs_info->fs_devices->devices.next,\n\t\t\t\t struct btrfs_device, dev_list);\n\tif (tgtdev->bdev == fs_info->sb->s_bdev)\n\t\tfs_info->sb->s_bdev = next_device->bdev;\n\tif (tgtdev->bdev == fs_info->fs_devices->latest_bdev)\n\t\tfs_info->fs_devices->latest_bdev = next_device->bdev;\n\tlist_del_rcu(&tgtdev->dev_list);\n\n\tcall_rcu(&tgtdev->rcu, free_device);\n\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n}"
  },
  {
    "function_name": "btrfs_rm_dev_replace_free_srcdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1832-1861",
    "snippet": "void btrfs_rm_dev_replace_free_srcdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct btrfs_device *srcdev)\n{\n\tstruct btrfs_fs_devices *fs_devices = srcdev->fs_devices;\n\n\tcall_rcu(&srcdev->rcu, free_device);\n\n\t/*\n\t * unless fs_devices is seed fs, num_devices shouldn't go\n\t * zero\n\t */\n\tBUG_ON(!fs_devices->num_devices && !fs_devices->seeding);\n\n\t/* if this is no devs we rather delete the fs_devices */\n\tif (!fs_devices->num_devices) {\n\t\tstruct btrfs_fs_devices *tmp_fs_devices;\n\n\t\ttmp_fs_devices = fs_info->fs_devices;\n\t\twhile (tmp_fs_devices) {\n\t\t\tif (tmp_fs_devices->seed == fs_devices) {\n\t\t\t\ttmp_fs_devices->seed = fs_devices->seed;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp_fs_devices = tmp_fs_devices->seed;\n\t\t}\n\t\tfs_devices->seed = NULL;\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_fs_devices",
          "args": [
            "fs_devices"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "free_fs_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "99-111",
          "snippet": "static void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_close_devices",
          "args": [
            "fs_devices"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_close_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "696-744",
          "snippet": "static int __btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\n\tif (--fs_devices->opened > 0)\n\t\treturn 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tstruct btrfs_device *new_device;\n\t\tstruct rcu_string *name;\n\n\t\tif (device->bdev)\n\t\t\tfs_devices->open_devices--;\n\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tfs_devices->rw_devices--;\n\t\t}\n\n\t\tif (device->missing)\n\t\t\tfs_devices->missing_devices--;\n\n\t\tnew_device = btrfs_alloc_device(NULL, &device->devid,\n\t\t\t\t\t\tdevice->uuid);\n\t\tBUG_ON(IS_ERR(new_device)); /* -ENOMEM */\n\n\t\t/* Safe because we are under uuid_mutex */\n\t\tif (device->name) {\n\t\t\tname = rcu_string_strdup(device->name->str, GFP_NOFS);\n\t\t\tBUG_ON(!name); /* -ENOMEM */\n\t\t\trcu_assign_pointer(new_device->name, name);\n\t\t}\n\n\t\tlist_replace_rcu(&device->dev_list, &new_device->dev_list);\n\t\tnew_device->fs_devices = device->fs_devices;\n\n\t\tcall_rcu(&device->rcu, free_device);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tWARN_ON(fs_devices->open_devices);\n\tWARN_ON(fs_devices->rw_devices);\n\tfs_devices->opened = 0;\n\tfs_devices->seeding = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\n\tif (--fs_devices->opened > 0)\n\t\treturn 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tstruct btrfs_device *new_device;\n\t\tstruct rcu_string *name;\n\n\t\tif (device->bdev)\n\t\t\tfs_devices->open_devices--;\n\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tfs_devices->rw_devices--;\n\t\t}\n\n\t\tif (device->missing)\n\t\t\tfs_devices->missing_devices--;\n\n\t\tnew_device = btrfs_alloc_device(NULL, &device->devid,\n\t\t\t\t\t\tdevice->uuid);\n\t\tBUG_ON(IS_ERR(new_device)); /* -ENOMEM */\n\n\t\t/* Safe because we are under uuid_mutex */\n\t\tif (device->name) {\n\t\t\tname = rcu_string_strdup(device->name->str, GFP_NOFS);\n\t\t\tBUG_ON(!name); /* -ENOMEM */\n\t\t\trcu_assign_pointer(new_device->name, name);\n\t\t}\n\n\t\tlist_replace_rcu(&device->dev_list, &new_device->dev_list);\n\t\tnew_device->fs_devices = device->fs_devices;\n\n\t\tcall_rcu(&device->rcu, free_device);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tWARN_ON(fs_devices->open_devices);\n\tWARN_ON(fs_devices->rw_devices);\n\tfs_devices->opened = 0;\n\tfs_devices->seeding = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!fs_devices->num_devices && !fs_devices->seeding"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&srcdev->rcu",
            "free_device"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_rm_dev_replace_free_srcdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct btrfs_device *srcdev)\n{\n\tstruct btrfs_fs_devices *fs_devices = srcdev->fs_devices;\n\n\tcall_rcu(&srcdev->rcu, free_device);\n\n\t/*\n\t * unless fs_devices is seed fs, num_devices shouldn't go\n\t * zero\n\t */\n\tBUG_ON(!fs_devices->num_devices && !fs_devices->seeding);\n\n\t/* if this is no devs we rather delete the fs_devices */\n\tif (!fs_devices->num_devices) {\n\t\tstruct btrfs_fs_devices *tmp_fs_devices;\n\n\t\ttmp_fs_devices = fs_info->fs_devices;\n\t\twhile (tmp_fs_devices) {\n\t\t\tif (tmp_fs_devices->seed == fs_devices) {\n\t\t\t\ttmp_fs_devices->seed = fs_devices->seed;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp_fs_devices = tmp_fs_devices->seed;\n\t\t}\n\t\tfs_devices->seed = NULL;\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n}"
  },
  {
    "function_name": "btrfs_rm_dev_replace_remove_srcdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1801-1830",
    "snippet": "void btrfs_rm_dev_replace_remove_srcdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct btrfs_device *srcdev)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\tWARN_ON(!mutex_is_locked(&fs_info->fs_devices->device_list_mutex));\n\n\t/*\n\t * in case of fs with no seed, srcdev->fs_devices will point\n\t * to fs_devices of fs_info. However when the dev being replaced is\n\t * a seed dev it will point to the seed's local fs_devices. In short\n\t * srcdev will have its correct fs_devices in both the cases.\n\t */\n\tfs_devices = srcdev->fs_devices;\n\n\tlist_del_rcu(&srcdev->dev_list);\n\tlist_del_rcu(&srcdev->dev_alloc_list);\n\tfs_devices->num_devices--;\n\tif (srcdev->missing)\n\t\tfs_devices->missing_devices--;\n\n\tif (srcdev->writeable) {\n\t\tfs_devices->rw_devices--;\n\t\t/* zero out the old super if it is writable */\n\t\tbtrfs_scratch_superblock(srcdev);\n\t}\n\n\tif (srcdev->bdev)\n\t\tfs_devices->open_devices--;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_scratch_superblock",
          "args": [
            "srcdev"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scratch_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6670-6686",
          "snippet": "int btrfs_scratch_superblock(struct btrfs_device *device)\n{\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\n\tbh = btrfs_read_dev_super(device->bdev);\n\tif (!bh)\n\t\treturn -EINVAL;\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\n\tmemset(&disk_super->magic, 0, sizeof(disk_super->magic));\n\tset_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_scratch_superblock(struct btrfs_device *device)\n{\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\n\tbh = btrfs_read_dev_super(device->bdev);\n\tif (!bh)\n\t\treturn -EINVAL;\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\n\tmemset(&disk_super->magic, 0, sizeof(disk_super->magic));\n\tset_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&srcdev->dev_alloc_list"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&srcdev->dev_list"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&fs_info->fs_devices->device_list_mutex)"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_rm_dev_replace_remove_srcdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct btrfs_device *srcdev)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\tWARN_ON(!mutex_is_locked(&fs_info->fs_devices->device_list_mutex));\n\n\t/*\n\t * in case of fs with no seed, srcdev->fs_devices will point\n\t * to fs_devices of fs_info. However when the dev being replaced is\n\t * a seed dev it will point to the seed's local fs_devices. In short\n\t * srcdev will have its correct fs_devices in both the cases.\n\t */\n\tfs_devices = srcdev->fs_devices;\n\n\tlist_del_rcu(&srcdev->dev_list);\n\tlist_del_rcu(&srcdev->dev_alloc_list);\n\tfs_devices->num_devices--;\n\tif (srcdev->missing)\n\t\tfs_devices->missing_devices--;\n\n\tif (srcdev->writeable) {\n\t\tfs_devices->rw_devices--;\n\t\t/* zero out the old super if it is writable */\n\t\tbtrfs_scratch_superblock(srcdev);\n\t}\n\n\tif (srcdev->bdev)\n\t\tfs_devices->open_devices--;\n}"
  },
  {
    "function_name": "btrfs_rm_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1538-1799",
    "snippet": "int btrfs_rm_device(struct btrfs_root *root, char *device_path)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *next_device;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh = NULL;\n\tstruct btrfs_super_block *disk_super;\n\tstruct btrfs_fs_devices *cur_devices;\n\tu64 all_avail;\n\tu64 devid;\n\tu64 num_devices;\n\tu8 *dev_uuid;\n\tunsigned seq;\n\tint ret = 0;\n\tbool clear_super = false;\n\n\tmutex_lock(&uuid_mutex);\n\n\tdo {\n\t\tseq = read_seqbegin(&root->fs_info->profiles_lock);\n\n\t\tall_avail = root->fs_info->avail_data_alloc_bits |\n\t\t\t    root->fs_info->avail_system_alloc_bits |\n\t\t\t    root->fs_info->avail_metadata_alloc_bits;\n\t} while (read_seqretry(&root->fs_info->profiles_lock, seq));\n\n\tnum_devices = root->fs_info->fs_devices->num_devices;\n\tbtrfs_dev_replace_lock(&root->fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&root->fs_info->dev_replace)) {\n\t\tWARN_ON(num_devices < 1);\n\t\tnum_devices--;\n\t}\n\tbtrfs_dev_replace_unlock(&root->fs_info->dev_replace);\n\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID10) && num_devices <= 4) {\n\t\tret = BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID1) && num_devices <= 2) {\n\t\tret = BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID5) &&\n\t    root->fs_info->fs_devices->rw_devices <= 2) {\n\t\tret = BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID6) &&\n\t    root->fs_info->fs_devices->rw_devices <= 3) {\n\t\tret = BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tstruct list_head *devices;\n\t\tstruct btrfs_device *tmp;\n\n\t\tdevice = NULL;\n\t\tdevices = &root->fs_info->fs_devices->devices;\n\t\t/*\n\t\t * It is safe to read the devices since the volume_mutex\n\t\t * is held.\n\t\t */\n\t\tlist_for_each_entry(tmp, devices, dev_list) {\n\t\t\tif (tmp->in_fs_metadata &&\n\t\t\t    !tmp->is_tgtdev_for_dev_replace &&\n\t\t\t    !tmp->bdev) {\n\t\t\t\tdevice = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbdev = NULL;\n\t\tbh = NULL;\n\t\tdisk_super = NULL;\n\t\tif (!device) {\n\t\t\tret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = btrfs_get_bdev_and_sb(device_path,\n\t\t\t\t\t    FMODE_WRITE | FMODE_EXCL,\n\t\t\t\t\t    root->fs_info->bdev_holder, 0,\n\t\t\t\t\t    &bdev, &bh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\t\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\t\tdev_uuid = disk_super->dev_item.uuid;\n\t\tdevice = btrfs_find_device(root->fs_info, devid, dev_uuid,\n\t\t\t\t\t   disk_super->fsid);\n\t\tif (!device) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error_brelse;\n\t\t}\n\t}\n\n\tif (device->is_tgtdev_for_dev_replace) {\n\t\tret = BTRFS_ERROR_DEV_TGT_REPLACE;\n\t\tgoto error_brelse;\n\t}\n\n\tif (device->writeable && root->fs_info->fs_devices->rw_devices == 1) {\n\t\tret = BTRFS_ERROR_DEV_ONLY_WRITABLE;\n\t\tgoto error_brelse;\n\t}\n\n\tif (device->writeable) {\n\t\tlock_chunks(root);\n\t\tlist_del_init(&device->dev_alloc_list);\n\t\tdevice->fs_devices->rw_devices--;\n\t\tunlock_chunks(root);\n\t\tclear_super = true;\n\t}\n\n\tmutex_unlock(&uuid_mutex);\n\tret = btrfs_shrink_device(device, 0);\n\tmutex_lock(&uuid_mutex);\n\tif (ret)\n\t\tgoto error_undo;\n\n\t/*\n\t * TODO: the superblock still includes this device in its num_devices\n\t * counter although write_all_supers() is not locked out. This\n\t * could give a filesystem state which requires a degraded mount.\n\t */\n\tret = btrfs_rm_dev_item(root->fs_info->chunk_root, device);\n\tif (ret)\n\t\tgoto error_undo;\n\n\tdevice->in_fs_metadata = 0;\n\tbtrfs_scrub_cancel_dev(root->fs_info, device);\n\n\t/*\n\t * the device list mutex makes sure that we don't change\n\t * the device list while someone else is writing out all\n\t * the device supers. Whoever is writing all supers, should\n\t * lock the device list mutex before getting the number of\n\t * devices in the super block (super_copy). Conversely,\n\t * whoever updates the number of devices in the super block\n\t * (super_copy) should hold the device list mutex.\n\t */\n\n\tcur_devices = device->fs_devices;\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlist_del_rcu(&device->dev_list);\n\n\tdevice->fs_devices->num_devices--;\n\tdevice->fs_devices->total_devices--;\n\n\tif (device->missing)\n\t\tdevice->fs_devices->missing_devices--;\n\n\tnext_device = list_entry(root->fs_info->fs_devices->devices.next,\n\t\t\t\t struct btrfs_device, dev_list);\n\tif (device->bdev == root->fs_info->sb->s_bdev)\n\t\troot->fs_info->sb->s_bdev = next_device->bdev;\n\tif (device->bdev == root->fs_info->fs_devices->latest_bdev)\n\t\troot->fs_info->fs_devices->latest_bdev = next_device->bdev;\n\n\tif (device->bdev) {\n\t\tdevice->fs_devices->open_devices--;\n\t\t/* remove sysfs entry */\n\t\tbtrfs_kobj_rm_device(root->fs_info, device);\n\t}\n\n\tcall_rcu(&device->rcu, free_device);\n\n\tnum_devices = btrfs_super_num_devices(root->fs_info->super_copy) - 1;\n\tbtrfs_set_super_num_devices(root->fs_info->super_copy, num_devices);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tif (cur_devices->open_devices == 0) {\n\t\tstruct btrfs_fs_devices *fs_devices;\n\t\tfs_devices = root->fs_info->fs_devices;\n\t\twhile (fs_devices) {\n\t\t\tif (fs_devices->seed == cur_devices) {\n\t\t\t\tfs_devices->seed = cur_devices->seed;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfs_devices = fs_devices->seed;\n\t\t}\n\t\tcur_devices->seed = NULL;\n\t\t__btrfs_close_devices(cur_devices);\n\t\tfree_fs_devices(cur_devices);\n\t}\n\n\troot->fs_info->num_tolerated_disk_barrier_failures =\n\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(root->fs_info);\n\n\t/*\n\t * at this point, the device is zero sized.  We want to\n\t * remove it from the devices list and zero out the old super\n\t */\n\tif (clear_super && disk_super) {\n\t\tu64 bytenr;\n\t\tint i;\n\n\t\t/* make sure this device isn't detected as part of\n\t\t * the FS anymore\n\t\t */\n\t\tmemset(&disk_super->magic, 0, sizeof(disk_super->magic));\n\t\tset_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\n\t\t/* clear the mirror copies of super block on the disk\n\t\t * being removed, 0th copy is been taken care above and\n\t\t * the below would take of the rest\n\t\t */\n\t\tfor (i = 1; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\t\tbytenr = btrfs_sb_offset(i);\n\t\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t\t\t\ti_size_read(bdev->bd_inode))\n\t\t\t\tbreak;\n\n\t\t\tbrelse(bh);\n\t\t\tbh = __bread(bdev, bytenr / 4096,\n\t\t\t\t\tBTRFS_SUPER_INFO_SIZE);\n\t\t\tif (!bh)\n\t\t\t\tcontinue;\n\n\t\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\n\t\t\tif (btrfs_super_bytenr(disk_super) != bytenr ||\n\t\t\t\tbtrfs_super_magic(disk_super) != BTRFS_MAGIC) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemset(&disk_super->magic, 0,\n\t\t\t\t\t\tsizeof(disk_super->magic));\n\t\t\tset_buffer_dirty(bh);\n\t\t\tsync_dirty_buffer(bh);\n\t\t}\n\t}\n\n\tret = 0;\n\n\tif (bdev) {\n\t\t/* Notify udev that device has changed */\n\t\tbtrfs_kobject_uevent(bdev, KOBJ_CHANGE);\n\n\t\t/* Update ctime/mtime for device path for libblkid */\n\t\tupdate_dev_time(device_path);\n\t}\n\nerror_brelse:\n\tbrelse(bh);\n\tif (bdev)\n\t\tblkdev_put(bdev, FMODE_READ | FMODE_EXCL);\nout:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\nerror_undo:\n\tif (device->writeable) {\n\t\tlock_chunks(root);\n\t\tlist_add(&device->dev_alloc_list,\n\t\t\t &root->fs_info->fs_devices->alloc_list);\n\t\tdevice->fs_devices->rw_devices++;\n\t\tunlock_chunks(root);\n\t}\n\tgoto error_brelse;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_chunks",
          "args": [
            "root"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "536-539",
          "snippet": "static inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&device->dev_alloc_list",
            "&root->fs_info->fs_devices->alloc_list"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "FMODE_READ | FMODE_EXCL"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dev_time",
          "args": [
            "device_path"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "update_dev_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1485-1495",
          "snippet": "static void update_dev_time(char *path_name)\n{\n\tstruct file *filp;\n\n\tfilp = filp_open(path_name, O_RDWR, 0);\n\tif (IS_ERR(filp))\n\t\treturn;\n\tfile_update_time(filp);\n\tfilp_close(filp, NULL);\n\treturn;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void update_dev_time(char *path_name)\n{\n\tstruct file *filp;\n\n\tfilp = filp_open(path_name, O_RDWR, 0);\n\tif (IS_ERR(filp))\n\t\treturn;\n\tfile_update_time(filp);\n\tfilp_close(filp, NULL);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_kobject_uevent",
          "args": [
            "bdev",
            "KOBJ_CHANGE"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kobject_uevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "113-124",
          "snippet": "static void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&disk_super->magic",
            "0",
            "sizeof(disk_super->magic)"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_magic",
          "args": [
            "disk_super"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_bytenr",
          "args": [
            "disk_super"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bread",
          "args": [
            "bdev",
            "bytenr / 4096",
            "BTRFS_SUPER_INFO_SIZE"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_sb_offset",
          "args": [
            "i"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "36-42",
          "snippet": "static inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_SUPER_MIRROR_SHIFT 12",
            "#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_SUPER_MIRROR_SHIFT 12\n#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)\n\nstatic inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&disk_super->magic",
            "0",
            "sizeof(disk_super->magic)"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_calc_num_tolerated_disk_barrier_failures",
          "args": [
            "root->fs_info"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_calc_num_tolerated_disk_barrier_failures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3348-3424",
          "snippet": "int btrfs_calc_num_tolerated_disk_barrier_failures(\n\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_space_info *sinfo;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint i;\n\tint c;\n\tint num_tolerated_disk_barrier_failures =\n\t\t(int)fs_info->fs_devices->num_devices;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tsinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &fs_info->space_info, list) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tsinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!sinfo)\n\t\t\tcontinue;\n\n\t\tdown_read(&sinfo->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&sinfo->block_groups[c])) {\n\t\t\t\tu64 flags;\n\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&sinfo->block_groups[c], &space);\n\t\t\t\tif (space.total_bytes == 0 ||\n\t\t\t\t    space.used_bytes == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tflags = space.flags;\n\t\t\t\t/*\n\t\t\t\t * return\n\t\t\t\t * 0: if dup, single or RAID0 is configured for\n\t\t\t\t *    any of metadata, system or data, else\n\t\t\t\t * 1: if RAID5 is configured, or if RAID1 or\n\t\t\t\t *    RAID10 is configured and only two mirrors\n\t\t\t\t *    are used, else\n\t\t\t\t * 2: if RAID6 is configured, else\n\t\t\t\t * num_mirrors - 1: if RAID1 or RAID10 is\n\t\t\t\t *                  configured and more than\n\t\t\t\t *                  2 mirrors are used.\n\t\t\t\t */\n\t\t\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t\t\t    ((flags & (BTRFS_BLOCK_GROUP_DUP |\n\t\t\t\t\t       BTRFS_BLOCK_GROUP_RAID0)) ||\n\t\t\t\t     ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK)\n\t\t\t\t      == 0)))\n\t\t\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\t\t\telse if (num_tolerated_disk_barrier_failures > 1) {\n\t\t\t\t\tif (flags & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\t\t\t\t\t} else if (flags &\n\t\t\t\t\t\t   BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tup_read(&sinfo->groups_sem);\n\t}\n\n\treturn num_tolerated_disk_barrier_failures;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_calc_num_tolerated_disk_barrier_failures(\n\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_space_info *sinfo;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint i;\n\tint c;\n\tint num_tolerated_disk_barrier_failures =\n\t\t(int)fs_info->fs_devices->num_devices;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tsinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &fs_info->space_info, list) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tsinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!sinfo)\n\t\t\tcontinue;\n\n\t\tdown_read(&sinfo->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&sinfo->block_groups[c])) {\n\t\t\t\tu64 flags;\n\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&sinfo->block_groups[c], &space);\n\t\t\t\tif (space.total_bytes == 0 ||\n\t\t\t\t    space.used_bytes == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tflags = space.flags;\n\t\t\t\t/*\n\t\t\t\t * return\n\t\t\t\t * 0: if dup, single or RAID0 is configured for\n\t\t\t\t *    any of metadata, system or data, else\n\t\t\t\t * 1: if RAID5 is configured, or if RAID1 or\n\t\t\t\t *    RAID10 is configured and only two mirrors\n\t\t\t\t *    are used, else\n\t\t\t\t * 2: if RAID6 is configured, else\n\t\t\t\t * num_mirrors - 1: if RAID1 or RAID10 is\n\t\t\t\t *                  configured and more than\n\t\t\t\t *                  2 mirrors are used.\n\t\t\t\t */\n\t\t\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t\t\t    ((flags & (BTRFS_BLOCK_GROUP_DUP |\n\t\t\t\t\t       BTRFS_BLOCK_GROUP_RAID0)) ||\n\t\t\t\t     ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK)\n\t\t\t\t      == 0)))\n\t\t\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\t\t\telse if (num_tolerated_disk_barrier_failures > 1) {\n\t\t\t\t\tif (flags & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\t\t\t\t\t} else if (flags &\n\t\t\t\t\t\t   BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tup_read(&sinfo->groups_sem);\n\t}\n\n\treturn num_tolerated_disk_barrier_failures;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_fs_devices",
          "args": [
            "cur_devices"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "free_fs_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "99-111",
          "snippet": "static void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_close_devices",
          "args": [
            "cur_devices"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_close_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "696-744",
          "snippet": "static int __btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\n\tif (--fs_devices->opened > 0)\n\t\treturn 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tstruct btrfs_device *new_device;\n\t\tstruct rcu_string *name;\n\n\t\tif (device->bdev)\n\t\t\tfs_devices->open_devices--;\n\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tfs_devices->rw_devices--;\n\t\t}\n\n\t\tif (device->missing)\n\t\t\tfs_devices->missing_devices--;\n\n\t\tnew_device = btrfs_alloc_device(NULL, &device->devid,\n\t\t\t\t\t\tdevice->uuid);\n\t\tBUG_ON(IS_ERR(new_device)); /* -ENOMEM */\n\n\t\t/* Safe because we are under uuid_mutex */\n\t\tif (device->name) {\n\t\t\tname = rcu_string_strdup(device->name->str, GFP_NOFS);\n\t\t\tBUG_ON(!name); /* -ENOMEM */\n\t\t\trcu_assign_pointer(new_device->name, name);\n\t\t}\n\n\t\tlist_replace_rcu(&device->dev_list, &new_device->dev_list);\n\t\tnew_device->fs_devices = device->fs_devices;\n\n\t\tcall_rcu(&device->rcu, free_device);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tWARN_ON(fs_devices->open_devices);\n\tWARN_ON(fs_devices->rw_devices);\n\tfs_devices->opened = 0;\n\tfs_devices->seeding = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\n\tif (--fs_devices->opened > 0)\n\t\treturn 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tstruct btrfs_device *new_device;\n\t\tstruct rcu_string *name;\n\n\t\tif (device->bdev)\n\t\t\tfs_devices->open_devices--;\n\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tfs_devices->rw_devices--;\n\t\t}\n\n\t\tif (device->missing)\n\t\t\tfs_devices->missing_devices--;\n\n\t\tnew_device = btrfs_alloc_device(NULL, &device->devid,\n\t\t\t\t\t\tdevice->uuid);\n\t\tBUG_ON(IS_ERR(new_device)); /* -ENOMEM */\n\n\t\t/* Safe because we are under uuid_mutex */\n\t\tif (device->name) {\n\t\t\tname = rcu_string_strdup(device->name->str, GFP_NOFS);\n\t\t\tBUG_ON(!name); /* -ENOMEM */\n\t\t\trcu_assign_pointer(new_device->name, name);\n\t\t}\n\n\t\tlist_replace_rcu(&device->dev_list, &new_device->dev_list);\n\t\tnew_device->fs_devices = device->fs_devices;\n\n\t\tcall_rcu(&device->rcu, free_device);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tWARN_ON(fs_devices->open_devices);\n\tWARN_ON(fs_devices->rw_devices);\n\tfs_devices->opened = 0;\n\tfs_devices->seeding = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_num_devices",
          "args": [
            "root->fs_info->super_copy",
            "num_devices"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_num_devices",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&device->rcu",
            "free_device"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_kobj_rm_device",
          "args": [
            "root->fs_info",
            "device"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kobj_rm_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/sysfs.c",
          "lines": "605-623",
          "snippet": "int btrfs_kobj_rm_device(struct btrfs_fs_info *fs_info,\n\t\tstruct btrfs_device *one_device)\n{\n\tstruct hd_struct *disk;\n\tstruct kobject *disk_kobj;\n\n\tif (!fs_info->device_dir_kobj)\n\t\treturn -EINVAL;\n\n\tif (one_device && one_device->bdev) {\n\t\tdisk = one_device->bdev->bd_part;\n\t\tdisk_kobj = &part_to_dev(disk)->kobj;\n\n\t\tsysfs_remove_link(fs_info->device_dir_kobj,\n\t\t\t\t\t\tdisk_kobj->name);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"sysfs.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bug.h>",
            "#include <linux/kobject.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"sysfs.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/debugfs.h>\n#include <linux/genhd.h>\n#include <linux/bug.h>\n#include <linux/kobject.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);\n\nint btrfs_kobj_rm_device(struct btrfs_fs_info *fs_info,\n\t\tstruct btrfs_device *one_device)\n{\n\tstruct hd_struct *disk;\n\tstruct kobject *disk_kobj;\n\n\tif (!fs_info->device_dir_kobj)\n\t\treturn -EINVAL;\n\n\tif (one_device && one_device->bdev) {\n\t\tdisk = one_device->bdev->bd_part;\n\t\tdisk_kobj = &part_to_dev(disk)->kobj;\n\n\t\tsysfs_remove_link(fs_info->device_dir_kobj,\n\t\t\t\t\t\tdisk_kobj->name);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "root->fs_info->fs_devices->devices.next",
            "structbtrfs_device",
            "dev_list"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&device->dev_list"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_scrub_cancel_dev",
          "args": [
            "root->fs_info",
            "device"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scrub_cancel_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3802-3823",
          "snippet": "int btrfs_scrub_cancel_dev(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_device *dev)\n{\n\tstruct scrub_ctx *sctx;\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tsctx = dev->scrub_device;\n\tif (!sctx) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\tatomic_inc(&sctx->cancel_req);\n\twhile (dev->scrub_device) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   dev->scrub_device == NULL);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_cancel_dev(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_device *dev)\n{\n\tstruct scrub_ctx *sctx;\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tsctx = dev->scrub_device;\n\tif (!sctx) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\tatomic_inc(&sctx->cancel_req);\n\twhile (dev->scrub_device) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   dev->scrub_device == NULL);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_rm_dev_item",
          "args": [
            "root->fs_info->chunk_root",
            "device"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_rm_dev_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1497-1536",
          "snippet": "static int btrfs_rm_dev_item(struct btrfs_root *root,\n\t\t\t     struct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_trans_handle *trans;\n\n\troot = root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, root, path);\n\tif (ret)\n\t\tgoto out;\nout:\n\tbtrfs_free_path(path);\n\tbtrfs_commit_transaction(trans, root);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_rm_dev_item(struct btrfs_root *root,\n\t\t\t     struct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_trans_handle *trans;\n\n\troot = root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, root, path);\n\tif (ret)\n\t\tgoto out;\nout:\n\tbtrfs_free_path(path);\n\tbtrfs_commit_transaction(trans, root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_shrink_device",
          "args": [
            "device",
            "0"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_shrink_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3953-4084",
          "snippet": "int btrfs_shrink_device(struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_path *path;\n\tu64 length;\n\tu64 chunk_tree;\n\tu64 chunk_objectid;\n\tu64 chunk_offset;\n\tint ret;\n\tint slot;\n\tint failed = 0;\n\tbool retried = false;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tu64 old_total = btrfs_super_total_bytes(super_copy);\n\tu64 old_size = btrfs_device_get_total_bytes(device);\n\tu64 diff = old_size - new_size;\n\n\tif (device->is_tgtdev_for_dev_replace)\n\t\treturn -EINVAL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->reada = 2;\n\n\tlock_chunks(root);\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tif (device->writeable) {\n\t\tdevice->fs_devices->total_rw_bytes -= diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space -= diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t}\n\tunlock_chunks(root);\n\nagain:\n\tkey.objectid = device->devid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tdo {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tret = btrfs_previous_item(root, path, 0, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(l, &key, path->slots[0]);\n\n\t\tif (key.objectid != device->devid) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\tlength = btrfs_dev_extent_length(l, dev_extent);\n\n\t\tif (key.offset + length <= new_size) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tchunk_tree = btrfs_dev_extent_chunk_tree(l, dev_extent);\n\t\tchunk_objectid = btrfs_dev_extent_chunk_objectid(l, dev_extent);\n\t\tchunk_offset = btrfs_dev_extent_chunk_offset(l, dev_extent);\n\t\tbtrfs_release_path(path);\n\n\t\tret = btrfs_relocate_chunk(root, chunk_tree, chunk_objectid,\n\t\t\t\t\t   chunk_offset);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto done;\n\t\tif (ret == -ENOSPC)\n\t\t\tfailed++;\n\t} while (key.offset-- > 0);\n\n\tif (failed && !retried) {\n\t\tfailed = 0;\n\t\tretried = true;\n\t\tgoto again;\n\t} else if (failed && retried) {\n\t\tret = -ENOSPC;\n\t\tlock_chunks(root);\n\n\t\tbtrfs_device_set_total_bytes(device, old_size);\n\t\tif (device->writeable)\n\t\t\tdevice->fs_devices->total_rw_bytes += diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space += diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t\tunlock_chunks(root);\n\t\tgoto done;\n\t}\n\n\t/* Shrinking succeeded, else we would be at \"done\". */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto done;\n\t}\n\n\tlock_chunks(root);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &root->fs_info->fs_devices->resized_devices);\n\n\tWARN_ON(diff > old_total);\n\tbtrfs_set_super_total_bytes(super_copy, old_total - diff);\n\tunlock_chunks(root);\n\n\t/* Now btrfs_update_device() will change the on-disk size. */\n\tret = btrfs_update_device(trans, device);\n\tbtrfs_end_transaction(trans, root);\ndone:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_shrink_device(struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_path *path;\n\tu64 length;\n\tu64 chunk_tree;\n\tu64 chunk_objectid;\n\tu64 chunk_offset;\n\tint ret;\n\tint slot;\n\tint failed = 0;\n\tbool retried = false;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tu64 old_total = btrfs_super_total_bytes(super_copy);\n\tu64 old_size = btrfs_device_get_total_bytes(device);\n\tu64 diff = old_size - new_size;\n\n\tif (device->is_tgtdev_for_dev_replace)\n\t\treturn -EINVAL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->reada = 2;\n\n\tlock_chunks(root);\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tif (device->writeable) {\n\t\tdevice->fs_devices->total_rw_bytes -= diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space -= diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t}\n\tunlock_chunks(root);\n\nagain:\n\tkey.objectid = device->devid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tdo {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tret = btrfs_previous_item(root, path, 0, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(l, &key, path->slots[0]);\n\n\t\tif (key.objectid != device->devid) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\tlength = btrfs_dev_extent_length(l, dev_extent);\n\n\t\tif (key.offset + length <= new_size) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tchunk_tree = btrfs_dev_extent_chunk_tree(l, dev_extent);\n\t\tchunk_objectid = btrfs_dev_extent_chunk_objectid(l, dev_extent);\n\t\tchunk_offset = btrfs_dev_extent_chunk_offset(l, dev_extent);\n\t\tbtrfs_release_path(path);\n\n\t\tret = btrfs_relocate_chunk(root, chunk_tree, chunk_objectid,\n\t\t\t\t\t   chunk_offset);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto done;\n\t\tif (ret == -ENOSPC)\n\t\t\tfailed++;\n\t} while (key.offset-- > 0);\n\n\tif (failed && !retried) {\n\t\tfailed = 0;\n\t\tretried = true;\n\t\tgoto again;\n\t} else if (failed && retried) {\n\t\tret = -ENOSPC;\n\t\tlock_chunks(root);\n\n\t\tbtrfs_device_set_total_bytes(device, old_size);\n\t\tif (device->writeable)\n\t\t\tdevice->fs_devices->total_rw_bytes += diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space += diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t\tunlock_chunks(root);\n\t\tgoto done;\n\t}\n\n\t/* Shrinking succeeded, else we would be at \"done\". */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto done;\n\t}\n\n\tlock_chunks(root);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &root->fs_info->fs_devices->resized_devices);\n\n\tWARN_ON(diff > old_total);\n\tbtrfs_set_super_total_bytes(super_copy, old_total - diff);\n\tunlock_chunks(root);\n\n\t/* Now btrfs_update_device() will change the on-disk size. */\n\tret = btrfs_update_device(trans, device);\n\tbtrfs_end_transaction(trans, root);\ndone:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&device->dev_alloc_list"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_device",
          "args": [
            "root->fs_info",
            "devid",
            "dev_uuid",
            "disk_super->fsid"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5918-5936",
          "snippet": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_device_id",
          "args": [
            "&disk_super->dev_item"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_bdev_and_sb",
          "args": [
            "device_path",
            "FMODE_WRITE | FMODE_EXCL",
            "root->fs_info->bdev_holder",
            "0",
            "&bdev",
            "&bh"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_bdev_and_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "186-222",
          "snippet": "static int\nbtrfs_get_bdev_and_sb(const char *device_path, fmode_t flags, void *holder,\n\t\t      int flush, struct block_device **bdev,\n\t\t      struct buffer_head **bh)\n{\n\tint ret;\n\n\t*bdev = blkdev_get_by_path(device_path, flags, holder);\n\n\tif (IS_ERR(*bdev)) {\n\t\tret = PTR_ERR(*bdev);\n\t\tprintk(KERN_INFO \"BTRFS: open %s failed\\n\", device_path);\n\t\tgoto error;\n\t}\n\n\tif (flush)\n\t\tfilemap_write_and_wait((*bdev)->bd_inode->i_mapping);\n\tret = set_blocksize(*bdev, 4096);\n\tif (ret) {\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\tinvalidate_bdev(*bdev);\n\t*bh = btrfs_read_dev_super(*bdev);\n\tif (!*bh) {\n\t\tret = -EINVAL;\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\t*bdev = NULL;\n\t*bh = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int\nbtrfs_get_bdev_and_sb(const char *device_path, fmode_t flags, void *holder,\n\t\t      int flush, struct block_device **bdev,\n\t\t      struct buffer_head **bh)\n{\n\tint ret;\n\n\t*bdev = blkdev_get_by_path(device_path, flags, holder);\n\n\tif (IS_ERR(*bdev)) {\n\t\tret = PTR_ERR(*bdev);\n\t\tprintk(KERN_INFO \"BTRFS: open %s failed\\n\", device_path);\n\t\tgoto error;\n\t}\n\n\tif (flush)\n\t\tfilemap_write_and_wait((*bdev)->bd_inode->i_mapping);\n\tret = set_blocksize(*bdev, 4096);\n\tif (ret) {\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\tinvalidate_bdev(*bdev);\n\t*bh = btrfs_read_dev_super(*bdev);\n\tif (!*bh) {\n\t\tret = -EINVAL;\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\t*bdev = NULL;\n\t*bh = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "devices",
            "dev_list"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "device_path",
            "\"missing\""
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_unlock",
          "args": [
            "&root->fs_info->dev_replace"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "895-909",
          "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "num_devices < 1"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_is_ongoing",
          "args": [
            "&root->fs_info->dev_replace"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_is_ongoing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "840-865",
          "snippet": "int btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\n\nint btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_lock",
          "args": [
            "&root->fs_info->dev_replace"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "867-893",
          "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&root->fs_info->profiles_lock",
            "seq"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&root->fs_info->profiles_lock"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_rm_device(struct btrfs_root *root, char *device_path)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *next_device;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh = NULL;\n\tstruct btrfs_super_block *disk_super;\n\tstruct btrfs_fs_devices *cur_devices;\n\tu64 all_avail;\n\tu64 devid;\n\tu64 num_devices;\n\tu8 *dev_uuid;\n\tunsigned seq;\n\tint ret = 0;\n\tbool clear_super = false;\n\n\tmutex_lock(&uuid_mutex);\n\n\tdo {\n\t\tseq = read_seqbegin(&root->fs_info->profiles_lock);\n\n\t\tall_avail = root->fs_info->avail_data_alloc_bits |\n\t\t\t    root->fs_info->avail_system_alloc_bits |\n\t\t\t    root->fs_info->avail_metadata_alloc_bits;\n\t} while (read_seqretry(&root->fs_info->profiles_lock, seq));\n\n\tnum_devices = root->fs_info->fs_devices->num_devices;\n\tbtrfs_dev_replace_lock(&root->fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&root->fs_info->dev_replace)) {\n\t\tWARN_ON(num_devices < 1);\n\t\tnum_devices--;\n\t}\n\tbtrfs_dev_replace_unlock(&root->fs_info->dev_replace);\n\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID10) && num_devices <= 4) {\n\t\tret = BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID1) && num_devices <= 2) {\n\t\tret = BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID5) &&\n\t    root->fs_info->fs_devices->rw_devices <= 2) {\n\t\tret = BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID6) &&\n\t    root->fs_info->fs_devices->rw_devices <= 3) {\n\t\tret = BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tstruct list_head *devices;\n\t\tstruct btrfs_device *tmp;\n\n\t\tdevice = NULL;\n\t\tdevices = &root->fs_info->fs_devices->devices;\n\t\t/*\n\t\t * It is safe to read the devices since the volume_mutex\n\t\t * is held.\n\t\t */\n\t\tlist_for_each_entry(tmp, devices, dev_list) {\n\t\t\tif (tmp->in_fs_metadata &&\n\t\t\t    !tmp->is_tgtdev_for_dev_replace &&\n\t\t\t    !tmp->bdev) {\n\t\t\t\tdevice = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbdev = NULL;\n\t\tbh = NULL;\n\t\tdisk_super = NULL;\n\t\tif (!device) {\n\t\t\tret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = btrfs_get_bdev_and_sb(device_path,\n\t\t\t\t\t    FMODE_WRITE | FMODE_EXCL,\n\t\t\t\t\t    root->fs_info->bdev_holder, 0,\n\t\t\t\t\t    &bdev, &bh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\t\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\t\tdev_uuid = disk_super->dev_item.uuid;\n\t\tdevice = btrfs_find_device(root->fs_info, devid, dev_uuid,\n\t\t\t\t\t   disk_super->fsid);\n\t\tif (!device) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error_brelse;\n\t\t}\n\t}\n\n\tif (device->is_tgtdev_for_dev_replace) {\n\t\tret = BTRFS_ERROR_DEV_TGT_REPLACE;\n\t\tgoto error_brelse;\n\t}\n\n\tif (device->writeable && root->fs_info->fs_devices->rw_devices == 1) {\n\t\tret = BTRFS_ERROR_DEV_ONLY_WRITABLE;\n\t\tgoto error_brelse;\n\t}\n\n\tif (device->writeable) {\n\t\tlock_chunks(root);\n\t\tlist_del_init(&device->dev_alloc_list);\n\t\tdevice->fs_devices->rw_devices--;\n\t\tunlock_chunks(root);\n\t\tclear_super = true;\n\t}\n\n\tmutex_unlock(&uuid_mutex);\n\tret = btrfs_shrink_device(device, 0);\n\tmutex_lock(&uuid_mutex);\n\tif (ret)\n\t\tgoto error_undo;\n\n\t/*\n\t * TODO: the superblock still includes this device in its num_devices\n\t * counter although write_all_supers() is not locked out. This\n\t * could give a filesystem state which requires a degraded mount.\n\t */\n\tret = btrfs_rm_dev_item(root->fs_info->chunk_root, device);\n\tif (ret)\n\t\tgoto error_undo;\n\n\tdevice->in_fs_metadata = 0;\n\tbtrfs_scrub_cancel_dev(root->fs_info, device);\n\n\t/*\n\t * the device list mutex makes sure that we don't change\n\t * the device list while someone else is writing out all\n\t * the device supers. Whoever is writing all supers, should\n\t * lock the device list mutex before getting the number of\n\t * devices in the super block (super_copy). Conversely,\n\t * whoever updates the number of devices in the super block\n\t * (super_copy) should hold the device list mutex.\n\t */\n\n\tcur_devices = device->fs_devices;\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlist_del_rcu(&device->dev_list);\n\n\tdevice->fs_devices->num_devices--;\n\tdevice->fs_devices->total_devices--;\n\n\tif (device->missing)\n\t\tdevice->fs_devices->missing_devices--;\n\n\tnext_device = list_entry(root->fs_info->fs_devices->devices.next,\n\t\t\t\t struct btrfs_device, dev_list);\n\tif (device->bdev == root->fs_info->sb->s_bdev)\n\t\troot->fs_info->sb->s_bdev = next_device->bdev;\n\tif (device->bdev == root->fs_info->fs_devices->latest_bdev)\n\t\troot->fs_info->fs_devices->latest_bdev = next_device->bdev;\n\n\tif (device->bdev) {\n\t\tdevice->fs_devices->open_devices--;\n\t\t/* remove sysfs entry */\n\t\tbtrfs_kobj_rm_device(root->fs_info, device);\n\t}\n\n\tcall_rcu(&device->rcu, free_device);\n\n\tnum_devices = btrfs_super_num_devices(root->fs_info->super_copy) - 1;\n\tbtrfs_set_super_num_devices(root->fs_info->super_copy, num_devices);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tif (cur_devices->open_devices == 0) {\n\t\tstruct btrfs_fs_devices *fs_devices;\n\t\tfs_devices = root->fs_info->fs_devices;\n\t\twhile (fs_devices) {\n\t\t\tif (fs_devices->seed == cur_devices) {\n\t\t\t\tfs_devices->seed = cur_devices->seed;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfs_devices = fs_devices->seed;\n\t\t}\n\t\tcur_devices->seed = NULL;\n\t\t__btrfs_close_devices(cur_devices);\n\t\tfree_fs_devices(cur_devices);\n\t}\n\n\troot->fs_info->num_tolerated_disk_barrier_failures =\n\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(root->fs_info);\n\n\t/*\n\t * at this point, the device is zero sized.  We want to\n\t * remove it from the devices list and zero out the old super\n\t */\n\tif (clear_super && disk_super) {\n\t\tu64 bytenr;\n\t\tint i;\n\n\t\t/* make sure this device isn't detected as part of\n\t\t * the FS anymore\n\t\t */\n\t\tmemset(&disk_super->magic, 0, sizeof(disk_super->magic));\n\t\tset_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\n\t\t/* clear the mirror copies of super block on the disk\n\t\t * being removed, 0th copy is been taken care above and\n\t\t * the below would take of the rest\n\t\t */\n\t\tfor (i = 1; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\t\tbytenr = btrfs_sb_offset(i);\n\t\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t\t\t\ti_size_read(bdev->bd_inode))\n\t\t\t\tbreak;\n\n\t\t\tbrelse(bh);\n\t\t\tbh = __bread(bdev, bytenr / 4096,\n\t\t\t\t\tBTRFS_SUPER_INFO_SIZE);\n\t\t\tif (!bh)\n\t\t\t\tcontinue;\n\n\t\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\n\t\t\tif (btrfs_super_bytenr(disk_super) != bytenr ||\n\t\t\t\tbtrfs_super_magic(disk_super) != BTRFS_MAGIC) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemset(&disk_super->magic, 0,\n\t\t\t\t\t\tsizeof(disk_super->magic));\n\t\t\tset_buffer_dirty(bh);\n\t\t\tsync_dirty_buffer(bh);\n\t\t}\n\t}\n\n\tret = 0;\n\n\tif (bdev) {\n\t\t/* Notify udev that device has changed */\n\t\tbtrfs_kobject_uevent(bdev, KOBJ_CHANGE);\n\n\t\t/* Update ctime/mtime for device path for libblkid */\n\t\tupdate_dev_time(device_path);\n\t}\n\nerror_brelse:\n\tbrelse(bh);\n\tif (bdev)\n\t\tblkdev_put(bdev, FMODE_READ | FMODE_EXCL);\nout:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\nerror_undo:\n\tif (device->writeable) {\n\t\tlock_chunks(root);\n\t\tlist_add(&device->dev_alloc_list,\n\t\t\t &root->fs_info->fs_devices->alloc_list);\n\t\tdevice->fs_devices->rw_devices++;\n\t\tunlock_chunks(root);\n\t}\n\tgoto error_brelse;\n}"
  },
  {
    "function_name": "btrfs_rm_dev_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1497-1536",
    "snippet": "static int btrfs_rm_dev_item(struct btrfs_root *root,\n\t\t\t     struct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_trans_handle *trans;\n\n\troot = root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, root, path);\n\tif (ret)\n\t\tgoto out;\nout:\n\tbtrfs_free_path(path);\n\tbtrfs_commit_transaction(trans, root);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "trans",
            "root",
            "path"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_rm_dev_item(struct btrfs_root *root,\n\t\t\t     struct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_trans_handle *trans;\n\n\troot = root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, root, path);\n\tif (ret)\n\t\tgoto out;\nout:\n\tbtrfs_free_path(path);\n\tbtrfs_commit_transaction(trans, root);\n\treturn ret;\n}"
  },
  {
    "function_name": "update_dev_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1485-1495",
    "snippet": "static void update_dev_time(char *path_name)\n{\n\tstruct file *filp;\n\n\tfilp = filp_open(path_name, O_RDWR, 0);\n\tif (IS_ERR(filp))\n\t\treturn;\n\tfile_update_time(filp);\n\tfilp_close(filp, NULL);\n\treturn;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "filp",
            "NULL"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "filp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "1060-1078",
          "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "filp"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filp"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_open",
          "args": [
            "path_name",
            "O_RDWR",
            "0"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "filp_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "969-979",
          "snippet": "struct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void update_dev_time(char *path_name)\n{\n\tstruct file *filp;\n\n\tfilp = filp_open(path_name, O_RDWR, 0);\n\tif (IS_ERR(filp))\n\t\treturn;\n\tfile_update_time(filp);\n\tfilp_close(filp, NULL);\n\treturn;\n}"
  },
  {
    "function_name": "btrfs_add_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1425-1479",
    "snippet": "static int btrfs_add_device(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tunsigned long ptr;\n\n\troot = root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(*dev_item));\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_generation(leaf, dev_item, 0);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_set_device_group(leaf, dev_item, 0);\n\tbtrfs_set_device_seek_speed(leaf, dev_item, 0);\n\tbtrfs_set_device_bandwidth(leaf, dev_item, 0);\n\tbtrfs_set_device_start_offset(leaf, dev_item, 0);\n\n\tptr = btrfs_device_uuid(dev_item);\n\twrite_extent_buffer(leaf, device->uuid, ptr, BTRFS_UUID_SIZE);\n\tptr = btrfs_device_fsid(dev_item);\n\twrite_extent_buffer(leaf, root->fs_info->fsid, ptr, BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "leaf",
            "root->fs_info->fsid",
            "ptr",
            "BTRFS_UUID_SIZE"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_fsid",
          "args": [
            "dev_item"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_device_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2352-2355",
          "snippet": "static inline unsigned long btrfs_device_fsid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, fsid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_device_fsid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, fsid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_uuid",
          "args": [
            "dev_item"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_device_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2347-2350",
          "snippet": "static inline unsigned long btrfs_device_uuid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, uuid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_device_uuid(struct btrfs_dev_item *d)\n{\n\treturn (unsigned long)d + offsetof(struct btrfs_dev_item, uuid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_start_offset",
          "args": [
            "leaf",
            "dev_item",
            "0"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_bandwidth",
          "args": [
            "leaf",
            "dev_item",
            "0"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_seek_speed",
          "args": [
            "leaf",
            "dev_item",
            "0"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_group",
          "args": [
            "leaf",
            "dev_item",
            "0"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_bytes_used",
          "args": [
            "leaf",
            "dev_item",
            "btrfs_device_get_bytes_used(device)"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_bytes_used",
          "args": [
            "device"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_total_bytes",
          "args": [
            "leaf",
            "dev_item",
            "btrfs_device_get_disk_total_bytes(device)"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_disk_total_bytes",
          "args": [
            "device"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_sector_size",
          "args": [
            "leaf",
            "dev_item",
            "device->sector_size"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_io_width",
          "args": [
            "leaf",
            "dev_item",
            "device->io_width"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_io_align",
          "args": [
            "leaf",
            "dev_item",
            "device->io_align"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_type",
          "args": [
            "leaf",
            "dev_item",
            "device->type"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_generation",
          "args": [
            "leaf",
            "dev_item",
            "0"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_device_id",
          "args": [
            "leaf",
            "dev_item",
            "device->devid"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_dev_item"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "root",
            "path",
            "&key",
            "sizeof(*dev_item)"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_add_device(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_device *device)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tunsigned long ptr;\n\n\troot = root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = device->devid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(*dev_item));\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tdev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item);\n\n\tbtrfs_set_device_id(leaf, dev_item, device->devid);\n\tbtrfs_set_device_generation(leaf, dev_item, 0);\n\tbtrfs_set_device_type(leaf, dev_item, device->type);\n\tbtrfs_set_device_io_align(leaf, dev_item, device->io_align);\n\tbtrfs_set_device_io_width(leaf, dev_item, device->io_width);\n\tbtrfs_set_device_sector_size(leaf, dev_item, device->sector_size);\n\tbtrfs_set_device_total_bytes(leaf, dev_item,\n\t\t\t\t     btrfs_device_get_disk_total_bytes(device));\n\tbtrfs_set_device_bytes_used(leaf, dev_item,\n\t\t\t\t    btrfs_device_get_bytes_used(device));\n\tbtrfs_set_device_group(leaf, dev_item, 0);\n\tbtrfs_set_device_seek_speed(leaf, dev_item, 0);\n\tbtrfs_set_device_bandwidth(leaf, dev_item, 0);\n\tbtrfs_set_device_start_offset(leaf, dev_item, 0);\n\n\tptr = btrfs_device_uuid(dev_item);\n\twrite_extent_buffer(leaf, device->uuid, ptr, BTRFS_UUID_SIZE);\n\tptr = btrfs_device_fsid(dev_item);\n\twrite_extent_buffer(leaf, root->fs_info->fsid, ptr, BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_next_devid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1383-1419",
    "snippet": "static noinline int find_next_devid(struct btrfs_fs_info *fs_info,\n\t\t\t\t    u64 *devid_ret)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->chunk_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tBUG_ON(ret == 0); /* Corruption */\n\n\tret = btrfs_previous_item(fs_info->chunk_root, path,\n\t\t\t\t  BTRFS_DEV_ITEMS_OBJECTID,\n\t\t\t\t  BTRFS_DEV_ITEM_KEY);\n\tif (ret) {\n\t\t*devid_ret = 1;\n\t} else {\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\t*devid_ret = found_key.offset + 1;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_previous_item",
          "args": [
            "fs_info->chunk_root",
            "path",
            "BTRFS_DEV_ITEMS_OBJECTID",
            "BTRFS_DEV_ITEM_KEY"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_previous_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5830-5865",
          "snippet": "int btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == 0"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "fs_info->chunk_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline int find_next_devid(struct btrfs_fs_info *fs_info,\n\t\t\t\t    u64 *devid_ret)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->chunk_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tBUG_ON(ret == 0); /* Corruption */\n\n\tret = btrfs_previous_item(fs_info->chunk_root, path,\n\t\t\t\t  BTRFS_DEV_ITEMS_OBJECTID,\n\t\t\t\t  BTRFS_DEV_ITEM_KEY);\n\tif (ret) {\n\t\t*devid_ret = 1;\n\t} else {\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\t*devid_ret = found_key.offset + 1;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_next_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1364-1381",
    "snippet": "static u64 find_next_chunk(struct btrfs_fs_info *fs_info)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct rb_node *n;\n\tu64 ret = 0;\n\n\tem_tree = &fs_info->mapping_tree.map_tree;\n\tread_lock(&em_tree->lock);\n\tn = rb_last(&em_tree->map);\n\tif (n) {\n\t\tem = rb_entry(n, struct extent_map, rb_node);\n\t\tret = em->start + em->len;\n\t}\n\tread_unlock(&em_tree->lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structextent_map",
            "rb_node"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_last",
          "args": [
            "&em_tree->map"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic u64 find_next_chunk(struct btrfs_fs_info *fs_info)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct rb_node *n;\n\tu64 ret = 0;\n\n\tem_tree = &fs_info->mapping_tree.map_tree;\n\tread_lock(&em_tree->lock);\n\tn = rb_last(&em_tree->map);\n\tif (n) {\n\t\tem = rb_entry(n, struct extent_map, rb_node);\n\t\tret = em->start + em->len;\n\t}\n\tread_unlock(&em_tree->lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_alloc_dev_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1321-1362",
    "snippet": "static int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_device *device,\n\t\t\t\t  u64 chunk_tree, u64 chunk_objectid,\n\t\t\t\t  u64 chunk_offset, u64 start, u64 num_bytes)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *extent;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\tWARN_ON(!device->in_fs_metadata);\n\tWARN_ON(device->is_tgtdev_for_dev_replace);\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = device->devid;\n\tkey.offset = start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(*extent));\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_dev_extent);\n\tbtrfs_set_dev_extent_chunk_tree(leaf, extent, chunk_tree);\n\tbtrfs_set_dev_extent_chunk_objectid(leaf, extent, chunk_objectid);\n\tbtrfs_set_dev_extent_chunk_offset(leaf, extent, chunk_offset);\n\n\twrite_extent_buffer(leaf, root->fs_info->chunk_tree_uuid,\n\t\t    btrfs_dev_extent_chunk_tree_uuid(extent), BTRFS_UUID_SIZE);\n\n\tbtrfs_set_dev_extent_length(leaf, extent, num_bytes);\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_extent_length",
          "args": [
            "leaf",
            "extent",
            "num_bytes"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "leaf",
            "root->fs_info->chunk_tree_uuid",
            "btrfs_dev_extent_chunk_tree_uuid(extent)",
            "BTRFS_UUID_SIZE"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_extent_chunk_tree_uuid",
          "args": [
            "extent"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_extent_chunk_tree_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2488-2492",
          "snippet": "static inline unsigned long btrfs_dev_extent_chunk_tree_uuid(struct btrfs_dev_extent *dev)\n{\n\tunsigned long ptr = offsetof(struct btrfs_dev_extent, chunk_tree_uuid);\n\treturn (unsigned long)dev + ptr;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_dev_extent_chunk_tree_uuid(struct btrfs_dev_extent *dev)\n{\n\tunsigned long ptr = offsetof(struct btrfs_dev_extent, chunk_tree_uuid);\n\treturn (unsigned long)dev + ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_extent_chunk_offset",
          "args": [
            "leaf",
            "extent",
            "chunk_offset"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_extent_chunk_objectid",
          "args": [
            "leaf",
            "extent",
            "chunk_objectid"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_extent_chunk_tree",
          "args": [
            "leaf",
            "extent",
            "chunk_tree"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_dev_extent"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "root",
            "path",
            "&key",
            "sizeof(*extent)"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "device->is_tgtdev_for_dev_replace"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!device->in_fs_metadata"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_device *device,\n\t\t\t\t  u64 chunk_tree, u64 chunk_objectid,\n\t\t\t\t  u64 chunk_offset, u64 start, u64 num_bytes)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *extent;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\tWARN_ON(!device->in_fs_metadata);\n\tWARN_ON(device->is_tgtdev_for_dev_replace);\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = device->devid;\n\tkey.offset = start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(*extent));\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_dev_extent);\n\tbtrfs_set_dev_extent_chunk_tree(leaf, extent, chunk_tree);\n\tbtrfs_set_dev_extent_chunk_objectid(leaf, extent, chunk_objectid);\n\tbtrfs_set_dev_extent_chunk_offset(leaf, extent, chunk_offset);\n\n\twrite_extent_buffer(leaf, root->fs_info->chunk_tree_uuid,\n\t\t    btrfs_dev_extent_chunk_tree_uuid(extent), BTRFS_UUID_SIZE);\n\n\tbtrfs_set_dev_extent_length(leaf, extent, num_bytes);\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_free_dev_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1263-1319",
    "snippet": "static int btrfs_free_dev_extent(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_device *device,\n\t\t\t  u64 start, u64 *dev_extent_len)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf = NULL;\n\tstruct btrfs_dev_extent *extent = NULL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = device->devid;\n\tkey.offset = start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\nagain:\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret > 0) {\n\t\tret = btrfs_previous_item(root, path, key.objectid,\n\t\t\t\t\t  BTRFS_DEV_EXTENT_KEY);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\tstruct btrfs_dev_extent);\n\t\tBUG_ON(found_key.offset > start || found_key.offset +\n\t\t       btrfs_dev_extent_length(leaf, extent) < start);\n\t\tkey = found_key;\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t} else if (ret == 0) {\n\t\tleaf = path->nodes[0];\n\t\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\tstruct btrfs_dev_extent);\n\t} else {\n\t\tbtrfs_error(root->fs_info, ret, \"Slot search failed\");\n\t\tgoto out;\n\t}\n\n\t*dev_extent_len = btrfs_dev_extent_length(leaf, extent);\n\n\tret = btrfs_del_item(trans, root, path);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Failed to remove dev extent item\");\n\t} else {\n\t\ttrans->transaction->have_free_bgs = 1;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_error",
          "args": [
            "root->fs_info",
            "ret",
            "\"Failed to remove dev extent item\""
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "trans",
            "root",
            "path"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_extent_length",
          "args": [
            "leaf",
            "extent"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_dev_extent"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "found_key.offset > start || found_key.offset +\n\t\t       btrfs_dev_extent_length(leaf, extent) < start"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_extent_length",
          "args": [
            "leaf",
            "extent"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_dev_extent"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_previous_item",
          "args": [
            "root",
            "path",
            "key.objectid",
            "BTRFS_DEV_EXTENT_KEY"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_previous_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5830-5865",
          "snippet": "int btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int btrfs_free_dev_extent(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_device *device,\n\t\t\t  u64 start, u64 *dev_extent_len)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf = NULL;\n\tstruct btrfs_dev_extent *extent = NULL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = device->devid;\n\tkey.offset = start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\nagain:\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret > 0) {\n\t\tret = btrfs_previous_item(root, path, key.objectid,\n\t\t\t\t\t  BTRFS_DEV_EXTENT_KEY);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\tstruct btrfs_dev_extent);\n\t\tBUG_ON(found_key.offset > start || found_key.offset +\n\t\t       btrfs_dev_extent_length(leaf, extent) < start);\n\t\tkey = found_key;\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t} else if (ret == 0) {\n\t\tleaf = path->nodes[0];\n\t\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\tstruct btrfs_dev_extent);\n\t} else {\n\t\tbtrfs_error(root->fs_info, ret, \"Slot search failed\");\n\t\tgoto out;\n\t}\n\n\t*dev_extent_len = btrfs_dev_extent_length(leaf, extent);\n\n\tret = btrfs_del_item(trans, root, path);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Failed to remove dev extent item\");\n\t} else {\n\t\ttrans->transaction->have_free_bgs = 1;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_free_dev_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1111-1261",
    "snippet": "int find_free_dev_extent(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_device *device, u64 num_bytes,\n\t\t\t u64 *start, u64 *len)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_path *path;\n\tu64 hole_size;\n\tu64 max_hole_start;\n\tu64 max_hole_size;\n\tu64 extent_end;\n\tu64 search_start;\n\tu64 search_end = device->total_bytes;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\n\t/* FIXME use last free of some kind */\n\n\t/* we don't want to overwrite the superblock on the drive,\n\t * so we make sure to start at an offset of at least 1MB\n\t */\n\tsearch_start = max(root->fs_info->alloc_start, 1024ull * 1024);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tmax_hole_start = search_start;\n\tmax_hole_size = 0;\n\thole_size = 0;\n\n\tif (search_start >= search_end || device->is_tgtdev_for_dev_replace) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tpath->reada = 2;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tkey.objectid = device->devid;\n\tkey.offset = search_start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = btrfs_previous_item(root, path, key.objectid, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\tif (key.objectid < device->devid)\n\t\t\tgoto next;\n\n\t\tif (key.objectid > device->devid)\n\t\t\tbreak;\n\n\t\tif (key.type != BTRFS_DEV_EXTENT_KEY)\n\t\t\tgoto next;\n\n\t\tif (key.offset > search_start) {\n\t\t\thole_size = key.offset - search_start;\n\n\t\t\t/*\n\t\t\t * Have to check before we set max_hole_start, otherwise\n\t\t\t * we could end up sending back this offset anyway.\n\t\t\t */\n\t\t\tif (contains_pending_extent(trans, device,\n\t\t\t\t\t\t    &search_start,\n\t\t\t\t\t\t    hole_size))\n\t\t\t\thole_size = 0;\n\n\t\t\tif (hole_size > max_hole_size) {\n\t\t\t\tmax_hole_start = search_start;\n\t\t\t\tmax_hole_size = hole_size;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this free space is greater than which we need,\n\t\t\t * it must be the max free space that we have found\n\t\t\t * until now, so max_hole_start must point to the start\n\t\t\t * of this free space and the length of this free space\n\t\t\t * is stored in max_hole_size. Thus, we return\n\t\t\t * max_hole_start and max_hole_size and go back to the\n\t\t\t * caller.\n\t\t\t */\n\t\t\tif (hole_size >= num_bytes) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\textent_end = key.offset + btrfs_dev_extent_length(l,\n\t\t\t\t\t\t\t\t  dev_extent);\n\t\tif (extent_end > search_start)\n\t\t\tsearch_start = extent_end;\nnext:\n\t\tpath->slots[0]++;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * At this point, search_start should be the end of\n\t * allocated dev extents, and when shrinking the device,\n\t * search_end may be smaller than search_start.\n\t */\n\tif (search_end > search_start)\n\t\thole_size = search_end - search_start;\n\n\tif (hole_size > max_hole_size) {\n\t\tmax_hole_start = search_start;\n\t\tmax_hole_size = hole_size;\n\t}\n\n\tif (contains_pending_extent(trans, device, &search_start, hole_size)) {\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t}\n\n\t/* See above. */\n\tif (hole_size < num_bytes)\n\t\tret = -ENOSPC;\n\telse\n\t\tret = 0;\n\nout:\n\tbtrfs_free_path(path);\n\t*start = max_hole_start;\n\tif (len)\n\t\t*len = max_hole_size;\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "contains_pending_extent",
          "args": [
            "trans",
            "device",
            "&search_start",
            "hole_size"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "contains_pending_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1056-1088",
          "snippet": "static int contains_pending_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_device *device,\n\t\t\t\t   u64 *start, u64 len)\n{\n\tstruct extent_map *em;\n\tstruct list_head *search_list = &trans->transaction->pending_chunks;\n\tint ret = 0;\n\nagain:\n\tlist_for_each_entry(em, search_list, list) {\n\t\tstruct map_lookup *map;\n\t\tint i;\n\n\t\tmap = (struct map_lookup *)em->bdev;\n\t\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t\tif (map->stripes[i].dev != device)\n\t\t\t\tcontinue;\n\t\t\tif (map->stripes[i].physical >= *start + len ||\n\t\t\t    map->stripes[i].physical + em->orig_block_len <=\n\t\t\t    *start)\n\t\t\t\tcontinue;\n\t\t\t*start = map->stripes[i].physical +\n\t\t\t\tem->orig_block_len;\n\t\t\tret = 1;\n\t\t}\n\t}\n\tif (search_list == &trans->transaction->pending_chunks) {\n\t\tsearch_list = &trans->root->fs_info->pinned_chunks;\n\t\tgoto again;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int contains_pending_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_device *device,\n\t\t\t\t   u64 *start, u64 len)\n{\n\tstruct extent_map *em;\n\tstruct list_head *search_list = &trans->transaction->pending_chunks;\n\tint ret = 0;\n\nagain:\n\tlist_for_each_entry(em, search_list, list) {\n\t\tstruct map_lookup *map;\n\t\tint i;\n\n\t\tmap = (struct map_lookup *)em->bdev;\n\t\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t\tif (map->stripes[i].dev != device)\n\t\t\t\tcontinue;\n\t\t\tif (map->stripes[i].physical >= *start + len ||\n\t\t\t    map->stripes[i].physical + em->orig_block_len <=\n\t\t\t    *start)\n\t\t\t\tcontinue;\n\t\t\t*start = map->stripes[i].physical +\n\t\t\t\tem->orig_block_len;\n\t\t\tret = 1;\n\t\t}\n\t}\n\tif (search_list == &trans->transaction->pending_chunks) {\n\t\tsearch_list = &trans->root->fs_info->pinned_chunks;\n\t\tgoto again;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_extent_length",
          "args": [
            "l",
            "dev_extent"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "l",
            "slot",
            "structbtrfs_dev_extent"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "l",
            "&key",
            "slot"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "l"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_previous_item",
          "args": [
            "root",
            "path",
            "key.objectid",
            "key.type"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_previous_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5830-5865",
          "snippet": "int btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "root->fs_info->alloc_start",
            "1024ull * 1024"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint find_free_dev_extent(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_device *device, u64 num_bytes,\n\t\t\t u64 *start, u64 *len)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_path *path;\n\tu64 hole_size;\n\tu64 max_hole_start;\n\tu64 max_hole_size;\n\tu64 extent_end;\n\tu64 search_start;\n\tu64 search_end = device->total_bytes;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\n\t/* FIXME use last free of some kind */\n\n\t/* we don't want to overwrite the superblock on the drive,\n\t * so we make sure to start at an offset of at least 1MB\n\t */\n\tsearch_start = max(root->fs_info->alloc_start, 1024ull * 1024);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tmax_hole_start = search_start;\n\tmax_hole_size = 0;\n\thole_size = 0;\n\n\tif (search_start >= search_end || device->is_tgtdev_for_dev_replace) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tpath->reada = 2;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tkey.objectid = device->devid;\n\tkey.offset = search_start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = btrfs_previous_item(root, path, key.objectid, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\tif (key.objectid < device->devid)\n\t\t\tgoto next;\n\n\t\tif (key.objectid > device->devid)\n\t\t\tbreak;\n\n\t\tif (key.type != BTRFS_DEV_EXTENT_KEY)\n\t\t\tgoto next;\n\n\t\tif (key.offset > search_start) {\n\t\t\thole_size = key.offset - search_start;\n\n\t\t\t/*\n\t\t\t * Have to check before we set max_hole_start, otherwise\n\t\t\t * we could end up sending back this offset anyway.\n\t\t\t */\n\t\t\tif (contains_pending_extent(trans, device,\n\t\t\t\t\t\t    &search_start,\n\t\t\t\t\t\t    hole_size))\n\t\t\t\thole_size = 0;\n\n\t\t\tif (hole_size > max_hole_size) {\n\t\t\t\tmax_hole_start = search_start;\n\t\t\t\tmax_hole_size = hole_size;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this free space is greater than which we need,\n\t\t\t * it must be the max free space that we have found\n\t\t\t * until now, so max_hole_start must point to the start\n\t\t\t * of this free space and the length of this free space\n\t\t\t * is stored in max_hole_size. Thus, we return\n\t\t\t * max_hole_start and max_hole_size and go back to the\n\t\t\t * caller.\n\t\t\t */\n\t\t\tif (hole_size >= num_bytes) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\textent_end = key.offset + btrfs_dev_extent_length(l,\n\t\t\t\t\t\t\t\t  dev_extent);\n\t\tif (extent_end > search_start)\n\t\t\tsearch_start = extent_end;\nnext:\n\t\tpath->slots[0]++;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * At this point, search_start should be the end of\n\t * allocated dev extents, and when shrinking the device,\n\t * search_end may be smaller than search_start.\n\t */\n\tif (search_end > search_start)\n\t\thole_size = search_end - search_start;\n\n\tif (hole_size > max_hole_size) {\n\t\tmax_hole_start = search_start;\n\t\tmax_hole_size = hole_size;\n\t}\n\n\tif (contains_pending_extent(trans, device, &search_start, hole_size)) {\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t}\n\n\t/* See above. */\n\tif (hole_size < num_bytes)\n\t\tret = -ENOSPC;\n\telse\n\t\tret = 0;\n\nout:\n\tbtrfs_free_path(path);\n\t*start = max_hole_start;\n\tif (len)\n\t\t*len = max_hole_size;\n\treturn ret;\n}"
  },
  {
    "function_name": "contains_pending_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "1056-1088",
    "snippet": "static int contains_pending_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_device *device,\n\t\t\t\t   u64 *start, u64 len)\n{\n\tstruct extent_map *em;\n\tstruct list_head *search_list = &trans->transaction->pending_chunks;\n\tint ret = 0;\n\nagain:\n\tlist_for_each_entry(em, search_list, list) {\n\t\tstruct map_lookup *map;\n\t\tint i;\n\n\t\tmap = (struct map_lookup *)em->bdev;\n\t\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t\tif (map->stripes[i].dev != device)\n\t\t\t\tcontinue;\n\t\t\tif (map->stripes[i].physical >= *start + len ||\n\t\t\t    map->stripes[i].physical + em->orig_block_len <=\n\t\t\t    *start)\n\t\t\t\tcontinue;\n\t\t\t*start = map->stripes[i].physical +\n\t\t\t\tem->orig_block_len;\n\t\t\tret = 1;\n\t\t}\n\t}\n\tif (search_list == &trans->transaction->pending_chunks) {\n\t\tsearch_list = &trans->root->fs_info->pinned_chunks;\n\t\tgoto again;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "em",
            "search_list",
            "list"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int contains_pending_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_device *device,\n\t\t\t\t   u64 *start, u64 len)\n{\n\tstruct extent_map *em;\n\tstruct list_head *search_list = &trans->transaction->pending_chunks;\n\tint ret = 0;\n\nagain:\n\tlist_for_each_entry(em, search_list, list) {\n\t\tstruct map_lookup *map;\n\t\tint i;\n\n\t\tmap = (struct map_lookup *)em->bdev;\n\t\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t\tif (map->stripes[i].dev != device)\n\t\t\t\tcontinue;\n\t\t\tif (map->stripes[i].physical >= *start + len ||\n\t\t\t    map->stripes[i].physical + em->orig_block_len <=\n\t\t\t    *start)\n\t\t\t\tcontinue;\n\t\t\t*start = map->stripes[i].physical +\n\t\t\t\tem->orig_block_len;\n\t\t\tret = 1;\n\t\t}\n\t}\n\tif (search_list == &trans->transaction->pending_chunks) {\n\t\tsearch_list = &trans->root->fs_info->pinned_chunks;\n\t\tgoto again;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_account_dev_extents_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "973-1054",
    "snippet": "int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,\n\t\t\t\t   u64 end, u64 *length)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_path *path;\n\tu64 extent_end;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\n\t*length = 0;\n\n\tif (start >= device->total_bytes || device->is_tgtdev_for_dev_replace)\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 2;\n\n\tkey.objectid = device->devid;\n\tkey.offset = start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = btrfs_previous_item(root, path, key.objectid, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\tif (key.objectid < device->devid)\n\t\t\tgoto next;\n\n\t\tif (key.objectid > device->devid)\n\t\t\tbreak;\n\n\t\tif (key.type != BTRFS_DEV_EXTENT_KEY)\n\t\t\tgoto next;\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\textent_end = key.offset + btrfs_dev_extent_length(l,\n\t\t\t\t\t\t\t\t  dev_extent);\n\t\tif (key.offset <= start && extent_end > end) {\n\t\t\t*length = end - start + 1;\n\t\t\tbreak;\n\t\t} else if (key.offset <= start && extent_end > start)\n\t\t\t*length += extent_end - start;\n\t\telse if (key.offset > start && extent_end <= end)\n\t\t\t*length += extent_end - key.offset;\n\t\telse if (key.offset > start && key.offset <= end) {\n\t\t\t*length += end - key.offset + 1;\n\t\t\tbreak;\n\t\t} else if (key.offset > end)\n\t\t\tbreak;\n\nnext:\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_extent_length",
          "args": [
            "l",
            "dev_extent"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "l",
            "slot",
            "structbtrfs_dev_extent"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "l",
            "&key",
            "slot"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "l"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_previous_item",
          "args": [
            "root",
            "path",
            "key.objectid",
            "key.type"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_previous_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5830-5865",
          "snippet": "int btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,\n\t\t\t\t   u64 end, u64 *length)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_path *path;\n\tu64 extent_end;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\n\t*length = 0;\n\n\tif (start >= device->total_bytes || device->is_tgtdev_for_dev_replace)\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 2;\n\n\tkey.objectid = device->devid;\n\tkey.offset = start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = btrfs_previous_item(root, path, key.objectid, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\tif (key.objectid < device->devid)\n\t\t\tgoto next;\n\n\t\tif (key.objectid > device->devid)\n\t\t\tbreak;\n\n\t\tif (key.type != BTRFS_DEV_EXTENT_KEY)\n\t\t\tgoto next;\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\textent_end = key.offset + btrfs_dev_extent_length(l,\n\t\t\t\t\t\t\t\t  dev_extent);\n\t\tif (key.offset <= start && extent_end > end) {\n\t\t\t*length = end - start + 1;\n\t\t\tbreak;\n\t\t} else if (key.offset <= start && extent_end > start)\n\t\t\t*length += extent_end - start;\n\t\telse if (key.offset > start && extent_end <= end)\n\t\t\t*length += extent_end - key.offset;\n\t\telse if (key.offset > start && key.offset <= end) {\n\t\t\t*length += end - key.offset + 1;\n\t\t\tbreak;\n\t\t} else if (key.offset > end)\n\t\t\tbreak;\n\nnext:\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_scan_one_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "881-970",
    "snippet": "int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,\n\t\t\t  struct btrfs_fs_devices **fs_devices_ret)\n{\n\tstruct btrfs_super_block *disk_super;\n\tstruct block_device *bdev;\n\tstruct page *page;\n\tvoid *p;\n\tint ret = -EINVAL;\n\tu64 devid;\n\tu64 transid;\n\tu64 total_devices;\n\tu64 bytenr;\n\tpgoff_t index;\n\n\t/*\n\t * we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tbytenr = btrfs_sb_offset(0);\n\tflags |= FMODE_EXCL;\n\tmutex_lock(&uuid_mutex);\n\n\tbdev = blkdev_get_by_path(path, flags, holder);\n\n\tif (IS_ERR(bdev)) {\n\t\tret = PTR_ERR(bdev);\n\t\tgoto error;\n\t}\n\n\t/* make sure our super fits in the device */\n\tif (bytenr + PAGE_CACHE_SIZE >= i_size_read(bdev->bd_inode))\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super fits in the page */\n\tif (sizeof(*disk_super) > PAGE_CACHE_SIZE)\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super doesn't straddle pages on disk */\n\tindex = bytenr >> PAGE_CACHE_SHIFT;\n\tif ((bytenr + sizeof(*disk_super) - 1) >> PAGE_CACHE_SHIFT != index)\n\t\tgoto error_bdev_put;\n\n\t/* pull in the page with our super */\n\tpage = read_cache_page_gfp(bdev->bd_inode->i_mapping,\n\t\t\t\t   index, GFP_NOFS);\n\n\tif (IS_ERR_OR_NULL(page))\n\t\tgoto error_bdev_put;\n\n\tp = kmap(page);\n\n\t/* align our pointer to the offset of the super block */\n\tdisk_super = p + (bytenr & ~PAGE_CACHE_MASK);\n\n\tif (btrfs_super_bytenr(disk_super) != bytenr ||\n\t    btrfs_super_magic(disk_super) != BTRFS_MAGIC)\n\t\tgoto error_unmap;\n\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\ttransid = btrfs_super_generation(disk_super);\n\ttotal_devices = btrfs_super_num_devices(disk_super);\n\n\tret = device_list_add(path, disk_super, devid, fs_devices_ret);\n\tif (ret > 0) {\n\t\tif (disk_super->label[0]) {\n\t\t\tif (disk_super->label[BTRFS_LABEL_SIZE - 1])\n\t\t\t\tdisk_super->label[BTRFS_LABEL_SIZE - 1] = '\\0';\n\t\t\tprintk(KERN_INFO \"BTRFS: device label %s \", disk_super->label);\n\t\t} else {\n\t\t\tprintk(KERN_INFO \"BTRFS: device fsid %pU \", disk_super->fsid);\n\t\t}\n\n\t\tprintk(KERN_CONT \"devid %llu transid %llu %s\\n\", devid, transid, path);\n\t\tret = 0;\n\t}\n\tif (!ret && fs_devices_ret)\n\t\t(*fs_devices_ret)->total_devices = total_devices;\n\nerror_unmap:\n\tkunmap(page);\n\tpage_cache_release(page);\n\nerror_bdev_put:\n\tblkdev_put(bdev, flags);\nerror:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "flags"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"devid %llu transid %llu %s\\n\"",
            "devid",
            "transid",
            "path"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_list_add",
          "args": [
            "path",
            "disk_super",
            "devid",
            "fs_devices_ret"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "device_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "453-563",
          "snippet": "static noinline int device_list_add(const char *path,\n\t\t\t   struct btrfs_super_block *disk_super,\n\t\t\t   u64 devid, struct btrfs_fs_devices **fs_devices_ret)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices;\n\tstruct rcu_string *name;\n\tint ret = 0;\n\tu64 found_transid = btrfs_super_generation(disk_super);\n\n\tfs_devices = find_fsid(disk_super->fsid);\n\tif (!fs_devices) {\n\t\tfs_devices = alloc_fs_devices(disk_super->fsid);\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn PTR_ERR(fs_devices);\n\n\t\tlist_add(&fs_devices->list, &fs_uuids);\n\n\t\tdevice = NULL;\n\t} else {\n\t\tdevice = __find_device(&fs_devices->devices, devid,\n\t\t\t\t       disk_super->dev_item.uuid);\n\t}\n\n\tif (!device) {\n\t\tif (fs_devices->opened)\n\t\t\treturn -EBUSY;\n\n\t\tdevice = btrfs_alloc_device(NULL, &devid,\n\t\t\t\t\t    disk_super->dev_item.uuid);\n\t\tif (IS_ERR(device)) {\n\t\t\t/* we can safely leave the fs_devices entry around */\n\t\t\treturn PTR_ERR(device);\n\t\t}\n\n\t\tname = rcu_string_strdup(path, GFP_NOFS);\n\t\tif (!name) {\n\t\t\tkfree(device);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trcu_assign_pointer(device->name, name);\n\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\t\tlist_add_rcu(&device->dev_list, &fs_devices->devices);\n\t\tfs_devices->num_devices++;\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t\tret = 1;\n\t\tdevice->fs_devices = fs_devices;\n\t} else if (!device->name || strcmp(device->name->str, path)) {\n\t\t/*\n\t\t * When FS is already mounted.\n\t\t * 1. If you are here and if the device->name is NULL that\n\t\t *    means this device was missing at time of FS mount.\n\t\t * 2. If you are here and if the device->name is different\n\t\t *    from 'path' that means either\n\t\t *      a. The same device disappeared and reappeared with\n\t\t *         different name. or\n\t\t *      b. The missing-disk-which-was-replaced, has\n\t\t *         reappeared now.\n\t\t *\n\t\t * We must allow 1 and 2a above. But 2b would be a spurious\n\t\t * and unintentional.\n\t\t *\n\t\t * Further in case of 1 and 2a above, the disk at 'path'\n\t\t * would have missed some transaction when it was away and\n\t\t * in case of 2a the stale bdev has to be updated as well.\n\t\t * 2b must not be allowed at all time.\n\t\t */\n\n\t\t/*\n\t\t * For now, we do allow update to btrfs_fs_device through the\n\t\t * btrfs dev scan cli after FS has been mounted.  We're still\n\t\t * tracking a problem where systems fail mount by subvolume id\n\t\t * when we reject replacement on a mounted FS.\n\t\t */\n\t\tif (!fs_devices->opened && found_transid < device->generation) {\n\t\t\t/*\n\t\t\t * That is if the FS is _not_ mounted and if you\n\t\t\t * are here, that means there is more than one\n\t\t\t * disk with same uuid and devid.We keep the one\n\t\t\t * with larger generation number or the last-in if\n\t\t\t * generation are equal.\n\t\t\t */\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\tname = rcu_string_strdup(path, GFP_NOFS);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\t\trcu_string_free(device->name);\n\t\trcu_assign_pointer(device->name, name);\n\t\tif (device->missing) {\n\t\t\tfs_devices->missing_devices--;\n\t\t\tdevice->missing = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Unmount does not free the btrfs_device struct but would zero\n\t * generation along with most of the other members. So just update\n\t * it back. We need it to pick the disk with largest generation\n\t * (as above).\n\t */\n\tif (!fs_devices->opened)\n\t\tdevice->generation = found_transid;\n\n\t*fs_devices_ret = fs_devices;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline int device_list_add(const char *path,\n\t\t\t   struct btrfs_super_block *disk_super,\n\t\t\t   u64 devid, struct btrfs_fs_devices **fs_devices_ret)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices;\n\tstruct rcu_string *name;\n\tint ret = 0;\n\tu64 found_transid = btrfs_super_generation(disk_super);\n\n\tfs_devices = find_fsid(disk_super->fsid);\n\tif (!fs_devices) {\n\t\tfs_devices = alloc_fs_devices(disk_super->fsid);\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn PTR_ERR(fs_devices);\n\n\t\tlist_add(&fs_devices->list, &fs_uuids);\n\n\t\tdevice = NULL;\n\t} else {\n\t\tdevice = __find_device(&fs_devices->devices, devid,\n\t\t\t\t       disk_super->dev_item.uuid);\n\t}\n\n\tif (!device) {\n\t\tif (fs_devices->opened)\n\t\t\treturn -EBUSY;\n\n\t\tdevice = btrfs_alloc_device(NULL, &devid,\n\t\t\t\t\t    disk_super->dev_item.uuid);\n\t\tif (IS_ERR(device)) {\n\t\t\t/* we can safely leave the fs_devices entry around */\n\t\t\treturn PTR_ERR(device);\n\t\t}\n\n\t\tname = rcu_string_strdup(path, GFP_NOFS);\n\t\tif (!name) {\n\t\t\tkfree(device);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trcu_assign_pointer(device->name, name);\n\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\t\tlist_add_rcu(&device->dev_list, &fs_devices->devices);\n\t\tfs_devices->num_devices++;\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t\tret = 1;\n\t\tdevice->fs_devices = fs_devices;\n\t} else if (!device->name || strcmp(device->name->str, path)) {\n\t\t/*\n\t\t * When FS is already mounted.\n\t\t * 1. If you are here and if the device->name is NULL that\n\t\t *    means this device was missing at time of FS mount.\n\t\t * 2. If you are here and if the device->name is different\n\t\t *    from 'path' that means either\n\t\t *      a. The same device disappeared and reappeared with\n\t\t *         different name. or\n\t\t *      b. The missing-disk-which-was-replaced, has\n\t\t *         reappeared now.\n\t\t *\n\t\t * We must allow 1 and 2a above. But 2b would be a spurious\n\t\t * and unintentional.\n\t\t *\n\t\t * Further in case of 1 and 2a above, the disk at 'path'\n\t\t * would have missed some transaction when it was away and\n\t\t * in case of 2a the stale bdev has to be updated as well.\n\t\t * 2b must not be allowed at all time.\n\t\t */\n\n\t\t/*\n\t\t * For now, we do allow update to btrfs_fs_device through the\n\t\t * btrfs dev scan cli after FS has been mounted.  We're still\n\t\t * tracking a problem where systems fail mount by subvolume id\n\t\t * when we reject replacement on a mounted FS.\n\t\t */\n\t\tif (!fs_devices->opened && found_transid < device->generation) {\n\t\t\t/*\n\t\t\t * That is if the FS is _not_ mounted and if you\n\t\t\t * are here, that means there is more than one\n\t\t\t * disk with same uuid and devid.We keep the one\n\t\t\t * with larger generation number or the last-in if\n\t\t\t * generation are equal.\n\t\t\t */\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\tname = rcu_string_strdup(path, GFP_NOFS);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\t\trcu_string_free(device->name);\n\t\trcu_assign_pointer(device->name, name);\n\t\tif (device->missing) {\n\t\t\tfs_devices->missing_devices--;\n\t\t\tdevice->missing = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Unmount does not free the btrfs_device struct but would zero\n\t * generation along with most of the other members. So just update\n\t * it back. We need it to pick the disk with largest generation\n\t * (as above).\n\t */\n\tif (!fs_devices->opened)\n\t\tdevice->generation = found_transid;\n\n\t*fs_devices_ret = fs_devices;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_num_devices",
          "args": [
            "disk_super"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "disk_super"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_device_id",
          "args": [
            "&disk_super->dev_item"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_magic",
          "args": [
            "disk_super"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_bytenr",
          "args": [
            "disk_super"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "page"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cache_page_gfp",
          "args": [
            "bdev->bd_inode->i_mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bdev"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bdev"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_path",
          "args": [
            "path",
            "flags",
            "holder"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1387-1407",
          "snippet": "struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_sb_offset",
          "args": [
            "0"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "36-42",
          "snippet": "static inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_SUPER_MIRROR_SHIFT 12",
            "#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_SUPER_MIRROR_SHIFT 12\n#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)\n\nstatic inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,\n\t\t\t  struct btrfs_fs_devices **fs_devices_ret)\n{\n\tstruct btrfs_super_block *disk_super;\n\tstruct block_device *bdev;\n\tstruct page *page;\n\tvoid *p;\n\tint ret = -EINVAL;\n\tu64 devid;\n\tu64 transid;\n\tu64 total_devices;\n\tu64 bytenr;\n\tpgoff_t index;\n\n\t/*\n\t * we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tbytenr = btrfs_sb_offset(0);\n\tflags |= FMODE_EXCL;\n\tmutex_lock(&uuid_mutex);\n\n\tbdev = blkdev_get_by_path(path, flags, holder);\n\n\tif (IS_ERR(bdev)) {\n\t\tret = PTR_ERR(bdev);\n\t\tgoto error;\n\t}\n\n\t/* make sure our super fits in the device */\n\tif (bytenr + PAGE_CACHE_SIZE >= i_size_read(bdev->bd_inode))\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super fits in the page */\n\tif (sizeof(*disk_super) > PAGE_CACHE_SIZE)\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super doesn't straddle pages on disk */\n\tindex = bytenr >> PAGE_CACHE_SHIFT;\n\tif ((bytenr + sizeof(*disk_super) - 1) >> PAGE_CACHE_SHIFT != index)\n\t\tgoto error_bdev_put;\n\n\t/* pull in the page with our super */\n\tpage = read_cache_page_gfp(bdev->bd_inode->i_mapping,\n\t\t\t\t   index, GFP_NOFS);\n\n\tif (IS_ERR_OR_NULL(page))\n\t\tgoto error_bdev_put;\n\n\tp = kmap(page);\n\n\t/* align our pointer to the offset of the super block */\n\tdisk_super = p + (bytenr & ~PAGE_CACHE_MASK);\n\n\tif (btrfs_super_bytenr(disk_super) != bytenr ||\n\t    btrfs_super_magic(disk_super) != BTRFS_MAGIC)\n\t\tgoto error_unmap;\n\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\ttransid = btrfs_super_generation(disk_super);\n\ttotal_devices = btrfs_super_num_devices(disk_super);\n\n\tret = device_list_add(path, disk_super, devid, fs_devices_ret);\n\tif (ret > 0) {\n\t\tif (disk_super->label[0]) {\n\t\t\tif (disk_super->label[BTRFS_LABEL_SIZE - 1])\n\t\t\t\tdisk_super->label[BTRFS_LABEL_SIZE - 1] = '\\0';\n\t\t\tprintk(KERN_INFO \"BTRFS: device label %s \", disk_super->label);\n\t\t} else {\n\t\t\tprintk(KERN_INFO \"BTRFS: device fsid %pU \", disk_super->fsid);\n\t\t}\n\n\t\tprintk(KERN_CONT \"devid %llu transid %llu %s\\n\", devid, transid, path);\n\t\tret = 0;\n\t}\n\tif (!ret && fs_devices_ret)\n\t\t(*fs_devices_ret)->total_devices = total_devices;\n\nerror_unmap:\n\tkunmap(page);\n\tpage_cache_release(page);\n\nerror_bdev_put:\n\tblkdev_put(bdev, flags);\nerror:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_open_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "860-874",
    "snippet": "int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,\n\t\t       fmode_t flags, void *holder)\n{\n\tint ret;\n\n\tmutex_lock(&uuid_mutex);\n\tif (fs_devices->opened) {\n\t\tfs_devices->opened++;\n\t\tret = 0;\n\t} else {\n\t\tret = __btrfs_open_devices(fs_devices, flags, holder);\n\t}\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_open_devices",
          "args": [
            "fs_devices",
            "flags",
            "holder"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_open_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "774-858",
          "snippet": "static int __btrfs_open_devices(struct btrfs_fs_devices *fs_devices,\n\t\t\t\tfmode_t flags, void *holder)\n{\n\tstruct request_queue *q;\n\tstruct block_device *bdev;\n\tstruct list_head *head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *latest_dev = NULL;\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tint seeding = 1;\n\tint ret = 0;\n\n\tflags |= FMODE_EXCL;\n\n\tlist_for_each_entry(device, head, dev_list) {\n\t\tif (device->bdev)\n\t\t\tcontinue;\n\t\tif (!device->name)\n\t\t\tcontinue;\n\n\t\t/* Just open everything we can; ignore failures here */\n\t\tif (btrfs_get_bdev_and_sb(device->name->str, flags, holder, 1,\n\t\t\t\t\t    &bdev, &bh))\n\t\t\tcontinue;\n\n\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\t\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\t\tif (devid != device->devid)\n\t\t\tgoto error_brelse;\n\n\t\tif (memcmp(device->uuid, disk_super->dev_item.uuid,\n\t\t\t   BTRFS_UUID_SIZE))\n\t\t\tgoto error_brelse;\n\n\t\tdevice->generation = btrfs_super_generation(disk_super);\n\t\tif (!latest_dev ||\n\t\t    device->generation > latest_dev->generation)\n\t\t\tlatest_dev = device;\n\n\t\tif (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_SEEDING) {\n\t\t\tdevice->writeable = 0;\n\t\t} else {\n\t\t\tdevice->writeable = !bdev_read_only(bdev);\n\t\t\tseeding = 0;\n\t\t}\n\n\t\tq = bdev_get_queue(bdev);\n\t\tif (blk_queue_discard(q))\n\t\t\tdevice->can_discard = 1;\n\n\t\tdevice->bdev = bdev;\n\t\tdevice->in_fs_metadata = 0;\n\t\tdevice->mode = flags;\n\n\t\tif (!blk_queue_nonrot(bdev_get_queue(bdev)))\n\t\t\tfs_devices->rotating = 1;\n\n\t\tfs_devices->open_devices++;\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tfs_devices->rw_devices++;\n\t\t\tlist_add(&device->dev_alloc_list,\n\t\t\t\t &fs_devices->alloc_list);\n\t\t}\n\t\tbrelse(bh);\n\t\tcontinue;\n\nerror_brelse:\n\t\tbrelse(bh);\n\t\tblkdev_put(bdev, flags);\n\t\tcontinue;\n\t}\n\tif (fs_devices->open_devices == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfs_devices->seeding = seeding;\n\tfs_devices->opened = 1;\n\tfs_devices->latest_bdev = latest_dev->bdev;\n\tfs_devices->total_rw_bytes = 0;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_open_devices(struct btrfs_fs_devices *fs_devices,\n\t\t\t\tfmode_t flags, void *holder)\n{\n\tstruct request_queue *q;\n\tstruct block_device *bdev;\n\tstruct list_head *head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *latest_dev = NULL;\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tint seeding = 1;\n\tint ret = 0;\n\n\tflags |= FMODE_EXCL;\n\n\tlist_for_each_entry(device, head, dev_list) {\n\t\tif (device->bdev)\n\t\t\tcontinue;\n\t\tif (!device->name)\n\t\t\tcontinue;\n\n\t\t/* Just open everything we can; ignore failures here */\n\t\tif (btrfs_get_bdev_and_sb(device->name->str, flags, holder, 1,\n\t\t\t\t\t    &bdev, &bh))\n\t\t\tcontinue;\n\n\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\t\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\t\tif (devid != device->devid)\n\t\t\tgoto error_brelse;\n\n\t\tif (memcmp(device->uuid, disk_super->dev_item.uuid,\n\t\t\t   BTRFS_UUID_SIZE))\n\t\t\tgoto error_brelse;\n\n\t\tdevice->generation = btrfs_super_generation(disk_super);\n\t\tif (!latest_dev ||\n\t\t    device->generation > latest_dev->generation)\n\t\t\tlatest_dev = device;\n\n\t\tif (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_SEEDING) {\n\t\t\tdevice->writeable = 0;\n\t\t} else {\n\t\t\tdevice->writeable = !bdev_read_only(bdev);\n\t\t\tseeding = 0;\n\t\t}\n\n\t\tq = bdev_get_queue(bdev);\n\t\tif (blk_queue_discard(q))\n\t\t\tdevice->can_discard = 1;\n\n\t\tdevice->bdev = bdev;\n\t\tdevice->in_fs_metadata = 0;\n\t\tdevice->mode = flags;\n\n\t\tif (!blk_queue_nonrot(bdev_get_queue(bdev)))\n\t\t\tfs_devices->rotating = 1;\n\n\t\tfs_devices->open_devices++;\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tfs_devices->rw_devices++;\n\t\t\tlist_add(&device->dev_alloc_list,\n\t\t\t\t &fs_devices->alloc_list);\n\t\t}\n\t\tbrelse(bh);\n\t\tcontinue;\n\nerror_brelse:\n\t\tbrelse(bh);\n\t\tblkdev_put(bdev, flags);\n\t\tcontinue;\n\t}\n\tif (fs_devices->open_devices == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfs_devices->seeding = seeding;\n\tfs_devices->opened = 1;\n\tfs_devices->latest_bdev = latest_dev->bdev;\n\tfs_devices->total_rw_bytes = 0;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_open_devices(struct btrfs_fs_devices *fs_devices,\n\t\t       fmode_t flags, void *holder)\n{\n\tint ret;\n\n\tmutex_lock(&uuid_mutex);\n\tif (fs_devices->opened) {\n\t\tfs_devices->opened++;\n\t\tret = 0;\n\t} else {\n\t\tret = __btrfs_open_devices(fs_devices, flags, holder);\n\t}\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__btrfs_open_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "774-858",
    "snippet": "static int __btrfs_open_devices(struct btrfs_fs_devices *fs_devices,\n\t\t\t\tfmode_t flags, void *holder)\n{\n\tstruct request_queue *q;\n\tstruct block_device *bdev;\n\tstruct list_head *head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *latest_dev = NULL;\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tint seeding = 1;\n\tint ret = 0;\n\n\tflags |= FMODE_EXCL;\n\n\tlist_for_each_entry(device, head, dev_list) {\n\t\tif (device->bdev)\n\t\t\tcontinue;\n\t\tif (!device->name)\n\t\t\tcontinue;\n\n\t\t/* Just open everything we can; ignore failures here */\n\t\tif (btrfs_get_bdev_and_sb(device->name->str, flags, holder, 1,\n\t\t\t\t\t    &bdev, &bh))\n\t\t\tcontinue;\n\n\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\t\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\t\tif (devid != device->devid)\n\t\t\tgoto error_brelse;\n\n\t\tif (memcmp(device->uuid, disk_super->dev_item.uuid,\n\t\t\t   BTRFS_UUID_SIZE))\n\t\t\tgoto error_brelse;\n\n\t\tdevice->generation = btrfs_super_generation(disk_super);\n\t\tif (!latest_dev ||\n\t\t    device->generation > latest_dev->generation)\n\t\t\tlatest_dev = device;\n\n\t\tif (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_SEEDING) {\n\t\t\tdevice->writeable = 0;\n\t\t} else {\n\t\t\tdevice->writeable = !bdev_read_only(bdev);\n\t\t\tseeding = 0;\n\t\t}\n\n\t\tq = bdev_get_queue(bdev);\n\t\tif (blk_queue_discard(q))\n\t\t\tdevice->can_discard = 1;\n\n\t\tdevice->bdev = bdev;\n\t\tdevice->in_fs_metadata = 0;\n\t\tdevice->mode = flags;\n\n\t\tif (!blk_queue_nonrot(bdev_get_queue(bdev)))\n\t\t\tfs_devices->rotating = 1;\n\n\t\tfs_devices->open_devices++;\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tfs_devices->rw_devices++;\n\t\t\tlist_add(&device->dev_alloc_list,\n\t\t\t\t &fs_devices->alloc_list);\n\t\t}\n\t\tbrelse(bh);\n\t\tcontinue;\n\nerror_brelse:\n\t\tbrelse(bh);\n\t\tblkdev_put(bdev, flags);\n\t\tcontinue;\n\t}\n\tif (fs_devices->open_devices == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfs_devices->seeding = seeding;\n\tfs_devices->opened = 1;\n\tfs_devices->latest_bdev = latest_dev->bdev;\n\tfs_devices->total_rw_bytes = 0;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "flags"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&device->dev_alloc_list",
            "&fs_devices->alloc_list"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_queue_nonrot",
          "args": [
            "bdev_get_queue(bdev)"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "bdev"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "bdev"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "bdev"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_flags",
          "args": [
            "disk_super"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "disk_super"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "device->uuid",
            "disk_super->dev_item.uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_device_id",
          "args": [
            "&disk_super->dev_item"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_bdev_and_sb",
          "args": [
            "device->name->str",
            "flags",
            "holder",
            "1",
            "&bdev",
            "&bh"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_bdev_and_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "186-222",
          "snippet": "static int\nbtrfs_get_bdev_and_sb(const char *device_path, fmode_t flags, void *holder,\n\t\t      int flush, struct block_device **bdev,\n\t\t      struct buffer_head **bh)\n{\n\tint ret;\n\n\t*bdev = blkdev_get_by_path(device_path, flags, holder);\n\n\tif (IS_ERR(*bdev)) {\n\t\tret = PTR_ERR(*bdev);\n\t\tprintk(KERN_INFO \"BTRFS: open %s failed\\n\", device_path);\n\t\tgoto error;\n\t}\n\n\tif (flush)\n\t\tfilemap_write_and_wait((*bdev)->bd_inode->i_mapping);\n\tret = set_blocksize(*bdev, 4096);\n\tif (ret) {\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\tinvalidate_bdev(*bdev);\n\t*bh = btrfs_read_dev_super(*bdev);\n\tif (!*bh) {\n\t\tret = -EINVAL;\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\t*bdev = NULL;\n\t*bh = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int\nbtrfs_get_bdev_and_sb(const char *device_path, fmode_t flags, void *holder,\n\t\t      int flush, struct block_device **bdev,\n\t\t      struct buffer_head **bh)\n{\n\tint ret;\n\n\t*bdev = blkdev_get_by_path(device_path, flags, holder);\n\n\tif (IS_ERR(*bdev)) {\n\t\tret = PTR_ERR(*bdev);\n\t\tprintk(KERN_INFO \"BTRFS: open %s failed\\n\", device_path);\n\t\tgoto error;\n\t}\n\n\tif (flush)\n\t\tfilemap_write_and_wait((*bdev)->bd_inode->i_mapping);\n\tret = set_blocksize(*bdev, 4096);\n\tif (ret) {\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\tinvalidate_bdev(*bdev);\n\t*bh = btrfs_read_dev_super(*bdev);\n\tif (!*bh) {\n\t\tret = -EINVAL;\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\t*bdev = NULL;\n\t*bh = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "head",
            "dev_list"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_open_devices(struct btrfs_fs_devices *fs_devices,\n\t\t\t\tfmode_t flags, void *holder)\n{\n\tstruct request_queue *q;\n\tstruct block_device *bdev;\n\tstruct list_head *head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *latest_dev = NULL;\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tint seeding = 1;\n\tint ret = 0;\n\n\tflags |= FMODE_EXCL;\n\n\tlist_for_each_entry(device, head, dev_list) {\n\t\tif (device->bdev)\n\t\t\tcontinue;\n\t\tif (!device->name)\n\t\t\tcontinue;\n\n\t\t/* Just open everything we can; ignore failures here */\n\t\tif (btrfs_get_bdev_and_sb(device->name->str, flags, holder, 1,\n\t\t\t\t\t    &bdev, &bh))\n\t\t\tcontinue;\n\n\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\t\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\t\tif (devid != device->devid)\n\t\t\tgoto error_brelse;\n\n\t\tif (memcmp(device->uuid, disk_super->dev_item.uuid,\n\t\t\t   BTRFS_UUID_SIZE))\n\t\t\tgoto error_brelse;\n\n\t\tdevice->generation = btrfs_super_generation(disk_super);\n\t\tif (!latest_dev ||\n\t\t    device->generation > latest_dev->generation)\n\t\t\tlatest_dev = device;\n\n\t\tif (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_SEEDING) {\n\t\t\tdevice->writeable = 0;\n\t\t} else {\n\t\t\tdevice->writeable = !bdev_read_only(bdev);\n\t\t\tseeding = 0;\n\t\t}\n\n\t\tq = bdev_get_queue(bdev);\n\t\tif (blk_queue_discard(q))\n\t\t\tdevice->can_discard = 1;\n\n\t\tdevice->bdev = bdev;\n\t\tdevice->in_fs_metadata = 0;\n\t\tdevice->mode = flags;\n\n\t\tif (!blk_queue_nonrot(bdev_get_queue(bdev)))\n\t\t\tfs_devices->rotating = 1;\n\n\t\tfs_devices->open_devices++;\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tfs_devices->rw_devices++;\n\t\t\tlist_add(&device->dev_alloc_list,\n\t\t\t\t &fs_devices->alloc_list);\n\t\t}\n\t\tbrelse(bh);\n\t\tcontinue;\n\nerror_brelse:\n\t\tbrelse(bh);\n\t\tblkdev_put(bdev, flags);\n\t\tcontinue;\n\t}\n\tif (fs_devices->open_devices == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfs_devices->seeding = seeding;\n\tfs_devices->opened = 1;\n\tfs_devices->latest_bdev = latest_dev->bdev;\n\tfs_devices->total_rw_bytes = 0;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_close_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "746-772",
    "snippet": "int btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_fs_devices *seed_devices = NULL;\n\tint ret;\n\n\tmutex_lock(&uuid_mutex);\n\tret = __btrfs_close_devices(fs_devices);\n\tif (!fs_devices->opened) {\n\t\tseed_devices = fs_devices->seed;\n\t\tfs_devices->seed = NULL;\n\t}\n\tmutex_unlock(&uuid_mutex);\n\n\twhile (seed_devices) {\n\t\tfs_devices = seed_devices;\n\t\tseed_devices = fs_devices->seed;\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n\t/*\n\t * Wait for rcu kworkers under __btrfs_close_devices\n\t * to finish all blkdev_puts so device is really\n\t * free when umount is done.\n\t */\n\trcu_barrier();\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_fs_devices",
          "args": [
            "fs_devices"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "free_fs_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "99-111",
          "snippet": "static void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_close_devices",
          "args": [
            "fs_devices"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_close_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "696-744",
          "snippet": "static int __btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\n\tif (--fs_devices->opened > 0)\n\t\treturn 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tstruct btrfs_device *new_device;\n\t\tstruct rcu_string *name;\n\n\t\tif (device->bdev)\n\t\t\tfs_devices->open_devices--;\n\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tfs_devices->rw_devices--;\n\t\t}\n\n\t\tif (device->missing)\n\t\t\tfs_devices->missing_devices--;\n\n\t\tnew_device = btrfs_alloc_device(NULL, &device->devid,\n\t\t\t\t\t\tdevice->uuid);\n\t\tBUG_ON(IS_ERR(new_device)); /* -ENOMEM */\n\n\t\t/* Safe because we are under uuid_mutex */\n\t\tif (device->name) {\n\t\t\tname = rcu_string_strdup(device->name->str, GFP_NOFS);\n\t\t\tBUG_ON(!name); /* -ENOMEM */\n\t\t\trcu_assign_pointer(new_device->name, name);\n\t\t}\n\n\t\tlist_replace_rcu(&device->dev_list, &new_device->dev_list);\n\t\tnew_device->fs_devices = device->fs_devices;\n\n\t\tcall_rcu(&device->rcu, free_device);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tWARN_ON(fs_devices->open_devices);\n\tWARN_ON(fs_devices->rw_devices);\n\tfs_devices->opened = 0;\n\tfs_devices->seeding = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\n\tif (--fs_devices->opened > 0)\n\t\treturn 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tstruct btrfs_device *new_device;\n\t\tstruct rcu_string *name;\n\n\t\tif (device->bdev)\n\t\t\tfs_devices->open_devices--;\n\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tfs_devices->rw_devices--;\n\t\t}\n\n\t\tif (device->missing)\n\t\t\tfs_devices->missing_devices--;\n\n\t\tnew_device = btrfs_alloc_device(NULL, &device->devid,\n\t\t\t\t\t\tdevice->uuid);\n\t\tBUG_ON(IS_ERR(new_device)); /* -ENOMEM */\n\n\t\t/* Safe because we are under uuid_mutex */\n\t\tif (device->name) {\n\t\t\tname = rcu_string_strdup(device->name->str, GFP_NOFS);\n\t\t\tBUG_ON(!name); /* -ENOMEM */\n\t\t\trcu_assign_pointer(new_device->name, name);\n\t\t}\n\n\t\tlist_replace_rcu(&device->dev_list, &new_device->dev_list);\n\t\tnew_device->fs_devices = device->fs_devices;\n\n\t\tcall_rcu(&device->rcu, free_device);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tWARN_ON(fs_devices->open_devices);\n\tWARN_ON(fs_devices->rw_devices);\n\tfs_devices->opened = 0;\n\tfs_devices->seeding = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_fs_devices *seed_devices = NULL;\n\tint ret;\n\n\tmutex_lock(&uuid_mutex);\n\tret = __btrfs_close_devices(fs_devices);\n\tif (!fs_devices->opened) {\n\t\tseed_devices = fs_devices->seed;\n\t\tfs_devices->seed = NULL;\n\t}\n\tmutex_unlock(&uuid_mutex);\n\n\twhile (seed_devices) {\n\t\tfs_devices = seed_devices;\n\t\tseed_devices = fs_devices->seed;\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n\t/*\n\t * Wait for rcu kworkers under __btrfs_close_devices\n\t * to finish all blkdev_puts so device is really\n\t * free when umount is done.\n\t */\n\trcu_barrier();\n\treturn ret;\n}"
  },
  {
    "function_name": "__btrfs_close_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "696-744",
    "snippet": "static int __btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\n\tif (--fs_devices->opened > 0)\n\t\treturn 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tstruct btrfs_device *new_device;\n\t\tstruct rcu_string *name;\n\n\t\tif (device->bdev)\n\t\t\tfs_devices->open_devices--;\n\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tfs_devices->rw_devices--;\n\t\t}\n\n\t\tif (device->missing)\n\t\t\tfs_devices->missing_devices--;\n\n\t\tnew_device = btrfs_alloc_device(NULL, &device->devid,\n\t\t\t\t\t\tdevice->uuid);\n\t\tBUG_ON(IS_ERR(new_device)); /* -ENOMEM */\n\n\t\t/* Safe because we are under uuid_mutex */\n\t\tif (device->name) {\n\t\t\tname = rcu_string_strdup(device->name->str, GFP_NOFS);\n\t\t\tBUG_ON(!name); /* -ENOMEM */\n\t\t\trcu_assign_pointer(new_device->name, name);\n\t\t}\n\n\t\tlist_replace_rcu(&device->dev_list, &new_device->dev_list);\n\t\tnew_device->fs_devices = device->fs_devices;\n\n\t\tcall_rcu(&device->rcu, free_device);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tWARN_ON(fs_devices->open_devices);\n\tWARN_ON(fs_devices->rw_devices);\n\tfs_devices->opened = 0;\n\tfs_devices->seeding = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "fs_devices->rw_devices"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "fs_devices->open_devices"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&device->rcu",
            "free_device"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_rcu",
          "args": [
            "&device->dev_list",
            "&new_device->dev_list"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "new_device->name",
            "name"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!name"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_string_strdup",
          "args": [
            "device->name->str",
            "GFP_NOFS"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_string_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/rcu-string.h",
          "lines": "24-33",
          "snippet": "static inline struct rcu_string *rcu_string_strdup(const char *src, gfp_t mask)\n{\n\tsize_t len = strlen(src) + 1;\n\tstruct rcu_string *ret = kzalloc(sizeof(struct rcu_string) +\n\t\t\t\t\t (len * sizeof(char)), mask);\n\tif (!ret)\n\t\treturn ret;\n\tstrncpy(ret->str, src, len);\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct rcu_string *rcu_string_strdup(const char *src, gfp_t mask)\n{\n\tsize_t len = strlen(src) + 1;\n\tstruct rcu_string *ret = kzalloc(sizeof(struct rcu_string) +\n\t\t\t\t\t (len * sizeof(char)), mask);\n\tif (!ret)\n\t\treturn ret;\n\tstrncpy(ret->str, src, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(new_device)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_device"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_device",
          "args": [
            "NULL",
            "&device->devid",
            "device->uuid"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5971-6007",
          "snippet": "struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&device->dev_alloc_list"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "&fs_devices->devices",
            "dev_list"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int __btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\n\tif (--fs_devices->opened > 0)\n\t\treturn 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tstruct btrfs_device *new_device;\n\t\tstruct rcu_string *name;\n\n\t\tif (device->bdev)\n\t\t\tfs_devices->open_devices--;\n\n\t\tif (device->writeable &&\n\t\t    device->devid != BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tfs_devices->rw_devices--;\n\t\t}\n\n\t\tif (device->missing)\n\t\t\tfs_devices->missing_devices--;\n\n\t\tnew_device = btrfs_alloc_device(NULL, &device->devid,\n\t\t\t\t\t\tdevice->uuid);\n\t\tBUG_ON(IS_ERR(new_device)); /* -ENOMEM */\n\n\t\t/* Safe because we are under uuid_mutex */\n\t\tif (device->name) {\n\t\t\tname = rcu_string_strdup(device->name->str, GFP_NOFS);\n\t\t\tBUG_ON(!name); /* -ENOMEM */\n\t\t\trcu_assign_pointer(new_device->name, name);\n\t\t}\n\n\t\tlist_replace_rcu(&device->dev_list, &new_device->dev_list);\n\t\tnew_device->fs_devices = device->fs_devices;\n\n\t\tcall_rcu(&device->rcu, free_device);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tWARN_ON(fs_devices->open_devices);\n\tWARN_ON(fs_devices->rw_devices);\n\tfs_devices->opened = 0;\n\tfs_devices->seeding = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "686-694",
    "snippet": "static void free_device(struct rcu_head *head)\n{\n\tstruct btrfs_device *device;\n\n\tdevice = container_of(head, struct btrfs_device, rcu);\n\n\tINIT_WORK(&device->rcu_work, __free_device);\n\tschedule_work(&device->rcu_work);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&device->rcu_work"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&device->rcu_work",
            "__free_device"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structbtrfs_device",
            "rcu"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void free_device(struct rcu_head *head)\n{\n\tstruct btrfs_device *device;\n\n\tdevice = container_of(head, struct btrfs_device, rcu);\n\n\tINIT_WORK(&device->rcu_work, __free_device);\n\tschedule_work(&device->rcu_work);\n}"
  },
  {
    "function_name": "__free_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "673-684",
    "snippet": "static void __free_device(struct work_struct *work)\n{\n\tstruct btrfs_device *device;\n\n\tdevice = container_of(work, struct btrfs_device, rcu_work);\n\n\tif (device->bdev)\n\t\tblkdev_put(device->bdev, device->mode);\n\n\trcu_string_free(device->name);\n\tkfree(device);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "device"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_string_free",
          "args": [
            "device->name"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_string_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/rcu-string.h",
          "lines": "35-39",
          "snippet": "static inline void rcu_string_free(struct rcu_string *str)\n{\n\tif (str)\n\t\tkfree_rcu(str, rcu);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void rcu_string_free(struct rcu_string *str)\n{\n\tif (str)\n\t\tkfree_rcu(str, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "device->bdev",
            "device->mode"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbtrfs_device",
            "rcu_work"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void __free_device(struct work_struct *work)\n{\n\tstruct btrfs_device *device;\n\n\tdevice = container_of(work, struct btrfs_device, rcu_work);\n\n\tif (device->bdev)\n\t\tblkdev_put(device->bdev, device->mode);\n\n\trcu_string_free(device->name);\n\tkfree(device);\n}"
  },
  {
    "function_name": "btrfs_close_extra_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "612-671",
    "snippet": "void btrfs_close_extra_devices(struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_fs_devices *fs_devices, int step)\n{\n\tstruct btrfs_device *device, *next;\n\tstruct btrfs_device *latest_dev = NULL;\n\n\tmutex_lock(&uuid_mutex);\nagain:\n\t/* This is the initialized path, it is safe to release the devices. */\n\tlist_for_each_entry_safe(device, next, &fs_devices->devices, dev_list) {\n\t\tif (device->in_fs_metadata) {\n\t\t\tif (!device->is_tgtdev_for_dev_replace &&\n\t\t\t    (!latest_dev ||\n\t\t\t     device->generation > latest_dev->generation)) {\n\t\t\t\tlatest_dev = device;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (device->devid == BTRFS_DEV_REPLACE_DEVID) {\n\t\t\t/*\n\t\t\t * In the first step, keep the device which has\n\t\t\t * the correct fsid and the devid that is used\n\t\t\t * for the dev_replace procedure.\n\t\t\t * In the second step, the dev_replace state is\n\t\t\t * read from the device tree and it is known\n\t\t\t * whether the procedure is really active or\n\t\t\t * not, which means whether this device is\n\t\t\t * used or whether it should be removed.\n\t\t\t */\n\t\t\tif (step == 0 || device->is_tgtdev_for_dev_replace) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (device->bdev) {\n\t\t\tblkdev_put(device->bdev, device->mode);\n\t\t\tdevice->bdev = NULL;\n\t\t\tfs_devices->open_devices--;\n\t\t}\n\t\tif (device->writeable) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tdevice->writeable = 0;\n\t\t\tif (!device->is_tgtdev_for_dev_replace)\n\t\t\t\tfs_devices->rw_devices--;\n\t\t}\n\t\tlist_del_init(&device->dev_list);\n\t\tfs_devices->num_devices--;\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\n\tif (fs_devices->seed) {\n\t\tfs_devices = fs_devices->seed;\n\t\tgoto again;\n\t}\n\n\tfs_devices->latest_bdev = latest_dev->bdev;\n\n\tmutex_unlock(&uuid_mutex);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "device"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_string_free",
          "args": [
            "device->name"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_string_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/rcu-string.h",
          "lines": "35-39",
          "snippet": "static inline void rcu_string_free(struct rcu_string *str)\n{\n\tif (str)\n\t\tkfree_rcu(str, rcu);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void rcu_string_free(struct rcu_string *str)\n{\n\tif (str)\n\t\tkfree_rcu(str, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&device->dev_list"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&device->dev_alloc_list"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "device->bdev",
            "device->mode"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "device",
            "next",
            "&fs_devices->devices",
            "dev_list"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_close_extra_devices(struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_fs_devices *fs_devices, int step)\n{\n\tstruct btrfs_device *device, *next;\n\tstruct btrfs_device *latest_dev = NULL;\n\n\tmutex_lock(&uuid_mutex);\nagain:\n\t/* This is the initialized path, it is safe to release the devices. */\n\tlist_for_each_entry_safe(device, next, &fs_devices->devices, dev_list) {\n\t\tif (device->in_fs_metadata) {\n\t\t\tif (!device->is_tgtdev_for_dev_replace &&\n\t\t\t    (!latest_dev ||\n\t\t\t     device->generation > latest_dev->generation)) {\n\t\t\t\tlatest_dev = device;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (device->devid == BTRFS_DEV_REPLACE_DEVID) {\n\t\t\t/*\n\t\t\t * In the first step, keep the device which has\n\t\t\t * the correct fsid and the devid that is used\n\t\t\t * for the dev_replace procedure.\n\t\t\t * In the second step, the dev_replace state is\n\t\t\t * read from the device tree and it is known\n\t\t\t * whether the procedure is really active or\n\t\t\t * not, which means whether this device is\n\t\t\t * used or whether it should be removed.\n\t\t\t */\n\t\t\tif (step == 0 || device->is_tgtdev_for_dev_replace) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (device->bdev) {\n\t\t\tblkdev_put(device->bdev, device->mode);\n\t\t\tdevice->bdev = NULL;\n\t\t\tfs_devices->open_devices--;\n\t\t}\n\t\tif (device->writeable) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tdevice->writeable = 0;\n\t\t\tif (!device->is_tgtdev_for_dev_replace)\n\t\t\t\tfs_devices->rw_devices--;\n\t\t}\n\t\tlist_del_init(&device->dev_list);\n\t\tfs_devices->num_devices--;\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\n\tif (fs_devices->seed) {\n\t\tfs_devices = fs_devices->seed;\n\t\tgoto again;\n\t}\n\n\tfs_devices->latest_bdev = latest_dev->bdev;\n\n\tmutex_unlock(&uuid_mutex);\n}"
  },
  {
    "function_name": "clone_fs_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "565-610",
    "snippet": "static struct btrfs_fs_devices *clone_fs_devices(struct btrfs_fs_devices *orig)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *orig_dev;\n\n\tfs_devices = alloc_fs_devices(orig->fsid);\n\tif (IS_ERR(fs_devices))\n\t\treturn fs_devices;\n\n\tmutex_lock(&orig->device_list_mutex);\n\tfs_devices->total_devices = orig->total_devices;\n\n\t/* We have held the volume lock, it is safe to get the devices. */\n\tlist_for_each_entry(orig_dev, &orig->devices, dev_list) {\n\t\tstruct rcu_string *name;\n\n\t\tdevice = btrfs_alloc_device(NULL, &orig_dev->devid,\n\t\t\t\t\t    orig_dev->uuid);\n\t\tif (IS_ERR(device))\n\t\t\tgoto error;\n\n\t\t/*\n\t\t * This is ok to do without rcu read locked because we hold the\n\t\t * uuid mutex so nothing we touch in here is going to disappear.\n\t\t */\n\t\tif (orig_dev->name) {\n\t\t\tname = rcu_string_strdup(orig_dev->name->str, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\tkfree(device);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\trcu_assign_pointer(device->name, name);\n\t\t}\n\n\t\tlist_add(&device->dev_list, &fs_devices->devices);\n\t\tdevice->fs_devices = fs_devices;\n\t\tfs_devices->num_devices++;\n\t}\n\tmutex_unlock(&orig->device_list_mutex);\n\treturn fs_devices;\nerror:\n\tmutex_unlock(&orig->device_list_mutex);\n\tfree_fs_devices(fs_devices);\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_fs_devices",
          "args": [
            "fs_devices"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "free_fs_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "99-111",
          "snippet": "static void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orig->device_list_mutex"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orig->device_list_mutex"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&device->dev_list",
            "&fs_devices->devices"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "device->name",
            "name"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "device"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_string_strdup",
          "args": [
            "orig_dev->name->str",
            "GFP_NOFS"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_string_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/rcu-string.h",
          "lines": "24-33",
          "snippet": "static inline struct rcu_string *rcu_string_strdup(const char *src, gfp_t mask)\n{\n\tsize_t len = strlen(src) + 1;\n\tstruct rcu_string *ret = kzalloc(sizeof(struct rcu_string) +\n\t\t\t\t\t (len * sizeof(char)), mask);\n\tif (!ret)\n\t\treturn ret;\n\tstrncpy(ret->str, src, len);\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct rcu_string *rcu_string_strdup(const char *src, gfp_t mask)\n{\n\tsize_t len = strlen(src) + 1;\n\tstruct rcu_string *ret = kzalloc(sizeof(struct rcu_string) +\n\t\t\t\t\t (len * sizeof(char)), mask);\n\tif (!ret)\n\t\treturn ret;\n\tstrncpy(ret->str, src, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "device"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_device",
          "args": [
            "NULL",
            "&orig_dev->devid",
            "orig_dev->uuid"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5971-6007",
          "snippet": "struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "orig_dev",
            "&orig->devices",
            "dev_list"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&orig->device_list_mutex"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_devices"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_fs_devices",
          "args": [
            "orig->fsid"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_fs_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "83-97",
          "snippet": "static struct btrfs_fs_devices *alloc_fs_devices(const u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = __alloc_fs_devices();\n\tif (IS_ERR(fs_devs))\n\t\treturn fs_devs;\n\n\tif (fsid)\n\t\tmemcpy(fs_devs->fsid, fsid, BTRFS_FSID_SIZE);\n\telse\n\t\tgenerate_random_uuid(fs_devs->fsid);\n\n\treturn fs_devs;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_fs_devices *alloc_fs_devices(const u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = __alloc_fs_devices();\n\tif (IS_ERR(fs_devs))\n\t\treturn fs_devs;\n\n\tif (fsid)\n\t\tmemcpy(fs_devs->fsid, fsid, BTRFS_FSID_SIZE);\n\telse\n\t\tgenerate_random_uuid(fs_devs->fsid);\n\n\treturn fs_devs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_fs_devices *clone_fs_devices(struct btrfs_fs_devices *orig)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *orig_dev;\n\n\tfs_devices = alloc_fs_devices(orig->fsid);\n\tif (IS_ERR(fs_devices))\n\t\treturn fs_devices;\n\n\tmutex_lock(&orig->device_list_mutex);\n\tfs_devices->total_devices = orig->total_devices;\n\n\t/* We have held the volume lock, it is safe to get the devices. */\n\tlist_for_each_entry(orig_dev, &orig->devices, dev_list) {\n\t\tstruct rcu_string *name;\n\n\t\tdevice = btrfs_alloc_device(NULL, &orig_dev->devid,\n\t\t\t\t\t    orig_dev->uuid);\n\t\tif (IS_ERR(device))\n\t\t\tgoto error;\n\n\t\t/*\n\t\t * This is ok to do without rcu read locked because we hold the\n\t\t * uuid mutex so nothing we touch in here is going to disappear.\n\t\t */\n\t\tif (orig_dev->name) {\n\t\t\tname = rcu_string_strdup(orig_dev->name->str, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\tkfree(device);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\trcu_assign_pointer(device->name, name);\n\t\t}\n\n\t\tlist_add(&device->dev_list, &fs_devices->devices);\n\t\tdevice->fs_devices = fs_devices;\n\t\tfs_devices->num_devices++;\n\t}\n\tmutex_unlock(&orig->device_list_mutex);\n\treturn fs_devices;\nerror:\n\tmutex_unlock(&orig->device_list_mutex);\n\tfree_fs_devices(fs_devices);\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "device_list_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "453-563",
    "snippet": "static noinline int device_list_add(const char *path,\n\t\t\t   struct btrfs_super_block *disk_super,\n\t\t\t   u64 devid, struct btrfs_fs_devices **fs_devices_ret)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices;\n\tstruct rcu_string *name;\n\tint ret = 0;\n\tu64 found_transid = btrfs_super_generation(disk_super);\n\n\tfs_devices = find_fsid(disk_super->fsid);\n\tif (!fs_devices) {\n\t\tfs_devices = alloc_fs_devices(disk_super->fsid);\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn PTR_ERR(fs_devices);\n\n\t\tlist_add(&fs_devices->list, &fs_uuids);\n\n\t\tdevice = NULL;\n\t} else {\n\t\tdevice = __find_device(&fs_devices->devices, devid,\n\t\t\t\t       disk_super->dev_item.uuid);\n\t}\n\n\tif (!device) {\n\t\tif (fs_devices->opened)\n\t\t\treturn -EBUSY;\n\n\t\tdevice = btrfs_alloc_device(NULL, &devid,\n\t\t\t\t\t    disk_super->dev_item.uuid);\n\t\tif (IS_ERR(device)) {\n\t\t\t/* we can safely leave the fs_devices entry around */\n\t\t\treturn PTR_ERR(device);\n\t\t}\n\n\t\tname = rcu_string_strdup(path, GFP_NOFS);\n\t\tif (!name) {\n\t\t\tkfree(device);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trcu_assign_pointer(device->name, name);\n\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\t\tlist_add_rcu(&device->dev_list, &fs_devices->devices);\n\t\tfs_devices->num_devices++;\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t\tret = 1;\n\t\tdevice->fs_devices = fs_devices;\n\t} else if (!device->name || strcmp(device->name->str, path)) {\n\t\t/*\n\t\t * When FS is already mounted.\n\t\t * 1. If you are here and if the device->name is NULL that\n\t\t *    means this device was missing at time of FS mount.\n\t\t * 2. If you are here and if the device->name is different\n\t\t *    from 'path' that means either\n\t\t *      a. The same device disappeared and reappeared with\n\t\t *         different name. or\n\t\t *      b. The missing-disk-which-was-replaced, has\n\t\t *         reappeared now.\n\t\t *\n\t\t * We must allow 1 and 2a above. But 2b would be a spurious\n\t\t * and unintentional.\n\t\t *\n\t\t * Further in case of 1 and 2a above, the disk at 'path'\n\t\t * would have missed some transaction when it was away and\n\t\t * in case of 2a the stale bdev has to be updated as well.\n\t\t * 2b must not be allowed at all time.\n\t\t */\n\n\t\t/*\n\t\t * For now, we do allow update to btrfs_fs_device through the\n\t\t * btrfs dev scan cli after FS has been mounted.  We're still\n\t\t * tracking a problem where systems fail mount by subvolume id\n\t\t * when we reject replacement on a mounted FS.\n\t\t */\n\t\tif (!fs_devices->opened && found_transid < device->generation) {\n\t\t\t/*\n\t\t\t * That is if the FS is _not_ mounted and if you\n\t\t\t * are here, that means there is more than one\n\t\t\t * disk with same uuid and devid.We keep the one\n\t\t\t * with larger generation number or the last-in if\n\t\t\t * generation are equal.\n\t\t\t */\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\tname = rcu_string_strdup(path, GFP_NOFS);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\t\trcu_string_free(device->name);\n\t\trcu_assign_pointer(device->name, name);\n\t\tif (device->missing) {\n\t\t\tfs_devices->missing_devices--;\n\t\t\tdevice->missing = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Unmount does not free the btrfs_device struct but would zero\n\t * generation along with most of the other members. So just update\n\t * it back. We need it to pick the disk with largest generation\n\t * (as above).\n\t */\n\tif (!fs_devices->opened)\n\t\tdevice->generation = found_transid;\n\n\t*fs_devices_ret = fs_devices;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static LIST_HEAD(fs_uuids);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "device->name",
            "name"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_string_free",
          "args": [
            "device->name"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_string_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/rcu-string.h",
          "lines": "35-39",
          "snippet": "static inline void rcu_string_free(struct rcu_string *str)\n{\n\tif (str)\n\t\tkfree_rcu(str, rcu);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void rcu_string_free(struct rcu_string *str)\n{\n\tif (str)\n\t\tkfree_rcu(str, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_string_strdup",
          "args": [
            "path",
            "GFP_NOFS"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_string_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/rcu-string.h",
          "lines": "24-33",
          "snippet": "static inline struct rcu_string *rcu_string_strdup(const char *src, gfp_t mask)\n{\n\tsize_t len = strlen(src) + 1;\n\tstruct rcu_string *ret = kzalloc(sizeof(struct rcu_string) +\n\t\t\t\t\t (len * sizeof(char)), mask);\n\tif (!ret)\n\t\treturn ret;\n\tstrncpy(ret->str, src, len);\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct rcu_string *rcu_string_strdup(const char *src, gfp_t mask)\n{\n\tsize_t len = strlen(src) + 1;\n\tstruct rcu_string *ret = kzalloc(sizeof(struct rcu_string) +\n\t\t\t\t\t (len * sizeof(char)), mask);\n\tif (!ret)\n\t\treturn ret;\n\tstrncpy(ret->str, src, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "device->name->str",
            "path"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&device->dev_list",
            "&fs_devices->devices"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "device->name",
            "name"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "device"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "device"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "device"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_device",
          "args": [
            "NULL",
            "&devid",
            "disk_super->dev_item.uuid"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5971-6007",
          "snippet": "struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid,\n\t\t\t\t\tconst u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tu64 tmp;\n\n\tif (WARN_ON(!devid && !fs_info))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = __alloc_device();\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tif (devid)\n\t\ttmp = *devid;\n\telse {\n\t\tint ret;\n\n\t\tret = find_next_devid(fs_info, &tmp);\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tdev->devid = tmp;\n\n\tif (uuid)\n\t\tmemcpy(dev->uuid, uuid, BTRFS_UUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(dev->uuid);\n\n\tbtrfs_init_work(&dev->work, btrfs_submit_helper,\n\t\t\tpending_bios_fn, NULL, NULL);\n\n\treturn dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_device",
          "args": [
            "&fs_devices->devices",
            "devid",
            "disk_super->dev_item.uuid"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "__find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "161-173",
          "snippet": "btrfs_device *__find_device(struct list_head *head,\n\t\t\t\t\t\t   u64 devid, u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\n\tlist_for_each_entry(dev, head, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nbtrfs_device *__find_device(struct list_head *head,\n\t\t\t\t\t\t   u64 devid, u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\n\tlist_for_each_entry(dev, head, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&fs_devices->list",
            "&fs_uuids"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fs_devices"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_devices"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_fs_devices",
          "args": [
            "disk_super->fsid"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_fs_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "83-97",
          "snippet": "static struct btrfs_fs_devices *alloc_fs_devices(const u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = __alloc_fs_devices();\n\tif (IS_ERR(fs_devs))\n\t\treturn fs_devs;\n\n\tif (fsid)\n\t\tmemcpy(fs_devs->fsid, fsid, BTRFS_FSID_SIZE);\n\telse\n\t\tgenerate_random_uuid(fs_devs->fsid);\n\n\treturn fs_devs;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_fs_devices *alloc_fs_devices(const u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = __alloc_fs_devices();\n\tif (IS_ERR(fs_devs))\n\t\treturn fs_devs;\n\n\tif (fsid)\n\t\tmemcpy(fs_devs->fsid, fsid, BTRFS_FSID_SIZE);\n\telse\n\t\tgenerate_random_uuid(fs_devs->fsid);\n\n\treturn fs_devs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_fsid",
          "args": [
            "disk_super->fsid"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "find_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "175-184",
          "snippet": "btrfs_fs_devices *find_fsid(u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\tlist_for_each_entry(fs_devices, &fs_uuids, list) {\n\t\tif (memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE) == 0)\n\t\t\treturn fs_devices;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nbtrfs_fs_devices *find_fsid(u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\tlist_for_each_entry(fs_devices, &fs_uuids, list) {\n\t\tif (memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE) == 0)\n\t\t\treturn fs_devices;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "disk_super"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline int device_list_add(const char *path,\n\t\t\t   struct btrfs_super_block *disk_super,\n\t\t\t   u64 devid, struct btrfs_fs_devices **fs_devices_ret)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices;\n\tstruct rcu_string *name;\n\tint ret = 0;\n\tu64 found_transid = btrfs_super_generation(disk_super);\n\n\tfs_devices = find_fsid(disk_super->fsid);\n\tif (!fs_devices) {\n\t\tfs_devices = alloc_fs_devices(disk_super->fsid);\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn PTR_ERR(fs_devices);\n\n\t\tlist_add(&fs_devices->list, &fs_uuids);\n\n\t\tdevice = NULL;\n\t} else {\n\t\tdevice = __find_device(&fs_devices->devices, devid,\n\t\t\t\t       disk_super->dev_item.uuid);\n\t}\n\n\tif (!device) {\n\t\tif (fs_devices->opened)\n\t\t\treturn -EBUSY;\n\n\t\tdevice = btrfs_alloc_device(NULL, &devid,\n\t\t\t\t\t    disk_super->dev_item.uuid);\n\t\tif (IS_ERR(device)) {\n\t\t\t/* we can safely leave the fs_devices entry around */\n\t\t\treturn PTR_ERR(device);\n\t\t}\n\n\t\tname = rcu_string_strdup(path, GFP_NOFS);\n\t\tif (!name) {\n\t\t\tkfree(device);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trcu_assign_pointer(device->name, name);\n\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\t\tlist_add_rcu(&device->dev_list, &fs_devices->devices);\n\t\tfs_devices->num_devices++;\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t\tret = 1;\n\t\tdevice->fs_devices = fs_devices;\n\t} else if (!device->name || strcmp(device->name->str, path)) {\n\t\t/*\n\t\t * When FS is already mounted.\n\t\t * 1. If you are here and if the device->name is NULL that\n\t\t *    means this device was missing at time of FS mount.\n\t\t * 2. If you are here and if the device->name is different\n\t\t *    from 'path' that means either\n\t\t *      a. The same device disappeared and reappeared with\n\t\t *         different name. or\n\t\t *      b. The missing-disk-which-was-replaced, has\n\t\t *         reappeared now.\n\t\t *\n\t\t * We must allow 1 and 2a above. But 2b would be a spurious\n\t\t * and unintentional.\n\t\t *\n\t\t * Further in case of 1 and 2a above, the disk at 'path'\n\t\t * would have missed some transaction when it was away and\n\t\t * in case of 2a the stale bdev has to be updated as well.\n\t\t * 2b must not be allowed at all time.\n\t\t */\n\n\t\t/*\n\t\t * For now, we do allow update to btrfs_fs_device through the\n\t\t * btrfs dev scan cli after FS has been mounted.  We're still\n\t\t * tracking a problem where systems fail mount by subvolume id\n\t\t * when we reject replacement on a mounted FS.\n\t\t */\n\t\tif (!fs_devices->opened && found_transid < device->generation) {\n\t\t\t/*\n\t\t\t * That is if the FS is _not_ mounted and if you\n\t\t\t * are here, that means there is more than one\n\t\t\t * disk with same uuid and devid.We keep the one\n\t\t\t * with larger generation number or the last-in if\n\t\t\t * generation are equal.\n\t\t\t */\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\tname = rcu_string_strdup(path, GFP_NOFS);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\t\trcu_string_free(device->name);\n\t\trcu_assign_pointer(device->name, name);\n\t\tif (device->missing) {\n\t\t\tfs_devices->missing_devices--;\n\t\t\tdevice->missing = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Unmount does not free the btrfs_device struct but would zero\n\t * generation along with most of the other members. So just update\n\t * it back. We need it to pick the disk with largest generation\n\t * (as above).\n\t */\n\tif (!fs_devices->opened)\n\t\tdevice->generation = found_transid;\n\n\t*fs_devices_ret = fs_devices;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pending_bios_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "437-443",
    "snippet": "static void pending_bios_fn(struct btrfs_work *work)\n{\n\tstruct btrfs_device *device;\n\n\tdevice = container_of(work, struct btrfs_device, work);\n\trun_scheduled_bios(device);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_scheduled_bios",
          "args": [
            "device"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "run_scheduled_bios",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "249-435",
          "snippet": "static noinline void run_scheduled_bios(struct btrfs_device *device)\n{\n\tstruct bio *pending;\n\tstruct backing_dev_info *bdi;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_pending_bios *pending_bios;\n\tstruct bio *tail;\n\tstruct bio *cur;\n\tint again = 0;\n\tunsigned long num_run;\n\tunsigned long batch_run = 0;\n\tunsigned long limit;\n\tunsigned long last_waited = 0;\n\tint force_reg = 0;\n\tint sync_pending = 0;\n\tstruct blk_plug plug;\n\n\t/*\n\t * this function runs all the bios we've collected for\n\t * a particular device.  We don't want to wander off to\n\t * another device without first sending all of these down.\n\t * So, setup a plug here and finish it off before we return\n\t */\n\tblk_start_plug(&plug);\n\n\tbdi = blk_get_backing_dev_info(device->bdev);\n\tfs_info = device->dev_root->fs_info;\n\tlimit = btrfs_async_submit_limit(fs_info);\n\tlimit = limit * 2 / 3;\n\nloop:\n\tspin_lock(&device->io_lock);\n\nloop_lock:\n\tnum_run = 0;\n\n\t/* take all the bios off the list at once and process them\n\t * later on (without the lock held).  But, remember the\n\t * tail and other pointers so the bios can be properly reinserted\n\t * into the list if we hit congestion\n\t */\n\tif (!force_reg && device->pending_sync_bios.head) {\n\t\tpending_bios = &device->pending_sync_bios;\n\t\tforce_reg = 1;\n\t} else {\n\t\tpending_bios = &device->pending_bios;\n\t\tforce_reg = 0;\n\t}\n\n\tpending = pending_bios->head;\n\ttail = pending_bios->tail;\n\tWARN_ON(pending && !tail);\n\n\t/*\n\t * if pending was null this time around, no bios need processing\n\t * at all and we can stop.  Otherwise it'll loop back up again\n\t * and do an additional check so no bios are missed.\n\t *\n\t * device->running_pending is used to synchronize with the\n\t * schedule_bio code.\n\t */\n\tif (device->pending_sync_bios.head == NULL &&\n\t    device->pending_bios.head == NULL) {\n\t\tagain = 0;\n\t\tdevice->running_pending = 0;\n\t} else {\n\t\tagain = 1;\n\t\tdevice->running_pending = 1;\n\t}\n\n\tpending_bios->head = NULL;\n\tpending_bios->tail = NULL;\n\n\tspin_unlock(&device->io_lock);\n\n\twhile (pending) {\n\n\t\trmb();\n\t\t/* we want to work on both lists, but do more bios on the\n\t\t * sync list than the regular list\n\t\t */\n\t\tif ((num_run > 32 &&\n\t\t    pending_bios != &device->pending_sync_bios &&\n\t\t    device->pending_sync_bios.head) ||\n\t\t   (num_run > 64 && pending_bios == &device->pending_sync_bios &&\n\t\t    device->pending_bios.head)) {\n\t\t\tspin_lock(&device->io_lock);\n\t\t\trequeue_list(pending_bios, pending, tail);\n\t\t\tgoto loop_lock;\n\t\t}\n\n\t\tcur = pending;\n\t\tpending = pending->bi_next;\n\t\tcur->bi_next = NULL;\n\n\t\tif (atomic_dec_return(&fs_info->nr_async_bios) < limit &&\n\t\t    waitqueue_active(&fs_info->async_submit_wait))\n\t\t\twake_up(&fs_info->async_submit_wait);\n\n\t\tBUG_ON(atomic_read(&cur->bi_cnt) == 0);\n\n\t\t/*\n\t\t * if we're doing the sync list, record that our\n\t\t * plug has some sync requests on it\n\t\t *\n\t\t * If we're doing the regular list and there are\n\t\t * sync requests sitting around, unplug before\n\t\t * we add more\n\t\t */\n\t\tif (pending_bios == &device->pending_sync_bios) {\n\t\t\tsync_pending = 1;\n\t\t} else if (sync_pending) {\n\t\t\tblk_finish_plug(&plug);\n\t\t\tblk_start_plug(&plug);\n\t\t\tsync_pending = 0;\n\t\t}\n\n\t\tbtrfsic_submit_bio(cur->bi_rw, cur);\n\t\tnum_run++;\n\t\tbatch_run++;\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\n\t\t/*\n\t\t * we made progress, there is more work to do and the bdi\n\t\t * is now congested.  Back off and let other work structs\n\t\t * run instead\n\t\t */\n\t\tif (pending && bdi_write_congested(bdi) && batch_run > 8 &&\n\t\t    fs_info->fs_devices->open_devices > 1) {\n\t\t\tstruct io_context *ioc;\n\n\t\t\tioc = current->io_context;\n\n\t\t\t/*\n\t\t\t * the main goal here is that we don't want to\n\t\t\t * block if we're going to be able to submit\n\t\t\t * more requests without blocking.\n\t\t\t *\n\t\t\t * This code does two great things, it pokes into\n\t\t\t * the elevator code from a filesystem _and_\n\t\t\t * it makes assumptions about how batching works.\n\t\t\t */\n\t\t\tif (ioc && ioc->nr_batch_requests > 0 &&\n\t\t\t    time_before(jiffies, ioc->last_waited + HZ/50UL) &&\n\t\t\t    (last_waited == 0 ||\n\t\t\t     ioc->last_waited == last_waited)) {\n\t\t\t\t/*\n\t\t\t\t * we want to go through our batch of\n\t\t\t\t * requests and stop.  So, we copy out\n\t\t\t\t * the ioc->last_waited time and test\n\t\t\t\t * against it before looping\n\t\t\t\t */\n\t\t\t\tlast_waited = ioc->last_waited;\n\t\t\t\tif (need_resched())\n\t\t\t\t\tcond_resched();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_lock(&device->io_lock);\n\t\t\trequeue_list(pending_bios, pending, tail);\n\t\t\tdevice->running_pending = 1;\n\n\t\t\tspin_unlock(&device->io_lock);\n\t\t\tbtrfs_queue_work(fs_info->submit_workers,\n\t\t\t\t\t &device->work);\n\t\t\tgoto done;\n\t\t}\n\t\t/* unplug every 64 requests just for good measure */\n\t\tif (batch_run % 64 == 0) {\n\t\t\tblk_finish_plug(&plug);\n\t\t\tblk_start_plug(&plug);\n\t\t\tsync_pending = 0;\n\t\t}\n\t}\n\n\tcond_resched();\n\tif (again)\n\t\tgoto loop;\n\n\tspin_lock(&device->io_lock);\n\tif (device->pending_bios.head || device->pending_sync_bios.head)\n\t\tgoto loop_lock;\n\tspin_unlock(&device->io_lock);\n\ndone:\n\tblk_finish_plug(&plug);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline void run_scheduled_bios(struct btrfs_device *device)\n{\n\tstruct bio *pending;\n\tstruct backing_dev_info *bdi;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_pending_bios *pending_bios;\n\tstruct bio *tail;\n\tstruct bio *cur;\n\tint again = 0;\n\tunsigned long num_run;\n\tunsigned long batch_run = 0;\n\tunsigned long limit;\n\tunsigned long last_waited = 0;\n\tint force_reg = 0;\n\tint sync_pending = 0;\n\tstruct blk_plug plug;\n\n\t/*\n\t * this function runs all the bios we've collected for\n\t * a particular device.  We don't want to wander off to\n\t * another device without first sending all of these down.\n\t * So, setup a plug here and finish it off before we return\n\t */\n\tblk_start_plug(&plug);\n\n\tbdi = blk_get_backing_dev_info(device->bdev);\n\tfs_info = device->dev_root->fs_info;\n\tlimit = btrfs_async_submit_limit(fs_info);\n\tlimit = limit * 2 / 3;\n\nloop:\n\tspin_lock(&device->io_lock);\n\nloop_lock:\n\tnum_run = 0;\n\n\t/* take all the bios off the list at once and process them\n\t * later on (without the lock held).  But, remember the\n\t * tail and other pointers so the bios can be properly reinserted\n\t * into the list if we hit congestion\n\t */\n\tif (!force_reg && device->pending_sync_bios.head) {\n\t\tpending_bios = &device->pending_sync_bios;\n\t\tforce_reg = 1;\n\t} else {\n\t\tpending_bios = &device->pending_bios;\n\t\tforce_reg = 0;\n\t}\n\n\tpending = pending_bios->head;\n\ttail = pending_bios->tail;\n\tWARN_ON(pending && !tail);\n\n\t/*\n\t * if pending was null this time around, no bios need processing\n\t * at all and we can stop.  Otherwise it'll loop back up again\n\t * and do an additional check so no bios are missed.\n\t *\n\t * device->running_pending is used to synchronize with the\n\t * schedule_bio code.\n\t */\n\tif (device->pending_sync_bios.head == NULL &&\n\t    device->pending_bios.head == NULL) {\n\t\tagain = 0;\n\t\tdevice->running_pending = 0;\n\t} else {\n\t\tagain = 1;\n\t\tdevice->running_pending = 1;\n\t}\n\n\tpending_bios->head = NULL;\n\tpending_bios->tail = NULL;\n\n\tspin_unlock(&device->io_lock);\n\n\twhile (pending) {\n\n\t\trmb();\n\t\t/* we want to work on both lists, but do more bios on the\n\t\t * sync list than the regular list\n\t\t */\n\t\tif ((num_run > 32 &&\n\t\t    pending_bios != &device->pending_sync_bios &&\n\t\t    device->pending_sync_bios.head) ||\n\t\t   (num_run > 64 && pending_bios == &device->pending_sync_bios &&\n\t\t    device->pending_bios.head)) {\n\t\t\tspin_lock(&device->io_lock);\n\t\t\trequeue_list(pending_bios, pending, tail);\n\t\t\tgoto loop_lock;\n\t\t}\n\n\t\tcur = pending;\n\t\tpending = pending->bi_next;\n\t\tcur->bi_next = NULL;\n\n\t\tif (atomic_dec_return(&fs_info->nr_async_bios) < limit &&\n\t\t    waitqueue_active(&fs_info->async_submit_wait))\n\t\t\twake_up(&fs_info->async_submit_wait);\n\n\t\tBUG_ON(atomic_read(&cur->bi_cnt) == 0);\n\n\t\t/*\n\t\t * if we're doing the sync list, record that our\n\t\t * plug has some sync requests on it\n\t\t *\n\t\t * If we're doing the regular list and there are\n\t\t * sync requests sitting around, unplug before\n\t\t * we add more\n\t\t */\n\t\tif (pending_bios == &device->pending_sync_bios) {\n\t\t\tsync_pending = 1;\n\t\t} else if (sync_pending) {\n\t\t\tblk_finish_plug(&plug);\n\t\t\tblk_start_plug(&plug);\n\t\t\tsync_pending = 0;\n\t\t}\n\n\t\tbtrfsic_submit_bio(cur->bi_rw, cur);\n\t\tnum_run++;\n\t\tbatch_run++;\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\n\t\t/*\n\t\t * we made progress, there is more work to do and the bdi\n\t\t * is now congested.  Back off and let other work structs\n\t\t * run instead\n\t\t */\n\t\tif (pending && bdi_write_congested(bdi) && batch_run > 8 &&\n\t\t    fs_info->fs_devices->open_devices > 1) {\n\t\t\tstruct io_context *ioc;\n\n\t\t\tioc = current->io_context;\n\n\t\t\t/*\n\t\t\t * the main goal here is that we don't want to\n\t\t\t * block if we're going to be able to submit\n\t\t\t * more requests without blocking.\n\t\t\t *\n\t\t\t * This code does two great things, it pokes into\n\t\t\t * the elevator code from a filesystem _and_\n\t\t\t * it makes assumptions about how batching works.\n\t\t\t */\n\t\t\tif (ioc && ioc->nr_batch_requests > 0 &&\n\t\t\t    time_before(jiffies, ioc->last_waited + HZ/50UL) &&\n\t\t\t    (last_waited == 0 ||\n\t\t\t     ioc->last_waited == last_waited)) {\n\t\t\t\t/*\n\t\t\t\t * we want to go through our batch of\n\t\t\t\t * requests and stop.  So, we copy out\n\t\t\t\t * the ioc->last_waited time and test\n\t\t\t\t * against it before looping\n\t\t\t\t */\n\t\t\t\tlast_waited = ioc->last_waited;\n\t\t\t\tif (need_resched())\n\t\t\t\t\tcond_resched();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_lock(&device->io_lock);\n\t\t\trequeue_list(pending_bios, pending, tail);\n\t\t\tdevice->running_pending = 1;\n\n\t\t\tspin_unlock(&device->io_lock);\n\t\t\tbtrfs_queue_work(fs_info->submit_workers,\n\t\t\t\t\t &device->work);\n\t\t\tgoto done;\n\t\t}\n\t\t/* unplug every 64 requests just for good measure */\n\t\tif (batch_run % 64 == 0) {\n\t\t\tblk_finish_plug(&plug);\n\t\t\tblk_start_plug(&plug);\n\t\t\tsync_pending = 0;\n\t\t}\n\t}\n\n\tcond_resched();\n\tif (again)\n\t\tgoto loop;\n\n\tspin_lock(&device->io_lock);\n\tif (device->pending_bios.head || device->pending_sync_bios.head)\n\t\tgoto loop_lock;\n\tspin_unlock(&device->io_lock);\n\ndone:\n\tblk_finish_plug(&plug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbtrfs_device",
            "work"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void pending_bios_fn(struct btrfs_work *work)\n{\n\tstruct btrfs_device *device;\n\n\tdevice = container_of(work, struct btrfs_device, work);\n\trun_scheduled_bios(device);\n}"
  },
  {
    "function_name": "run_scheduled_bios",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "249-435",
    "snippet": "static noinline void run_scheduled_bios(struct btrfs_device *device)\n{\n\tstruct bio *pending;\n\tstruct backing_dev_info *bdi;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_pending_bios *pending_bios;\n\tstruct bio *tail;\n\tstruct bio *cur;\n\tint again = 0;\n\tunsigned long num_run;\n\tunsigned long batch_run = 0;\n\tunsigned long limit;\n\tunsigned long last_waited = 0;\n\tint force_reg = 0;\n\tint sync_pending = 0;\n\tstruct blk_plug plug;\n\n\t/*\n\t * this function runs all the bios we've collected for\n\t * a particular device.  We don't want to wander off to\n\t * another device without first sending all of these down.\n\t * So, setup a plug here and finish it off before we return\n\t */\n\tblk_start_plug(&plug);\n\n\tbdi = blk_get_backing_dev_info(device->bdev);\n\tfs_info = device->dev_root->fs_info;\n\tlimit = btrfs_async_submit_limit(fs_info);\n\tlimit = limit * 2 / 3;\n\nloop:\n\tspin_lock(&device->io_lock);\n\nloop_lock:\n\tnum_run = 0;\n\n\t/* take all the bios off the list at once and process them\n\t * later on (without the lock held).  But, remember the\n\t * tail and other pointers so the bios can be properly reinserted\n\t * into the list if we hit congestion\n\t */\n\tif (!force_reg && device->pending_sync_bios.head) {\n\t\tpending_bios = &device->pending_sync_bios;\n\t\tforce_reg = 1;\n\t} else {\n\t\tpending_bios = &device->pending_bios;\n\t\tforce_reg = 0;\n\t}\n\n\tpending = pending_bios->head;\n\ttail = pending_bios->tail;\n\tWARN_ON(pending && !tail);\n\n\t/*\n\t * if pending was null this time around, no bios need processing\n\t * at all and we can stop.  Otherwise it'll loop back up again\n\t * and do an additional check so no bios are missed.\n\t *\n\t * device->running_pending is used to synchronize with the\n\t * schedule_bio code.\n\t */\n\tif (device->pending_sync_bios.head == NULL &&\n\t    device->pending_bios.head == NULL) {\n\t\tagain = 0;\n\t\tdevice->running_pending = 0;\n\t} else {\n\t\tagain = 1;\n\t\tdevice->running_pending = 1;\n\t}\n\n\tpending_bios->head = NULL;\n\tpending_bios->tail = NULL;\n\n\tspin_unlock(&device->io_lock);\n\n\twhile (pending) {\n\n\t\trmb();\n\t\t/* we want to work on both lists, but do more bios on the\n\t\t * sync list than the regular list\n\t\t */\n\t\tif ((num_run > 32 &&\n\t\t    pending_bios != &device->pending_sync_bios &&\n\t\t    device->pending_sync_bios.head) ||\n\t\t   (num_run > 64 && pending_bios == &device->pending_sync_bios &&\n\t\t    device->pending_bios.head)) {\n\t\t\tspin_lock(&device->io_lock);\n\t\t\trequeue_list(pending_bios, pending, tail);\n\t\t\tgoto loop_lock;\n\t\t}\n\n\t\tcur = pending;\n\t\tpending = pending->bi_next;\n\t\tcur->bi_next = NULL;\n\n\t\tif (atomic_dec_return(&fs_info->nr_async_bios) < limit &&\n\t\t    waitqueue_active(&fs_info->async_submit_wait))\n\t\t\twake_up(&fs_info->async_submit_wait);\n\n\t\tBUG_ON(atomic_read(&cur->bi_cnt) == 0);\n\n\t\t/*\n\t\t * if we're doing the sync list, record that our\n\t\t * plug has some sync requests on it\n\t\t *\n\t\t * If we're doing the regular list and there are\n\t\t * sync requests sitting around, unplug before\n\t\t * we add more\n\t\t */\n\t\tif (pending_bios == &device->pending_sync_bios) {\n\t\t\tsync_pending = 1;\n\t\t} else if (sync_pending) {\n\t\t\tblk_finish_plug(&plug);\n\t\t\tblk_start_plug(&plug);\n\t\t\tsync_pending = 0;\n\t\t}\n\n\t\tbtrfsic_submit_bio(cur->bi_rw, cur);\n\t\tnum_run++;\n\t\tbatch_run++;\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\n\t\t/*\n\t\t * we made progress, there is more work to do and the bdi\n\t\t * is now congested.  Back off and let other work structs\n\t\t * run instead\n\t\t */\n\t\tif (pending && bdi_write_congested(bdi) && batch_run > 8 &&\n\t\t    fs_info->fs_devices->open_devices > 1) {\n\t\t\tstruct io_context *ioc;\n\n\t\t\tioc = current->io_context;\n\n\t\t\t/*\n\t\t\t * the main goal here is that we don't want to\n\t\t\t * block if we're going to be able to submit\n\t\t\t * more requests without blocking.\n\t\t\t *\n\t\t\t * This code does two great things, it pokes into\n\t\t\t * the elevator code from a filesystem _and_\n\t\t\t * it makes assumptions about how batching works.\n\t\t\t */\n\t\t\tif (ioc && ioc->nr_batch_requests > 0 &&\n\t\t\t    time_before(jiffies, ioc->last_waited + HZ/50UL) &&\n\t\t\t    (last_waited == 0 ||\n\t\t\t     ioc->last_waited == last_waited)) {\n\t\t\t\t/*\n\t\t\t\t * we want to go through our batch of\n\t\t\t\t * requests and stop.  So, we copy out\n\t\t\t\t * the ioc->last_waited time and test\n\t\t\t\t * against it before looping\n\t\t\t\t */\n\t\t\t\tlast_waited = ioc->last_waited;\n\t\t\t\tif (need_resched())\n\t\t\t\t\tcond_resched();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_lock(&device->io_lock);\n\t\t\trequeue_list(pending_bios, pending, tail);\n\t\t\tdevice->running_pending = 1;\n\n\t\t\tspin_unlock(&device->io_lock);\n\t\t\tbtrfs_queue_work(fs_info->submit_workers,\n\t\t\t\t\t &device->work);\n\t\t\tgoto done;\n\t\t}\n\t\t/* unplug every 64 requests just for good measure */\n\t\tif (batch_run % 64 == 0) {\n\t\t\tblk_finish_plug(&plug);\n\t\t\tblk_start_plug(&plug);\n\t\t\tsync_pending = 0;\n\t\t}\n\t}\n\n\tcond_resched();\n\tif (again)\n\t\tgoto loop;\n\n\tspin_lock(&device->io_lock);\n\tif (device->pending_bios.head || device->pending_sync_bios.head)\n\t\tgoto loop_lock;\n\tspin_unlock(&device->io_lock);\n\ndone:\n\tblk_finish_plug(&plug);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&device->io_lock"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&device->io_lock"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "fs_info->submit_workers",
            "&device->work"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "requeue_list",
          "args": [
            "pending_bios",
            "pending",
            "tail"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "requeue_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "224-236",
          "snippet": "static void requeue_list(struct btrfs_pending_bios *pending_bios,\n\t\t\tstruct bio *head, struct bio *tail)\n{\n\n\tstruct bio *old_head;\n\n\told_head = pending_bios->head;\n\tpending_bios->head = head;\n\tif (pending_bios->tail)\n\t\ttail->bi_next = old_head;\n\telse\n\t\tpending_bios->tail = tail;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void requeue_list(struct btrfs_pending_bios *pending_bios,\n\t\t\tstruct bio *head, struct bio *tail)\n{\n\n\tstruct bio *old_head;\n\n\told_head = pending_bios->head;\n\tpending_bios->head = head;\n\tif (pending_bios->tail)\n\t\ttail->bi_next = old_head;\n\telse\n\t\tpending_bios->tail = tail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "ioc->last_waited + HZ/50UL"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_write_congested",
          "args": [
            "bdi"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_submit_bio",
          "args": [
            "cur->bi_rw",
            "cur"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&cur->bi_cnt) == 0"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cur->bi_cnt"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fs_info->async_submit_wait"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&fs_info->async_submit_wait"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&fs_info->nr_async_bios"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmb",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pending && !tail"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_async_submit_limit",
          "args": [
            "fs_info"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_async_submit_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "777-783",
          "snippet": "unsigned long btrfs_async_submit_limit(struct btrfs_fs_info *info)\n{\n\tunsigned long limit = min_t(unsigned long,\n\t\t\t\t    info->thread_pool_size,\n\t\t\t\t    info->fs_devices->open_devices);\n\treturn 256 * limit;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nunsigned long btrfs_async_submit_limit(struct btrfs_fs_info *info)\n{\n\tunsigned long limit = min_t(unsigned long,\n\t\t\t\t    info->thread_pool_size,\n\t\t\t\t    info->fs_devices->open_devices);\n\treturn 256 * limit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_get_backing_dev_info",
          "args": [
            "device->bdev"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic noinline void run_scheduled_bios(struct btrfs_device *device)\n{\n\tstruct bio *pending;\n\tstruct backing_dev_info *bdi;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_pending_bios *pending_bios;\n\tstruct bio *tail;\n\tstruct bio *cur;\n\tint again = 0;\n\tunsigned long num_run;\n\tunsigned long batch_run = 0;\n\tunsigned long limit;\n\tunsigned long last_waited = 0;\n\tint force_reg = 0;\n\tint sync_pending = 0;\n\tstruct blk_plug plug;\n\n\t/*\n\t * this function runs all the bios we've collected for\n\t * a particular device.  We don't want to wander off to\n\t * another device without first sending all of these down.\n\t * So, setup a plug here and finish it off before we return\n\t */\n\tblk_start_plug(&plug);\n\n\tbdi = blk_get_backing_dev_info(device->bdev);\n\tfs_info = device->dev_root->fs_info;\n\tlimit = btrfs_async_submit_limit(fs_info);\n\tlimit = limit * 2 / 3;\n\nloop:\n\tspin_lock(&device->io_lock);\n\nloop_lock:\n\tnum_run = 0;\n\n\t/* take all the bios off the list at once and process them\n\t * later on (without the lock held).  But, remember the\n\t * tail and other pointers so the bios can be properly reinserted\n\t * into the list if we hit congestion\n\t */\n\tif (!force_reg && device->pending_sync_bios.head) {\n\t\tpending_bios = &device->pending_sync_bios;\n\t\tforce_reg = 1;\n\t} else {\n\t\tpending_bios = &device->pending_bios;\n\t\tforce_reg = 0;\n\t}\n\n\tpending = pending_bios->head;\n\ttail = pending_bios->tail;\n\tWARN_ON(pending && !tail);\n\n\t/*\n\t * if pending was null this time around, no bios need processing\n\t * at all and we can stop.  Otherwise it'll loop back up again\n\t * and do an additional check so no bios are missed.\n\t *\n\t * device->running_pending is used to synchronize with the\n\t * schedule_bio code.\n\t */\n\tif (device->pending_sync_bios.head == NULL &&\n\t    device->pending_bios.head == NULL) {\n\t\tagain = 0;\n\t\tdevice->running_pending = 0;\n\t} else {\n\t\tagain = 1;\n\t\tdevice->running_pending = 1;\n\t}\n\n\tpending_bios->head = NULL;\n\tpending_bios->tail = NULL;\n\n\tspin_unlock(&device->io_lock);\n\n\twhile (pending) {\n\n\t\trmb();\n\t\t/* we want to work on both lists, but do more bios on the\n\t\t * sync list than the regular list\n\t\t */\n\t\tif ((num_run > 32 &&\n\t\t    pending_bios != &device->pending_sync_bios &&\n\t\t    device->pending_sync_bios.head) ||\n\t\t   (num_run > 64 && pending_bios == &device->pending_sync_bios &&\n\t\t    device->pending_bios.head)) {\n\t\t\tspin_lock(&device->io_lock);\n\t\t\trequeue_list(pending_bios, pending, tail);\n\t\t\tgoto loop_lock;\n\t\t}\n\n\t\tcur = pending;\n\t\tpending = pending->bi_next;\n\t\tcur->bi_next = NULL;\n\n\t\tif (atomic_dec_return(&fs_info->nr_async_bios) < limit &&\n\t\t    waitqueue_active(&fs_info->async_submit_wait))\n\t\t\twake_up(&fs_info->async_submit_wait);\n\n\t\tBUG_ON(atomic_read(&cur->bi_cnt) == 0);\n\n\t\t/*\n\t\t * if we're doing the sync list, record that our\n\t\t * plug has some sync requests on it\n\t\t *\n\t\t * If we're doing the regular list and there are\n\t\t * sync requests sitting around, unplug before\n\t\t * we add more\n\t\t */\n\t\tif (pending_bios == &device->pending_sync_bios) {\n\t\t\tsync_pending = 1;\n\t\t} else if (sync_pending) {\n\t\t\tblk_finish_plug(&plug);\n\t\t\tblk_start_plug(&plug);\n\t\t\tsync_pending = 0;\n\t\t}\n\n\t\tbtrfsic_submit_bio(cur->bi_rw, cur);\n\t\tnum_run++;\n\t\tbatch_run++;\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\n\t\t/*\n\t\t * we made progress, there is more work to do and the bdi\n\t\t * is now congested.  Back off and let other work structs\n\t\t * run instead\n\t\t */\n\t\tif (pending && bdi_write_congested(bdi) && batch_run > 8 &&\n\t\t    fs_info->fs_devices->open_devices > 1) {\n\t\t\tstruct io_context *ioc;\n\n\t\t\tioc = current->io_context;\n\n\t\t\t/*\n\t\t\t * the main goal here is that we don't want to\n\t\t\t * block if we're going to be able to submit\n\t\t\t * more requests without blocking.\n\t\t\t *\n\t\t\t * This code does two great things, it pokes into\n\t\t\t * the elevator code from a filesystem _and_\n\t\t\t * it makes assumptions about how batching works.\n\t\t\t */\n\t\t\tif (ioc && ioc->nr_batch_requests > 0 &&\n\t\t\t    time_before(jiffies, ioc->last_waited + HZ/50UL) &&\n\t\t\t    (last_waited == 0 ||\n\t\t\t     ioc->last_waited == last_waited)) {\n\t\t\t\t/*\n\t\t\t\t * we want to go through our batch of\n\t\t\t\t * requests and stop.  So, we copy out\n\t\t\t\t * the ioc->last_waited time and test\n\t\t\t\t * against it before looping\n\t\t\t\t */\n\t\t\t\tlast_waited = ioc->last_waited;\n\t\t\t\tif (need_resched())\n\t\t\t\t\tcond_resched();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_lock(&device->io_lock);\n\t\t\trequeue_list(pending_bios, pending, tail);\n\t\t\tdevice->running_pending = 1;\n\n\t\t\tspin_unlock(&device->io_lock);\n\t\t\tbtrfs_queue_work(fs_info->submit_workers,\n\t\t\t\t\t &device->work);\n\t\t\tgoto done;\n\t\t}\n\t\t/* unplug every 64 requests just for good measure */\n\t\tif (batch_run % 64 == 0) {\n\t\t\tblk_finish_plug(&plug);\n\t\t\tblk_start_plug(&plug);\n\t\t\tsync_pending = 0;\n\t\t}\n\t}\n\n\tcond_resched();\n\tif (again)\n\t\tgoto loop;\n\n\tspin_lock(&device->io_lock);\n\tif (device->pending_bios.head || device->pending_sync_bios.head)\n\t\tgoto loop_lock;\n\tspin_unlock(&device->io_lock);\n\ndone:\n\tblk_finish_plug(&plug);\n}"
  },
  {
    "function_name": "requeue_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "224-236",
    "snippet": "static void requeue_list(struct btrfs_pending_bios *pending_bios,\n\t\t\tstruct bio *head, struct bio *tail)\n{\n\n\tstruct bio *old_head;\n\n\told_head = pending_bios->head;\n\tpending_bios->head = head;\n\tif (pending_bios->tail)\n\t\ttail->bi_next = old_head;\n\telse\n\t\tpending_bios->tail = tail;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void requeue_list(struct btrfs_pending_bios *pending_bios,\n\t\t\tstruct bio *head, struct bio *tail)\n{\n\n\tstruct bio *old_head;\n\n\told_head = pending_bios->head;\n\tpending_bios->head = head;\n\tif (pending_bios->tail)\n\t\ttail->bi_next = old_head;\n\telse\n\t\tpending_bios->tail = tail;\n}"
  },
  {
    "function_name": "btrfs_get_bdev_and_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "186-222",
    "snippet": "static int\nbtrfs_get_bdev_and_sb(const char *device_path, fmode_t flags, void *holder,\n\t\t      int flush, struct block_device **bdev,\n\t\t      struct buffer_head **bh)\n{\n\tint ret;\n\n\t*bdev = blkdev_get_by_path(device_path, flags, holder);\n\n\tif (IS_ERR(*bdev)) {\n\t\tret = PTR_ERR(*bdev);\n\t\tprintk(KERN_INFO \"BTRFS: open %s failed\\n\", device_path);\n\t\tgoto error;\n\t}\n\n\tif (flush)\n\t\tfilemap_write_and_wait((*bdev)->bd_inode->i_mapping);\n\tret = set_blocksize(*bdev, 4096);\n\tif (ret) {\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\tinvalidate_bdev(*bdev);\n\t*bh = btrfs_read_dev_super(*bdev);\n\tif (!*bh) {\n\t\tret = -EINVAL;\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\t*bdev = NULL;\n\t*bh = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "*bdev",
            "flags"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_read_dev_super",
          "args": [
            "*bdev"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_dev_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3084-3124",
          "snippet": "struct buffer_head *btrfs_read_dev_super(struct block_device *bdev)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *latest = NULL;\n\tstruct btrfs_super_block *super;\n\tint i;\n\tu64 transid = 0;\n\tu64 bytenr;\n\n\t/* we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tfor (i = 0; i < 1; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t\t\t\ti_size_read(bdev->bd_inode))\n\t\t\tbreak;\n\t\tbh = __bread(bdev, bytenr / 4096,\n\t\t\t\t\tBTRFS_SUPER_INFO_SIZE);\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tsuper = (struct btrfs_super_block *)bh->b_data;\n\t\tif (btrfs_super_bytenr(super) != bytenr ||\n\t\t    btrfs_super_magic(super) != BTRFS_MAGIC) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!latest || btrfs_super_generation(super) > transid) {\n\t\t\tbrelse(latest);\n\t\t\tlatest = bh;\n\t\t\ttransid = btrfs_super_generation(super);\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n\treturn latest;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstruct buffer_head *btrfs_read_dev_super(struct block_device *bdev)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *latest = NULL;\n\tstruct btrfs_super_block *super;\n\tint i;\n\tu64 transid = 0;\n\tu64 bytenr;\n\n\t/* we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tfor (i = 0; i < 1; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t\t\t\ti_size_read(bdev->bd_inode))\n\t\t\tbreak;\n\t\tbh = __bread(bdev, bytenr / 4096,\n\t\t\t\t\tBTRFS_SUPER_INFO_SIZE);\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tsuper = (struct btrfs_super_block *)bh->b_data;\n\t\tif (btrfs_super_bytenr(super) != bytenr ||\n\t\t    btrfs_super_magic(super) != BTRFS_MAGIC) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!latest || btrfs_super_generation(super) > transid) {\n\t\t\tbrelse(latest);\n\t\t\tlatest = bh;\n\t\t\ttransid = btrfs_super_generation(super);\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n\treturn latest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_bdev",
          "args": [
            "*bdev"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "77-91",
          "snippet": "void invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\tinvalidate_mapping_pages(mapping, 0, -1);\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\tinvalidate_mapping_pages(mapping, 0, -1);\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "*bdev",
            "4096"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "(*bdev)->bd_inode->i_mapping"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"BTRFS: open %s failed\\n\"",
            "device_path"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "*bdev"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*bdev"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_path",
          "args": [
            "device_path",
            "flags",
            "holder"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1387-1407",
          "snippet": "struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic int\nbtrfs_get_bdev_and_sb(const char *device_path, fmode_t flags, void *holder,\n\t\t      int flush, struct block_device **bdev,\n\t\t      struct buffer_head **bh)\n{\n\tint ret;\n\n\t*bdev = blkdev_get_by_path(device_path, flags, holder);\n\n\tif (IS_ERR(*bdev)) {\n\t\tret = PTR_ERR(*bdev);\n\t\tprintk(KERN_INFO \"BTRFS: open %s failed\\n\", device_path);\n\t\tgoto error;\n\t}\n\n\tif (flush)\n\t\tfilemap_write_and_wait((*bdev)->bd_inode->i_mapping);\n\tret = set_blocksize(*bdev, 4096);\n\tif (ret) {\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\tinvalidate_bdev(*bdev);\n\t*bh = btrfs_read_dev_super(*bdev);\n\tif (!*bh) {\n\t\tret = -EINVAL;\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\t*bdev = NULL;\n\t*bh = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "find_fsid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "175-184",
    "snippet": "btrfs_fs_devices *find_fsid(u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\tlist_for_each_entry(fs_devices, &fs_uuids, list) {\n\t\tif (memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE) == 0)\n\t\t\treturn fs_devices;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(fs_uuids);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "fsid",
            "fs_devices->fsid",
            "BTRFS_FSID_SIZE"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fs_devices",
            "&fs_uuids",
            "list"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nbtrfs_fs_devices *find_fsid(u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\tlist_for_each_entry(fs_devices, &fs_uuids, list) {\n\t\tif (memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE) == 0)\n\t\t\treturn fs_devices;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "__find_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "161-173",
    "snippet": "btrfs_device *__find_device(struct list_head *head,\n\t\t\t\t\t\t   u64 devid, u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\n\tlist_for_each_entry(dev, head, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dev->uuid",
            "uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev",
            "head",
            "dev_list"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nbtrfs_device *__find_device(struct list_head *head,\n\t\t\t\t\t\t   u64 devid, u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\n\tlist_for_each_entry(dev, head, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "__alloc_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "138-159",
    "snippet": "static struct btrfs_device *__alloc_device(void)\n{\n\tstruct btrfs_device *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_NOFS);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&dev->dev_list);\n\tINIT_LIST_HEAD(&dev->dev_alloc_list);\n\tINIT_LIST_HEAD(&dev->resized_list);\n\n\tspin_lock_init(&dev->io_lock);\n\n\tspin_lock_init(&dev->reada_lock);\n\tatomic_set(&dev->reada_in_flight, 0);\n\tatomic_set(&dev->dev_stats_ccnt, 0);\n\tINIT_RADIX_TREE(&dev->reada_zones, GFP_NOFS & ~__GFP_WAIT);\n\tINIT_RADIX_TREE(&dev->reada_extents, GFP_NOFS & ~__GFP_WAIT);\n\n\treturn dev;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
      "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&dev->reada_extents",
            "GFP_NOFS & ~__GFP_WAIT"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&dev->reada_zones",
            "GFP_NOFS & ~__GFP_WAIT"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&dev->dev_stats_ccnt",
            "0"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&dev->reada_in_flight",
            "0"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&dev->reada_lock"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&dev->io_lock"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dev->resized_list"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dev->dev_alloc_list"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dev->dev_list"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*dev)",
            "GFP_NOFS"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_device *__alloc_device(void)\n{\n\tstruct btrfs_device *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_NOFS);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&dev->dev_list);\n\tINIT_LIST_HEAD(&dev->dev_alloc_list);\n\tINIT_LIST_HEAD(&dev->resized_list);\n\n\tspin_lock_init(&dev->io_lock);\n\n\tspin_lock_init(&dev->reada_lock);\n\tatomic_set(&dev->reada_in_flight, 0);\n\tatomic_set(&dev->dev_stats_ccnt, 0);\n\tINIT_RADIX_TREE(&dev->reada_zones, GFP_NOFS & ~__GFP_WAIT);\n\tINIT_RADIX_TREE(&dev->reada_extents, GFP_NOFS & ~__GFP_WAIT);\n\n\treturn dev;\n}"
  },
  {
    "function_name": "btrfs_cleanup_fs_uuids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "126-136",
    "snippet": "void btrfs_cleanup_fs_uuids(void)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\twhile (!list_empty(&fs_uuids)) {\n\t\tfs_devices = list_entry(fs_uuids.next,\n\t\t\t\t\tstruct btrfs_fs_devices, list);\n\t\tlist_del(&fs_devices->list);\n\t\tfree_fs_devices(fs_devices);\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(fs_uuids);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_fs_devices",
          "args": [
            "fs_devices"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "free_fs_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "99-111",
          "snippet": "static void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&fs_devices->list"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "fs_uuids.next",
            "structbtrfs_fs_devices",
            "list"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fs_uuids"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_cleanup_fs_uuids(void)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\twhile (!list_empty(&fs_uuids)) {\n\t\tfs_devices = list_entry(fs_uuids.next,\n\t\t\t\t\tstruct btrfs_fs_devices, list);\n\t\tlist_del(&fs_devices->list);\n\t\tfree_fs_devices(fs_devices);\n\t}\n}"
  },
  {
    "function_name": "btrfs_kobject_uevent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "113-124",
    "snippet": "static void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\"",
            "action",
            "kobject_name(&disk_to_dev(bdev->bd_disk)->kobj)",
            "&disk_to_dev(bdev->bd_disk)->kobj"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_to_dev",
          "args": [
            "bdev->bd_disk"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_name",
          "args": [
            "&disk_to_dev(bdev->bd_disk)->kobj"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_to_dev",
          "args": [
            "bdev->bd_disk"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&disk_to_dev(bdev->bd_disk)->kobj",
            "action"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kobject_uevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "113-124",
          "snippet": "static void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "disk_to_dev",
          "args": [
            "bdev->bd_disk"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}"
  },
  {
    "function_name": "free_fs_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "99-111",
    "snippet": "static void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
      "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fs_devices"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "device"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_string_free",
          "args": [
            "device->name"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_string_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/rcu-string.h",
          "lines": "35-39",
          "snippet": "static inline void rcu_string_free(struct rcu_string *str)\n{\n\tif (str)\n\t\tkfree_rcu(str, rcu);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void rcu_string_free(struct rcu_string *str)\n{\n\tif (str)\n\t\tkfree_rcu(str, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&device->dev_list"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "fs_devices->devices.next",
            "structbtrfs_device",
            "dev_list"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fs_devices->devices"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "fs_devices->opened"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void free_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tWARN_ON(fs_devices->opened);\n\twhile (!list_empty(&fs_devices->devices)) {\n\t\tdevice = list_entry(fs_devices->devices.next,\n\t\t\t\t    struct btrfs_device, dev_list);\n\t\tlist_del(&device->dev_list);\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\tkfree(fs_devices);\n}"
  },
  {
    "function_name": "alloc_fs_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "83-97",
    "snippet": "static struct btrfs_fs_devices *alloc_fs_devices(const u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = __alloc_fs_devices();\n\tif (IS_ERR(fs_devs))\n\t\treturn fs_devs;\n\n\tif (fsid)\n\t\tmemcpy(fs_devs->fsid, fsid, BTRFS_FSID_SIZE);\n\telse\n\t\tgenerate_random_uuid(fs_devs->fsid);\n\n\treturn fs_devs;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generate_random_uuid",
          "args": [
            "fs_devs->fsid"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fs_devs->fsid",
            "fsid",
            "BTRFS_FSID_SIZE"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_devs"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_fs_devices",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_fs_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "56-72",
          "snippet": "static struct btrfs_fs_devices *__alloc_fs_devices(void)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = kzalloc(sizeof(*fs_devs), GFP_NOFS);\n\tif (!fs_devs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&fs_devs->device_list_mutex);\n\n\tINIT_LIST_HEAD(&fs_devs->devices);\n\tINIT_LIST_HEAD(&fs_devs->resized_devices);\n\tINIT_LIST_HEAD(&fs_devs->alloc_list);\n\tINIT_LIST_HEAD(&fs_devs->list);\n\n\treturn fs_devs;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_fs_devices *__alloc_fs_devices(void)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = kzalloc(sizeof(*fs_devs), GFP_NOFS);\n\tif (!fs_devs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&fs_devs->device_list_mutex);\n\n\tINIT_LIST_HEAD(&fs_devs->devices);\n\tINIT_LIST_HEAD(&fs_devs->resized_devices);\n\tINIT_LIST_HEAD(&fs_devs->alloc_list);\n\tINIT_LIST_HEAD(&fs_devs->list);\n\n\treturn fs_devs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_fs_devices *alloc_fs_devices(const u8 *fsid)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = __alloc_fs_devices();\n\tif (IS_ERR(fs_devs))\n\t\treturn fs_devs;\n\n\tif (fsid)\n\t\tmemcpy(fs_devs->fsid, fsid, BTRFS_FSID_SIZE);\n\telse\n\t\tgenerate_random_uuid(fs_devs->fsid);\n\n\treturn fs_devs;\n}"
  },
  {
    "function_name": "__alloc_fs_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
    "lines": "56-72",
    "snippet": "static struct btrfs_fs_devices *__alloc_fs_devices(void)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = kzalloc(sizeof(*fs_devs), GFP_NOFS);\n\tif (!fs_devs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&fs_devs->device_list_mutex);\n\n\tINIT_LIST_HEAD(&fs_devs->devices);\n\tINIT_LIST_HEAD(&fs_devs->resized_devices);\n\tINIT_LIST_HEAD(&fs_devs->alloc_list);\n\tINIT_LIST_HEAD(&fs_devs->list);\n\n\treturn fs_devs;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"math.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_devs->list"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_devs->alloc_list"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_devs->resized_devices"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_devs->devices"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_devs->device_list_mutex"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*fs_devs)",
            "GFP_NOFS"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic struct btrfs_fs_devices *__alloc_fs_devices(void)\n{\n\tstruct btrfs_fs_devices *fs_devs;\n\n\tfs_devs = kzalloc(sizeof(*fs_devs), GFP_NOFS);\n\tif (!fs_devs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&fs_devs->device_list_mutex);\n\n\tINIT_LIST_HEAD(&fs_devs->devices);\n\tINIT_LIST_HEAD(&fs_devs->resized_devices);\n\tINIT_LIST_HEAD(&fs_devs->alloc_list);\n\tINIT_LIST_HEAD(&fs_devs->list);\n\n\treturn fs_devs;\n}"
  }
]