[
  {
    "function_name": "ext3_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "2378-2548",
    "snippet": "static int ext3_rename (struct inode * old_dir, struct dentry *old_dentry,\n\t\t\t   struct inode * new_dir,struct dentry *new_dentry)\n{\n\thandle_t *handle;\n\tstruct inode * old_inode, * new_inode;\n\tstruct buffer_head * old_bh, * new_bh, * dir_bh;\n\tstruct ext3_dir_entry_2 * old_de, * new_de;\n\tint retval, flush_file = 0;\n\n\tdquot_initialize(old_dir);\n\tdquot_initialize(new_dir);\n\n\told_bh = new_bh = dir_bh = NULL;\n\n\t/* Initialize quotas before so that eventual writes go\n\t * in separate transaction */\n\tif (new_dentry->d_inode)\n\t\tdquot_initialize(new_dentry->d_inode);\n\thandle = ext3_journal_start(old_dir, 2 *\n\t\t\t\t\tEXT3_DATA_TRANS_BLOCKS(old_dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))\n\t\thandle->h_sync = 1;\n\n\told_bh = ext3_find_entry(old_dir, &old_dentry->d_name, &old_de);\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\told_inode = old_dentry->d_inode;\n\tretval = -ENOENT;\n\tif (!old_bh || le32_to_cpu(old_de->inode) != old_inode->i_ino)\n\t\tgoto end_rename;\n\n\tnew_inode = new_dentry->d_inode;\n\tnew_bh = ext3_find_entry(new_dir, &new_dentry->d_name, &new_de);\n\tif (new_bh) {\n\t\tif (!new_inode) {\n\t\t\tbrelse (new_bh);\n\t\t\tnew_bh = NULL;\n\t\t}\n\t}\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\tif (new_inode) {\n\t\t\tretval = -ENOTEMPTY;\n\t\t\tif (!empty_dir (new_inode))\n\t\t\t\tgoto end_rename;\n\t\t}\n\t\tretval = -EIO;\n\t\tdir_bh = ext3_dir_bread(handle, old_inode, 0, 0, &retval);\n\t\tif (!dir_bh)\n\t\t\tgoto end_rename;\n\t\tif (le32_to_cpu(PARENT_INO(dir_bh->b_data)) != old_dir->i_ino)\n\t\t\tgoto end_rename;\n\t\tretval = -EMLINK;\n\t\tif (!new_inode && new_dir!=old_dir &&\n\t\t\t\tnew_dir->i_nlink >= EXT3_LINK_MAX)\n\t\t\tgoto end_rename;\n\t}\n\tif (!new_bh) {\n\t\tretval = ext3_add_entry (handle, new_dentry, old_inode);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t} else {\n\t\tBUFFER_TRACE(new_bh, \"get write access\");\n\t\tretval = ext3_journal_get_write_access(handle, new_bh);\n\t\tif (retval)\n\t\t\tgoto journal_error;\n\t\tnew_de->inode = cpu_to_le32(old_inode->i_ino);\n\t\tif (EXT3_HAS_INCOMPAT_FEATURE(new_dir->i_sb,\n\t\t\t\t\t      EXT3_FEATURE_INCOMPAT_FILETYPE))\n\t\t\tnew_de->file_type = old_de->file_type;\n\t\tnew_dir->i_version++;\n\t\tnew_dir->i_ctime = new_dir->i_mtime = CURRENT_TIME_SEC;\n\t\text3_mark_inode_dirty(handle, new_dir);\n\t\tBUFFER_TRACE(new_bh, \"call ext3_journal_dirty_metadata\");\n\t\tretval = ext3_journal_dirty_metadata(handle, new_bh);\n\t\tif (retval)\n\t\t\tgoto journal_error;\n\t\tbrelse(new_bh);\n\t\tnew_bh = NULL;\n\t}\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n\t * rename.\n\t */\n\told_inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, old_inode);\n\n\t/*\n\t * ok, that's it\n\t */\n\tif (le32_to_cpu(old_de->inode) != old_inode->i_ino ||\n\t    old_de->name_len != old_dentry->d_name.len ||\n\t    strncmp(old_de->name, old_dentry->d_name.name, old_de->name_len) ||\n\t    (retval = ext3_delete_entry(handle, old_dir,\n\t\t\t\t\told_de, old_bh)) == -ENOENT) {\n\t\t/* old_de could have moved from under us during htree split, so\n\t\t * make sure that we are deleting the right entry.  We might\n\t\t * also be pointing to a stale entry in the unused part of\n\t\t * old_bh so just checking inum and the name isn't enough. */\n\t\tstruct buffer_head *old_bh2;\n\t\tstruct ext3_dir_entry_2 *old_de2;\n\n\t\told_bh2 = ext3_find_entry(old_dir, &old_dentry->d_name,\n\t\t\t\t\t  &old_de2);\n\t\tif (old_bh2) {\n\t\t\tretval = ext3_delete_entry(handle, old_dir,\n\t\t\t\t\t\t   old_de2, old_bh2);\n\t\t\tbrelse(old_bh2);\n\t\t}\n\t}\n\tif (retval) {\n\t\text3_warning(old_dir->i_sb, \"ext3_rename\",\n\t\t\t\t\"Deleting old file (%lu), %d, error=%d\",\n\t\t\t\told_dir->i_ino, old_dir->i_nlink, retval);\n\t}\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tnew_inode->i_ctime = CURRENT_TIME_SEC;\n\t}\n\told_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME_SEC;\n\text3_update_dx_flag(old_dir);\n\tif (dir_bh) {\n\t\tBUFFER_TRACE(dir_bh, \"get_write_access\");\n\t\tretval = ext3_journal_get_write_access(handle, dir_bh);\n\t\tif (retval)\n\t\t\tgoto journal_error;\n\t\tPARENT_INO(dir_bh->b_data) = cpu_to_le32(new_dir->i_ino);\n\t\tBUFFER_TRACE(dir_bh, \"call ext3_journal_dirty_metadata\");\n\t\tretval = ext3_journal_dirty_metadata(handle, dir_bh);\n\t\tif (retval) {\njournal_error:\n\t\t\text3_std_error(new_dir->i_sb, retval);\n\t\t\tgoto end_rename;\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tif (new_inode) {\n\t\t\tdrop_nlink(new_inode);\n\t\t} else {\n\t\t\tinc_nlink(new_dir);\n\t\t\text3_update_dx_flag(new_dir);\n\t\t\text3_mark_inode_dirty(handle, new_dir);\n\t\t}\n\t}\n\text3_mark_inode_dirty(handle, old_dir);\n\tif (new_inode) {\n\t\text3_mark_inode_dirty(handle, new_inode);\n\t\tif (!new_inode->i_nlink)\n\t\t\text3_orphan_add(handle, new_inode);\n\t\tif (ext3_should_writeback_data(new_inode))\n\t\t\tflush_file = 1;\n\t}\n\tretval = 0;\n\nend_rename:\n\tbrelse (dir_bh);\n\tbrelse (old_bh);\n\tbrelse (new_bh);\n\text3_journal_stop(handle);\n\tif (retval == 0 && flush_file)\n\t\tfilemap_flush(old_inode->i_mapping);\n\treturn retval;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline unsigned dx_get_block (struct dx_entry *entry);",
      "static inline unsigned dx_get_hash (struct dx_entry *entry);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_flush",
          "args": [
            "old_inode->i_mapping"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_should_writeback_data",
          "args": [
            "new_inode"
          ],
          "line": 2535
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_writeback_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1321-1330",
          "snippet": "static inline int ext3_should_writeback_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_WRITEBACK_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MOUNT_WRITEBACK_DATA\t0x00C00\t/* No data ordering */",
            "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
          ],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_WRITEBACK_DATA\t0x00C00\t/* No data ordering */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_writeback_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_WRITEBACK_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_orphan_add",
          "args": [
            "handle",
            "new_inode"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1967-2028",
          "snippet": "int ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "new_inode"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_update_dx_flag",
          "args": [
            "new_dir"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_update_dx_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "767-772",
          "snippet": "static void ext3_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext3_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "new_dir"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "new_inode"
          ],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "new_dir->i_sb",
            "retval"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "dir_bh"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "dir_bh",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_dir->i_ino"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PARENT_INO",
          "args": [
            "dir_bh->b_data"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "dir_bh"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "dir_bh",
            "\"get_write_access\""
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "old_dir->i_sb",
            "\"ext3_rename\"",
            "\"Deleting old file (%lu), %d, error=%d\"",
            "old_dir->i_ino",
            "old_dir->i_nlink",
            "retval"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_delete_entry",
          "args": [
            "handle",
            "old_dir",
            "old_de2",
            "old_bh2"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1623-1666",
          "snippet": "static int ext3_delete_entry (handle_t *handle,\n\t\t\t      struct inode * dir,\n\t\t\t      struct ext3_dir_entry_2 * de_del,\n\t\t\t      struct buffer_head * bh)\n{\n\tstruct ext3_dir_entry_2 * de, * pde;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\twhile (i < bh->b_size) {\n\t\tif (!ext3_check_dir_entry(\"ext3_delete_entry\", dir, de, bh, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tint err;\n\n\t\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext3_rec_len_to_disk(\n\t\t\t\t\text3_rec_len_from_disk(pde->rec_len) +\n\t\t\t\t\text3_rec_len_from_disk(de->rec_len));\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (err) {\njournal_error:\n\t\t\t\text3_std_error(dir->i_sb, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext3_rec_len_from_disk(de->rec_len);\n\t\tpde = de;\n\t\tde = ext3_next_entry(de);\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_delete_entry (handle_t *handle,\n\t\t\t      struct inode * dir,\n\t\t\t      struct ext3_dir_entry_2 * de_del,\n\t\t\t      struct buffer_head * bh)\n{\n\tstruct ext3_dir_entry_2 * de, * pde;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\twhile (i < bh->b_size) {\n\t\tif (!ext3_check_dir_entry(\"ext3_delete_entry\", dir, de, bh, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tint err;\n\n\t\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext3_rec_len_to_disk(\n\t\t\t\t\text3_rec_len_from_disk(pde->rec_len) +\n\t\t\t\t\text3_rec_len_from_disk(de->rec_len));\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (err) {\njournal_error:\n\t\t\t\text3_std_error(dir->i_sb, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext3_rec_len_from_disk(de->rec_len);\n\t\tpde = de;\n\t\tde = ext3_next_entry(de);\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_find_entry",
          "args": [
            "old_dir",
            "&old_dentry->d_name",
            "&old_de2"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "842-962",
          "snippet": "static struct buffer_head *ext3_find_entry(struct inode *dir,\n\t\t\t\t\tstruct qstr *entry,\n\t\t\t\t\tstruct ext3_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head * bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tconst u8 *name = entry->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = entry->len;\n\tif (namelen > EXT3_NAME_LEN)\n\t\treturn NULL;\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == 0)) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext3_dx_find_entry(dir, entry, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(\"ext3_find_entry: dx failed, falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tstart = EXT3_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext3_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh && !bh_uptodate_or_lock(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\t\tsubmit_bh(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t  bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\text3_error(sb, __func__, \"reading directory #%lu \"\n\t\t\t\t   \"offset %lu\", dir->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\ti = search_dirblock(bh, dir, entry,\n\t\t\t    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT3_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse (bh_use[ra_ptr]);\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [
            "#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
          ],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\n#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext3_find_entry(struct inode *dir,\n\t\t\t\t\tstruct qstr *entry,\n\t\t\t\t\tstruct ext3_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head * bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tconst u8 *name = entry->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = entry->len;\n\tif (namelen > EXT3_NAME_LEN)\n\t\treturn NULL;\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == 0)) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext3_dx_find_entry(dir, entry, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(\"ext3_find_entry: dx failed, falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tstart = EXT3_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext3_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh && !bh_uptodate_or_lock(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\t\tsubmit_bh(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t  bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\text3_error(sb, __func__, \"reading directory #%lu \"\n\t\t\t\t   \"offset %lu\", dir->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\ti = search_dirblock(bh, dir, entry,\n\t\t\t    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT3_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse (bh_use[ra_ptr]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "old_de->name",
            "old_dentry->d_name.name",
            "old_de->name_len"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "old_de->inode"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "new_bh"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "new_bh",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_INCOMPAT_FEATURE",
          "args": [
            "new_dir->i_sb",
            "EXT3_FEATURE_INCOMPAT_FILETYPE"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "old_inode->i_ino"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "new_bh"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "new_bh",
            "\"get write access\""
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_add_entry",
          "args": [
            "handle",
            "new_dentry",
            "old_inode"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1435-1480",
          "snippet": "static int ext3_add_entry (handle_t *handle, struct dentry *dentry,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct super_block * sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\tu32 block, blocks;\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\tif (is_dx(dir)) {\n\t\tretval = ext3_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\tEXT3_I(dir)->i_flags &= ~EXT3_INDEX_FL;\n\t\tdx_fallback++;\n\t\text3_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tif (!(bh = ext3_dir_bread(handle, dir, block, 0, &retval)))\n\t\t\treturn retval;\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC)\n\t\t\treturn retval;\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext3_append(handle, dir, &block, &retval);\n\tif (!bh)\n\t\treturn retval;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext3_rec_len_to_disk(blocksize);\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_add_entry (handle_t *handle, struct dentry *dentry,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct super_block * sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\tu32 block, blocks;\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\tif (is_dx(dir)) {\n\t\tretval = ext3_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\tEXT3_I(dir)->i_flags &= ~EXT3_INDEX_FL;\n\t\tdx_fallback++;\n\t\text3_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tif (!(bh = ext3_dir_bread(handle, dir, block, 0, &retval)))\n\t\t\treturn retval;\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC)\n\t\t\treturn retval;\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext3_append(handle, dir, &block, &retval);\n\tif (!bh)\n\t\treturn retval;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext3_rec_len_to_disk(blocksize);\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PARENT_INO",
          "args": [
            "dir_bh->b_data"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_dir_bread",
          "args": [
            "handle",
            "old_inode",
            "0",
            "0",
            "&retval"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_dir_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.h",
          "lines": "10-27",
          "snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "empty_dir",
          "args": [
            "new_inode"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1889-1957",
          "snippet": "static int empty_dir (struct inode * inode)\n{\n\tunsigned long offset;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 * de, * de1;\n\tstruct super_block * sb;\n\tint err = 0;\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT3_DIR_REC_LEN(1) + EXT3_DIR_REC_LEN(2) ||\n\t    !(bh = ext3_dir_bread(NULL, inode, 0, 0, &err))) {\n\t\tif (err)\n\t\t\text3_error(inode->i_sb, __func__,\n\t\t\t\t   \"error %d reading directory #%lu offset 0\",\n\t\t\t\t   err, inode->i_ino);\n\t\telse\n\t\t\text3_warning(inode->i_sb, __func__,\n\t\t\t\t     \"bad directory (dir #%lu) - no data block\",\n\t\t\t\t     inode->i_ino);\n\t\treturn 1;\n\t}\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde1 = ext3_next_entry(de);\n\tif (le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t\t!le32_to_cpu(de1->inode) ||\n\t\t\tstrcmp (\".\", de->name) ||\n\t\t\tstrcmp (\"..\", de1->name)) {\n\t\text3_warning (inode->i_sb, \"empty_dir\",\n\t\t\t      \"bad directory (dir #%lu) - no `.' or `..'\",\n\t\t\t      inode->i_ino);\n\t\tbrelse (bh);\n\t\treturn 1;\n\t}\n\toffset = ext3_rec_len_from_disk(de->rec_len) +\n\t\t\text3_rec_len_from_disk(de1->rec_len);\n\tde = ext3_next_entry(de1);\n\twhile (offset < inode->i_size ) {\n\t\tif (!bh ||\n\t\t\t(void *) de >= (void *) (bh->b_data+sb->s_blocksize)) {\n\t\t\terr = 0;\n\t\t\tbrelse (bh);\n\t\t\tif (!(bh = ext3_dir_bread (NULL, inode,\n\t\t\t\toffset >> EXT3_BLOCK_SIZE_BITS(sb), 0, &err))) {\n\t\t\t\tif (err)\n\t\t\t\t\text3_error(sb, __func__,\n\t\t\t\t\t\t   \"error %d reading directory\"\n\t\t\t\t\t\t   \" #%lu offset %lu\",\n\t\t\t\t\t\t   err, inode->i_ino, offset);\n\t\t\t\toffset += sb->s_blocksize;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\t\t}\n\t\tif (!ext3_check_dir_entry(\"empty_dir\", inode, de, bh, offset)) {\n\t\t\tde = (struct ext3_dir_entry_2 *)(bh->b_data +\n\t\t\t\t\t\t\t sb->s_blocksize);\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse (bh);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += ext3_rec_len_from_disk(de->rec_len);\n\t\tde = ext3_next_entry(de);\n\t}\n\tbrelse (bh);\n\treturn 1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int empty_dir (struct inode * inode)\n{\n\tunsigned long offset;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 * de, * de1;\n\tstruct super_block * sb;\n\tint err = 0;\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT3_DIR_REC_LEN(1) + EXT3_DIR_REC_LEN(2) ||\n\t    !(bh = ext3_dir_bread(NULL, inode, 0, 0, &err))) {\n\t\tif (err)\n\t\t\text3_error(inode->i_sb, __func__,\n\t\t\t\t   \"error %d reading directory #%lu offset 0\",\n\t\t\t\t   err, inode->i_ino);\n\t\telse\n\t\t\text3_warning(inode->i_sb, __func__,\n\t\t\t\t     \"bad directory (dir #%lu) - no data block\",\n\t\t\t\t     inode->i_ino);\n\t\treturn 1;\n\t}\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde1 = ext3_next_entry(de);\n\tif (le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t\t!le32_to_cpu(de1->inode) ||\n\t\t\tstrcmp (\".\", de->name) ||\n\t\t\tstrcmp (\"..\", de1->name)) {\n\t\text3_warning (inode->i_sb, \"empty_dir\",\n\t\t\t      \"bad directory (dir #%lu) - no `.' or `..'\",\n\t\t\t      inode->i_ino);\n\t\tbrelse (bh);\n\t\treturn 1;\n\t}\n\toffset = ext3_rec_len_from_disk(de->rec_len) +\n\t\t\text3_rec_len_from_disk(de1->rec_len);\n\tde = ext3_next_entry(de1);\n\twhile (offset < inode->i_size ) {\n\t\tif (!bh ||\n\t\t\t(void *) de >= (void *) (bh->b_data+sb->s_blocksize)) {\n\t\t\terr = 0;\n\t\t\tbrelse (bh);\n\t\t\tif (!(bh = ext3_dir_bread (NULL, inode,\n\t\t\t\toffset >> EXT3_BLOCK_SIZE_BITS(sb), 0, &err))) {\n\t\t\t\tif (err)\n\t\t\t\t\text3_error(sb, __func__,\n\t\t\t\t\t\t   \"error %d reading directory\"\n\t\t\t\t\t\t   \" #%lu offset %lu\",\n\t\t\t\t\t\t   err, inode->i_ino, offset);\n\t\t\t\toffset += sb->s_blocksize;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\t\t}\n\t\tif (!ext3_check_dir_entry(\"empty_dir\", inode, de, bh, offset)) {\n\t\t\tde = (struct ext3_dir_entry_2 *)(bh->b_data +\n\t\t\t\t\t\t\t sb->s_blocksize);\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse (bh);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += ext3_rec_len_from_disk(de->rec_len);\n\t\tde = ext3_next_entry(de);\n\t}\n\tbrelse (bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "new_dir"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "old_dir"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "old_dir",
            "2 *\n\t\t\t\t\tEXT3_DATA_TRANS_BLOCKS(old_dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 2"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DATA_TRANS_BLOCKS",
          "args": [
            "old_dir->i_sb"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "new_dentry->d_inode"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_rename (struct inode * old_dir, struct dentry *old_dentry,\n\t\t\t   struct inode * new_dir,struct dentry *new_dentry)\n{\n\thandle_t *handle;\n\tstruct inode * old_inode, * new_inode;\n\tstruct buffer_head * old_bh, * new_bh, * dir_bh;\n\tstruct ext3_dir_entry_2 * old_de, * new_de;\n\tint retval, flush_file = 0;\n\n\tdquot_initialize(old_dir);\n\tdquot_initialize(new_dir);\n\n\told_bh = new_bh = dir_bh = NULL;\n\n\t/* Initialize quotas before so that eventual writes go\n\t * in separate transaction */\n\tif (new_dentry->d_inode)\n\t\tdquot_initialize(new_dentry->d_inode);\n\thandle = ext3_journal_start(old_dir, 2 *\n\t\t\t\t\tEXT3_DATA_TRANS_BLOCKS(old_dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))\n\t\thandle->h_sync = 1;\n\n\told_bh = ext3_find_entry(old_dir, &old_dentry->d_name, &old_de);\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\told_inode = old_dentry->d_inode;\n\tretval = -ENOENT;\n\tif (!old_bh || le32_to_cpu(old_de->inode) != old_inode->i_ino)\n\t\tgoto end_rename;\n\n\tnew_inode = new_dentry->d_inode;\n\tnew_bh = ext3_find_entry(new_dir, &new_dentry->d_name, &new_de);\n\tif (new_bh) {\n\t\tif (!new_inode) {\n\t\t\tbrelse (new_bh);\n\t\t\tnew_bh = NULL;\n\t\t}\n\t}\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\tif (new_inode) {\n\t\t\tretval = -ENOTEMPTY;\n\t\t\tif (!empty_dir (new_inode))\n\t\t\t\tgoto end_rename;\n\t\t}\n\t\tretval = -EIO;\n\t\tdir_bh = ext3_dir_bread(handle, old_inode, 0, 0, &retval);\n\t\tif (!dir_bh)\n\t\t\tgoto end_rename;\n\t\tif (le32_to_cpu(PARENT_INO(dir_bh->b_data)) != old_dir->i_ino)\n\t\t\tgoto end_rename;\n\t\tretval = -EMLINK;\n\t\tif (!new_inode && new_dir!=old_dir &&\n\t\t\t\tnew_dir->i_nlink >= EXT3_LINK_MAX)\n\t\t\tgoto end_rename;\n\t}\n\tif (!new_bh) {\n\t\tretval = ext3_add_entry (handle, new_dentry, old_inode);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t} else {\n\t\tBUFFER_TRACE(new_bh, \"get write access\");\n\t\tretval = ext3_journal_get_write_access(handle, new_bh);\n\t\tif (retval)\n\t\t\tgoto journal_error;\n\t\tnew_de->inode = cpu_to_le32(old_inode->i_ino);\n\t\tif (EXT3_HAS_INCOMPAT_FEATURE(new_dir->i_sb,\n\t\t\t\t\t      EXT3_FEATURE_INCOMPAT_FILETYPE))\n\t\t\tnew_de->file_type = old_de->file_type;\n\t\tnew_dir->i_version++;\n\t\tnew_dir->i_ctime = new_dir->i_mtime = CURRENT_TIME_SEC;\n\t\text3_mark_inode_dirty(handle, new_dir);\n\t\tBUFFER_TRACE(new_bh, \"call ext3_journal_dirty_metadata\");\n\t\tretval = ext3_journal_dirty_metadata(handle, new_bh);\n\t\tif (retval)\n\t\t\tgoto journal_error;\n\t\tbrelse(new_bh);\n\t\tnew_bh = NULL;\n\t}\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n\t * rename.\n\t */\n\told_inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, old_inode);\n\n\t/*\n\t * ok, that's it\n\t */\n\tif (le32_to_cpu(old_de->inode) != old_inode->i_ino ||\n\t    old_de->name_len != old_dentry->d_name.len ||\n\t    strncmp(old_de->name, old_dentry->d_name.name, old_de->name_len) ||\n\t    (retval = ext3_delete_entry(handle, old_dir,\n\t\t\t\t\told_de, old_bh)) == -ENOENT) {\n\t\t/* old_de could have moved from under us during htree split, so\n\t\t * make sure that we are deleting the right entry.  We might\n\t\t * also be pointing to a stale entry in the unused part of\n\t\t * old_bh so just checking inum and the name isn't enough. */\n\t\tstruct buffer_head *old_bh2;\n\t\tstruct ext3_dir_entry_2 *old_de2;\n\n\t\told_bh2 = ext3_find_entry(old_dir, &old_dentry->d_name,\n\t\t\t\t\t  &old_de2);\n\t\tif (old_bh2) {\n\t\t\tretval = ext3_delete_entry(handle, old_dir,\n\t\t\t\t\t\t   old_de2, old_bh2);\n\t\t\tbrelse(old_bh2);\n\t\t}\n\t}\n\tif (retval) {\n\t\text3_warning(old_dir->i_sb, \"ext3_rename\",\n\t\t\t\t\"Deleting old file (%lu), %d, error=%d\",\n\t\t\t\told_dir->i_ino, old_dir->i_nlink, retval);\n\t}\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tnew_inode->i_ctime = CURRENT_TIME_SEC;\n\t}\n\told_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME_SEC;\n\text3_update_dx_flag(old_dir);\n\tif (dir_bh) {\n\t\tBUFFER_TRACE(dir_bh, \"get_write_access\");\n\t\tretval = ext3_journal_get_write_access(handle, dir_bh);\n\t\tif (retval)\n\t\t\tgoto journal_error;\n\t\tPARENT_INO(dir_bh->b_data) = cpu_to_le32(new_dir->i_ino);\n\t\tBUFFER_TRACE(dir_bh, \"call ext3_journal_dirty_metadata\");\n\t\tretval = ext3_journal_dirty_metadata(handle, dir_bh);\n\t\tif (retval) {\njournal_error:\n\t\t\text3_std_error(new_dir->i_sb, retval);\n\t\t\tgoto end_rename;\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tif (new_inode) {\n\t\t\tdrop_nlink(new_inode);\n\t\t} else {\n\t\t\tinc_nlink(new_dir);\n\t\t\text3_update_dx_flag(new_dir);\n\t\t\text3_mark_inode_dirty(handle, new_dir);\n\t\t}\n\t}\n\text3_mark_inode_dirty(handle, old_dir);\n\tif (new_inode) {\n\t\text3_mark_inode_dirty(handle, new_inode);\n\t\tif (!new_inode->i_nlink)\n\t\t\text3_orphan_add(handle, new_inode);\n\t\tif (ext3_should_writeback_data(new_inode))\n\t\t\tflush_file = 1;\n\t}\n\tretval = 0;\n\nend_rename:\n\tbrelse (dir_bh);\n\tbrelse (old_bh);\n\tbrelse (new_bh);\n\text3_journal_stop(handle);\n\tif (retval == 0 && flush_file)\n\t\tfilemap_flush(old_inode->i_mapping);\n\treturn retval;\n}"
  },
  {
    "function_name": "ext3_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "2327-2369",
    "snippet": "static int ext3_link (struct dentry * old_dentry,\n\t\tstruct inode * dir, struct dentry *dentry)\n{\n\thandle_t *handle;\n\tstruct inode *inode = old_dentry->d_inode;\n\tint err, retries = 0;\n\n\tif (inode->i_nlink >= EXT3_LINK_MAX)\n\t\treturn -EMLINK;\n\n\tdquot_initialize(dir);\n\nretry:\n\thandle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tinc_nlink(inode);\n\tihold(inode);\n\n\terr = ext3_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text3_mark_inode_dirty(handle, inode);\n\t\t/* this can happen only for tmpfile being\n\t\t * linked the first time\n\t\t */\n\t\tif (inode->i_nlink == 1)\n\t\t\text3_orphan_del(handle, inode);\n\t\td_instantiate(dentry, inode);\n\t} else {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t}\n\text3_journal_stop(handle);\n\tif (err == -ENOSPC && ext3_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_should_retry_alloc",
          "args": [
            "dir->i_sb",
            "&retries"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1462-1470",
          "snippet": "int ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_orphan_del",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "2034-2101",
          "snippet": "int ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_add_entry",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1435-1480",
          "snippet": "static int ext3_add_entry (handle_t *handle, struct dentry *dentry,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct super_block * sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\tu32 block, blocks;\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\tif (is_dx(dir)) {\n\t\tretval = ext3_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\tEXT3_I(dir)->i_flags &= ~EXT3_INDEX_FL;\n\t\tdx_fallback++;\n\t\text3_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tif (!(bh = ext3_dir_bread(handle, dir, block, 0, &retval)))\n\t\t\treturn retval;\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC)\n\t\t\treturn retval;\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext3_append(handle, dir, &block, &retval);\n\tif (!bh)\n\t\treturn retval;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext3_rec_len_to_disk(blocksize);\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_add_entry (handle_t *handle, struct dentry *dentry,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct super_block * sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\tu32 block, blocks;\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\tif (is_dx(dir)) {\n\t\tretval = ext3_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\tEXT3_I(dir)->i_flags &= ~EXT3_INDEX_FL;\n\t\tdx_fallback++;\n\t\text3_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tif (!(bh = ext3_dir_bread(handle, dir, block, 0, &retval)))\n\t\t\treturn retval;\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC)\n\t\t\treturn retval;\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext3_append(handle, dir, &block, &retval);\n\tif (!bh)\n\t\treturn retval;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext3_rec_len_to_disk(blocksize);\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "dir",
            "EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 1"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_link (struct dentry * old_dentry,\n\t\tstruct inode * dir, struct dentry *dentry)\n{\n\thandle_t *handle;\n\tstruct inode *inode = old_dentry->d_inode;\n\tint err, retries = 0;\n\n\tif (inode->i_nlink >= EXT3_LINK_MAX)\n\t\treturn -EMLINK;\n\n\tdquot_initialize(dir);\n\nretry:\n\thandle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tinc_nlink(inode);\n\tihold(inode);\n\n\terr = ext3_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text3_mark_inode_dirty(handle, inode);\n\t\t/* this can happen only for tmpfile being\n\t\t * linked the first time\n\t\t */\n\t\tif (inode->i_nlink == 1)\n\t\t\text3_orphan_del(handle, inode);\n\t\td_instantiate(dentry, inode);\n\t} else {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t}\n\text3_journal_stop(handle);\n\tif (err == -ENOSPC && ext3_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "2222-2325",
    "snippet": "static int ext3_symlink (struct inode * dir,\n\t\tstruct dentry *dentry, const char * symname)\n{\n\thandle_t *handle;\n\tstruct inode * inode;\n\tint l, err, retries = 0;\n\tint credits;\n\n\tl = strlen(symname)+1;\n\tif (l > dir->i_sb->s_blocksize)\n\t\treturn -ENAMETOOLONG;\n\n\tdquot_initialize(dir);\n\n\tif (l > EXT3_N_BLOCKS * 4) {\n\t\t/*\n\t\t * For non-fast symlinks, we just allocate inode and put it on\n\t\t * orphan list in the first transaction => we need bitmap,\n\t\t * group descriptor, sb, inode block, quota blocks, and\n\t\t * possibly selinux xattr blocks.\n\t\t */\n\t\tcredits = 4 + EXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +\n\t\t\t  EXT3_XATTR_TRANS_BLOCKS;\n\t} else {\n\t\t/*\n\t\t * Fast symlink. We have to add entry to directory\n\t\t * (EXT3_DATA_TRANS_BLOCKS + EXT3_INDEX_EXTRA_TRANS_BLOCKS),\n\t\t * allocate new inode (bitmap, group descriptor, inode block,\n\t\t * quota blocks, sb is already counted in previous macros).\n\t\t */\n\t\tcredits = EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t  EXT3_INDEX_EXTRA_TRANS_BLOCKS + 3 +\n\t\t\t  EXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb);\n\t}\nretry:\n\thandle = ext3_journal_start(dir, credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tinode = ext3_new_inode (handle, dir, &dentry->d_name, S_IFLNK|S_IRWXUGO);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_stop;\n\n\tif (l > EXT3_N_BLOCKS * 4) {\n\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\text3_set_aops(inode);\n\t\t/*\n\t\t * We cannot call page_symlink() with transaction started\n\t\t * because it calls into ext3_write_begin() which acquires page\n\t\t * lock which ranks below transaction start (and it can also\n\t\t * wait for journal commit if we are running out of space). So\n\t\t * we have to stop transaction now and restart it when symlink\n\t\t * contents is written. \n\t\t *\n\t\t * To keep fs consistent in case of crash, we have to put inode\n\t\t * to orphan list in the mean time.\n\t\t */\n\t\tdrop_nlink(inode);\n\t\terr = ext3_orphan_add(handle, inode);\n\t\text3_journal_stop(handle);\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t\terr = __page_symlink(inode, symname, l, 1);\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t\t/*\n\t\t * Now inode is being linked into dir (EXT3_DATA_TRANS_BLOCKS\n\t\t * + EXT3_INDEX_EXTRA_TRANS_BLOCKS), inode is also modified\n\t\t */\n\t\thandle = ext3_journal_start(dir,\n\t\t\t\tEXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto err_drop_inode;\n\t\t}\n\t\tset_nlink(inode, 1);\n\t\terr = ext3_orphan_del(handle, inode);\n\t\tif (err) {\n\t\t\text3_journal_stop(handle);\n\t\t\tdrop_nlink(inode);\n\t\t\tgoto err_drop_inode;\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\tmemcpy((char*)&EXT3_I(inode)->i_data,symname,l);\n\t\tinode->i_size = l-1;\n\t}\n\tEXT3_I(inode)->i_disksize = inode->i_size;\n\terr = ext3_add_nondir(handle, dentry, inode);\nout_stop:\n\text3_journal_stop(handle);\n\tif (err == -ENOSPC && ext3_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\nerr_drop_inode:\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline unsigned dx_get_block (struct dx_entry *entry);",
      "static inline unsigned dx_get_hash (struct dx_entry *entry);",
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_should_retry_alloc",
          "args": [
            "dir->i_sb",
            "&retries"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1462-1470",
          "snippet": "int ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_add_nondir",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1668-1682",
          "snippet": "static int ext3_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext3_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text3_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext3_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text3_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char*)&EXT3_I(inode)->i_data",
            "symname",
            "l"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_orphan_del",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "2034-2101",
          "snippet": "int ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "dir",
            "EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 1"
          ],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__page_symlink",
          "args": [
            "inode",
            "symname",
            "l",
            "1"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "__page_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4497-4529",
          "snippet": "int __page_symlink(struct inode *inode, const char *symname, int len, int nofs)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\tchar *kaddr;\n\tunsigned int flags = AOP_FLAG_UNINTERRUPTIBLE;\n\tif (nofs)\n\t\tflags |= AOP_FLAG_NOFS;\n\nretry:\n\terr = pagecache_write_begin(NULL, mapping, 0, len-1,\n\t\t\t\tflags, &page, &fsdata);\n\tif (err)\n\t\tgoto fail;\n\n\tkaddr = kmap_atomic(page);\n\tmemcpy(kaddr, symname, len-1);\n\tkunmap_atomic(kaddr);\n\n\terr = pagecache_write_end(NULL, mapping, 0, len-1, len-1,\n\t\t\t\t\t\t\tpage, fsdata);\n\tif (err < 0)\n\t\tgoto fail;\n\tif (err < len-1)\n\t\tgoto retry;\n\n\tmark_inode_dirty(inode);\n\treturn 0;\nfail:\n\treturn err;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint __page_symlink(struct inode *inode, const char *symname, int len, int nofs)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\tchar *kaddr;\n\tunsigned int flags = AOP_FLAG_UNINTERRUPTIBLE;\n\tif (nofs)\n\t\tflags |= AOP_FLAG_NOFS;\n\nretry:\n\terr = pagecache_write_begin(NULL, mapping, 0, len-1,\n\t\t\t\tflags, &page, &fsdata);\n\tif (err)\n\t\tgoto fail;\n\n\tkaddr = kmap_atomic(page);\n\tmemcpy(kaddr, symname, len-1);\n\tkunmap_atomic(kaddr);\n\n\terr = pagecache_write_end(NULL, mapping, 0, len-1, len-1,\n\t\t\t\t\t\t\tpage, fsdata);\n\tif (err < 0)\n\t\tgoto fail;\n\tif (err < len-1)\n\t\tgoto retry;\n\n\tmark_inode_dirty(inode);\n\treturn 0;\nfail:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1967-2028",
          "snippet": "int ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_set_aops",
          "args": [
            "inode"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_aops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1979-1987",
          "snippet": "void ext3_set_aops(struct inode *inode)\n{\n\tif (ext3_should_order_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_ordered_aops;\n\telse if (ext3_should_writeback_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_writeback_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext3_journalled_aops;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static const struct address_space_operations ext3_ordered_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_ordered_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_ordered_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.is_dirty_writeback\t= buffer_check_dirty_writeback,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext3_writeback_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_writeback_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_writeback_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext3_journalled_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_journalled_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_journalled_write_end,\n\t.set_page_dirty\t\t= ext3_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic const struct address_space_operations ext3_ordered_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_ordered_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_ordered_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.is_dirty_writeback\t= buffer_check_dirty_writeback,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext3_writeback_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_writeback_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_writeback_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext3_journalled_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_journalled_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_journalled_write_end,\n\t.set_page_dirty\t\t= ext3_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext3_set_aops(struct inode *inode)\n{\n\tif (ext3_should_order_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_ordered_aops;\n\telse if (ext3_should_writeback_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_writeback_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext3_journalled_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_new_inode",
          "args": [
            "handle",
            "dir",
            "&dentry->d_name",
            "S_IFLNK|S_IRWXUGO"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "346-567",
          "snippet": "struct inode *ext3_new_inode(handle_t *handle, struct inode * dir,\n\t\t\t     const struct qstr *qstr, umode_t mode)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group;\n\tunsigned long ino = 0;\n\tstruct inode * inode;\n\tstruct ext3_group_desc * gdp = NULL;\n\tstruct ext3_super_block * es;\n\tstruct ext3_inode_info *ei;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0;\n\tstruct inode *ret;\n\tint i;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\ttrace_ext3_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT3_I(inode);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode))\n\t\tgroup = find_group_orlov(sb, dir);\n\telse\n\t\tgroup = find_group_other(sb, dir);\n\n\terr = -ENOSPC;\n\tif (group == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\terr = -EIO;\n\n\t\tgdp = ext3_get_group_desc(sb, group, &bh2);\n\t\tif (!gdp)\n\t\t\tgoto fail;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh)\n\t\t\tgoto fail;\n\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext3_find_next_zero_bit((unsigned long *)\n\t\t\t\tbitmap_bh->b_data, EXT3_INODES_PER_GROUP(sb), ino);\n\t\tif (ino < EXT3_INODES_PER_GROUP(sb)) {\n\n\t\t\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bitmap_bh);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!ext3_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t\t/* we won it */\n\t\t\t\tBUFFER_TRACE(bitmap_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto got;\n\t\t\t}\n\t\t\t/* we lost it */\n\t\t\tjournal_release_buffer(handle, bitmap_bh);\n\n\t\t\tif (++ino < EXT3_INODES_PER_GROUP(sb))\n\t\t\t\tgoto repeat_in_this_group;\n\t\t}\n\n\t\t/*\n\t\t * This case is possible in concurrent environment.  It is very\n\t\t * rare.  We cannot repeat the find_group_xxx() call because\n\t\t * that will simply return the same blockgroup, because the\n\t\t * group descriptor metadata has not yet been updated.\n\t\t * So we just go onto the next blockgroup.\n\t\t */\n\t\tif (++group == sbi->s_groups_count)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tino += group * EXT3_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d, inode=%lu\", group, ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tBUFFER_TRACE(bh2, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh2);\n\tif (err) goto fail;\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh2);\n\tif (err) goto fail;\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\tei->i_flags =\n\t\text3_mask_flags(mode, EXT3_I(dir)->i_flags & EXT3_FL_INHERITED);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n#endif\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\n\text3_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\thandle->h_sync = 1;\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\tei->i_state_flags = 0;\n\text3_set_inode_state(inode, EXT3_STATE_NEW);\n\n\t/* See comment in ext3_iget for explanation */\n\tif (ino >= EXT3_FIRST_INO(sb) + 1 &&\n\t    EXT3_INODE_SIZE(sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize =\n\t\t\tsizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE;\n\t} else {\n\t\tei->i_extra_isize = 0;\n\t}\n\n\tret = inode;\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext3_init_acl(handle, inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_init_security(handle, inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text3_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text3_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext3_allocate_inode(inode, dir, mode);\n\tgoto really_out;\nfail:\n\text3_std_error(sb, err);\nout:\n\tiput(inode);\n\tret = ERR_PTR(err);\nreally_out:\n\tbrelse(bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tbrelse(bitmap_bh);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext3_new_inode(handle_t *handle, struct inode * dir,\n\t\t\t     const struct qstr *qstr, umode_t mode)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group;\n\tunsigned long ino = 0;\n\tstruct inode * inode;\n\tstruct ext3_group_desc * gdp = NULL;\n\tstruct ext3_super_block * es;\n\tstruct ext3_inode_info *ei;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0;\n\tstruct inode *ret;\n\tint i;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\ttrace_ext3_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT3_I(inode);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode))\n\t\tgroup = find_group_orlov(sb, dir);\n\telse\n\t\tgroup = find_group_other(sb, dir);\n\n\terr = -ENOSPC;\n\tif (group == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\terr = -EIO;\n\n\t\tgdp = ext3_get_group_desc(sb, group, &bh2);\n\t\tif (!gdp)\n\t\t\tgoto fail;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh)\n\t\t\tgoto fail;\n\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext3_find_next_zero_bit((unsigned long *)\n\t\t\t\tbitmap_bh->b_data, EXT3_INODES_PER_GROUP(sb), ino);\n\t\tif (ino < EXT3_INODES_PER_GROUP(sb)) {\n\n\t\t\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bitmap_bh);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!ext3_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t\t/* we won it */\n\t\t\t\tBUFFER_TRACE(bitmap_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto got;\n\t\t\t}\n\t\t\t/* we lost it */\n\t\t\tjournal_release_buffer(handle, bitmap_bh);\n\n\t\t\tif (++ino < EXT3_INODES_PER_GROUP(sb))\n\t\t\t\tgoto repeat_in_this_group;\n\t\t}\n\n\t\t/*\n\t\t * This case is possible in concurrent environment.  It is very\n\t\t * rare.  We cannot repeat the find_group_xxx() call because\n\t\t * that will simply return the same blockgroup, because the\n\t\t * group descriptor metadata has not yet been updated.\n\t\t * So we just go onto the next blockgroup.\n\t\t */\n\t\tif (++group == sbi->s_groups_count)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tino += group * EXT3_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d, inode=%lu\", group, ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tBUFFER_TRACE(bh2, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh2);\n\tif (err) goto fail;\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh2);\n\tif (err) goto fail;\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\tei->i_flags =\n\t\text3_mask_flags(mode, EXT3_I(dir)->i_flags & EXT3_FL_INHERITED);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n#endif\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\n\text3_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\thandle->h_sync = 1;\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\tei->i_state_flags = 0;\n\text3_set_inode_state(inode, EXT3_STATE_NEW);\n\n\t/* See comment in ext3_iget for explanation */\n\tif (ino >= EXT3_FIRST_INO(sb) + 1 &&\n\t    EXT3_INODE_SIZE(sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize =\n\t\t\tsizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE;\n\t} else {\n\t\tei->i_extra_isize = 0;\n\t}\n\n\tret = inode;\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext3_init_acl(handle, inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_init_security(handle, inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text3_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text3_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext3_allocate_inode(inode, dir, mode);\n\tgoto really_out;\nfail:\n\text3_std_error(sb, err);\nout:\n\tiput(inode);\n\tret = ERR_PTR(err);\nreally_out:\n\tbrelse(bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tbrelse(bitmap_bh);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_MAXQUOTAS_INIT_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_MAXQUOTAS_INIT_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_symlink (struct inode * dir,\n\t\tstruct dentry *dentry, const char * symname)\n{\n\thandle_t *handle;\n\tstruct inode * inode;\n\tint l, err, retries = 0;\n\tint credits;\n\n\tl = strlen(symname)+1;\n\tif (l > dir->i_sb->s_blocksize)\n\t\treturn -ENAMETOOLONG;\n\n\tdquot_initialize(dir);\n\n\tif (l > EXT3_N_BLOCKS * 4) {\n\t\t/*\n\t\t * For non-fast symlinks, we just allocate inode and put it on\n\t\t * orphan list in the first transaction => we need bitmap,\n\t\t * group descriptor, sb, inode block, quota blocks, and\n\t\t * possibly selinux xattr blocks.\n\t\t */\n\t\tcredits = 4 + EXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +\n\t\t\t  EXT3_XATTR_TRANS_BLOCKS;\n\t} else {\n\t\t/*\n\t\t * Fast symlink. We have to add entry to directory\n\t\t * (EXT3_DATA_TRANS_BLOCKS + EXT3_INDEX_EXTRA_TRANS_BLOCKS),\n\t\t * allocate new inode (bitmap, group descriptor, inode block,\n\t\t * quota blocks, sb is already counted in previous macros).\n\t\t */\n\t\tcredits = EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t  EXT3_INDEX_EXTRA_TRANS_BLOCKS + 3 +\n\t\t\t  EXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb);\n\t}\nretry:\n\thandle = ext3_journal_start(dir, credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tinode = ext3_new_inode (handle, dir, &dentry->d_name, S_IFLNK|S_IRWXUGO);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_stop;\n\n\tif (l > EXT3_N_BLOCKS * 4) {\n\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\text3_set_aops(inode);\n\t\t/*\n\t\t * We cannot call page_symlink() with transaction started\n\t\t * because it calls into ext3_write_begin() which acquires page\n\t\t * lock which ranks below transaction start (and it can also\n\t\t * wait for journal commit if we are running out of space). So\n\t\t * we have to stop transaction now and restart it when symlink\n\t\t * contents is written. \n\t\t *\n\t\t * To keep fs consistent in case of crash, we have to put inode\n\t\t * to orphan list in the mean time.\n\t\t */\n\t\tdrop_nlink(inode);\n\t\terr = ext3_orphan_add(handle, inode);\n\t\text3_journal_stop(handle);\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t\terr = __page_symlink(inode, symname, l, 1);\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t\t/*\n\t\t * Now inode is being linked into dir (EXT3_DATA_TRANS_BLOCKS\n\t\t * + EXT3_INDEX_EXTRA_TRANS_BLOCKS), inode is also modified\n\t\t */\n\t\thandle = ext3_journal_start(dir,\n\t\t\t\tEXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto err_drop_inode;\n\t\t}\n\t\tset_nlink(inode, 1);\n\t\terr = ext3_orphan_del(handle, inode);\n\t\tif (err) {\n\t\t\text3_journal_stop(handle);\n\t\t\tdrop_nlink(inode);\n\t\t\tgoto err_drop_inode;\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\tmemcpy((char*)&EXT3_I(inode)->i_data,symname,l);\n\t\tinode->i_size = l-1;\n\t}\n\tEXT3_I(inode)->i_disksize = inode->i_size;\n\terr = ext3_add_nondir(handle, dentry, inode);\nout_stop:\n\text3_journal_stop(handle);\n\tif (err == -ENOSPC && ext3_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\nerr_drop_inode:\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "2164-2220",
    "snippet": "static int ext3_unlink(struct inode * dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode * inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 * de;\n\thandle_t *handle;\n\n\ttrace_ext3_unlink_enter(dir, dentry);\n\t/* Initialize quotas before so that eventual writes go\n\t * in separate transaction */\n\tdquot_initialize(dir);\n\tdquot_initialize(dentry->d_inode);\n\n\thandle = ext3_journal_start(dir, EXT3_DELETE_TRANS_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tretval = -ENOENT;\n\tbh = ext3_find_entry(dir, &dentry->d_name, &de);\n\tif (!bh)\n\t\tgoto end_unlink;\n\n\tinode = dentry->d_inode;\n\n\tretval = -EIO;\n\tif (le32_to_cpu(de->inode) != inode->i_ino)\n\t\tgoto end_unlink;\n\n\tif (!inode->i_nlink) {\n\t\text3_warning (inode->i_sb, \"ext3_unlink\",\n\t\t\t      \"Deleting nonexistent file (%lu), %d\",\n\t\t\t      inode->i_ino, inode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\tretval = ext3_delete_entry(handle, dir, de, bh);\n\tif (retval)\n\t\tgoto end_unlink;\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;\n\text3_update_dx_flag(dir);\n\text3_mark_inode_dirty(handle, dir);\n\tdrop_nlink(inode);\n\tif (!inode->i_nlink)\n\t\text3_orphan_add(handle, inode);\n\tinode->i_ctime = dir->i_ctime;\n\text3_mark_inode_dirty(handle, inode);\n\tretval = 0;\n\nend_unlink:\n\text3_journal_stop(handle);\n\tbrelse (bh);\n\ttrace_ext3_unlink_exit(dentry, retval);\n\treturn retval;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext3_unlink_exit",
          "args": [
            "dentry",
            "retval"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1967-2028",
          "snippet": "int ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_update_dx_flag",
          "args": [
            "dir"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_update_dx_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "767-772",
          "snippet": "static void ext3_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext3_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_delete_entry",
          "args": [
            "handle",
            "dir",
            "de",
            "bh"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1623-1666",
          "snippet": "static int ext3_delete_entry (handle_t *handle,\n\t\t\t      struct inode * dir,\n\t\t\t      struct ext3_dir_entry_2 * de_del,\n\t\t\t      struct buffer_head * bh)\n{\n\tstruct ext3_dir_entry_2 * de, * pde;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\twhile (i < bh->b_size) {\n\t\tif (!ext3_check_dir_entry(\"ext3_delete_entry\", dir, de, bh, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tint err;\n\n\t\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext3_rec_len_to_disk(\n\t\t\t\t\text3_rec_len_from_disk(pde->rec_len) +\n\t\t\t\t\text3_rec_len_from_disk(de->rec_len));\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (err) {\njournal_error:\n\t\t\t\text3_std_error(dir->i_sb, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext3_rec_len_from_disk(de->rec_len);\n\t\tpde = de;\n\t\tde = ext3_next_entry(de);\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_delete_entry (handle_t *handle,\n\t\t\t      struct inode * dir,\n\t\t\t      struct ext3_dir_entry_2 * de_del,\n\t\t\t      struct buffer_head * bh)\n{\n\tstruct ext3_dir_entry_2 * de, * pde;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\twhile (i < bh->b_size) {\n\t\tif (!ext3_check_dir_entry(\"ext3_delete_entry\", dir, de, bh, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tint err;\n\n\t\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext3_rec_len_to_disk(\n\t\t\t\t\text3_rec_len_from_disk(pde->rec_len) +\n\t\t\t\t\text3_rec_len_from_disk(de->rec_len));\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (err) {\njournal_error:\n\t\t\t\text3_std_error(dir->i_sb, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext3_rec_len_from_disk(de->rec_len);\n\t\tpde = de;\n\t\tde = ext3_next_entry(de);\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "inode->i_sb",
            "\"ext3_unlink\"",
            "\"Deleting nonexistent file (%lu), %d\"",
            "inode->i_ino",
            "inode->i_nlink"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_find_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "&de"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "842-962",
          "snippet": "static struct buffer_head *ext3_find_entry(struct inode *dir,\n\t\t\t\t\tstruct qstr *entry,\n\t\t\t\t\tstruct ext3_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head * bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tconst u8 *name = entry->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = entry->len;\n\tif (namelen > EXT3_NAME_LEN)\n\t\treturn NULL;\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == 0)) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext3_dx_find_entry(dir, entry, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(\"ext3_find_entry: dx failed, falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tstart = EXT3_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext3_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh && !bh_uptodate_or_lock(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\t\tsubmit_bh(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t  bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\text3_error(sb, __func__, \"reading directory #%lu \"\n\t\t\t\t   \"offset %lu\", dir->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\ti = search_dirblock(bh, dir, entry,\n\t\t\t    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT3_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse (bh_use[ra_ptr]);\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [
            "#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
          ],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\n#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext3_find_entry(struct inode *dir,\n\t\t\t\t\tstruct qstr *entry,\n\t\t\t\t\tstruct ext3_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head * bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tconst u8 *name = entry->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = entry->len;\n\tif (namelen > EXT3_NAME_LEN)\n\t\treturn NULL;\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == 0)) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext3_dx_find_entry(dir, entry, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(\"ext3_find_entry: dx failed, falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tstart = EXT3_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext3_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh && !bh_uptodate_or_lock(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\t\tsubmit_bh(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t  bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\text3_error(sb, __func__, \"reading directory #%lu \"\n\t\t\t\t   \"offset %lu\", dir->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\ti = search_dirblock(bh, dir, entry,\n\t\t\t    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT3_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse (bh_use[ra_ptr]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "dir",
            "EXT3_DELETE_TRANS_BLOCKS(dir->i_sb)"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DELETE_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dentry->d_inode"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext3_unlink_enter",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_unlink(struct inode * dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode * inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 * de;\n\thandle_t *handle;\n\n\ttrace_ext3_unlink_enter(dir, dentry);\n\t/* Initialize quotas before so that eventual writes go\n\t * in separate transaction */\n\tdquot_initialize(dir);\n\tdquot_initialize(dentry->d_inode);\n\n\thandle = ext3_journal_start(dir, EXT3_DELETE_TRANS_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tretval = -ENOENT;\n\tbh = ext3_find_entry(dir, &dentry->d_name, &de);\n\tif (!bh)\n\t\tgoto end_unlink;\n\n\tinode = dentry->d_inode;\n\n\tretval = -EIO;\n\tif (le32_to_cpu(de->inode) != inode->i_ino)\n\t\tgoto end_unlink;\n\n\tif (!inode->i_nlink) {\n\t\text3_warning (inode->i_sb, \"ext3_unlink\",\n\t\t\t      \"Deleting nonexistent file (%lu), %d\",\n\t\t\t      inode->i_ino, inode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\tretval = ext3_delete_entry(handle, dir, de, bh);\n\tif (retval)\n\t\tgoto end_unlink;\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;\n\text3_update_dx_flag(dir);\n\text3_mark_inode_dirty(handle, dir);\n\tdrop_nlink(inode);\n\tif (!inode->i_nlink)\n\t\text3_orphan_add(handle, inode);\n\tinode->i_ctime = dir->i_ctime;\n\text3_mark_inode_dirty(handle, inode);\n\tretval = 0;\n\nend_unlink:\n\text3_journal_stop(handle);\n\tbrelse (bh);\n\ttrace_ext3_unlink_exit(dentry, retval);\n\treturn retval;\n}"
  },
  {
    "function_name": "ext3_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "2103-2162",
    "snippet": "static int ext3_rmdir (struct inode * dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode * inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 * de;\n\thandle_t *handle;\n\n\t/* Initialize quotas before so that eventual writes go in\n\t * separate transaction */\n\tdquot_initialize(dir);\n\tdquot_initialize(dentry->d_inode);\n\n\thandle = ext3_journal_start(dir, EXT3_DELETE_TRANS_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tretval = -ENOENT;\n\tbh = ext3_find_entry(dir, &dentry->d_name, &de);\n\tif (!bh)\n\t\tgoto end_rmdir;\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tinode = dentry->d_inode;\n\n\tretval = -EIO;\n\tif (le32_to_cpu(de->inode) != inode->i_ino)\n\t\tgoto end_rmdir;\n\n\tretval = -ENOTEMPTY;\n\tif (!empty_dir (inode))\n\t\tgoto end_rmdir;\n\n\tretval = ext3_delete_entry(handle, dir, de, bh);\n\tif (retval)\n\t\tgoto end_rmdir;\n\tif (inode->i_nlink != 2)\n\t\text3_warning (inode->i_sb, \"ext3_rmdir\",\n\t\t\t      \"empty directory has nlink!=2 (%d)\",\n\t\t\t      inode->i_nlink);\n\tinode->i_version++;\n\tclear_nlink(inode);\n\t/* There's no need to set i_disksize: the fact that i_nlink is\n\t * zero will ensure that the right thing happens during any\n\t * recovery. */\n\tinode->i_size = 0;\n\text3_orphan_add(handle, inode);\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\tdrop_nlink(dir);\n\text3_update_dx_flag(dir);\n\text3_mark_inode_dirty(handle, dir);\n\nend_rmdir:\n\text3_journal_stop(handle);\n\tbrelse (bh);\n\treturn retval;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "dir"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_update_dx_flag",
          "args": [
            "dir"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_update_dx_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "767-772",
          "snippet": "static void ext3_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext3_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "dir"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1967-2028",
          "snippet": "int ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "inode->i_sb",
            "\"ext3_rmdir\"",
            "\"empty directory has nlink!=2 (%d)\"",
            "inode->i_nlink"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_delete_entry",
          "args": [
            "handle",
            "dir",
            "de",
            "bh"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1623-1666",
          "snippet": "static int ext3_delete_entry (handle_t *handle,\n\t\t\t      struct inode * dir,\n\t\t\t      struct ext3_dir_entry_2 * de_del,\n\t\t\t      struct buffer_head * bh)\n{\n\tstruct ext3_dir_entry_2 * de, * pde;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\twhile (i < bh->b_size) {\n\t\tif (!ext3_check_dir_entry(\"ext3_delete_entry\", dir, de, bh, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tint err;\n\n\t\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext3_rec_len_to_disk(\n\t\t\t\t\text3_rec_len_from_disk(pde->rec_len) +\n\t\t\t\t\text3_rec_len_from_disk(de->rec_len));\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (err) {\njournal_error:\n\t\t\t\text3_std_error(dir->i_sb, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext3_rec_len_from_disk(de->rec_len);\n\t\tpde = de;\n\t\tde = ext3_next_entry(de);\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_delete_entry (handle_t *handle,\n\t\t\t      struct inode * dir,\n\t\t\t      struct ext3_dir_entry_2 * de_del,\n\t\t\t      struct buffer_head * bh)\n{\n\tstruct ext3_dir_entry_2 * de, * pde;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\twhile (i < bh->b_size) {\n\t\tif (!ext3_check_dir_entry(\"ext3_delete_entry\", dir, de, bh, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tint err;\n\n\t\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext3_rec_len_to_disk(\n\t\t\t\t\text3_rec_len_from_disk(pde->rec_len) +\n\t\t\t\t\text3_rec_len_from_disk(de->rec_len));\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (err) {\njournal_error:\n\t\t\t\text3_std_error(dir->i_sb, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext3_rec_len_from_disk(de->rec_len);\n\t\tpde = de;\n\t\tde = ext3_next_entry(de);\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "empty_dir",
          "args": [
            "inode"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1889-1957",
          "snippet": "static int empty_dir (struct inode * inode)\n{\n\tunsigned long offset;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 * de, * de1;\n\tstruct super_block * sb;\n\tint err = 0;\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT3_DIR_REC_LEN(1) + EXT3_DIR_REC_LEN(2) ||\n\t    !(bh = ext3_dir_bread(NULL, inode, 0, 0, &err))) {\n\t\tif (err)\n\t\t\text3_error(inode->i_sb, __func__,\n\t\t\t\t   \"error %d reading directory #%lu offset 0\",\n\t\t\t\t   err, inode->i_ino);\n\t\telse\n\t\t\text3_warning(inode->i_sb, __func__,\n\t\t\t\t     \"bad directory (dir #%lu) - no data block\",\n\t\t\t\t     inode->i_ino);\n\t\treturn 1;\n\t}\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde1 = ext3_next_entry(de);\n\tif (le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t\t!le32_to_cpu(de1->inode) ||\n\t\t\tstrcmp (\".\", de->name) ||\n\t\t\tstrcmp (\"..\", de1->name)) {\n\t\text3_warning (inode->i_sb, \"empty_dir\",\n\t\t\t      \"bad directory (dir #%lu) - no `.' or `..'\",\n\t\t\t      inode->i_ino);\n\t\tbrelse (bh);\n\t\treturn 1;\n\t}\n\toffset = ext3_rec_len_from_disk(de->rec_len) +\n\t\t\text3_rec_len_from_disk(de1->rec_len);\n\tde = ext3_next_entry(de1);\n\twhile (offset < inode->i_size ) {\n\t\tif (!bh ||\n\t\t\t(void *) de >= (void *) (bh->b_data+sb->s_blocksize)) {\n\t\t\terr = 0;\n\t\t\tbrelse (bh);\n\t\t\tif (!(bh = ext3_dir_bread (NULL, inode,\n\t\t\t\toffset >> EXT3_BLOCK_SIZE_BITS(sb), 0, &err))) {\n\t\t\t\tif (err)\n\t\t\t\t\text3_error(sb, __func__,\n\t\t\t\t\t\t   \"error %d reading directory\"\n\t\t\t\t\t\t   \" #%lu offset %lu\",\n\t\t\t\t\t\t   err, inode->i_ino, offset);\n\t\t\t\toffset += sb->s_blocksize;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\t\t}\n\t\tif (!ext3_check_dir_entry(\"empty_dir\", inode, de, bh, offset)) {\n\t\t\tde = (struct ext3_dir_entry_2 *)(bh->b_data +\n\t\t\t\t\t\t\t sb->s_blocksize);\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse (bh);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += ext3_rec_len_from_disk(de->rec_len);\n\t\tde = ext3_next_entry(de);\n\t}\n\tbrelse (bh);\n\treturn 1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int empty_dir (struct inode * inode)\n{\n\tunsigned long offset;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 * de, * de1;\n\tstruct super_block * sb;\n\tint err = 0;\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT3_DIR_REC_LEN(1) + EXT3_DIR_REC_LEN(2) ||\n\t    !(bh = ext3_dir_bread(NULL, inode, 0, 0, &err))) {\n\t\tif (err)\n\t\t\text3_error(inode->i_sb, __func__,\n\t\t\t\t   \"error %d reading directory #%lu offset 0\",\n\t\t\t\t   err, inode->i_ino);\n\t\telse\n\t\t\text3_warning(inode->i_sb, __func__,\n\t\t\t\t     \"bad directory (dir #%lu) - no data block\",\n\t\t\t\t     inode->i_ino);\n\t\treturn 1;\n\t}\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde1 = ext3_next_entry(de);\n\tif (le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t\t!le32_to_cpu(de1->inode) ||\n\t\t\tstrcmp (\".\", de->name) ||\n\t\t\tstrcmp (\"..\", de1->name)) {\n\t\text3_warning (inode->i_sb, \"empty_dir\",\n\t\t\t      \"bad directory (dir #%lu) - no `.' or `..'\",\n\t\t\t      inode->i_ino);\n\t\tbrelse (bh);\n\t\treturn 1;\n\t}\n\toffset = ext3_rec_len_from_disk(de->rec_len) +\n\t\t\text3_rec_len_from_disk(de1->rec_len);\n\tde = ext3_next_entry(de1);\n\twhile (offset < inode->i_size ) {\n\t\tif (!bh ||\n\t\t\t(void *) de >= (void *) (bh->b_data+sb->s_blocksize)) {\n\t\t\terr = 0;\n\t\t\tbrelse (bh);\n\t\t\tif (!(bh = ext3_dir_bread (NULL, inode,\n\t\t\t\toffset >> EXT3_BLOCK_SIZE_BITS(sb), 0, &err))) {\n\t\t\t\tif (err)\n\t\t\t\t\text3_error(sb, __func__,\n\t\t\t\t\t\t   \"error %d reading directory\"\n\t\t\t\t\t\t   \" #%lu offset %lu\",\n\t\t\t\t\t\t   err, inode->i_ino, offset);\n\t\t\t\toffset += sb->s_blocksize;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\t\t}\n\t\tif (!ext3_check_dir_entry(\"empty_dir\", inode, de, bh, offset)) {\n\t\t\tde = (struct ext3_dir_entry_2 *)(bh->b_data +\n\t\t\t\t\t\t\t sb->s_blocksize);\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse (bh);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += ext3_rec_len_from_disk(de->rec_len);\n\t\tde = ext3_next_entry(de);\n\t}\n\tbrelse (bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_find_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "&de"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "842-962",
          "snippet": "static struct buffer_head *ext3_find_entry(struct inode *dir,\n\t\t\t\t\tstruct qstr *entry,\n\t\t\t\t\tstruct ext3_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head * bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tconst u8 *name = entry->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = entry->len;\n\tif (namelen > EXT3_NAME_LEN)\n\t\treturn NULL;\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == 0)) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext3_dx_find_entry(dir, entry, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(\"ext3_find_entry: dx failed, falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tstart = EXT3_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext3_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh && !bh_uptodate_or_lock(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\t\tsubmit_bh(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t  bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\text3_error(sb, __func__, \"reading directory #%lu \"\n\t\t\t\t   \"offset %lu\", dir->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\ti = search_dirblock(bh, dir, entry,\n\t\t\t    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT3_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse (bh_use[ra_ptr]);\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [
            "#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
          ],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\n#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext3_find_entry(struct inode *dir,\n\t\t\t\t\tstruct qstr *entry,\n\t\t\t\t\tstruct ext3_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head * bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tconst u8 *name = entry->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = entry->len;\n\tif (namelen > EXT3_NAME_LEN)\n\t\treturn NULL;\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == 0)) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext3_dx_find_entry(dir, entry, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(\"ext3_find_entry: dx failed, falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tstart = EXT3_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext3_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh && !bh_uptodate_or_lock(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\t\tsubmit_bh(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t  bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\text3_error(sb, __func__, \"reading directory #%lu \"\n\t\t\t\t   \"offset %lu\", dir->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\ti = search_dirblock(bh, dir, entry,\n\t\t\t    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT3_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse (bh_use[ra_ptr]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "dir",
            "EXT3_DELETE_TRANS_BLOCKS(dir->i_sb)"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DELETE_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dentry->d_inode"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_rmdir (struct inode * dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode * inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 * de;\n\thandle_t *handle;\n\n\t/* Initialize quotas before so that eventual writes go in\n\t * separate transaction */\n\tdquot_initialize(dir);\n\tdquot_initialize(dentry->d_inode);\n\n\thandle = ext3_journal_start(dir, EXT3_DELETE_TRANS_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tretval = -ENOENT;\n\tbh = ext3_find_entry(dir, &dentry->d_name, &de);\n\tif (!bh)\n\t\tgoto end_rmdir;\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tinode = dentry->d_inode;\n\n\tretval = -EIO;\n\tif (le32_to_cpu(de->inode) != inode->i_ino)\n\t\tgoto end_rmdir;\n\n\tretval = -ENOTEMPTY;\n\tif (!empty_dir (inode))\n\t\tgoto end_rmdir;\n\n\tretval = ext3_delete_entry(handle, dir, de, bh);\n\tif (retval)\n\t\tgoto end_rmdir;\n\tif (inode->i_nlink != 2)\n\t\text3_warning (inode->i_sb, \"ext3_rmdir\",\n\t\t\t      \"empty directory has nlink!=2 (%d)\",\n\t\t\t      inode->i_nlink);\n\tinode->i_version++;\n\tclear_nlink(inode);\n\t/* There's no need to set i_disksize: the fact that i_nlink is\n\t * zero will ensure that the right thing happens during any\n\t * recovery. */\n\tinode->i_size = 0;\n\text3_orphan_add(handle, inode);\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\tdrop_nlink(dir);\n\text3_update_dx_flag(dir);\n\text3_mark_inode_dirty(handle, dir);\n\nend_rmdir:\n\text3_journal_stop(handle);\n\tbrelse (bh);\n\treturn retval;\n}"
  },
  {
    "function_name": "ext3_orphan_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "2034-2101",
    "snippet": "int ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&EXT3_SB(inode->i_sb)->s_orphan_lock"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3391-3403",
          "snippet": "int ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "i_prev"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_reserve_inode_write",
          "args": [
            "handle",
            "i_prev",
            "&iloc2"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_reserve_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3410-3428",
          "snippet": "int\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"orphan inode %lu will point to %lu\\n\"",
            "i_prev->i_ino",
            "ino_next"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "prev",
            "structext3_inode_info",
            "i_orphan"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "sbi->s_sbh"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ino_next"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "sbi->s_sbh"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "sbi->s_sbh",
            "\"get_write_access\""
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"superblock will point to %lu\\n\"",
            "ino_next"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ei->i_orphan"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"remove inode %lu from orphan list\\n\"",
            "inode->i_ino"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ei->i_orphan"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&EXT3_SB(inode->i_sb)->s_orphan_lock"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_sb_info *sbi;\n\tunsigned long ino_next;\n\tstruct ext3_iloc iloc;\n\tint err = 0;\n\n\tmutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT3_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %lu\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\t} else {\n\t\tstruct ext3_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %lu\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext3_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext3_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text3_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
  },
  {
    "function_name": "ext3_orphan_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1967-2028",
    "snippet": "int ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&EXT3_SB(sb)->s_orphan_lock"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"orphan inode %lu will point to %d\\n\"",
            "inode->i_ino",
            "NEXT_ORPHAN(inode)"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"superblock will point to %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&EXT3_I(inode)->i_orphan",
            "&EXT3_SB(sb)->s_orphan"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3391-3403",
          "snippet": "int ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "EXT3_SB(sb)->s_sbh"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT3_SB(sb)->s_es->s_last_orphan"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_reserve_inode_write",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_reserve_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3410-3428",
          "snippet": "int\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "EXT3_SB(sb)->s_sbh"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "EXT3_SB(sb)->s_sbh",
            "\"get_write_access\""
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&EXT3_I(inode)->i_orphan"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&EXT3_SB(sb)->s_orphan_lock"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
  },
  {
    "function_name": "empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1889-1957",
    "snippet": "static int empty_dir (struct inode * inode)\n{\n\tunsigned long offset;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 * de, * de1;\n\tstruct super_block * sb;\n\tint err = 0;\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT3_DIR_REC_LEN(1) + EXT3_DIR_REC_LEN(2) ||\n\t    !(bh = ext3_dir_bread(NULL, inode, 0, 0, &err))) {\n\t\tif (err)\n\t\t\text3_error(inode->i_sb, __func__,\n\t\t\t\t   \"error %d reading directory #%lu offset 0\",\n\t\t\t\t   err, inode->i_ino);\n\t\telse\n\t\t\text3_warning(inode->i_sb, __func__,\n\t\t\t\t     \"bad directory (dir #%lu) - no data block\",\n\t\t\t\t     inode->i_ino);\n\t\treturn 1;\n\t}\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde1 = ext3_next_entry(de);\n\tif (le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t\t!le32_to_cpu(de1->inode) ||\n\t\t\tstrcmp (\".\", de->name) ||\n\t\t\tstrcmp (\"..\", de1->name)) {\n\t\text3_warning (inode->i_sb, \"empty_dir\",\n\t\t\t      \"bad directory (dir #%lu) - no `.' or `..'\",\n\t\t\t      inode->i_ino);\n\t\tbrelse (bh);\n\t\treturn 1;\n\t}\n\toffset = ext3_rec_len_from_disk(de->rec_len) +\n\t\t\text3_rec_len_from_disk(de1->rec_len);\n\tde = ext3_next_entry(de1);\n\twhile (offset < inode->i_size ) {\n\t\tif (!bh ||\n\t\t\t(void *) de >= (void *) (bh->b_data+sb->s_blocksize)) {\n\t\t\terr = 0;\n\t\t\tbrelse (bh);\n\t\t\tif (!(bh = ext3_dir_bread (NULL, inode,\n\t\t\t\toffset >> EXT3_BLOCK_SIZE_BITS(sb), 0, &err))) {\n\t\t\t\tif (err)\n\t\t\t\t\text3_error(sb, __func__,\n\t\t\t\t\t\t   \"error %d reading directory\"\n\t\t\t\t\t\t   \" #%lu offset %lu\",\n\t\t\t\t\t\t   err, inode->i_ino, offset);\n\t\t\t\toffset += sb->s_blocksize;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\t\t}\n\t\tif (!ext3_check_dir_entry(\"empty_dir\", inode, de, bh, offset)) {\n\t\t\tde = (struct ext3_dir_entry_2 *)(bh->b_data +\n\t\t\t\t\t\t\t sb->s_blocksize);\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse (bh);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += ext3_rec_len_from_disk(de->rec_len);\n\t\tde = ext3_next_entry(de);\n\t}\n\tbrelse (bh);\n\treturn 1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_next_entry",
          "args": [
            "de"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "171-176",
          "snippet": "static inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_rec_len_from_disk",
          "args": [
            "de->rec_len"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "878-887",
          "snippet": "static inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_check_dir_entry",
          "args": [
            "\"empty_dir\"",
            "inode",
            "de",
            "bh",
            "offset"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_check_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "62-91",
          "snippet": "int ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nint ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "__func__",
            "\"error %d reading directory\"\n\t\t\t\t\t\t   \" #%lu offset %lu\"",
            "err",
            "inode->i_ino",
            "offset"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_dir_bread",
          "args": [
            "NULL",
            "inode",
            "offset >> EXT3_BLOCK_SIZE_BITS(sb)",
            "0",
            "&err"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_dir_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.h",
          "lines": "10-27",
          "snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "inode->i_sb",
            "\"empty_dir\"",
            "\"bad directory (dir #%lu) - no `.' or `..'\"",
            "inode->i_ino"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"..\"",
            "de1->name"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "2"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int empty_dir (struct inode * inode)\n{\n\tunsigned long offset;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 * de, * de1;\n\tstruct super_block * sb;\n\tint err = 0;\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT3_DIR_REC_LEN(1) + EXT3_DIR_REC_LEN(2) ||\n\t    !(bh = ext3_dir_bread(NULL, inode, 0, 0, &err))) {\n\t\tif (err)\n\t\t\text3_error(inode->i_sb, __func__,\n\t\t\t\t   \"error %d reading directory #%lu offset 0\",\n\t\t\t\t   err, inode->i_ino);\n\t\telse\n\t\t\text3_warning(inode->i_sb, __func__,\n\t\t\t\t     \"bad directory (dir #%lu) - no data block\",\n\t\t\t\t     inode->i_ino);\n\t\treturn 1;\n\t}\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde1 = ext3_next_entry(de);\n\tif (le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t\t!le32_to_cpu(de1->inode) ||\n\t\t\tstrcmp (\".\", de->name) ||\n\t\t\tstrcmp (\"..\", de1->name)) {\n\t\text3_warning (inode->i_sb, \"empty_dir\",\n\t\t\t      \"bad directory (dir #%lu) - no `.' or `..'\",\n\t\t\t      inode->i_ino);\n\t\tbrelse (bh);\n\t\treturn 1;\n\t}\n\toffset = ext3_rec_len_from_disk(de->rec_len) +\n\t\t\text3_rec_len_from_disk(de1->rec_len);\n\tde = ext3_next_entry(de1);\n\twhile (offset < inode->i_size ) {\n\t\tif (!bh ||\n\t\t\t(void *) de >= (void *) (bh->b_data+sb->s_blocksize)) {\n\t\t\terr = 0;\n\t\t\tbrelse (bh);\n\t\t\tif (!(bh = ext3_dir_bread (NULL, inode,\n\t\t\t\toffset >> EXT3_BLOCK_SIZE_BITS(sb), 0, &err))) {\n\t\t\t\tif (err)\n\t\t\t\t\text3_error(sb, __func__,\n\t\t\t\t\t\t   \"error %d reading directory\"\n\t\t\t\t\t\t   \" #%lu offset %lu\",\n\t\t\t\t\t\t   err, inode->i_ino, offset);\n\t\t\t\toffset += sb->s_blocksize;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\t\t}\n\t\tif (!ext3_check_dir_entry(\"empty_dir\", inode, de, bh, offset)) {\n\t\t\tde = (struct ext3_dir_entry_2 *)(bh->b_data +\n\t\t\t\t\t\t\t sb->s_blocksize);\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse (bh);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += ext3_rec_len_from_disk(de->rec_len);\n\t\tde = ext3_next_entry(de);\n\t}\n\tbrelse (bh);\n\treturn 1;\n}"
  },
  {
    "function_name": "ext3_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1800-1884",
    "snippet": "static int ext3_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)\n{\n\thandle_t *handle;\n\tstruct inode * inode;\n\tstruct buffer_head * dir_block = NULL;\n\tstruct ext3_dir_entry_2 * de;\n\tint err, retries = 0;\n\n\tif (dir->i_nlink >= EXT3_LINK_MAX)\n\t\treturn -EMLINK;\n\n\tdquot_initialize(dir);\n\nretry:\n\thandle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 3 +\n\t\t\t\t\tEXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tinode = ext3_new_inode (handle, dir, &dentry->d_name, S_IFDIR | mode);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_stop;\n\n\tinode->i_op = &ext3_dir_inode_operations;\n\tinode->i_fop = &ext3_dir_operations;\n\tinode->i_size = EXT3_I(inode)->i_disksize = inode->i_sb->s_blocksize;\n\tif (!(dir_block = ext3_dir_bread(handle, inode, 0, 1, &err)))\n\t\tgoto out_clear_inode;\n\n\tBUFFER_TRACE(dir_block, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, dir_block);\n\tif (err)\n\t\tgoto out_clear_inode;\n\n\tde = (struct ext3_dir_entry_2 *) dir_block->b_data;\n\tde->inode = cpu_to_le32(inode->i_ino);\n\tde->name_len = 1;\n\tde->rec_len = ext3_rec_len_to_disk(EXT3_DIR_REC_LEN(de->name_len));\n\tstrcpy (de->name, \".\");\n\text3_set_de_type(dir->i_sb, de, S_IFDIR);\n\tde = ext3_next_entry(de);\n\tde->inode = cpu_to_le32(dir->i_ino);\n\tde->rec_len = ext3_rec_len_to_disk(inode->i_sb->s_blocksize -\n\t\t\t\t\tEXT3_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tstrcpy (de->name, \"..\");\n\text3_set_de_type(dir->i_sb, de, S_IFDIR);\n\tset_nlink(inode, 2);\n\tBUFFER_TRACE(dir_block, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, dir_block);\n\tif (err)\n\t\tgoto out_clear_inode;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (!err)\n\t\terr = ext3_add_entry (handle, dentry, inode);\n\n\tif (err) {\nout_clear_inode:\n\t\tclear_nlink(inode);\n\t\tunlock_new_inode(inode);\n\t\text3_mark_inode_dirty(handle, inode);\n\t\tiput (inode);\n\t\tgoto out_stop;\n\t}\n\tinc_nlink(dir);\n\text3_update_dx_flag(dir);\n\terr = ext3_mark_inode_dirty(handle, dir);\n\tif (err)\n\t\tgoto out_clear_inode;\n\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\nout_stop:\n\tbrelse(dir_block);\n\text3_journal_stop(handle);\n\tif (err == -ENOSPC && ext3_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);",
      "const struct inode_operations ext3_dir_inode_operations = {\n\t.create\t\t= ext3_create,\n\t.lookup\t\t= ext3_lookup,\n\t.link\t\t= ext3_link,\n\t.unlink\t\t= ext3_unlink,\n\t.symlink\t= ext3_symlink,\n\t.mkdir\t\t= ext3_mkdir,\n\t.rmdir\t\t= ext3_rmdir,\n\t.mknod\t\t= ext3_mknod,\n\t.tmpfile\t= ext3_tmpfile,\n\t.rename\t\t= ext3_rename,\n\t.setattr\t= ext3_setattr,\n#ifdef CONFIG_EXT3_FS_XATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext3_listxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n\t.get_acl\t= ext3_get_acl,\n\t.set_acl\t= ext3_set_acl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_should_retry_alloc",
          "args": [
            "dir->i_sb",
            "&retries"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1462-1470",
          "snippet": "int ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dir_block"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "dir"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_update_dx_flag",
          "args": [
            "dir"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_update_dx_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "767-772",
          "snippet": "static void ext3_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext3_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_add_entry",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1435-1480",
          "snippet": "static int ext3_add_entry (handle_t *handle, struct dentry *dentry,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct super_block * sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\tu32 block, blocks;\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\tif (is_dx(dir)) {\n\t\tretval = ext3_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\tEXT3_I(dir)->i_flags &= ~EXT3_INDEX_FL;\n\t\tdx_fallback++;\n\t\text3_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tif (!(bh = ext3_dir_bread(handle, dir, block, 0, &retval)))\n\t\t\treturn retval;\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC)\n\t\t\treturn retval;\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext3_append(handle, dir, &block, &retval);\n\tif (!bh)\n\t\treturn retval;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext3_rec_len_to_disk(blocksize);\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_add_entry (handle_t *handle, struct dentry *dentry,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct super_block * sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\tu32 block, blocks;\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\tif (is_dx(dir)) {\n\t\tretval = ext3_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\tEXT3_I(dir)->i_flags &= ~EXT3_INDEX_FL;\n\t\tdx_fallback++;\n\t\text3_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tif (!(bh = ext3_dir_bread(handle, dir, block, 0, &retval)))\n\t\t\treturn retval;\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC)\n\t\t\treturn retval;\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext3_append(handle, dir, &block, &retval);\n\tif (!bh)\n\t\treturn retval;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext3_rec_len_to_disk(blocksize);\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "dir_block"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "dir_block",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_set_de_type",
          "args": [
            "dir->i_sb",
            "de",
            "S_IFDIR"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1078-1083",
          "snippet": "static inline void ext3_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext3_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext3_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [
            "#define S_SHIFT 12"
          ],
          "globals_used": [
            "static unsigned char ext3_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXT3_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXT3_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXT3_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXT3_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXT3_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXT3_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXT3_FT_SYMLINK,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\n#define S_SHIFT 12\n\nstatic unsigned char ext3_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXT3_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXT3_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXT3_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXT3_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXT3_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXT3_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXT3_FT_SYMLINK,\n};\n\nstatic inline void ext3_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext3_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext3_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "de->name",
            "\"..\""
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_rec_len_to_disk",
          "args": [
            "inode->i_sb->s_blocksize -\n\t\t\t\t\tEXT3_DIR_REC_LEN(1)"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "889-898",
          "snippet": "static inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dir->i_ino"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_next_entry",
          "args": [
            "de"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "171-176",
          "snippet": "static inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "de->name",
            "\".\""
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "dir_block"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "dir_block",
            "\"get_write_access\""
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_dir_bread",
          "args": [
            "handle",
            "inode",
            "0",
            "1",
            "&err"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_dir_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.h",
          "lines": "10-27",
          "snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_new_inode",
          "args": [
            "handle",
            "dir",
            "&dentry->d_name",
            "S_IFDIR | mode"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "346-567",
          "snippet": "struct inode *ext3_new_inode(handle_t *handle, struct inode * dir,\n\t\t\t     const struct qstr *qstr, umode_t mode)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group;\n\tunsigned long ino = 0;\n\tstruct inode * inode;\n\tstruct ext3_group_desc * gdp = NULL;\n\tstruct ext3_super_block * es;\n\tstruct ext3_inode_info *ei;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0;\n\tstruct inode *ret;\n\tint i;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\ttrace_ext3_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT3_I(inode);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode))\n\t\tgroup = find_group_orlov(sb, dir);\n\telse\n\t\tgroup = find_group_other(sb, dir);\n\n\terr = -ENOSPC;\n\tif (group == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\terr = -EIO;\n\n\t\tgdp = ext3_get_group_desc(sb, group, &bh2);\n\t\tif (!gdp)\n\t\t\tgoto fail;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh)\n\t\t\tgoto fail;\n\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext3_find_next_zero_bit((unsigned long *)\n\t\t\t\tbitmap_bh->b_data, EXT3_INODES_PER_GROUP(sb), ino);\n\t\tif (ino < EXT3_INODES_PER_GROUP(sb)) {\n\n\t\t\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bitmap_bh);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!ext3_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t\t/* we won it */\n\t\t\t\tBUFFER_TRACE(bitmap_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto got;\n\t\t\t}\n\t\t\t/* we lost it */\n\t\t\tjournal_release_buffer(handle, bitmap_bh);\n\n\t\t\tif (++ino < EXT3_INODES_PER_GROUP(sb))\n\t\t\t\tgoto repeat_in_this_group;\n\t\t}\n\n\t\t/*\n\t\t * This case is possible in concurrent environment.  It is very\n\t\t * rare.  We cannot repeat the find_group_xxx() call because\n\t\t * that will simply return the same blockgroup, because the\n\t\t * group descriptor metadata has not yet been updated.\n\t\t * So we just go onto the next blockgroup.\n\t\t */\n\t\tif (++group == sbi->s_groups_count)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tino += group * EXT3_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d, inode=%lu\", group, ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tBUFFER_TRACE(bh2, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh2);\n\tif (err) goto fail;\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh2);\n\tif (err) goto fail;\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\tei->i_flags =\n\t\text3_mask_flags(mode, EXT3_I(dir)->i_flags & EXT3_FL_INHERITED);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n#endif\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\n\text3_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\thandle->h_sync = 1;\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\tei->i_state_flags = 0;\n\text3_set_inode_state(inode, EXT3_STATE_NEW);\n\n\t/* See comment in ext3_iget for explanation */\n\tif (ino >= EXT3_FIRST_INO(sb) + 1 &&\n\t    EXT3_INODE_SIZE(sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize =\n\t\t\tsizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE;\n\t} else {\n\t\tei->i_extra_isize = 0;\n\t}\n\n\tret = inode;\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext3_init_acl(handle, inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_init_security(handle, inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text3_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text3_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext3_allocate_inode(inode, dir, mode);\n\tgoto really_out;\nfail:\n\text3_std_error(sb, err);\nout:\n\tiput(inode);\n\tret = ERR_PTR(err);\nreally_out:\n\tbrelse(bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tbrelse(bitmap_bh);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext3_new_inode(handle_t *handle, struct inode * dir,\n\t\t\t     const struct qstr *qstr, umode_t mode)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group;\n\tunsigned long ino = 0;\n\tstruct inode * inode;\n\tstruct ext3_group_desc * gdp = NULL;\n\tstruct ext3_super_block * es;\n\tstruct ext3_inode_info *ei;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0;\n\tstruct inode *ret;\n\tint i;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\ttrace_ext3_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT3_I(inode);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode))\n\t\tgroup = find_group_orlov(sb, dir);\n\telse\n\t\tgroup = find_group_other(sb, dir);\n\n\terr = -ENOSPC;\n\tif (group == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\terr = -EIO;\n\n\t\tgdp = ext3_get_group_desc(sb, group, &bh2);\n\t\tif (!gdp)\n\t\t\tgoto fail;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh)\n\t\t\tgoto fail;\n\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext3_find_next_zero_bit((unsigned long *)\n\t\t\t\tbitmap_bh->b_data, EXT3_INODES_PER_GROUP(sb), ino);\n\t\tif (ino < EXT3_INODES_PER_GROUP(sb)) {\n\n\t\t\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bitmap_bh);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!ext3_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t\t/* we won it */\n\t\t\t\tBUFFER_TRACE(bitmap_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto got;\n\t\t\t}\n\t\t\t/* we lost it */\n\t\t\tjournal_release_buffer(handle, bitmap_bh);\n\n\t\t\tif (++ino < EXT3_INODES_PER_GROUP(sb))\n\t\t\t\tgoto repeat_in_this_group;\n\t\t}\n\n\t\t/*\n\t\t * This case is possible in concurrent environment.  It is very\n\t\t * rare.  We cannot repeat the find_group_xxx() call because\n\t\t * that will simply return the same blockgroup, because the\n\t\t * group descriptor metadata has not yet been updated.\n\t\t * So we just go onto the next blockgroup.\n\t\t */\n\t\tif (++group == sbi->s_groups_count)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tino += group * EXT3_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d, inode=%lu\", group, ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tBUFFER_TRACE(bh2, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh2);\n\tif (err) goto fail;\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh2);\n\tif (err) goto fail;\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\tei->i_flags =\n\t\text3_mask_flags(mode, EXT3_I(dir)->i_flags & EXT3_FL_INHERITED);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n#endif\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\n\text3_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\thandle->h_sync = 1;\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\tei->i_state_flags = 0;\n\text3_set_inode_state(inode, EXT3_STATE_NEW);\n\n\t/* See comment in ext3_iget for explanation */\n\tif (ino >= EXT3_FIRST_INO(sb) + 1 &&\n\t    EXT3_INODE_SIZE(sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize =\n\t\t\tsizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE;\n\t} else {\n\t\tei->i_extra_isize = 0;\n\t}\n\n\tret = inode;\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext3_init_acl(handle, inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_init_security(handle, inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text3_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text3_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext3_allocate_inode(inode, dir, mode);\n\tgoto really_out;\nfail:\n\text3_std_error(sb, err);\nout:\n\tiput(inode);\n\tret = ERR_PTR(err);\nreally_out:\n\tbrelse(bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tbrelse(bitmap_bh);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "dir",
            "EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 3 +\n\t\t\t\t\tEXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb)"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_MAXQUOTAS_INIT_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\nconst struct inode_operations ext3_dir_inode_operations = {\n\t.create\t\t= ext3_create,\n\t.lookup\t\t= ext3_lookup,\n\t.link\t\t= ext3_link,\n\t.unlink\t\t= ext3_unlink,\n\t.symlink\t= ext3_symlink,\n\t.mkdir\t\t= ext3_mkdir,\n\t.rmdir\t\t= ext3_rmdir,\n\t.mknod\t\t= ext3_mknod,\n\t.tmpfile\t= ext3_tmpfile,\n\t.rename\t\t= ext3_rename,\n\t.setattr\t= ext3_setattr,\n#ifdef CONFIG_EXT3_FS_XATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext3_listxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n\t.get_acl\t= ext3_get_acl,\n\t.set_acl\t= ext3_set_acl,\n};\n\nstatic int ext3_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)\n{\n\thandle_t *handle;\n\tstruct inode * inode;\n\tstruct buffer_head * dir_block = NULL;\n\tstruct ext3_dir_entry_2 * de;\n\tint err, retries = 0;\n\n\tif (dir->i_nlink >= EXT3_LINK_MAX)\n\t\treturn -EMLINK;\n\n\tdquot_initialize(dir);\n\nretry:\n\thandle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 3 +\n\t\t\t\t\tEXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tinode = ext3_new_inode (handle, dir, &dentry->d_name, S_IFDIR | mode);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_stop;\n\n\tinode->i_op = &ext3_dir_inode_operations;\n\tinode->i_fop = &ext3_dir_operations;\n\tinode->i_size = EXT3_I(inode)->i_disksize = inode->i_sb->s_blocksize;\n\tif (!(dir_block = ext3_dir_bread(handle, inode, 0, 1, &err)))\n\t\tgoto out_clear_inode;\n\n\tBUFFER_TRACE(dir_block, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, dir_block);\n\tif (err)\n\t\tgoto out_clear_inode;\n\n\tde = (struct ext3_dir_entry_2 *) dir_block->b_data;\n\tde->inode = cpu_to_le32(inode->i_ino);\n\tde->name_len = 1;\n\tde->rec_len = ext3_rec_len_to_disk(EXT3_DIR_REC_LEN(de->name_len));\n\tstrcpy (de->name, \".\");\n\text3_set_de_type(dir->i_sb, de, S_IFDIR);\n\tde = ext3_next_entry(de);\n\tde->inode = cpu_to_le32(dir->i_ino);\n\tde->rec_len = ext3_rec_len_to_disk(inode->i_sb->s_blocksize -\n\t\t\t\t\tEXT3_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tstrcpy (de->name, \"..\");\n\text3_set_de_type(dir->i_sb, de, S_IFDIR);\n\tset_nlink(inode, 2);\n\tBUFFER_TRACE(dir_block, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, dir_block);\n\tif (err)\n\t\tgoto out_clear_inode;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (!err)\n\t\terr = ext3_add_entry (handle, dentry, inode);\n\n\tif (err) {\nout_clear_inode:\n\t\tclear_nlink(inode);\n\t\tunlock_new_inode(inode);\n\t\text3_mark_inode_dirty(handle, inode);\n\t\tiput (inode);\n\t\tgoto out_stop;\n\t}\n\tinc_nlink(dir);\n\text3_update_dx_flag(dir);\n\terr = ext3_mark_inode_dirty(handle, dir);\n\tif (err)\n\t\tgoto out_clear_inode;\n\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\nout_stop:\n\tbrelse(dir_block);\n\text3_journal_stop(handle);\n\tif (err == -ENOSPC && ext3_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_tmpfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1762-1798",
    "snippet": "static int ext3_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, retries = 0;\n\n\tdquot_initialize(dir);\n\nretry:\n\thandle = ext3_journal_start(dir, EXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +\n\t\t\t  4 + EXT3_XATTR_TRANS_BLOCKS);\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tinode = ext3_new_inode (handle, dir, NULL, mode);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t\td_tmpfile(dentry, inode);\n\t\terr = ext3_orphan_add(handle, inode);\n\t\tif (err)\n\t\t\tgoto err_unlock_inode;\n\t\tmark_inode_dirty(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\text3_journal_stop(handle);\n\tif (err == -ENOSPC && ext3_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\nerr_unlock_inode:\n\text3_journal_stop(handle);\n\tunlock_new_inode(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_should_retry_alloc",
          "args": [
            "dir->i_sb",
            "&retries"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1462-1470",
          "snippet": "int ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1967-2028",
          "snippet": "int ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_iloc iloc;\n\tint err = 0, rc;\n\n\tmutex_lock(&EXT3_SB(sb)->s_orphan_lock);\n\tif (!list_empty(&EXT3_I(inode)->i_orphan))\n\t\tgoto out_unlock;\n\n\t/* Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. */\n\n\t/* @@@ FIXME: Observation from aviro:\n\t * I think I can trigger J_ASSERT in ext3_orphan_add().  We block\n\t * here (on s_orphan_lock), so race with ext3_link() which might bump\n\t * ->i_nlink. For, say it, character device. Not a regular file,\n\t * not a directory, not a symlink and ->i_nlink > 0.\n\t *\n\t * tytso, 4/25/2009: I'm not sure how that could happen;\n\t * shouldn't the fs core protect us from these sort of\n\t * unlink()/link() races?\n\t */\n\tJ_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\tS_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(EXT3_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);\n\tEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\trc = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can't risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we're going to ignore the orphan list\n\t * anyway on the next recovery. */\n\tif (!err)\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&EXT3_SB(sb)->s_orphan_lock);\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_tmpfile",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "d_tmpfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3325-3338",
          "snippet": "void d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_set_aops",
          "args": [
            "inode"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_aops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1979-1987",
          "snippet": "void ext3_set_aops(struct inode *inode)\n{\n\tif (ext3_should_order_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_ordered_aops;\n\telse if (ext3_should_writeback_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_writeback_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext3_journalled_aops;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static const struct address_space_operations ext3_ordered_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_ordered_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_ordered_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.is_dirty_writeback\t= buffer_check_dirty_writeback,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext3_writeback_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_writeback_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_writeback_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext3_journalled_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_journalled_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_journalled_write_end,\n\t.set_page_dirty\t\t= ext3_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic const struct address_space_operations ext3_ordered_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_ordered_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_ordered_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.is_dirty_writeback\t= buffer_check_dirty_writeback,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext3_writeback_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_writeback_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_writeback_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext3_journalled_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_journalled_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_journalled_write_end,\n\t.set_page_dirty\t\t= ext3_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext3_set_aops(struct inode *inode)\n{\n\tif (ext3_should_order_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_ordered_aops;\n\telse if (ext3_should_writeback_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_writeback_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext3_journalled_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_new_inode",
          "args": [
            "handle",
            "dir",
            "NULL",
            "mode"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "346-567",
          "snippet": "struct inode *ext3_new_inode(handle_t *handle, struct inode * dir,\n\t\t\t     const struct qstr *qstr, umode_t mode)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group;\n\tunsigned long ino = 0;\n\tstruct inode * inode;\n\tstruct ext3_group_desc * gdp = NULL;\n\tstruct ext3_super_block * es;\n\tstruct ext3_inode_info *ei;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0;\n\tstruct inode *ret;\n\tint i;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\ttrace_ext3_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT3_I(inode);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode))\n\t\tgroup = find_group_orlov(sb, dir);\n\telse\n\t\tgroup = find_group_other(sb, dir);\n\n\terr = -ENOSPC;\n\tif (group == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\terr = -EIO;\n\n\t\tgdp = ext3_get_group_desc(sb, group, &bh2);\n\t\tif (!gdp)\n\t\t\tgoto fail;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh)\n\t\t\tgoto fail;\n\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext3_find_next_zero_bit((unsigned long *)\n\t\t\t\tbitmap_bh->b_data, EXT3_INODES_PER_GROUP(sb), ino);\n\t\tif (ino < EXT3_INODES_PER_GROUP(sb)) {\n\n\t\t\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bitmap_bh);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!ext3_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t\t/* we won it */\n\t\t\t\tBUFFER_TRACE(bitmap_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto got;\n\t\t\t}\n\t\t\t/* we lost it */\n\t\t\tjournal_release_buffer(handle, bitmap_bh);\n\n\t\t\tif (++ino < EXT3_INODES_PER_GROUP(sb))\n\t\t\t\tgoto repeat_in_this_group;\n\t\t}\n\n\t\t/*\n\t\t * This case is possible in concurrent environment.  It is very\n\t\t * rare.  We cannot repeat the find_group_xxx() call because\n\t\t * that will simply return the same blockgroup, because the\n\t\t * group descriptor metadata has not yet been updated.\n\t\t * So we just go onto the next blockgroup.\n\t\t */\n\t\tif (++group == sbi->s_groups_count)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tino += group * EXT3_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d, inode=%lu\", group, ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tBUFFER_TRACE(bh2, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh2);\n\tif (err) goto fail;\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh2);\n\tif (err) goto fail;\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\tei->i_flags =\n\t\text3_mask_flags(mode, EXT3_I(dir)->i_flags & EXT3_FL_INHERITED);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n#endif\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\n\text3_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\thandle->h_sync = 1;\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\tei->i_state_flags = 0;\n\text3_set_inode_state(inode, EXT3_STATE_NEW);\n\n\t/* See comment in ext3_iget for explanation */\n\tif (ino >= EXT3_FIRST_INO(sb) + 1 &&\n\t    EXT3_INODE_SIZE(sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize =\n\t\t\tsizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE;\n\t} else {\n\t\tei->i_extra_isize = 0;\n\t}\n\n\tret = inode;\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext3_init_acl(handle, inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_init_security(handle, inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text3_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text3_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext3_allocate_inode(inode, dir, mode);\n\tgoto really_out;\nfail:\n\text3_std_error(sb, err);\nout:\n\tiput(inode);\n\tret = ERR_PTR(err);\nreally_out:\n\tbrelse(bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tbrelse(bitmap_bh);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext3_new_inode(handle_t *handle, struct inode * dir,\n\t\t\t     const struct qstr *qstr, umode_t mode)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group;\n\tunsigned long ino = 0;\n\tstruct inode * inode;\n\tstruct ext3_group_desc * gdp = NULL;\n\tstruct ext3_super_block * es;\n\tstruct ext3_inode_info *ei;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0;\n\tstruct inode *ret;\n\tint i;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\ttrace_ext3_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT3_I(inode);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode))\n\t\tgroup = find_group_orlov(sb, dir);\n\telse\n\t\tgroup = find_group_other(sb, dir);\n\n\terr = -ENOSPC;\n\tif (group == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\terr = -EIO;\n\n\t\tgdp = ext3_get_group_desc(sb, group, &bh2);\n\t\tif (!gdp)\n\t\t\tgoto fail;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh)\n\t\t\tgoto fail;\n\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext3_find_next_zero_bit((unsigned long *)\n\t\t\t\tbitmap_bh->b_data, EXT3_INODES_PER_GROUP(sb), ino);\n\t\tif (ino < EXT3_INODES_PER_GROUP(sb)) {\n\n\t\t\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bitmap_bh);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!ext3_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t\t/* we won it */\n\t\t\t\tBUFFER_TRACE(bitmap_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto got;\n\t\t\t}\n\t\t\t/* we lost it */\n\t\t\tjournal_release_buffer(handle, bitmap_bh);\n\n\t\t\tif (++ino < EXT3_INODES_PER_GROUP(sb))\n\t\t\t\tgoto repeat_in_this_group;\n\t\t}\n\n\t\t/*\n\t\t * This case is possible in concurrent environment.  It is very\n\t\t * rare.  We cannot repeat the find_group_xxx() call because\n\t\t * that will simply return the same blockgroup, because the\n\t\t * group descriptor metadata has not yet been updated.\n\t\t * So we just go onto the next blockgroup.\n\t\t */\n\t\tif (++group == sbi->s_groups_count)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tino += group * EXT3_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d, inode=%lu\", group, ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tBUFFER_TRACE(bh2, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh2);\n\tif (err) goto fail;\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh2);\n\tif (err) goto fail;\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\tei->i_flags =\n\t\text3_mask_flags(mode, EXT3_I(dir)->i_flags & EXT3_FL_INHERITED);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n#endif\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\n\text3_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\thandle->h_sync = 1;\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\tei->i_state_flags = 0;\n\text3_set_inode_state(inode, EXT3_STATE_NEW);\n\n\t/* See comment in ext3_iget for explanation */\n\tif (ino >= EXT3_FIRST_INO(sb) + 1 &&\n\t    EXT3_INODE_SIZE(sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize =\n\t\t\tsizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE;\n\t} else {\n\t\tei->i_extra_isize = 0;\n\t}\n\n\tret = inode;\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext3_init_acl(handle, inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_init_security(handle, inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text3_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text3_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext3_allocate_inode(inode, dir, mode);\n\tgoto really_out;\nfail:\n\text3_std_error(sb, err);\nout:\n\tiput(inode);\n\tret = ERR_PTR(err);\nreally_out:\n\tbrelse(bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tbrelse(bitmap_bh);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "dir",
            "EXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +\n\t\t\t  4 + EXT3_XATTR_TRANS_BLOCKS"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_MAXQUOTAS_INIT_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, retries = 0;\n\n\tdquot_initialize(dir);\n\nretry:\n\thandle = ext3_journal_start(dir, EXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +\n\t\t\t  4 + EXT3_XATTR_TRANS_BLOCKS);\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tinode = ext3_new_inode (handle, dir, NULL, mode);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t\td_tmpfile(dentry, inode);\n\t\terr = ext3_orphan_add(handle, inode);\n\t\tif (err)\n\t\t\tgoto err_unlock_inode;\n\t\tmark_inode_dirty(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\text3_journal_stop(handle);\n\tif (err == -ENOSPC && ext3_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\nerr_unlock_inode:\n\text3_journal_stop(handle);\n\tunlock_new_inode(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1725-1760",
    "snippet": "static int ext3_mknod (struct inode * dir, struct dentry *dentry,\n\t\t\tumode_t mode, dev_t rdev)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, retries = 0;\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tdquot_initialize(dir);\n\nretry:\n\thandle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 3 +\n\t\t\t\t\tEXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tinode = ext3_new_inode (handle, dir, &dentry->d_name, mode);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n#ifdef CONFIG_EXT3_FS_XATTR\n\t\tinode->i_op = &ext3_special_inode_operations;\n#endif\n\t\terr = ext3_add_nondir(handle, dentry, inode);\n\t}\n\text3_journal_stop(handle);\n\tif (err == -ENOSPC && ext3_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);",
      "const struct inode_operations ext3_special_inode_operations = {\n\t.setattr\t= ext3_setattr,\n#ifdef CONFIG_EXT3_FS_XATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext3_listxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n\t.get_acl\t= ext3_get_acl,\n\t.set_acl\t= ext3_set_acl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_should_retry_alloc",
          "args": [
            "dir->i_sb",
            "&retries"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1462-1470",
          "snippet": "int ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_add_nondir",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1668-1682",
          "snippet": "static int ext3_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext3_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text3_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext3_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text3_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "rdev"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_new_inode",
          "args": [
            "handle",
            "dir",
            "&dentry->d_name",
            "mode"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "346-567",
          "snippet": "struct inode *ext3_new_inode(handle_t *handle, struct inode * dir,\n\t\t\t     const struct qstr *qstr, umode_t mode)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group;\n\tunsigned long ino = 0;\n\tstruct inode * inode;\n\tstruct ext3_group_desc * gdp = NULL;\n\tstruct ext3_super_block * es;\n\tstruct ext3_inode_info *ei;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0;\n\tstruct inode *ret;\n\tint i;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\ttrace_ext3_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT3_I(inode);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode))\n\t\tgroup = find_group_orlov(sb, dir);\n\telse\n\t\tgroup = find_group_other(sb, dir);\n\n\terr = -ENOSPC;\n\tif (group == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\terr = -EIO;\n\n\t\tgdp = ext3_get_group_desc(sb, group, &bh2);\n\t\tif (!gdp)\n\t\t\tgoto fail;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh)\n\t\t\tgoto fail;\n\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext3_find_next_zero_bit((unsigned long *)\n\t\t\t\tbitmap_bh->b_data, EXT3_INODES_PER_GROUP(sb), ino);\n\t\tif (ino < EXT3_INODES_PER_GROUP(sb)) {\n\n\t\t\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bitmap_bh);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!ext3_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t\t/* we won it */\n\t\t\t\tBUFFER_TRACE(bitmap_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto got;\n\t\t\t}\n\t\t\t/* we lost it */\n\t\t\tjournal_release_buffer(handle, bitmap_bh);\n\n\t\t\tif (++ino < EXT3_INODES_PER_GROUP(sb))\n\t\t\t\tgoto repeat_in_this_group;\n\t\t}\n\n\t\t/*\n\t\t * This case is possible in concurrent environment.  It is very\n\t\t * rare.  We cannot repeat the find_group_xxx() call because\n\t\t * that will simply return the same blockgroup, because the\n\t\t * group descriptor metadata has not yet been updated.\n\t\t * So we just go onto the next blockgroup.\n\t\t */\n\t\tif (++group == sbi->s_groups_count)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tino += group * EXT3_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d, inode=%lu\", group, ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tBUFFER_TRACE(bh2, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh2);\n\tif (err) goto fail;\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh2);\n\tif (err) goto fail;\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\tei->i_flags =\n\t\text3_mask_flags(mode, EXT3_I(dir)->i_flags & EXT3_FL_INHERITED);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n#endif\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\n\text3_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\thandle->h_sync = 1;\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\tei->i_state_flags = 0;\n\text3_set_inode_state(inode, EXT3_STATE_NEW);\n\n\t/* See comment in ext3_iget for explanation */\n\tif (ino >= EXT3_FIRST_INO(sb) + 1 &&\n\t    EXT3_INODE_SIZE(sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize =\n\t\t\tsizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE;\n\t} else {\n\t\tei->i_extra_isize = 0;\n\t}\n\n\tret = inode;\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext3_init_acl(handle, inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_init_security(handle, inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text3_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text3_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext3_allocate_inode(inode, dir, mode);\n\tgoto really_out;\nfail:\n\text3_std_error(sb, err);\nout:\n\tiput(inode);\n\tret = ERR_PTR(err);\nreally_out:\n\tbrelse(bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tbrelse(bitmap_bh);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext3_new_inode(handle_t *handle, struct inode * dir,\n\t\t\t     const struct qstr *qstr, umode_t mode)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group;\n\tunsigned long ino = 0;\n\tstruct inode * inode;\n\tstruct ext3_group_desc * gdp = NULL;\n\tstruct ext3_super_block * es;\n\tstruct ext3_inode_info *ei;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0;\n\tstruct inode *ret;\n\tint i;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\ttrace_ext3_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT3_I(inode);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode))\n\t\tgroup = find_group_orlov(sb, dir);\n\telse\n\t\tgroup = find_group_other(sb, dir);\n\n\terr = -ENOSPC;\n\tif (group == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\terr = -EIO;\n\n\t\tgdp = ext3_get_group_desc(sb, group, &bh2);\n\t\tif (!gdp)\n\t\t\tgoto fail;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh)\n\t\t\tgoto fail;\n\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext3_find_next_zero_bit((unsigned long *)\n\t\t\t\tbitmap_bh->b_data, EXT3_INODES_PER_GROUP(sb), ino);\n\t\tif (ino < EXT3_INODES_PER_GROUP(sb)) {\n\n\t\t\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bitmap_bh);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!ext3_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t\t/* we won it */\n\t\t\t\tBUFFER_TRACE(bitmap_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto got;\n\t\t\t}\n\t\t\t/* we lost it */\n\t\t\tjournal_release_buffer(handle, bitmap_bh);\n\n\t\t\tif (++ino < EXT3_INODES_PER_GROUP(sb))\n\t\t\t\tgoto repeat_in_this_group;\n\t\t}\n\n\t\t/*\n\t\t * This case is possible in concurrent environment.  It is very\n\t\t * rare.  We cannot repeat the find_group_xxx() call because\n\t\t * that will simply return the same blockgroup, because the\n\t\t * group descriptor metadata has not yet been updated.\n\t\t * So we just go onto the next blockgroup.\n\t\t */\n\t\tif (++group == sbi->s_groups_count)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tino += group * EXT3_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d, inode=%lu\", group, ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tBUFFER_TRACE(bh2, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh2);\n\tif (err) goto fail;\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh2);\n\tif (err) goto fail;\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\tei->i_flags =\n\t\text3_mask_flags(mode, EXT3_I(dir)->i_flags & EXT3_FL_INHERITED);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n#endif\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\n\text3_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\thandle->h_sync = 1;\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\tei->i_state_flags = 0;\n\text3_set_inode_state(inode, EXT3_STATE_NEW);\n\n\t/* See comment in ext3_iget for explanation */\n\tif (ino >= EXT3_FIRST_INO(sb) + 1 &&\n\t    EXT3_INODE_SIZE(sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize =\n\t\t\tsizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE;\n\t} else {\n\t\tei->i_extra_isize = 0;\n\t}\n\n\tret = inode;\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext3_init_acl(handle, inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_init_security(handle, inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text3_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text3_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext3_allocate_inode(inode, dir, mode);\n\tgoto really_out;\nfail:\n\text3_std_error(sb, err);\nout:\n\tiput(inode);\n\tret = ERR_PTR(err);\nreally_out:\n\tbrelse(bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tbrelse(bitmap_bh);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "dir",
            "EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 3 +\n\t\t\t\t\tEXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb)"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_MAXQUOTAS_INIT_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\nconst struct inode_operations ext3_special_inode_operations = {\n\t.setattr\t= ext3_setattr,\n#ifdef CONFIG_EXT3_FS_XATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext3_listxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n\t.get_acl\t= ext3_get_acl,\n\t.set_acl\t= ext3_set_acl,\n};\n\nstatic int ext3_mknod (struct inode * dir, struct dentry *dentry,\n\t\t\tumode_t mode, dev_t rdev)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, retries = 0;\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tdquot_initialize(dir);\n\nretry:\n\thandle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 3 +\n\t\t\t\t\tEXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tinode = ext3_new_inode (handle, dir, &dentry->d_name, mode);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n#ifdef CONFIG_EXT3_FS_XATTR\n\t\tinode->i_op = &ext3_special_inode_operations;\n#endif\n\t\terr = ext3_add_nondir(handle, dentry, inode);\n\t}\n\text3_journal_stop(handle);\n\tif (err == -ENOSPC && ext3_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1692-1723",
    "snippet": "static int ext3_create (struct inode * dir, struct dentry * dentry, umode_t mode,\n\t\tbool excl)\n{\n\thandle_t *handle;\n\tstruct inode * inode;\n\tint err, retries = 0;\n\n\tdquot_initialize(dir);\n\nretry:\n\thandle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 3 +\n\t\t\t\t\tEXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tinode = ext3_new_inode (handle, dir, &dentry->d_name, mode);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t\terr = ext3_add_nondir(handle, dentry, inode);\n\t}\n\text3_journal_stop(handle);\n\tif (err == -ENOSPC && ext3_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_should_retry_alloc",
          "args": [
            "dir->i_sb",
            "&retries"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1462-1470",
          "snippet": "int ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_add_nondir",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1668-1682",
          "snippet": "static int ext3_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext3_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text3_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext3_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text3_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_set_aops",
          "args": [
            "inode"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_aops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1979-1987",
          "snippet": "void ext3_set_aops(struct inode *inode)\n{\n\tif (ext3_should_order_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_ordered_aops;\n\telse if (ext3_should_writeback_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_writeback_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext3_journalled_aops;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static const struct address_space_operations ext3_ordered_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_ordered_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_ordered_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.is_dirty_writeback\t= buffer_check_dirty_writeback,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext3_writeback_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_writeback_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_writeback_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext3_journalled_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_journalled_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_journalled_write_end,\n\t.set_page_dirty\t\t= ext3_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic const struct address_space_operations ext3_ordered_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_ordered_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_ordered_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.is_dirty_writeback\t= buffer_check_dirty_writeback,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext3_writeback_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_writeback_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_writeback_write_end,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.direct_IO\t\t= ext3_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext3_journalled_aops = {\n\t.readpage\t\t= ext3_readpage,\n\t.readpages\t\t= ext3_readpages,\n\t.writepage\t\t= ext3_journalled_writepage,\n\t.write_begin\t\t= ext3_write_begin,\n\t.write_end\t\t= ext3_journalled_write_end,\n\t.set_page_dirty\t\t= ext3_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext3_bmap,\n\t.invalidatepage\t\t= ext3_invalidatepage,\n\t.releasepage\t\t= ext3_releasepage,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext3_set_aops(struct inode *inode)\n{\n\tif (ext3_should_order_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_ordered_aops;\n\telse if (ext3_should_writeback_data(inode))\n\t\tinode->i_mapping->a_ops = &ext3_writeback_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext3_journalled_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_new_inode",
          "args": [
            "handle",
            "dir",
            "&dentry->d_name",
            "mode"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "346-567",
          "snippet": "struct inode *ext3_new_inode(handle_t *handle, struct inode * dir,\n\t\t\t     const struct qstr *qstr, umode_t mode)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group;\n\tunsigned long ino = 0;\n\tstruct inode * inode;\n\tstruct ext3_group_desc * gdp = NULL;\n\tstruct ext3_super_block * es;\n\tstruct ext3_inode_info *ei;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0;\n\tstruct inode *ret;\n\tint i;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\ttrace_ext3_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT3_I(inode);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode))\n\t\tgroup = find_group_orlov(sb, dir);\n\telse\n\t\tgroup = find_group_other(sb, dir);\n\n\terr = -ENOSPC;\n\tif (group == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\terr = -EIO;\n\n\t\tgdp = ext3_get_group_desc(sb, group, &bh2);\n\t\tif (!gdp)\n\t\t\tgoto fail;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh)\n\t\t\tgoto fail;\n\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext3_find_next_zero_bit((unsigned long *)\n\t\t\t\tbitmap_bh->b_data, EXT3_INODES_PER_GROUP(sb), ino);\n\t\tif (ino < EXT3_INODES_PER_GROUP(sb)) {\n\n\t\t\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bitmap_bh);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!ext3_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t\t/* we won it */\n\t\t\t\tBUFFER_TRACE(bitmap_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto got;\n\t\t\t}\n\t\t\t/* we lost it */\n\t\t\tjournal_release_buffer(handle, bitmap_bh);\n\n\t\t\tif (++ino < EXT3_INODES_PER_GROUP(sb))\n\t\t\t\tgoto repeat_in_this_group;\n\t\t}\n\n\t\t/*\n\t\t * This case is possible in concurrent environment.  It is very\n\t\t * rare.  We cannot repeat the find_group_xxx() call because\n\t\t * that will simply return the same blockgroup, because the\n\t\t * group descriptor metadata has not yet been updated.\n\t\t * So we just go onto the next blockgroup.\n\t\t */\n\t\tif (++group == sbi->s_groups_count)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tino += group * EXT3_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d, inode=%lu\", group, ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tBUFFER_TRACE(bh2, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh2);\n\tif (err) goto fail;\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh2);\n\tif (err) goto fail;\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\tei->i_flags =\n\t\text3_mask_flags(mode, EXT3_I(dir)->i_flags & EXT3_FL_INHERITED);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n#endif\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\n\text3_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\thandle->h_sync = 1;\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\tei->i_state_flags = 0;\n\text3_set_inode_state(inode, EXT3_STATE_NEW);\n\n\t/* See comment in ext3_iget for explanation */\n\tif (ino >= EXT3_FIRST_INO(sb) + 1 &&\n\t    EXT3_INODE_SIZE(sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize =\n\t\t\tsizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE;\n\t} else {\n\t\tei->i_extra_isize = 0;\n\t}\n\n\tret = inode;\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext3_init_acl(handle, inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_init_security(handle, inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text3_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text3_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext3_allocate_inode(inode, dir, mode);\n\tgoto really_out;\nfail:\n\text3_std_error(sb, err);\nout:\n\tiput(inode);\n\tret = ERR_PTR(err);\nreally_out:\n\tbrelse(bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tbrelse(bitmap_bh);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext3_new_inode(handle_t *handle, struct inode * dir,\n\t\t\t     const struct qstr *qstr, umode_t mode)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group;\n\tunsigned long ino = 0;\n\tstruct inode * inode;\n\tstruct ext3_group_desc * gdp = NULL;\n\tstruct ext3_super_block * es;\n\tstruct ext3_inode_info *ei;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0;\n\tstruct inode *ret;\n\tint i;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\ttrace_ext3_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT3_I(inode);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode))\n\t\tgroup = find_group_orlov(sb, dir);\n\telse\n\t\tgroup = find_group_other(sb, dir);\n\n\terr = -ENOSPC;\n\tif (group == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\terr = -EIO;\n\n\t\tgdp = ext3_get_group_desc(sb, group, &bh2);\n\t\tif (!gdp)\n\t\t\tgoto fail;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh)\n\t\t\tgoto fail;\n\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext3_find_next_zero_bit((unsigned long *)\n\t\t\t\tbitmap_bh->b_data, EXT3_INODES_PER_GROUP(sb), ino);\n\t\tif (ino < EXT3_INODES_PER_GROUP(sb)) {\n\n\t\t\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bitmap_bh);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!ext3_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t\t/* we won it */\n\t\t\t\tBUFFER_TRACE(bitmap_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto got;\n\t\t\t}\n\t\t\t/* we lost it */\n\t\t\tjournal_release_buffer(handle, bitmap_bh);\n\n\t\t\tif (++ino < EXT3_INODES_PER_GROUP(sb))\n\t\t\t\tgoto repeat_in_this_group;\n\t\t}\n\n\t\t/*\n\t\t * This case is possible in concurrent environment.  It is very\n\t\t * rare.  We cannot repeat the find_group_xxx() call because\n\t\t * that will simply return the same blockgroup, because the\n\t\t * group descriptor metadata has not yet been updated.\n\t\t * So we just go onto the next blockgroup.\n\t\t */\n\t\tif (++group == sbi->s_groups_count)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tino += group * EXT3_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d, inode=%lu\", group, ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tBUFFER_TRACE(bh2, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh2);\n\tif (err) goto fail;\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh2);\n\tif (err) goto fail;\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\tei->i_flags =\n\t\text3_mask_flags(mode, EXT3_I(dir)->i_flags & EXT3_FL_INHERITED);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n#endif\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\n\text3_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\thandle->h_sync = 1;\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\tei->i_state_flags = 0;\n\text3_set_inode_state(inode, EXT3_STATE_NEW);\n\n\t/* See comment in ext3_iget for explanation */\n\tif (ino >= EXT3_FIRST_INO(sb) + 1 &&\n\t    EXT3_INODE_SIZE(sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize =\n\t\t\tsizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE;\n\t} else {\n\t\tei->i_extra_isize = 0;\n\t}\n\n\tret = inode;\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext3_init_acl(handle, inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_init_security(handle, inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text3_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text3_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext3_allocate_inode(inode, dir, mode);\n\tgoto really_out;\nfail:\n\text3_std_error(sb, err);\nout:\n\tiput(inode);\n\tret = ERR_PTR(err);\nreally_out:\n\tbrelse(bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tbrelse(bitmap_bh);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "dir",
            "EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 3 +\n\t\t\t\t\tEXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb)"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_MAXQUOTAS_INIT_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DATA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_create (struct inode * dir, struct dentry * dentry, umode_t mode,\n\t\tbool excl)\n{\n\thandle_t *handle;\n\tstruct inode * inode;\n\tint err, retries = 0;\n\n\tdquot_initialize(dir);\n\nretry:\n\thandle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\t\tEXT3_INDEX_EXTRA_TRANS_BLOCKS + 3 +\n\t\t\t\t\tEXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\thandle->h_sync = 1;\n\n\tinode = ext3_new_inode (handle, dir, &dentry->d_name, mode);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t\terr = ext3_add_nondir(handle, dentry, inode);\n\t}\n\text3_journal_stop(handle);\n\tif (err == -ENOSPC && ext3_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_add_nondir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1668-1682",
    "snippet": "static int ext3_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext3_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text3_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_add_entry",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1435-1480",
          "snippet": "static int ext3_add_entry (handle_t *handle, struct dentry *dentry,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct super_block * sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\tu32 block, blocks;\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\tif (is_dx(dir)) {\n\t\tretval = ext3_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\tEXT3_I(dir)->i_flags &= ~EXT3_INDEX_FL;\n\t\tdx_fallback++;\n\t\text3_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tif (!(bh = ext3_dir_bread(handle, dir, block, 0, &retval)))\n\t\t\treturn retval;\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC)\n\t\t\treturn retval;\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext3_append(handle, dir, &block, &retval);\n\tif (!bh)\n\t\treturn retval;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext3_rec_len_to_disk(blocksize);\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_add_entry (handle_t *handle, struct dentry *dentry,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct super_block * sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\tu32 block, blocks;\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\tif (is_dx(dir)) {\n\t\tretval = ext3_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\tEXT3_I(dir)->i_flags &= ~EXT3_INDEX_FL;\n\t\tdx_fallback++;\n\t\text3_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tif (!(bh = ext3_dir_bread(handle, dir, block, 0, &retval)))\n\t\t\treturn retval;\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC)\n\t\t\treturn retval;\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext3_append(handle, dir, &block, &retval);\n\tif (!bh)\n\t\treturn retval;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext3_rec_len_to_disk(blocksize);\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tint err = ext3_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text3_mark_inode_dirty(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tdrop_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_delete_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1623-1666",
    "snippet": "static int ext3_delete_entry (handle_t *handle,\n\t\t\t      struct inode * dir,\n\t\t\t      struct ext3_dir_entry_2 * de_del,\n\t\t\t      struct buffer_head * bh)\n{\n\tstruct ext3_dir_entry_2 * de, * pde;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\twhile (i < bh->b_size) {\n\t\tif (!ext3_check_dir_entry(\"ext3_delete_entry\", dir, de, bh, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tint err;\n\n\t\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext3_rec_len_to_disk(\n\t\t\t\t\text3_rec_len_from_disk(pde->rec_len) +\n\t\t\t\t\text3_rec_len_from_disk(de->rec_len));\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (err) {\njournal_error:\n\t\t\t\text3_std_error(dir->i_sb, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext3_rec_len_from_disk(de->rec_len);\n\t\tpde = de;\n\t\tde = ext3_next_entry(de);\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_next_entry",
          "args": [
            "de"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "171-176",
          "snippet": "static inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_rec_len_from_disk",
          "args": [
            "de->rec_len"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "878-887",
          "snippet": "static inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "dir->i_sb",
            "err"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_rec_len_to_disk",
          "args": [
            "ext3_rec_len_from_disk(pde->rec_len) +\n\t\t\t\t\text3_rec_len_from_disk(de->rec_len)"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "889-898",
          "snippet": "static inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get_write_access\""
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_check_dir_entry",
          "args": [
            "\"ext3_delete_entry\"",
            "dir",
            "de",
            "bh",
            "i"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_check_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "62-91",
          "snippet": "int ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nint ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_delete_entry (handle_t *handle,\n\t\t\t      struct inode * dir,\n\t\t\t      struct ext3_dir_entry_2 * de_del,\n\t\t\t      struct buffer_head * bh)\n{\n\tstruct ext3_dir_entry_2 * de, * pde;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\twhile (i < bh->b_size) {\n\t\tif (!ext3_check_dir_entry(\"ext3_delete_entry\", dir, de, bh, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tint err;\n\n\t\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext3_rec_len_to_disk(\n\t\t\t\t\text3_rec_len_from_disk(pde->rec_len) +\n\t\t\t\t\text3_rec_len_from_disk(de->rec_len));\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (err) {\njournal_error:\n\t\t\t\text3_std_error(dir->i_sb, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext3_rec_len_from_disk(de->rec_len);\n\t\tpde = de;\n\t\tde = ext3_next_entry(de);\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "ext3_dx_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1485-1617",
    "snippet": "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct dx_frame frames[2], *frame;\n\tstruct dx_entry *entries, *at;\n\tstruct dx_hash_info hinfo;\n\tstruct buffer_head * bh;\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct ext3_dir_entry_2 *de;\n\tint err;\n\n\tframe = dx_probe(&dentry->d_name, dir, &hinfo, frames, &err);\n\tif (!frame)\n\t\treturn err;\n\tentries = frame->entries;\n\tat = frame->at;\n\n\tif (!(bh = ext3_dir_bread(handle, dir, dx_get_block(frame->at), 0, &err)))\n\t\tgoto cleanup;\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\terr = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\tif (err != -ENOSPC) {\n\t\tbh = NULL;\n\t\tgoto cleanup;\n\t}\n\n\t/* Block full, should compress but for now just split */\n\tdxtrace(printk(\"using %u of %u node entries\\n\",\n\t\t       dx_get_count(entries), dx_get_limit(entries)));\n\t/* Need to split index? */\n\tif (dx_get_count(entries) == dx_get_limit(entries)) {\n\t\tu32 newblock;\n\t\tunsigned icount = dx_get_count(entries);\n\t\tint levels = frame - frames;\n\t\tstruct dx_entry *entries2;\n\t\tstruct dx_node *node2;\n\t\tstruct buffer_head *bh2;\n\n\t\tif (levels && (dx_get_count(frames->entries) ==\n\t\t\t       dx_get_limit(frames->entries))) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"Directory index full!\");\n\t\t\terr = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbh2 = ext3_append (handle, dir, &newblock, &err);\n\t\tif (!(bh2))\n\t\t\tgoto cleanup;\n\t\tnode2 = (struct dx_node *)(bh2->b_data);\n\t\tentries2 = node2->entries;\n\t\tmemset(&node2->fake, 0, sizeof(struct fake_dirent));\n\t\tnode2->fake.rec_len = ext3_rec_len_to_disk(sb->s_blocksize);\n\t\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, frame->bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t\tif (levels) {\n\t\t\tunsigned icount1 = icount/2, icount2 = icount - icount1;\n\t\t\tunsigned hash2 = dx_get_hash(entries + icount1);\n\t\t\tdxtrace(printk(\"Split index %i/%i\\n\", icount1, icount2));\n\n\t\t\tBUFFER_TRACE(frame->bh, \"get_write_access\"); /* index root */\n\t\t\terr = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frames[0].bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tmemcpy ((char *) entries2, (char *) (entries + icount1),\n\t\t\t\ticount2 * sizeof(struct dx_entry));\n\t\t\tdx_set_count (entries, icount1);\n\t\t\tdx_set_count (entries2, icount2);\n\t\t\tdx_set_limit (entries2, dx_node_limit(dir));\n\n\t\t\t/* Which index block gets the new entry? */\n\t\t\tif (at - entries >= icount1) {\n\t\t\t\tframe->at = at = at - entries - icount1 + entries2;\n\t\t\t\tframe->entries = entries = entries2;\n\t\t\t\tswap(frame->bh, bh2);\n\t\t\t}\n\t\t\tdx_insert_block (frames + 0, hash2, newblock);\n\t\t\tdxtrace(dx_show_index (\"node\", frames[1].entries));\n\t\t\tdxtrace(dx_show_index (\"node\",\n\t\t\t       ((struct dx_node *) bh2->b_data)->entries));\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh2);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\tbrelse (bh2);\n\t\t} else {\n\t\t\tdxtrace(printk(\"Creating second level index...\\n\"));\n\t\t\tmemcpy((char *) entries2, (char *) entries,\n\t\t\t       icount * sizeof(struct dx_entry));\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Set up root */\n\t\t\tdx_set_count(entries, 1);\n\t\t\tdx_set_block(entries + 0, newblock);\n\t\t\t((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels = 1;\n\n\t\t\t/* Add new access path frame */\n\t\t\tframe = frames + 1;\n\t\t\tframe->at = at = at - entries + entries2;\n\t\t\tframe->entries = entries = entries2;\n\t\t\tframe->bh = bh2;\n\t\t\terr = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frame->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t}\n\t\terr = ext3_journal_dirty_metadata(handle, frames[0].bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t}\n\tde = do_split(handle, dir, &bh, frame, &hinfo, &err);\n\tif (!de)\n\t\tgoto cleanup;\n\terr = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbh = NULL;\n\tgoto cleanup;\n\njournal_error:\n\text3_std_error(dir->i_sb, err);\ncleanup:\n\tif (bh)\n\t\tbrelse(bh);\n\tdx_release(frames);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline unsigned dx_get_block (struct dx_entry *entry);",
      "static inline unsigned dx_get_hash (struct dx_entry *entry);",
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);",
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static void dx_release (struct dx_frame *frames);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dx_release",
          "args": [
            "frames"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "dx_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "467-475",
          "snippet": "static void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_release (struct dx_frame *frames);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_release (struct dx_frame *frames);\n\nstatic void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "dir->i_sb",
            "err"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_dirent_to_buf",
          "args": [
            "handle",
            "dentry",
            "inode",
            "de",
            "bh"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "add_dirent_to_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1242-1324",
          "snippet": "static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext3_dir_entry_2 *de,\n\t\t\t     struct buffer_head * bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned long\toffset = 0;\n\tunsigned short\treclen;\n\tint\t\tnlen, rlen, err;\n\tchar\t\t*top;\n\n\treclen = EXT3_DIR_REC_LEN(namelen);\n\tif (!de) {\n\t\tde = (struct ext3_dir_entry_2 *)bh->b_data;\n\t\ttop = bh->b_data + dir->i_sb->s_blocksize - reclen;\n\t\twhile ((char *) de <= top) {\n\t\t\tif (!ext3_check_dir_entry(\"ext3_add_entry\", dir, de,\n\t\t\t\t\t\t  bh, offset)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (ext3_match (namelen, name, de)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\t\t\trlen = ext3_rec_len_from_disk(de->rec_len);\n\t\t\tif ((de->inode? rlen - nlen: rlen) >= reclen)\n\t\t\t\tbreak;\n\t\t\tde = (struct ext3_dir_entry_2 *)((char *)de + rlen);\n\t\t\toffset += rlen;\n\t\t}\n\t\tif ((char *) de > top)\n\t\t\treturn -ENOSPC;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text3_std_error(dir->i_sb, err);\n\t\tbrelse(bh);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\trlen = ext3_rec_len_from_disk(de->rec_len);\n\tif (de->inode) {\n\t\tstruct ext3_dir_entry_2 *de1 = (struct ext3_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext3_rec_len_to_disk(rlen - nlen);\n\t\tde->rec_len = ext3_rec_len_to_disk(nlen);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT3_FT_UNKNOWN;\n\tif (inode) {\n\t\tde->inode = cpu_to_le32(inode->i_ino);\n\t\text3_set_de_type(dir->i_sb, de, inode->i_mode);\n\t} else\n\t\tde->inode = 0;\n\tde->name_len = namelen;\n\tmemcpy (de->name, name, namelen);\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext3_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\text3_update_dx_flag(dir);\n\tdir->i_version++;\n\text3_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\text3_std_error(dir->i_sb, err);\n\tbrelse(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext3_dir_entry_2 *de,\n\t\t\t     struct buffer_head * bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned long\toffset = 0;\n\tunsigned short\treclen;\n\tint\t\tnlen, rlen, err;\n\tchar\t\t*top;\n\n\treclen = EXT3_DIR_REC_LEN(namelen);\n\tif (!de) {\n\t\tde = (struct ext3_dir_entry_2 *)bh->b_data;\n\t\ttop = bh->b_data + dir->i_sb->s_blocksize - reclen;\n\t\twhile ((char *) de <= top) {\n\t\t\tif (!ext3_check_dir_entry(\"ext3_add_entry\", dir, de,\n\t\t\t\t\t\t  bh, offset)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (ext3_match (namelen, name, de)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\t\t\trlen = ext3_rec_len_from_disk(de->rec_len);\n\t\t\tif ((de->inode? rlen - nlen: rlen) >= reclen)\n\t\t\t\tbreak;\n\t\t\tde = (struct ext3_dir_entry_2 *)((char *)de + rlen);\n\t\t\toffset += rlen;\n\t\t}\n\t\tif ((char *) de > top)\n\t\t\treturn -ENOSPC;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text3_std_error(dir->i_sb, err);\n\t\tbrelse(bh);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\trlen = ext3_rec_len_from_disk(de->rec_len);\n\tif (de->inode) {\n\t\tstruct ext3_dir_entry_2 *de1 = (struct ext3_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext3_rec_len_to_disk(rlen - nlen);\n\t\tde->rec_len = ext3_rec_len_to_disk(nlen);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT3_FT_UNKNOWN;\n\tif (inode) {\n\t\tde->inode = cpu_to_le32(inode->i_ino);\n\t\text3_set_de_type(dir->i_sb, de, inode->i_mode);\n\t} else\n\t\tde->inode = 0;\n\tde->name_len = namelen;\n\tmemcpy (de->name, name, namelen);\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext3_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\text3_update_dx_flag(dir);\n\tdir->i_version++;\n\text3_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\text3_std_error(dir->i_sb, err);\n\tbrelse(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_split",
          "args": [
            "handle",
            "dir",
            "&bh",
            "frame",
            "&hinfo",
            "&err"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "do_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1138-1228",
          "snippet": "static struct ext3_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo, int *error)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\tu32 newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext3_dir_entry_2 *de = NULL, *de2;\n\tint\terr = 0, i;\n\n\tbh2 = ext3_append (handle, dir, &newblock, &err);\n\tif (!(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\tgoto errout;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map ((struct ext3_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map (map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(\"Split block %i at %x, %i/%i\\n\",\n\t\tdx_get_block(frame->at), hash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split);\n\tde = dx_pack_dirents(data1,blocksize);\n\tde->rec_len = ext3_rec_len_to_disk(data1 + blocksize - (char *) de);\n\tde2->rec_len = ext3_rec_len_to_disk(data2 + blocksize - (char *) de2);\n\tdxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data1, blocksize, 1));\n\tdxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data2, blocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2)\n\t{\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block (frame, hash2 + continued, newblock);\n\terr = ext3_journal_dirty_metadata (handle, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext3_journal_dirty_metadata (handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse (bh2);\n\tdxtrace(dx_show_index (\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text3_std_error(dir->i_sb, err);\nerrout:\n\t*error = err;\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
            "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext3_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo, int *error)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\tu32 newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext3_dir_entry_2 *de = NULL, *de2;\n\tint\terr = 0, i;\n\n\tbh2 = ext3_append (handle, dir, &newblock, &err);\n\tif (!(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\tgoto errout;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map ((struct ext3_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map (map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(\"Split block %i at %x, %i/%i\\n\",\n\t\tdx_get_block(frame->at), hash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split);\n\tde = dx_pack_dirents(data1,blocksize);\n\tde->rec_len = ext3_rec_len_to_disk(data1 + blocksize - (char *) de);\n\tde2->rec_len = ext3_rec_len_to_disk(data2 + blocksize - (char *) de2);\n\tdxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data1, blocksize, 1));\n\tdxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data2, blocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2)\n\t{\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block (frame, hash2 + continued, newblock);\n\terr = ext3_journal_dirty_metadata (handle, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext3_journal_dirty_metadata (handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse (bh2);\n\tdxtrace(dx_show_index (\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text3_std_error(dir->i_sb, err);\nerrout:\n\t*error = err;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "frames[0].bh"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "frame->bh"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_set_block",
          "args": [
            "entries + 0",
            "newblock"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "188-191",
          "snippet": "static inline void dx_set_block (struct dx_entry *entry, unsigned value)\n{\n\tentry->block = cpu_to_le32(value);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static void dx_set_block (struct dx_entry *entry, unsigned value);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
            "static void dx_set_count (struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit (struct dx_entry *entries, unsigned value);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic inline void dx_set_block (struct dx_entry *entry, unsigned value)\n{\n\tentry->block = cpu_to_le32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_count",
          "args": [
            "entries",
            "1"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "213-216",
          "snippet": "static inline void dx_set_count (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block (struct dx_entry *entry, unsigned value);",
            "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_set_count (struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit (struct dx_entry *entries, unsigned value);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\n\nstatic inline void dx_set_count (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_limit",
          "args": [
            "entries2",
            "dx_node_limit(dir)"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "218-221",
          "snippet": "static inline void dx_set_limit (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block (struct dx_entry *entry, unsigned value);",
            "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_set_count (struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit (struct dx_entry *entries, unsigned value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\n\nstatic inline void dx_set_limit (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_node_limit",
          "args": [
            "dir"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "dx_node_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "230-234",
          "snippet": "static inline unsigned dx_node_limit (struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(0);\n\treturn entry_space / sizeof(struct dx_entry);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline unsigned dx_node_limit (struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(0);\n\treturn entry_space / sizeof(struct dx_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) entries2",
            "(char *) entries",
            "icount * sizeof(struct dx_entry)"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\"Creating second level index...\\n\")"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Creating second level index...\\n\""
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh2"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "dx_show_index (\"node\",\n\t\t\t       ((struct dx_node *) bh2->b_data)->entries)"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_show_index",
          "args": [
            "\"node\"",
            "((struct dx_node *) bh2->b_data)->entries"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "dx_show_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "240-249",
          "snippet": "static void dx_show_index (char * label, struct dx_entry *entries)\n{\n        int i, n = dx_get_count (entries);\n        printk(\"%s index \", label);\n        for (i = 0; i < n; i++)\n        {\n                printk(\"%x->%u \", i? dx_get_hash(entries + i): 0, dx_get_block(entries + i));\n        }\n        printk(\"\\n\");\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\n\nstatic void dx_show_index (char * label, struct dx_entry *entries)\n{\n        int i, n = dx_get_count (entries);\n        printk(\"%s index \", label);\n        for (i = 0; i < n; i++)\n        {\n                printk(\"%x->%u \", i? dx_get_hash(entries + i): 0, dx_get_block(entries + i));\n        }\n        printk(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "dx_show_index (\"node\", frames[1].entries)"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_insert_block",
          "args": [
            "frames + 0",
            "hash2",
            "newblock"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "dx_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "753-765",
          "snippet": "static void dx_insert_block(struct dx_frame *frame, u32 hash, u32 block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tassert(count < dx_get_limit(entries));\n\tassert(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic void dx_insert_block(struct dx_frame *frame, u32 hash, u32 block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tassert(count < dx_get_limit(entries));\n\tassert(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "frame->bh",
            "bh2"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "swap_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2438-2481",
          "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) entries2",
            "(char *) (entries + icount1)",
            "icount2 * sizeof(struct dx_entry)"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "frames[0].bh"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "frame->bh",
            "\"get_write_access\""
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\"Split index %i/%i\\n\", icount1, icount2)"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Split index %i/%i\\n\"",
            "icount1",
            "icount2"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "__cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "30-75",
          "snippet": "static noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_hash",
          "args": [
            "entries + icount1"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "193-196",
          "snippet": "static inline unsigned dx_get_hash (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\n\nstatic inline unsigned dx_get_hash (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "frame->bh"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "frame->bh",
            "\"get_write_access\""
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_rec_len_to_disk",
          "args": [
            "sb->s_blocksize"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "889-898",
          "snippet": "static inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&node2->fake",
            "0",
            "sizeof(struct fake_dirent)"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_append",
          "args": [
            "handle",
            "dir",
            "&newblock",
            "&err"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "40-58",
          "snippet": "static struct buffer_head *ext3_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tu32 *block, int *err)\n{\n\tstruct buffer_head *bh;\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tif ((bh = ext3_dir_bread(handle, inode, *block, 1, err))) {\n\t\tinode->i_size += inode->i_sb->s_blocksize;\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t\t*err = ext3_journal_get_write_access(handle, bh);\n\t\tif (*err) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext3_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tu32 *block, int *err)\n{\n\tstruct buffer_head *bh;\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tif ((bh = ext3_dir_bread(handle, inode, *block, 1, err))) {\n\t\tinode->i_size += inode->i_sb->s_blocksize;\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t\t*err = ext3_journal_get_write_access(handle, bh);\n\t\tif (*err) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "sb",
            "__func__",
            "\"Directory index full!\""
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_limit",
          "args": [
            "frames->entries"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "208-211",
          "snippet": "static inline unsigned dx_get_limit (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\n\nstatic inline unsigned dx_get_limit (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_count",
          "args": [
            "frames->entries"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "203-206",
          "snippet": "static inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\n\nstatic inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\"using %u of %u node entries\\n\",\n\t\t       dx_get_count(entries), dx_get_limit(entries))"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get_write_access\""
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_dir_bread",
          "args": [
            "handle",
            "dir",
            "dx_get_block(frame->at)",
            "0",
            "&err"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_dir_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.h",
          "lines": "10-27",
          "snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "frame->at"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "183-186",
          "snippet": "static inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_probe",
          "args": [
            "&dentry->d_name",
            "dir",
            "&hinfo",
            "frames",
            "&err"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "dx_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "328-465",
          "snippet": "static struct dx_frame *\ndx_probe(struct qstr *entry, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in, int *err)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct buffer_head *bh;\n\tstruct dx_frame *frame = frame_in;\n\tu32 hash;\n\n\tframe->bh = NULL;\n\tif (!(bh = ext3_dir_bread(NULL, dir, 0, 0, err))) {\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT3_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\tif (entry)\n\t\text3fs_dirhash(entry->name, entry->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"dx entry: limit != root limit\");\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tdxtrace (printk(\"Look up %x\", hash));\n\twhile (1)\n\t{\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q)\n\t\t{\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) // linear search cross check\n\t\t{\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->bh = bh;\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--) return frame;\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(at), 0, err))) {\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tat = entries = ((struct dx_node *) bh->b_data)->entries;\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tframe++;\n\t\tframe->bh = NULL;\n\t}\nfail2:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\nfail:\n\tif (*err == ERR_BAD_DX_DIR)\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Corrupt dir inode %ld, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct dx_frame *\ndx_probe(struct qstr *entry, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in, int *err)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct buffer_head *bh;\n\tstruct dx_frame *frame = frame_in;\n\tu32 hash;\n\n\tframe->bh = NULL;\n\tif (!(bh = ext3_dir_bread(NULL, dir, 0, 0, err))) {\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT3_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\tif (entry)\n\t\text3fs_dirhash(entry->name, entry->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"dx entry: limit != root limit\");\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tdxtrace (printk(\"Look up %x\", hash));\n\twhile (1)\n\t{\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q)\n\t\t{\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) // linear search cross check\n\t\t{\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->bh = bh;\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--) return frame;\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(at), 0, err))) {\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tat = entries = ((struct dx_node *) bh->b_data)->entries;\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tframe++;\n\t\tframe->bh = NULL;\n\t}\nfail2:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\nfail:\n\tif (*err == ERR_BAD_DX_DIR)\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Corrupt dir inode %ld, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_release (struct dx_frame *frames);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct dx_frame frames[2], *frame;\n\tstruct dx_entry *entries, *at;\n\tstruct dx_hash_info hinfo;\n\tstruct buffer_head * bh;\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct ext3_dir_entry_2 *de;\n\tint err;\n\n\tframe = dx_probe(&dentry->d_name, dir, &hinfo, frames, &err);\n\tif (!frame)\n\t\treturn err;\n\tentries = frame->entries;\n\tat = frame->at;\n\n\tif (!(bh = ext3_dir_bread(handle, dir, dx_get_block(frame->at), 0, &err)))\n\t\tgoto cleanup;\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\terr = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\tif (err != -ENOSPC) {\n\t\tbh = NULL;\n\t\tgoto cleanup;\n\t}\n\n\t/* Block full, should compress but for now just split */\n\tdxtrace(printk(\"using %u of %u node entries\\n\",\n\t\t       dx_get_count(entries), dx_get_limit(entries)));\n\t/* Need to split index? */\n\tif (dx_get_count(entries) == dx_get_limit(entries)) {\n\t\tu32 newblock;\n\t\tunsigned icount = dx_get_count(entries);\n\t\tint levels = frame - frames;\n\t\tstruct dx_entry *entries2;\n\t\tstruct dx_node *node2;\n\t\tstruct buffer_head *bh2;\n\n\t\tif (levels && (dx_get_count(frames->entries) ==\n\t\t\t       dx_get_limit(frames->entries))) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"Directory index full!\");\n\t\t\terr = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbh2 = ext3_append (handle, dir, &newblock, &err);\n\t\tif (!(bh2))\n\t\t\tgoto cleanup;\n\t\tnode2 = (struct dx_node *)(bh2->b_data);\n\t\tentries2 = node2->entries;\n\t\tmemset(&node2->fake, 0, sizeof(struct fake_dirent));\n\t\tnode2->fake.rec_len = ext3_rec_len_to_disk(sb->s_blocksize);\n\t\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, frame->bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t\tif (levels) {\n\t\t\tunsigned icount1 = icount/2, icount2 = icount - icount1;\n\t\t\tunsigned hash2 = dx_get_hash(entries + icount1);\n\t\t\tdxtrace(printk(\"Split index %i/%i\\n\", icount1, icount2));\n\n\t\t\tBUFFER_TRACE(frame->bh, \"get_write_access\"); /* index root */\n\t\t\terr = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frames[0].bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tmemcpy ((char *) entries2, (char *) (entries + icount1),\n\t\t\t\ticount2 * sizeof(struct dx_entry));\n\t\t\tdx_set_count (entries, icount1);\n\t\t\tdx_set_count (entries2, icount2);\n\t\t\tdx_set_limit (entries2, dx_node_limit(dir));\n\n\t\t\t/* Which index block gets the new entry? */\n\t\t\tif (at - entries >= icount1) {\n\t\t\t\tframe->at = at = at - entries - icount1 + entries2;\n\t\t\t\tframe->entries = entries = entries2;\n\t\t\t\tswap(frame->bh, bh2);\n\t\t\t}\n\t\t\tdx_insert_block (frames + 0, hash2, newblock);\n\t\t\tdxtrace(dx_show_index (\"node\", frames[1].entries));\n\t\t\tdxtrace(dx_show_index (\"node\",\n\t\t\t       ((struct dx_node *) bh2->b_data)->entries));\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh2);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\tbrelse (bh2);\n\t\t} else {\n\t\t\tdxtrace(printk(\"Creating second level index...\\n\"));\n\t\t\tmemcpy((char *) entries2, (char *) entries,\n\t\t\t       icount * sizeof(struct dx_entry));\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Set up root */\n\t\t\tdx_set_count(entries, 1);\n\t\t\tdx_set_block(entries + 0, newblock);\n\t\t\t((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels = 1;\n\n\t\t\t/* Add new access path frame */\n\t\t\tframe = frames + 1;\n\t\t\tframe->at = at = at - entries + entries2;\n\t\t\tframe->entries = entries = entries2;\n\t\t\tframe->bh = bh2;\n\t\t\terr = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frame->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t}\n\t\terr = ext3_journal_dirty_metadata(handle, frames[0].bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t}\n\tde = do_split(handle, dir, &bh, frame, &hinfo, &err);\n\tif (!de)\n\t\tgoto cleanup;\n\terr = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbh = NULL;\n\tgoto cleanup;\n\njournal_error:\n\text3_std_error(dir->i_sb, err);\ncleanup:\n\tif (bh)\n\t\tbrelse(bh);\n\tdx_release(frames);\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1435-1480",
    "snippet": "static int ext3_add_entry (handle_t *handle, struct dentry *dentry,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct super_block * sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\tu32 block, blocks;\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\tif (is_dx(dir)) {\n\t\tretval = ext3_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\tEXT3_I(dir)->i_flags &= ~EXT3_INDEX_FL;\n\t\tdx_fallback++;\n\t\text3_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tif (!(bh = ext3_dir_bread(handle, dir, block, 0, &retval)))\n\t\t\treturn retval;\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC)\n\t\t\treturn retval;\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext3_append(handle, dir, &block, &retval);\n\tif (!bh)\n\t\treturn retval;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext3_rec_len_to_disk(blocksize);\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_dirent_to_buf",
          "args": [
            "handle",
            "dentry",
            "inode",
            "de",
            "bh"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "add_dirent_to_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1242-1324",
          "snippet": "static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext3_dir_entry_2 *de,\n\t\t\t     struct buffer_head * bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned long\toffset = 0;\n\tunsigned short\treclen;\n\tint\t\tnlen, rlen, err;\n\tchar\t\t*top;\n\n\treclen = EXT3_DIR_REC_LEN(namelen);\n\tif (!de) {\n\t\tde = (struct ext3_dir_entry_2 *)bh->b_data;\n\t\ttop = bh->b_data + dir->i_sb->s_blocksize - reclen;\n\t\twhile ((char *) de <= top) {\n\t\t\tif (!ext3_check_dir_entry(\"ext3_add_entry\", dir, de,\n\t\t\t\t\t\t  bh, offset)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (ext3_match (namelen, name, de)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\t\t\trlen = ext3_rec_len_from_disk(de->rec_len);\n\t\t\tif ((de->inode? rlen - nlen: rlen) >= reclen)\n\t\t\t\tbreak;\n\t\t\tde = (struct ext3_dir_entry_2 *)((char *)de + rlen);\n\t\t\toffset += rlen;\n\t\t}\n\t\tif ((char *) de > top)\n\t\t\treturn -ENOSPC;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text3_std_error(dir->i_sb, err);\n\t\tbrelse(bh);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\trlen = ext3_rec_len_from_disk(de->rec_len);\n\tif (de->inode) {\n\t\tstruct ext3_dir_entry_2 *de1 = (struct ext3_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext3_rec_len_to_disk(rlen - nlen);\n\t\tde->rec_len = ext3_rec_len_to_disk(nlen);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT3_FT_UNKNOWN;\n\tif (inode) {\n\t\tde->inode = cpu_to_le32(inode->i_ino);\n\t\text3_set_de_type(dir->i_sb, de, inode->i_mode);\n\t} else\n\t\tde->inode = 0;\n\tde->name_len = namelen;\n\tmemcpy (de->name, name, namelen);\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext3_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\text3_update_dx_flag(dir);\n\tdir->i_version++;\n\text3_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\text3_std_error(dir->i_sb, err);\n\tbrelse(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext3_dir_entry_2 *de,\n\t\t\t     struct buffer_head * bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned long\toffset = 0;\n\tunsigned short\treclen;\n\tint\t\tnlen, rlen, err;\n\tchar\t\t*top;\n\n\treclen = EXT3_DIR_REC_LEN(namelen);\n\tif (!de) {\n\t\tde = (struct ext3_dir_entry_2 *)bh->b_data;\n\t\ttop = bh->b_data + dir->i_sb->s_blocksize - reclen;\n\t\twhile ((char *) de <= top) {\n\t\t\tif (!ext3_check_dir_entry(\"ext3_add_entry\", dir, de,\n\t\t\t\t\t\t  bh, offset)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (ext3_match (namelen, name, de)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\t\t\trlen = ext3_rec_len_from_disk(de->rec_len);\n\t\t\tif ((de->inode? rlen - nlen: rlen) >= reclen)\n\t\t\t\tbreak;\n\t\t\tde = (struct ext3_dir_entry_2 *)((char *)de + rlen);\n\t\t\toffset += rlen;\n\t\t}\n\t\tif ((char *) de > top)\n\t\t\treturn -ENOSPC;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text3_std_error(dir->i_sb, err);\n\t\tbrelse(bh);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\trlen = ext3_rec_len_from_disk(de->rec_len);\n\tif (de->inode) {\n\t\tstruct ext3_dir_entry_2 *de1 = (struct ext3_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext3_rec_len_to_disk(rlen - nlen);\n\t\tde->rec_len = ext3_rec_len_to_disk(nlen);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT3_FT_UNKNOWN;\n\tif (inode) {\n\t\tde->inode = cpu_to_le32(inode->i_ino);\n\t\text3_set_de_type(dir->i_sb, de, inode->i_mode);\n\t} else\n\t\tde->inode = 0;\n\tde->name_len = namelen;\n\tmemcpy (de->name, name, namelen);\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext3_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\text3_update_dx_flag(dir);\n\tdir->i_version++;\n\text3_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\text3_std_error(dir->i_sb, err);\n\tbrelse(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_rec_len_to_disk",
          "args": [
            "blocksize"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "889-898",
          "snippet": "static inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_append",
          "args": [
            "handle",
            "dir",
            "&block",
            "&retval"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "40-58",
          "snippet": "static struct buffer_head *ext3_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tu32 *block, int *err)\n{\n\tstruct buffer_head *bh;\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tif ((bh = ext3_dir_bread(handle, inode, *block, 1, err))) {\n\t\tinode->i_size += inode->i_sb->s_blocksize;\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t\t*err = ext3_journal_get_write_access(handle, bh);\n\t\tif (*err) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext3_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tu32 *block, int *err)\n{\n\tstruct buffer_head *bh;\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tif ((bh = ext3_dir_bread(handle, inode, *block, 1, err))) {\n\t\tinode->i_size += inode->i_sb->s_blocksize;\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t\t*err = ext3_journal_get_write_access(handle, bh);\n\t\tif (*err) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_indexed_dir",
          "args": [
            "handle",
            "dentry",
            "inode",
            "bh"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "make_indexed_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1330-1423",
          "snippet": "static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext3_dir_entry_2\t*de, *de2;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\tu32\t\tblock;\n\tstruct fake_dirent *fde;\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n\tretval = ext3_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text3_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext3_dir_entry_2 *)((char *)fde +\n\t\t\text3_rec_len_from_disk(fde->rec_len));\n\tif ((char *) de >= (((char *) root) + blocksize)) {\n\t\text3_error(dir->i_sb, __func__,\n\t\t\t   \"invalid rec_len for '..' in inode %lu\",\n\t\t\t   dir->i_ino);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\tlen = ((char *) root) + blocksize - (char *) de;\n\n\tbh2 = ext3_append (handle, dir, &block, &retval);\n\tif (!(bh2)) {\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\tEXT3_I(dir)->i_flags |= EXT3_INDEX_FL;\n\tdata1 = bh2->b_data;\n\n\tmemcpy (data1, de, len);\n\tde = (struct ext3_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext3_next_entry(de)) < top)\n\t\tde = de2;\n\tde->rec_len = ext3_rec_len_to_disk(data1 + blocksize - (char *) de);\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext3_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext3_rec_len_to_disk(blocksize - EXT3_DIR_REC_LEN(2));\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT3_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block (entries, 1);\n\tdx_set_count (entries, 1);\n\tdx_set_limit (entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT3_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\text3fs_dirhash(name, namelen, &hinfo);\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\t/*\n\t * Mark buffers dirty here so that if do_split() fails we write a\n\t * consistent set of buffers to disk.\n\t */\n\text3_journal_dirty_metadata(handle, frame->bh);\n\text3_journal_dirty_metadata(handle, bh);\n\tde = do_split(handle,dir, &bh, frame, &hinfo, &retval);\n\tif (!de) {\n\t\text3_mark_inode_dirty(handle, dir);\n\t\tdx_release(frames);\n\t\treturn retval;\n\t}\n\tdx_release(frames);\n\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static void dx_release (struct dx_frame *frames);",
            "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic void dx_release (struct dx_frame *frames);\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext3_dir_entry_2\t*de, *de2;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\tu32\t\tblock;\n\tstruct fake_dirent *fde;\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n\tretval = ext3_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text3_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext3_dir_entry_2 *)((char *)fde +\n\t\t\text3_rec_len_from_disk(fde->rec_len));\n\tif ((char *) de >= (((char *) root) + blocksize)) {\n\t\text3_error(dir->i_sb, __func__,\n\t\t\t   \"invalid rec_len for '..' in inode %lu\",\n\t\t\t   dir->i_ino);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\tlen = ((char *) root) + blocksize - (char *) de;\n\n\tbh2 = ext3_append (handle, dir, &block, &retval);\n\tif (!(bh2)) {\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\tEXT3_I(dir)->i_flags |= EXT3_INDEX_FL;\n\tdata1 = bh2->b_data;\n\n\tmemcpy (data1, de, len);\n\tde = (struct ext3_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext3_next_entry(de)) < top)\n\t\tde = de2;\n\tde->rec_len = ext3_rec_len_to_disk(data1 + blocksize - (char *) de);\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext3_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext3_rec_len_to_disk(blocksize - EXT3_DIR_REC_LEN(2));\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT3_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block (entries, 1);\n\tdx_set_count (entries, 1);\n\tdx_set_limit (entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT3_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\text3fs_dirhash(name, namelen, &hinfo);\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\t/*\n\t * Mark buffers dirty here so that if do_split() fails we write a\n\t * consistent set of buffers to disk.\n\t */\n\text3_journal_dirty_metadata(handle, frame->bh);\n\text3_journal_dirty_metadata(handle, bh);\n\tde = do_split(handle,dir, &bh, frame, &hinfo, &retval);\n\tif (!de) {\n\t\text3_mark_inode_dirty(handle, dir);\n\t\tdx_release(frames);\n\t\treturn retval;\n\t}\n\tdx_release(frames);\n\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_COMPAT_DIR_INDEX"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_dir_bread",
          "args": [
            "handle",
            "dir",
            "block",
            "0",
            "&retval"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_dir_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.h",
          "lines": "10-27",
          "snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "dir"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "dir"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_dx_add_entry",
          "args": [
            "handle",
            "dentry",
            "inode"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_dx_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1485-1617",
          "snippet": "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct dx_frame frames[2], *frame;\n\tstruct dx_entry *entries, *at;\n\tstruct dx_hash_info hinfo;\n\tstruct buffer_head * bh;\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct ext3_dir_entry_2 *de;\n\tint err;\n\n\tframe = dx_probe(&dentry->d_name, dir, &hinfo, frames, &err);\n\tif (!frame)\n\t\treturn err;\n\tentries = frame->entries;\n\tat = frame->at;\n\n\tif (!(bh = ext3_dir_bread(handle, dir, dx_get_block(frame->at), 0, &err)))\n\t\tgoto cleanup;\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\terr = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\tif (err != -ENOSPC) {\n\t\tbh = NULL;\n\t\tgoto cleanup;\n\t}\n\n\t/* Block full, should compress but for now just split */\n\tdxtrace(printk(\"using %u of %u node entries\\n\",\n\t\t       dx_get_count(entries), dx_get_limit(entries)));\n\t/* Need to split index? */\n\tif (dx_get_count(entries) == dx_get_limit(entries)) {\n\t\tu32 newblock;\n\t\tunsigned icount = dx_get_count(entries);\n\t\tint levels = frame - frames;\n\t\tstruct dx_entry *entries2;\n\t\tstruct dx_node *node2;\n\t\tstruct buffer_head *bh2;\n\n\t\tif (levels && (dx_get_count(frames->entries) ==\n\t\t\t       dx_get_limit(frames->entries))) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"Directory index full!\");\n\t\t\terr = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbh2 = ext3_append (handle, dir, &newblock, &err);\n\t\tif (!(bh2))\n\t\t\tgoto cleanup;\n\t\tnode2 = (struct dx_node *)(bh2->b_data);\n\t\tentries2 = node2->entries;\n\t\tmemset(&node2->fake, 0, sizeof(struct fake_dirent));\n\t\tnode2->fake.rec_len = ext3_rec_len_to_disk(sb->s_blocksize);\n\t\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, frame->bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t\tif (levels) {\n\t\t\tunsigned icount1 = icount/2, icount2 = icount - icount1;\n\t\t\tunsigned hash2 = dx_get_hash(entries + icount1);\n\t\t\tdxtrace(printk(\"Split index %i/%i\\n\", icount1, icount2));\n\n\t\t\tBUFFER_TRACE(frame->bh, \"get_write_access\"); /* index root */\n\t\t\terr = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frames[0].bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tmemcpy ((char *) entries2, (char *) (entries + icount1),\n\t\t\t\ticount2 * sizeof(struct dx_entry));\n\t\t\tdx_set_count (entries, icount1);\n\t\t\tdx_set_count (entries2, icount2);\n\t\t\tdx_set_limit (entries2, dx_node_limit(dir));\n\n\t\t\t/* Which index block gets the new entry? */\n\t\t\tif (at - entries >= icount1) {\n\t\t\t\tframe->at = at = at - entries - icount1 + entries2;\n\t\t\t\tframe->entries = entries = entries2;\n\t\t\t\tswap(frame->bh, bh2);\n\t\t\t}\n\t\t\tdx_insert_block (frames + 0, hash2, newblock);\n\t\t\tdxtrace(dx_show_index (\"node\", frames[1].entries));\n\t\t\tdxtrace(dx_show_index (\"node\",\n\t\t\t       ((struct dx_node *) bh2->b_data)->entries));\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh2);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\tbrelse (bh2);\n\t\t} else {\n\t\t\tdxtrace(printk(\"Creating second level index...\\n\"));\n\t\t\tmemcpy((char *) entries2, (char *) entries,\n\t\t\t       icount * sizeof(struct dx_entry));\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Set up root */\n\t\t\tdx_set_count(entries, 1);\n\t\t\tdx_set_block(entries + 0, newblock);\n\t\t\t((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels = 1;\n\n\t\t\t/* Add new access path frame */\n\t\t\tframe = frames + 1;\n\t\t\tframe->at = at = at - entries + entries2;\n\t\t\tframe->entries = entries = entries2;\n\t\t\tframe->bh = bh2;\n\t\t\terr = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frame->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t}\n\t\terr = ext3_journal_dirty_metadata(handle, frames[0].bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t}\n\tde = do_split(handle, dir, &bh, frame, &hinfo, &err);\n\tif (!de)\n\t\tgoto cleanup;\n\terr = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbh = NULL;\n\tgoto cleanup;\n\njournal_error:\n\text3_std_error(dir->i_sb, err);\ncleanup:\n\tif (bh)\n\t\tbrelse(bh);\n\tdx_release(frames);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_release (struct dx_frame *frames);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_release (struct dx_frame *frames);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct dx_frame frames[2], *frame;\n\tstruct dx_entry *entries, *at;\n\tstruct dx_hash_info hinfo;\n\tstruct buffer_head * bh;\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct ext3_dir_entry_2 *de;\n\tint err;\n\n\tframe = dx_probe(&dentry->d_name, dir, &hinfo, frames, &err);\n\tif (!frame)\n\t\treturn err;\n\tentries = frame->entries;\n\tat = frame->at;\n\n\tif (!(bh = ext3_dir_bread(handle, dir, dx_get_block(frame->at), 0, &err)))\n\t\tgoto cleanup;\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\terr = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\tif (err != -ENOSPC) {\n\t\tbh = NULL;\n\t\tgoto cleanup;\n\t}\n\n\t/* Block full, should compress but for now just split */\n\tdxtrace(printk(\"using %u of %u node entries\\n\",\n\t\t       dx_get_count(entries), dx_get_limit(entries)));\n\t/* Need to split index? */\n\tif (dx_get_count(entries) == dx_get_limit(entries)) {\n\t\tu32 newblock;\n\t\tunsigned icount = dx_get_count(entries);\n\t\tint levels = frame - frames;\n\t\tstruct dx_entry *entries2;\n\t\tstruct dx_node *node2;\n\t\tstruct buffer_head *bh2;\n\n\t\tif (levels && (dx_get_count(frames->entries) ==\n\t\t\t       dx_get_limit(frames->entries))) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"Directory index full!\");\n\t\t\terr = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbh2 = ext3_append (handle, dir, &newblock, &err);\n\t\tif (!(bh2))\n\t\t\tgoto cleanup;\n\t\tnode2 = (struct dx_node *)(bh2->b_data);\n\t\tentries2 = node2->entries;\n\t\tmemset(&node2->fake, 0, sizeof(struct fake_dirent));\n\t\tnode2->fake.rec_len = ext3_rec_len_to_disk(sb->s_blocksize);\n\t\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\t\terr = ext3_journal_get_write_access(handle, frame->bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t\tif (levels) {\n\t\t\tunsigned icount1 = icount/2, icount2 = icount - icount1;\n\t\t\tunsigned hash2 = dx_get_hash(entries + icount1);\n\t\t\tdxtrace(printk(\"Split index %i/%i\\n\", icount1, icount2));\n\n\t\t\tBUFFER_TRACE(frame->bh, \"get_write_access\"); /* index root */\n\t\t\terr = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frames[0].bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tmemcpy ((char *) entries2, (char *) (entries + icount1),\n\t\t\t\ticount2 * sizeof(struct dx_entry));\n\t\t\tdx_set_count (entries, icount1);\n\t\t\tdx_set_count (entries2, icount2);\n\t\t\tdx_set_limit (entries2, dx_node_limit(dir));\n\n\t\t\t/* Which index block gets the new entry? */\n\t\t\tif (at - entries >= icount1) {\n\t\t\t\tframe->at = at = at - entries - icount1 + entries2;\n\t\t\t\tframe->entries = entries = entries2;\n\t\t\t\tswap(frame->bh, bh2);\n\t\t\t}\n\t\t\tdx_insert_block (frames + 0, hash2, newblock);\n\t\t\tdxtrace(dx_show_index (\"node\", frames[1].entries));\n\t\t\tdxtrace(dx_show_index (\"node\",\n\t\t\t       ((struct dx_node *) bh2->b_data)->entries));\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh2);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\tbrelse (bh2);\n\t\t} else {\n\t\t\tdxtrace(printk(\"Creating second level index...\\n\"));\n\t\t\tmemcpy((char *) entries2, (char *) entries,\n\t\t\t       icount * sizeof(struct dx_entry));\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Set up root */\n\t\t\tdx_set_count(entries, 1);\n\t\t\tdx_set_block(entries + 0, newblock);\n\t\t\t((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels = 1;\n\n\t\t\t/* Add new access path frame */\n\t\t\tframe = frames + 1;\n\t\t\tframe->at = at = at - entries + entries2;\n\t\t\tframe->entries = entries = entries2;\n\t\t\tframe->bh = bh2;\n\t\t\terr = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     frame->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t}\n\t\terr = ext3_journal_dirty_metadata(handle, frames[0].bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t}\n\tde = do_split(handle, dir, &bh, frame, &hinfo, &err);\n\tif (!de)\n\t\tgoto cleanup;\n\terr = add_dirent_to_buf(handle, dentry, inode, de, bh);\n\tbh = NULL;\n\tgoto cleanup;\n\njournal_error:\n\text3_std_error(dir->i_sb, err);\ncleanup:\n\tif (bh)\n\t\tbrelse(bh);\n\tdx_release(frames);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx",
          "args": [
            "dir"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "49-60",
          "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((EXT3_I(inode)->i_flags & EXT3_INDEX_FL) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((EXT3_I(inode)->i_flags & EXT3_INDEX_FL) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_add_entry (handle_t *handle, struct dentry *dentry,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct buffer_head * bh;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct super_block * sb;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\tu32 block, blocks;\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\tif (is_dx(dir)) {\n\t\tretval = ext3_dx_add_entry(handle, dentry, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\treturn retval;\n\t\tEXT3_I(dir)->i_flags &= ~EXT3_INDEX_FL;\n\t\tdx_fallback++;\n\t\text3_mark_inode_dirty(handle, dir);\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tif (!(bh = ext3_dir_bread(handle, dir, block, 0, &retval)))\n\t\t\treturn retval;\n\n\t\tretval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);\n\t\tif (retval != -ENOSPC)\n\t\t\treturn retval;\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\t\treturn make_indexed_dir(handle, dentry, inode, bh);\n\t\tbrelse(bh);\n\t}\n\tbh = ext3_append(handle, dir, &block, &retval);\n\tif (!bh)\n\t\treturn retval;\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext3_rec_len_to_disk(blocksize);\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}"
  },
  {
    "function_name": "make_indexed_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1330-1423",
    "snippet": "static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext3_dir_entry_2\t*de, *de2;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\tu32\t\tblock;\n\tstruct fake_dirent *fde;\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n\tretval = ext3_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text3_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext3_dir_entry_2 *)((char *)fde +\n\t\t\text3_rec_len_from_disk(fde->rec_len));\n\tif ((char *) de >= (((char *) root) + blocksize)) {\n\t\text3_error(dir->i_sb, __func__,\n\t\t\t   \"invalid rec_len for '..' in inode %lu\",\n\t\t\t   dir->i_ino);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\tlen = ((char *) root) + blocksize - (char *) de;\n\n\tbh2 = ext3_append (handle, dir, &block, &retval);\n\tif (!(bh2)) {\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\tEXT3_I(dir)->i_flags |= EXT3_INDEX_FL;\n\tdata1 = bh2->b_data;\n\n\tmemcpy (data1, de, len);\n\tde = (struct ext3_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext3_next_entry(de)) < top)\n\t\tde = de2;\n\tde->rec_len = ext3_rec_len_to_disk(data1 + blocksize - (char *) de);\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext3_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext3_rec_len_to_disk(blocksize - EXT3_DIR_REC_LEN(2));\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT3_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block (entries, 1);\n\tdx_set_count (entries, 1);\n\tdx_set_limit (entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT3_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\text3fs_dirhash(name, namelen, &hinfo);\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\t/*\n\t * Mark buffers dirty here so that if do_split() fails we write a\n\t * consistent set of buffers to disk.\n\t */\n\text3_journal_dirty_metadata(handle, frame->bh);\n\text3_journal_dirty_metadata(handle, bh);\n\tde = do_split(handle,dir, &bh, frame, &hinfo, &retval);\n\tif (!de) {\n\t\text3_mark_inode_dirty(handle, dir);\n\t\tdx_release(frames);\n\t\treturn retval;\n\t}\n\tdx_release(frames);\n\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);",
      "static unsigned dx_node_limit (struct inode *dir);",
      "static void dx_release (struct dx_frame *frames);",
      "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_dirent_to_buf",
          "args": [
            "handle",
            "dentry",
            "inode",
            "de",
            "bh"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "add_dirent_to_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1242-1324",
          "snippet": "static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext3_dir_entry_2 *de,\n\t\t\t     struct buffer_head * bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned long\toffset = 0;\n\tunsigned short\treclen;\n\tint\t\tnlen, rlen, err;\n\tchar\t\t*top;\n\n\treclen = EXT3_DIR_REC_LEN(namelen);\n\tif (!de) {\n\t\tde = (struct ext3_dir_entry_2 *)bh->b_data;\n\t\ttop = bh->b_data + dir->i_sb->s_blocksize - reclen;\n\t\twhile ((char *) de <= top) {\n\t\t\tif (!ext3_check_dir_entry(\"ext3_add_entry\", dir, de,\n\t\t\t\t\t\t  bh, offset)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (ext3_match (namelen, name, de)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\t\t\trlen = ext3_rec_len_from_disk(de->rec_len);\n\t\t\tif ((de->inode? rlen - nlen: rlen) >= reclen)\n\t\t\t\tbreak;\n\t\t\tde = (struct ext3_dir_entry_2 *)((char *)de + rlen);\n\t\t\toffset += rlen;\n\t\t}\n\t\tif ((char *) de > top)\n\t\t\treturn -ENOSPC;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text3_std_error(dir->i_sb, err);\n\t\tbrelse(bh);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\trlen = ext3_rec_len_from_disk(de->rec_len);\n\tif (de->inode) {\n\t\tstruct ext3_dir_entry_2 *de1 = (struct ext3_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext3_rec_len_to_disk(rlen - nlen);\n\t\tde->rec_len = ext3_rec_len_to_disk(nlen);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT3_FT_UNKNOWN;\n\tif (inode) {\n\t\tde->inode = cpu_to_le32(inode->i_ino);\n\t\text3_set_de_type(dir->i_sb, de, inode->i_mode);\n\t} else\n\t\tde->inode = 0;\n\tde->name_len = namelen;\n\tmemcpy (de->name, name, namelen);\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext3_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\text3_update_dx_flag(dir);\n\tdir->i_version++;\n\text3_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\text3_std_error(dir->i_sb, err);\n\tbrelse(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext3_dir_entry_2 *de,\n\t\t\t     struct buffer_head * bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned long\toffset = 0;\n\tunsigned short\treclen;\n\tint\t\tnlen, rlen, err;\n\tchar\t\t*top;\n\n\treclen = EXT3_DIR_REC_LEN(namelen);\n\tif (!de) {\n\t\tde = (struct ext3_dir_entry_2 *)bh->b_data;\n\t\ttop = bh->b_data + dir->i_sb->s_blocksize - reclen;\n\t\twhile ((char *) de <= top) {\n\t\t\tif (!ext3_check_dir_entry(\"ext3_add_entry\", dir, de,\n\t\t\t\t\t\t  bh, offset)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (ext3_match (namelen, name, de)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\t\t\trlen = ext3_rec_len_from_disk(de->rec_len);\n\t\t\tif ((de->inode? rlen - nlen: rlen) >= reclen)\n\t\t\t\tbreak;\n\t\t\tde = (struct ext3_dir_entry_2 *)((char *)de + rlen);\n\t\t\toffset += rlen;\n\t\t}\n\t\tif ((char *) de > top)\n\t\t\treturn -ENOSPC;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text3_std_error(dir->i_sb, err);\n\t\tbrelse(bh);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\trlen = ext3_rec_len_from_disk(de->rec_len);\n\tif (de->inode) {\n\t\tstruct ext3_dir_entry_2 *de1 = (struct ext3_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext3_rec_len_to_disk(rlen - nlen);\n\t\tde->rec_len = ext3_rec_len_to_disk(nlen);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT3_FT_UNKNOWN;\n\tif (inode) {\n\t\tde->inode = cpu_to_le32(inode->i_ino);\n\t\text3_set_de_type(dir->i_sb, de, inode->i_mode);\n\t} else\n\t\tde->inode = 0;\n\tde->name_len = namelen;\n\tmemcpy (de->name, name, namelen);\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext3_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\text3_update_dx_flag(dir);\n\tdir->i_version++;\n\text3_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\text3_std_error(dir->i_sb, err);\n\tbrelse(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_release",
          "args": [
            "frames"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "dx_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "467-475",
          "snippet": "static void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_release (struct dx_frame *frames);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_release (struct dx_frame *frames);\n\nstatic void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "dir"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_split",
          "args": [
            "handle",
            "dir",
            "&bh",
            "frame",
            "&hinfo",
            "&retval"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "do_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1138-1228",
          "snippet": "static struct ext3_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo, int *error)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\tu32 newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext3_dir_entry_2 *de = NULL, *de2;\n\tint\terr = 0, i;\n\n\tbh2 = ext3_append (handle, dir, &newblock, &err);\n\tif (!(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\tgoto errout;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map ((struct ext3_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map (map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(\"Split block %i at %x, %i/%i\\n\",\n\t\tdx_get_block(frame->at), hash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split);\n\tde = dx_pack_dirents(data1,blocksize);\n\tde->rec_len = ext3_rec_len_to_disk(data1 + blocksize - (char *) de);\n\tde2->rec_len = ext3_rec_len_to_disk(data2 + blocksize - (char *) de2);\n\tdxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data1, blocksize, 1));\n\tdxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data2, blocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2)\n\t{\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block (frame, hash2 + continued, newblock);\n\terr = ext3_journal_dirty_metadata (handle, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext3_journal_dirty_metadata (handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse (bh2);\n\tdxtrace(dx_show_index (\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text3_std_error(dir->i_sb, err);\nerrout:\n\t*error = err;\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
            "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext3_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo, int *error)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\tu32 newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext3_dir_entry_2 *de = NULL, *de2;\n\tint\terr = 0, i;\n\n\tbh2 = ext3_append (handle, dir, &newblock, &err);\n\tif (!(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\tgoto errout;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map ((struct ext3_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map (map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(\"Split block %i at %x, %i/%i\\n\",\n\t\tdx_get_block(frame->at), hash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split);\n\tde = dx_pack_dirents(data1,blocksize);\n\tde->rec_len = ext3_rec_len_to_disk(data1 + blocksize - (char *) de);\n\tde2->rec_len = ext3_rec_len_to_disk(data2 + blocksize - (char *) de2);\n\tdxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data1, blocksize, 1));\n\tdxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data2, blocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2)\n\t{\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block (frame, hash2 + continued, newblock);\n\terr = ext3_journal_dirty_metadata (handle, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext3_journal_dirty_metadata (handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse (bh2);\n\tdxtrace(dx_show_index (\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text3_std_error(dir->i_sb, err);\nerrout:\n\t*error = err;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "frame->bh"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3fs_dirhash",
          "args": [
            "name",
            "namelen",
            "&hinfo"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "ext3fs_dirhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/hash.c",
          "lines": "137-206",
          "snippet": "int ext3fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i=0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < 4)\n\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT3_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT3_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cryptohash.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cryptohash.h>\n#include \"ext3.h\"\n\nint ext3fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i=0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < 4)\n\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT3_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT3_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_limit",
          "args": [
            "entries",
            "dx_root_limit(dir, sizeof(root->info))"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "218-221",
          "snippet": "static inline void dx_set_limit (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block (struct dx_entry *entry, unsigned value);",
            "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_set_count (struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit (struct dx_entry *entries, unsigned value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\n\nstatic inline void dx_set_limit (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_root_limit",
          "args": [
            "dir",
            "sizeof(root->info)"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "dx_root_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "223-228",
          "snippet": "static inline unsigned dx_root_limit (struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(1) -\n\t\tEXT3_DIR_REC_LEN(2) - infosize;\n\treturn entry_space / sizeof(struct dx_entry);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_root_limit (struct inode *dir, unsigned infosize);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_root_limit (struct inode *dir, unsigned infosize);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline unsigned dx_root_limit (struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(1) -\n\t\tEXT3_DIR_REC_LEN(2) - infosize;\n\treturn entry_space / sizeof(struct dx_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_count",
          "args": [
            "entries",
            "1"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "213-216",
          "snippet": "static inline void dx_set_count (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block (struct dx_entry *entry, unsigned value);",
            "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_set_count (struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit (struct dx_entry *entries, unsigned value);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\n\nstatic inline void dx_set_count (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_block",
          "args": [
            "entries",
            "1"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "188-191",
          "snippet": "static inline void dx_set_block (struct dx_entry *entry, unsigned value)\n{\n\tentry->block = cpu_to_le32(value);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static void dx_set_block (struct dx_entry *entry, unsigned value);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
            "static void dx_set_count (struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit (struct dx_entry *entries, unsigned value);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic inline void dx_set_block (struct dx_entry *entry, unsigned value)\n{\n\tentry->block = cpu_to_le32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root->info",
            "0",
            "sizeof(root->info)"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_rec_len_to_disk",
          "args": [
            "blocksize - EXT3_DIR_REC_LEN(2)"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "889-898",
          "snippet": "static inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "2"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_next_entry",
          "args": [
            "de"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "171-176",
          "snippet": "static inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data1",
            "de",
            "len"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "dir"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_append",
          "args": [
            "handle",
            "dir",
            "&block",
            "&retval"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "40-58",
          "snippet": "static struct buffer_head *ext3_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tu32 *block, int *err)\n{\n\tstruct buffer_head *bh;\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tif ((bh = ext3_dir_bread(handle, inode, *block, 1, err))) {\n\t\tinode->i_size += inode->i_sb->s_blocksize;\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t\t*err = ext3_journal_get_write_access(handle, bh);\n\t\tif (*err) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext3_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tu32 *block, int *err)\n{\n\tstruct buffer_head *bh;\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tif ((bh = ext3_dir_bread(handle, inode, *block, 1, err))) {\n\t\tinode->i_size += inode->i_sb->s_blocksize;\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t\t*err = ext3_journal_get_write_access(handle, bh);\n\t\tif (*err) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "dir->i_sb",
            "__func__",
            "\"invalid rec_len for '..' in inode %lu\"",
            "dir->i_ino"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_rec_len_from_disk",
          "args": [
            "fde->rec_len"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "878-887",
          "snippet": "static inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "dir->i_sb",
            "retval"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino)"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Creating index: inode %lu\\n\"",
            "dir->i_ino"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic void dx_release (struct dx_frame *frames);\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext3_dir_entry_2\t*de, *de2;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\tu32\t\tblock;\n\tstruct fake_dirent *fde;\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n\tretval = ext3_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text3_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext3_dir_entry_2 *)((char *)fde +\n\t\t\text3_rec_len_from_disk(fde->rec_len));\n\tif ((char *) de >= (((char *) root) + blocksize)) {\n\t\text3_error(dir->i_sb, __func__,\n\t\t\t   \"invalid rec_len for '..' in inode %lu\",\n\t\t\t   dir->i_ino);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\tlen = ((char *) root) + blocksize - (char *) de;\n\n\tbh2 = ext3_append (handle, dir, &block, &retval);\n\tif (!(bh2)) {\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\tEXT3_I(dir)->i_flags |= EXT3_INDEX_FL;\n\tdata1 = bh2->b_data;\n\n\tmemcpy (data1, de, len);\n\tde = (struct ext3_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext3_next_entry(de)) < top)\n\t\tde = de2;\n\tde->rec_len = ext3_rec_len_to_disk(data1 + blocksize - (char *) de);\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext3_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext3_rec_len_to_disk(blocksize - EXT3_DIR_REC_LEN(2));\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT3_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block (entries, 1);\n\tdx_set_count (entries, 1);\n\tdx_set_limit (entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT3_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\text3fs_dirhash(name, namelen, &hinfo);\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\t/*\n\t * Mark buffers dirty here so that if do_split() fails we write a\n\t * consistent set of buffers to disk.\n\t */\n\text3_journal_dirty_metadata(handle, frame->bh);\n\text3_journal_dirty_metadata(handle, bh);\n\tde = do_split(handle,dir, &bh, frame, &hinfo, &retval);\n\tif (!de) {\n\t\text3_mark_inode_dirty(handle, dir);\n\t\tdx_release(frames);\n\t\treturn retval;\n\t}\n\tdx_release(frames);\n\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}"
  },
  {
    "function_name": "add_dirent_to_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1242-1324",
    "snippet": "static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext3_dir_entry_2 *de,\n\t\t\t     struct buffer_head * bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned long\toffset = 0;\n\tunsigned short\treclen;\n\tint\t\tnlen, rlen, err;\n\tchar\t\t*top;\n\n\treclen = EXT3_DIR_REC_LEN(namelen);\n\tif (!de) {\n\t\tde = (struct ext3_dir_entry_2 *)bh->b_data;\n\t\ttop = bh->b_data + dir->i_sb->s_blocksize - reclen;\n\t\twhile ((char *) de <= top) {\n\t\t\tif (!ext3_check_dir_entry(\"ext3_add_entry\", dir, de,\n\t\t\t\t\t\t  bh, offset)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (ext3_match (namelen, name, de)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\t\t\trlen = ext3_rec_len_from_disk(de->rec_len);\n\t\t\tif ((de->inode? rlen - nlen: rlen) >= reclen)\n\t\t\t\tbreak;\n\t\t\tde = (struct ext3_dir_entry_2 *)((char *)de + rlen);\n\t\t\toffset += rlen;\n\t\t}\n\t\tif ((char *) de > top)\n\t\t\treturn -ENOSPC;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text3_std_error(dir->i_sb, err);\n\t\tbrelse(bh);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\trlen = ext3_rec_len_from_disk(de->rec_len);\n\tif (de->inode) {\n\t\tstruct ext3_dir_entry_2 *de1 = (struct ext3_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext3_rec_len_to_disk(rlen - nlen);\n\t\tde->rec_len = ext3_rec_len_to_disk(nlen);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT3_FT_UNKNOWN;\n\tif (inode) {\n\t\tde->inode = cpu_to_le32(inode->i_ino);\n\t\text3_set_de_type(dir->i_sb, de, inode->i_mode);\n\t} else\n\t\tde->inode = 0;\n\tde->name_len = namelen;\n\tmemcpy (de->name, name, namelen);\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext3_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\text3_update_dx_flag(dir);\n\tdir->i_version++;\n\text3_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\text3_std_error(dir->i_sb, err);\n\tbrelse(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "dir->i_sb",
            "err"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "dir"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_update_dx_flag",
          "args": [
            "dir"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_update_dx_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "767-772",
          "snippet": "static void ext3_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext3_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de->name",
            "name",
            "namelen"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_de_type",
          "args": [
            "dir->i_sb",
            "de",
            "inode->i_mode"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1078-1083",
          "snippet": "static inline void ext3_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext3_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext3_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [
            "#define S_SHIFT 12"
          ],
          "globals_used": [
            "static unsigned char ext3_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXT3_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXT3_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXT3_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXT3_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXT3_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXT3_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXT3_FT_SYMLINK,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\n#define S_SHIFT 12\n\nstatic unsigned char ext3_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXT3_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXT3_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXT3_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXT3_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXT3_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXT3_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXT3_FT_SYMLINK,\n};\n\nstatic inline void ext3_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext3_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext3_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_rec_len_to_disk",
          "args": [
            "nlen"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "889-898",
          "snippet": "static inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_rec_len_from_disk",
          "args": [
            "de->rec_len"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "878-887",
          "snippet": "static inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "dir->i_sb",
            "err"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get_write_access\""
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_match",
          "args": [
            "namelen",
            "name",
            "de"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "780-788",
          "snippet": "static inline int ext3_match (int len, const char * const name,\n\t\t\t      struct ext3_dir_entry_2 * de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int ext3_match (int len, const char * const name,\n\t\t\t      struct ext3_dir_entry_2 * de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_check_dir_entry",
          "args": [
            "\"ext3_add_entry\"",
            "dir",
            "de",
            "bh",
            "offset"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_check_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "62-91",
          "snippet": "int ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nint ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "namelen"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode, struct ext3_dir_entry_2 *de,\n\t\t\t     struct buffer_head * bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tunsigned long\toffset = 0;\n\tunsigned short\treclen;\n\tint\t\tnlen, rlen, err;\n\tchar\t\t*top;\n\n\treclen = EXT3_DIR_REC_LEN(namelen);\n\tif (!de) {\n\t\tde = (struct ext3_dir_entry_2 *)bh->b_data;\n\t\ttop = bh->b_data + dir->i_sb->s_blocksize - reclen;\n\t\twhile ((char *) de <= top) {\n\t\t\tif (!ext3_check_dir_entry(\"ext3_add_entry\", dir, de,\n\t\t\t\t\t\t  bh, offset)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (ext3_match (namelen, name, de)) {\n\t\t\t\tbrelse (bh);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\t\t\trlen = ext3_rec_len_from_disk(de->rec_len);\n\t\t\tif ((de->inode? rlen - nlen: rlen) >= reclen)\n\t\t\t\tbreak;\n\t\t\tde = (struct ext3_dir_entry_2 *)((char *)de + rlen);\n\t\t\toffset += rlen;\n\t\t}\n\t\tif ((char *) de > top)\n\t\t\treturn -ENOSPC;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text3_std_error(dir->i_sb, err);\n\t\tbrelse(bh);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\tnlen = EXT3_DIR_REC_LEN(de->name_len);\n\trlen = ext3_rec_len_from_disk(de->rec_len);\n\tif (de->inode) {\n\t\tstruct ext3_dir_entry_2 *de1 = (struct ext3_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext3_rec_len_to_disk(rlen - nlen);\n\t\tde->rec_len = ext3_rec_len_to_disk(nlen);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT3_FT_UNKNOWN;\n\tif (inode) {\n\t\tde->inode = cpu_to_le32(inode->i_ino);\n\t\text3_set_de_type(dir->i_sb, de, inode->i_mode);\n\t} else\n\t\tde->inode = 0;\n\tde->name_len = namelen;\n\tmemcpy (de->name, name, namelen);\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext3_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\text3_update_dx_flag(dir);\n\tdir->i_version++;\n\text3_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\text3_std_error(dir->i_sb, err);\n\tbrelse(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "do_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1138-1228",
    "snippet": "static struct ext3_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo, int *error)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\tu32 newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext3_dir_entry_2 *de = NULL, *de2;\n\tint\terr = 0, i;\n\n\tbh2 = ext3_append (handle, dir, &newblock, &err);\n\tif (!(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\tgoto errout;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map ((struct ext3_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map (map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(\"Split block %i at %x, %i/%i\\n\",\n\t\tdx_get_block(frame->at), hash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split);\n\tde = dx_pack_dirents(data1,blocksize);\n\tde->rec_len = ext3_rec_len_to_disk(data1 + blocksize - (char *) de);\n\tde2->rec_len = ext3_rec_len_to_disk(data2 + blocksize - (char *) de2);\n\tdxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data1, blocksize, 1));\n\tdxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data2, blocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2)\n\t{\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block (frame, hash2 + continued, newblock);\n\terr = ext3_journal_dirty_metadata (handle, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext3_journal_dirty_metadata (handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse (bh2);\n\tdxtrace(dx_show_index (\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text3_std_error(dir->i_sb, err);\nerrout:\n\t*error = err;\n\treturn NULL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline unsigned dx_get_block (struct dx_entry *entry);",
      "static inline unsigned dx_get_hash (struct dx_entry *entry);",
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);",
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
      "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "dir->i_sb",
            "err"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh2"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "dx_show_index (\"frame\", frame->entries)"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_show_index",
          "args": [
            "\"frame\"",
            "frame->entries"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "dx_show_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "240-249",
          "snippet": "static void dx_show_index (char * label, struct dx_entry *entries)\n{\n        int i, n = dx_get_count (entries);\n        printk(\"%s index \", label);\n        for (i = 0; i < n; i++)\n        {\n                printk(\"%x->%u \", i? dx_get_hash(entries + i): 0, dx_get_block(entries + i));\n        }\n        printk(\"\\n\");\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\n\nstatic void dx_show_index (char * label, struct dx_entry *entries)\n{\n        int i, n = dx_get_count (entries);\n        printk(\"%s index \", label);\n        for (i = 0; i < n; i++)\n        {\n                printk(\"%x->%u \", i? dx_get_hash(entries + i): 0, dx_get_block(entries + i));\n        }\n        printk(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "frame->bh"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh2"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_insert_block",
          "args": [
            "frame",
            "hash2 + continued",
            "newblock"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "dx_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "753-765",
          "snippet": "static void dx_insert_block(struct dx_frame *frame, u32 hash, u32 block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tassert(count < dx_get_limit(entries));\n\tassert(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic void dx_insert_block(struct dx_frame *frame, u32 hash, u32 block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tassert(count < dx_get_limit(entries));\n\tassert(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "*bh",
            "bh2"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "swap_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2438-2481",
          "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data2, blocksize, 1)"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_show_leaf",
          "args": [
            "hinfo",
            "(struct ext3_dir_entry_2 *) data2",
            "blocksize",
            "1"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "dx_show_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "258-286",
          "snippet": "static struct stats dx_show_leaf(struct dx_hash_info *hinfo, struct ext3_dir_entry_2 *de,\n\t\t\t\t int size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\twhile (len--) printk(\"%c\", *name++);\n\t\t\t\text3fs_dirhash(de->name, de->name_len, &h);\n\t\t\t\tprintk(\":%x.%u \", h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n\t\t\t}\n\t\t\tspace += EXT3_DIR_REC_LEN(de->name_len);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext3_next_entry(de);\n\t}\n\tprintk(\"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct stats dx_show_leaf(struct dx_hash_info *hinfo, struct ext3_dir_entry_2 *de,\n\t\t\t\t int size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\twhile (len--) printk(\"%c\", *name++);\n\t\t\t\text3fs_dirhash(de->name, de->name_len, &h);\n\t\t\t\tprintk(\":%x.%u \", h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n\t\t\t}\n\t\t\tspace += EXT3_DIR_REC_LEN(de->name_len);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext3_next_entry(de);\n\t}\n\tprintk(\"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data1, blocksize, 1)"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_rec_len_to_disk",
          "args": [
            "data2 + blocksize - (char *) de2"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "889-898",
          "snippet": "static inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_pack_dirents",
          "args": [
            "data1",
            "blocksize"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "dx_pack_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1111-1131",
          "snippet": "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize)\n{\n\tstruct ext3_dir_entry_2 *next, *to, *prev;\n\tstruct ext3_dir_entry_2 *de = (struct ext3_dir_entry_2 *)base;\n\tunsigned rec_len = 0;\n\n\tprev = to = de;\n\twhile ((char *)de < base + blocksize) {\n\t\tnext = ext3_next_entry(de);\n\t\tif (de->inode && de->name_len) {\n\t\t\trec_len = EXT3_DIR_REC_LEN(de->name_len);\n\t\t\tif (de > to)\n\t\t\t\tmemmove(to, de, rec_len);\n\t\t\tto->rec_len = ext3_rec_len_to_disk(rec_len);\n\t\t\tprev = to;\n\t\t\tto = (struct ext3_dir_entry_2 *) (((char *) to) + rec_len);\n\t\t}\n\t\tde = next;\n\t}\n\treturn prev;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize)\n{\n\tstruct ext3_dir_entry_2 *next, *to, *prev;\n\tstruct ext3_dir_entry_2 *de = (struct ext3_dir_entry_2 *)base;\n\tunsigned rec_len = 0;\n\n\tprev = to = de;\n\twhile ((char *)de < base + blocksize) {\n\t\tnext = ext3_next_entry(de);\n\t\tif (de->inode && de->name_len) {\n\t\t\trec_len = EXT3_DIR_REC_LEN(de->name_len);\n\t\t\tif (de > to)\n\t\t\t\tmemmove(to, de, rec_len);\n\t\t\tto->rec_len = ext3_rec_len_to_disk(rec_len);\n\t\t\tprev = to;\n\t\t\tto = (struct ext3_dir_entry_2 *) (((char *) to) + rec_len);\n\t\t}\n\t\tde = next;\n\t}\n\treturn prev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_move_dirents",
          "args": [
            "data1",
            "data2",
            "map + split",
            "count - split"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "dx_move_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "1089-1105",
          "snippet": "static struct ext3_dir_entry_2 *\ndx_move_dirents(char *from, char *to, struct dx_map_entry *map, int count)\n{\n\tunsigned rec_len = 0;\n\n\twhile (count--) {\n\t\tstruct ext3_dir_entry_2 *de = (struct ext3_dir_entry_2 *) (from + map->offs);\n\t\trec_len = EXT3_DIR_REC_LEN(de->name_len);\n\t\tmemcpy (to, de, rec_len);\n\t\t((struct ext3_dir_entry_2 *) to)->rec_len =\n\t\t\t\text3_rec_len_to_disk(rec_len);\n\t\tde->inode = 0;\n\t\tmap++;\n\t\tto += rec_len;\n\t}\n\treturn (struct ext3_dir_entry_2 *) (to - rec_len);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext3_dir_entry_2 *\ndx_move_dirents(char *from, char *to, struct dx_map_entry *map, int count)\n{\n\tunsigned rec_len = 0;\n\n\twhile (count--) {\n\t\tstruct ext3_dir_entry_2 *de = (struct ext3_dir_entry_2 *) (from + map->offs);\n\t\trec_len = EXT3_DIR_REC_LEN(de->name_len);\n\t\tmemcpy (to, de, rec_len);\n\t\t((struct ext3_dir_entry_2 *) to)->rec_len =\n\t\t\t\text3_rec_len_to_disk(rec_len);\n\t\tde->inode = 0;\n\t\tmap++;\n\t\tto += rec_len;\n\t}\n\treturn (struct ext3_dir_entry_2 *) (to - rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\"Split block %i at %x, %i/%i\\n\",\n\t\tdx_get_block(frame->at), hash2, split, count-split)"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Split block %i at %x, %i/%i\\n\"",
            "dx_get_block(frame->at)",
            "hash2",
            "split",
            "count-split"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "frame->at"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "183-186",
          "snippet": "static inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_sort_map",
          "args": [
            "map",
            "count"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "dx_sort_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "725-751",
          "snippet": "static void dx_sort_map (struct dx_map_entry *map, unsigned count)\n{\n        struct dx_map_entry *p, *q, *top = map + count - 1;\n        int more;\n        /* Combsort until bubble sort doesn't suck */\n        while (count > 2)\n\t{\n                count = count*10/13;\n                if (count - 9 < 2) /* 9, 10 -> 11 */\n                        count = 11;\n                for (p = top, q = p - count; q >= map; p--, q--)\n                        if (p->hash < q->hash)\n                                swap(*p, *q);\n        }\n        /* Garden variety bubble sort */\n        do {\n                more = 0;\n                q = top;\n                while (q-- > map)\n\t\t{\n                        if (q[1].hash >= q[0].hash)\n\t\t\t\tcontinue;\n                        swap(*(q+1), *q);\n                        more = 1;\n\t\t}\n\t} while(more);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\n\nstatic void dx_sort_map (struct dx_map_entry *map, unsigned count)\n{\n        struct dx_map_entry *p, *q, *top = map + count - 1;\n        int more;\n        /* Combsort until bubble sort doesn't suck */\n        while (count > 2)\n\t{\n                count = count*10/13;\n                if (count - 9 < 2) /* 9, 10 -> 11 */\n                        count = 11;\n                for (p = top, q = p - count; q >= map; p--, q--)\n                        if (p->hash < q->hash)\n                                swap(*p, *q);\n        }\n        /* Garden variety bubble sort */\n        do {\n                more = 0;\n                q = top;\n                while (q-- > map)\n\t\t{\n                        if (q[1].hash >= q[0].hash)\n\t\t\t\tcontinue;\n                        swap(*(q+1), *q);\n                        more = 1;\n\t\t}\n\t} while(more);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_make_map",
          "args": [
            "(struct ext3_dir_entry_2 *) data1",
            "blocksize",
            "hinfo",
            "map"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "dx_make_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "700-722",
          "snippet": "static int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\tstruct dx_hash_info *hinfo, struct dx_map_entry *map_tail)\n{\n\tint count = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\twhile ((char *) de < base + blocksize)\n\t{\n\t\tif (de->name_len && de->inode) {\n\t\t\text3fs_dirhash(de->name, de->name_len, &h);\n\t\t\tmap_tail--;\n\t\t\tmap_tail->hash = h.hash;\n\t\t\tmap_tail->offs = (u16) ((char *) de - base);\n\t\t\tmap_tail->size = le16_to_cpu(de->rec_len);\n\t\t\tcount++;\n\t\t\tcond_resched();\n\t\t}\n\t\t/* XXX: do we need to check rec_len == 0 case? -Chris */\n\t\tde = ext3_next_entry(de);\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
            "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\tstruct dx_hash_info *hinfo, struct dx_map_entry *map_tail)\n{\n\tint count = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\twhile ((char *) de < base + blocksize)\n\t{\n\t\tif (de->name_len && de->inode) {\n\t\t\text3fs_dirhash(de->name, de->name_len, &h);\n\t\t\tmap_tail--;\n\t\t\tmap_tail->hash = h.hash;\n\t\t\tmap_tail->offs = (u16) ((char *) de - base);\n\t\t\tmap_tail->size = le16_to_cpu(de->rec_len);\n\t\t\tcount++;\n\t\t\tcond_resched();\n\t\t}\n\t\t/* XXX: do we need to check rec_len == 0 case? -Chris */\n\t\tde = ext3_next_entry(de);\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "frame->bh"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "frame->bh",
            "\"get_write_access\""
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "*bh"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "*bh",
            "\"get_write_access\""
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_append",
          "args": [
            "handle",
            "dir",
            "&newblock",
            "&err"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "40-58",
          "snippet": "static struct buffer_head *ext3_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tu32 *block, int *err)\n{\n\tstruct buffer_head *bh;\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tif ((bh = ext3_dir_bread(handle, inode, *block, 1, err))) {\n\t\tinode->i_size += inode->i_sb->s_blocksize;\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t\t*err = ext3_journal_get_write_access(handle, bh);\n\t\tif (*err) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext3_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tu32 *block, int *err)\n{\n\tstruct buffer_head *bh;\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tif ((bh = ext3_dir_bread(handle, inode, *block, 1, err))) {\n\t\tinode->i_size += inode->i_sb->s_blocksize;\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t\t*err = ext3_journal_get_write_access(handle, bh);\n\t\tif (*err) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext3_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo, int *error)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\tu32 newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext3_dir_entry_2 *de = NULL, *de2;\n\tint\terr = 0, i;\n\n\tbh2 = ext3_append (handle, dir, &newblock, &err);\n\tif (!(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\tgoto errout;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map ((struct ext3_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map (map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(\"Split block %i at %x, %i/%i\\n\",\n\t\tdx_get_block(frame->at), hash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split);\n\tde = dx_pack_dirents(data1,blocksize);\n\tde->rec_len = ext3_rec_len_to_disk(data1 + blocksize - (char *) de);\n\tde2->rec_len = ext3_rec_len_to_disk(data2 + blocksize - (char *) de2);\n\tdxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data1, blocksize, 1));\n\tdxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data2, blocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2)\n\t{\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block (frame, hash2 + continued, newblock);\n\terr = ext3_journal_dirty_metadata (handle, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext3_journal_dirty_metadata (handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse (bh2);\n\tdxtrace(dx_show_index (\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text3_std_error(dir->i_sb, err);\nerrout:\n\t*error = err;\n\treturn NULL;\n}"
  },
  {
    "function_name": "dx_pack_dirents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1111-1131",
    "snippet": "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize)\n{\n\tstruct ext3_dir_entry_2 *next, *to, *prev;\n\tstruct ext3_dir_entry_2 *de = (struct ext3_dir_entry_2 *)base;\n\tunsigned rec_len = 0;\n\n\tprev = to = de;\n\twhile ((char *)de < base + blocksize) {\n\t\tnext = ext3_next_entry(de);\n\t\tif (de->inode && de->name_len) {\n\t\t\trec_len = EXT3_DIR_REC_LEN(de->name_len);\n\t\t\tif (de > to)\n\t\t\t\tmemmove(to, de, rec_len);\n\t\t\tto->rec_len = ext3_rec_len_to_disk(rec_len);\n\t\t\tprev = to;\n\t\t\tto = (struct ext3_dir_entry_2 *) (((char *) to) + rec_len);\n\t\t}\n\t\tde = next;\n\t}\n\treturn prev;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_rec_len_to_disk",
          "args": [
            "rec_len"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "889-898",
          "snippet": "static inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "to",
            "de",
            "rec_len"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_next_entry",
          "args": [
            "de"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "171-176",
          "snippet": "static inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize)\n{\n\tstruct ext3_dir_entry_2 *next, *to, *prev;\n\tstruct ext3_dir_entry_2 *de = (struct ext3_dir_entry_2 *)base;\n\tunsigned rec_len = 0;\n\n\tprev = to = de;\n\twhile ((char *)de < base + blocksize) {\n\t\tnext = ext3_next_entry(de);\n\t\tif (de->inode && de->name_len) {\n\t\t\trec_len = EXT3_DIR_REC_LEN(de->name_len);\n\t\t\tif (de > to)\n\t\t\t\tmemmove(to, de, rec_len);\n\t\t\tto->rec_len = ext3_rec_len_to_disk(rec_len);\n\t\t\tprev = to;\n\t\t\tto = (struct ext3_dir_entry_2 *) (((char *) to) + rec_len);\n\t\t}\n\t\tde = next;\n\t}\n\treturn prev;\n}"
  },
  {
    "function_name": "dx_move_dirents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1089-1105",
    "snippet": "static struct ext3_dir_entry_2 *\ndx_move_dirents(char *from, char *to, struct dx_map_entry *map, int count)\n{\n\tunsigned rec_len = 0;\n\n\twhile (count--) {\n\t\tstruct ext3_dir_entry_2 *de = (struct ext3_dir_entry_2 *) (from + map->offs);\n\t\trec_len = EXT3_DIR_REC_LEN(de->name_len);\n\t\tmemcpy (to, de, rec_len);\n\t\t((struct ext3_dir_entry_2 *) to)->rec_len =\n\t\t\t\text3_rec_len_to_disk(rec_len);\n\t\tde->inode = 0;\n\t\tmap++;\n\t\tto += rec_len;\n\t}\n\treturn (struct ext3_dir_entry_2 *) (to - rec_len);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_rec_len_to_disk",
          "args": [
            "rec_len"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "889-898",
          "snippet": "static inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "to",
            "de",
            "rec_len"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct ext3_dir_entry_2 *\ndx_move_dirents(char *from, char *to, struct dx_map_entry *map, int count)\n{\n\tunsigned rec_len = 0;\n\n\twhile (count--) {\n\t\tstruct ext3_dir_entry_2 *de = (struct ext3_dir_entry_2 *) (from + map->offs);\n\t\trec_len = EXT3_DIR_REC_LEN(de->name_len);\n\t\tmemcpy (to, de, rec_len);\n\t\t((struct ext3_dir_entry_2 *) to)->rec_len =\n\t\t\t\text3_rec_len_to_disk(rec_len);\n\t\tde->inode = 0;\n\t\tmap++;\n\t\tto += rec_len;\n\t}\n\treturn (struct ext3_dir_entry_2 *) (to - rec_len);\n}"
  },
  {
    "function_name": "ext3_set_de_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1078-1083",
    "snippet": "static inline void ext3_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext3_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext3_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [
      "#define S_SHIFT 12"
    ],
    "globals_used": [
      "static unsigned char ext3_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXT3_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXT3_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXT3_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXT3_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXT3_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXT3_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXT3_FT_SYMLINK,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_FILETYPE"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\n#define S_SHIFT 12\n\nstatic unsigned char ext3_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXT3_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXT3_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXT3_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXT3_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXT3_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXT3_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXT3_FT_SYMLINK,\n};\n\nstatic inline void ext3_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext3_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext3_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}"
  },
  {
    "function_name": "ext3_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1045-1065",
    "snippet": "struct dentry *ext3_get_parent(struct dentry *child)\n{\n\tunsigned long ino;\n\tstruct qstr dotdot = QSTR_INIT(\"..\", 2);\n\tstruct ext3_dir_entry_2 * de;\n\tstruct buffer_head *bh;\n\n\tbh = ext3_find_entry(child->d_inode, &dotdot, &de);\n\tif (!bh)\n\t\treturn ERR_PTR(-ENOENT);\n\tino = le32_to_cpu(de->inode);\n\tbrelse(bh);\n\n\tif (!ext3_valid_inum(child->d_inode->i_sb, ino)) {\n\t\text3_error(child->d_inode->i_sb, \"ext3_get_parent\",\n\t\t\t   \"bad inode number: %lu\", ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn d_obtain_alias(ext3_iget(child->d_inode->i_sb, ino));\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "ext3_iget(child->d_inode->i_sb, ino)"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_iget",
          "args": [
            "child->d_inode->i_sb",
            "ino"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2848-3023",
          "snippet": "struct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstruct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "child->d_inode->i_sb",
            "\"ext3_get_parent\"",
            "\"bad inode number: %lu\"",
            "ino"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_valid_inum",
          "args": [
            "child->d_inode->i_sb",
            "ino"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_valid_inum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "698-705",
          "snippet": "static inline int ext3_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT3_ROOT_INO ||\n\t\tino == EXT3_JOURNAL_INO ||\n\t\tino == EXT3_RESIZE_INO ||\n\t\t(ino >= EXT3_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count));\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_JOURNAL_INO\t 8\t/* Journal inode */",
            "#define EXT3_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */",
            "#define EXT3_ROOT_INO\t\t 2\t/* Root inode */"
          ],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_JOURNAL_INO\t 8\t/* Journal inode */\n#define EXT3_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */\n#define EXT3_ROOT_INO\t\t 2\t/* Root inode */\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline int ext3_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT3_ROOT_INO ||\n\t\tino == EXT3_JOURNAL_INO ||\n\t\tino == EXT3_RESIZE_INO ||\n\t\t(ino >= EXT3_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_find_entry",
          "args": [
            "child->d_inode",
            "&dotdot",
            "&de"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "842-962",
          "snippet": "static struct buffer_head *ext3_find_entry(struct inode *dir,\n\t\t\t\t\tstruct qstr *entry,\n\t\t\t\t\tstruct ext3_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head * bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tconst u8 *name = entry->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = entry->len;\n\tif (namelen > EXT3_NAME_LEN)\n\t\treturn NULL;\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == 0)) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext3_dx_find_entry(dir, entry, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(\"ext3_find_entry: dx failed, falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tstart = EXT3_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext3_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh && !bh_uptodate_or_lock(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\t\tsubmit_bh(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t  bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\text3_error(sb, __func__, \"reading directory #%lu \"\n\t\t\t\t   \"offset %lu\", dir->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\ti = search_dirblock(bh, dir, entry,\n\t\t\t    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT3_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse (bh_use[ra_ptr]);\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [
            "#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
          ],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\n#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext3_find_entry(struct inode *dir,\n\t\t\t\t\tstruct qstr *entry,\n\t\t\t\t\tstruct ext3_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head * bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tconst u8 *name = entry->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = entry->len;\n\tif (namelen > EXT3_NAME_LEN)\n\t\treturn NULL;\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == 0)) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext3_dx_find_entry(dir, entry, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(\"ext3_find_entry: dx failed, falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tstart = EXT3_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext3_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh && !bh_uptodate_or_lock(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\t\tsubmit_bh(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t  bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\text3_error(sb, __func__, \"reading directory #%lu \"\n\t\t\t\t   \"offset %lu\", dir->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\ti = search_dirblock(bh, dir, entry,\n\t\t\t    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT3_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse (bh_use[ra_ptr]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QSTR_INIT",
          "args": [
            "\"..\"",
            "2"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstruct dentry *ext3_get_parent(struct dentry *child)\n{\n\tunsigned long ino;\n\tstruct qstr dotdot = QSTR_INIT(\"..\", 2);\n\tstruct ext3_dir_entry_2 * de;\n\tstruct buffer_head *bh;\n\n\tbh = ext3_find_entry(child->d_inode, &dotdot, &de);\n\tif (!bh)\n\t\treturn ERR_PTR(-ENOENT);\n\tino = le32_to_cpu(de->inode);\n\tbrelse(bh);\n\n\tif (!ext3_valid_inum(child->d_inode->i_sb, ino)) {\n\t\text3_error(child->d_inode->i_sb, \"ext3_get_parent\",\n\t\t\t   \"bad inode number: %lu\", ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn d_obtain_alias(ext3_iget(child->d_inode->i_sb, ino));\n}"
  },
  {
    "function_name": "ext3_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "1014-1042",
    "snippet": "static struct dentry *ext3_lookup(struct inode * dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode * inode;\n\tstruct ext3_dir_entry_2 * de;\n\tstruct buffer_head * bh;\n\n\tif (dentry->d_name.len > EXT3_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbh = ext3_find_entry(dir, &dentry->d_name, &de);\n\tinode = NULL;\n\tif (bh) {\n\t\tunsigned long ino = le32_to_cpu(de->inode);\n\t\tbrelse (bh);\n\t\tif (!ext3_valid_inum(dir->i_sb, ino)) {\n\t\t\text3_error(dir->i_sb, \"ext3_lookup\",\n\t\t\t\t   \"bad inode number: %lu\", ino);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t\tinode = ext3_iget(dir->i_sb, ino);\n\t\tif (inode == ERR_PTR(-ESTALE)) {\n\t\t\text3_error(dir->i_sb, __func__,\n\t\t\t\t\t\"deleted inode referenced: %lu\",\n\t\t\t\t\tino);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn d_splice_alias(inode, dentry);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "dir->i_sb",
            "__func__",
            "\"deleted inode referenced: %lu\"",
            "ino"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_iget",
          "args": [
            "dir->i_sb",
            "ino"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2848-3023",
          "snippet": "struct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstruct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_valid_inum",
          "args": [
            "dir->i_sb",
            "ino"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_valid_inum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "698-705",
          "snippet": "static inline int ext3_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT3_ROOT_INO ||\n\t\tino == EXT3_JOURNAL_INO ||\n\t\tino == EXT3_RESIZE_INO ||\n\t\t(ino >= EXT3_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count));\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_JOURNAL_INO\t 8\t/* Journal inode */",
            "#define EXT3_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */",
            "#define EXT3_ROOT_INO\t\t 2\t/* Root inode */"
          ],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_JOURNAL_INO\t 8\t/* Journal inode */\n#define EXT3_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */\n#define EXT3_ROOT_INO\t\t 2\t/* Root inode */\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline int ext3_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT3_ROOT_INO ||\n\t\tino == EXT3_JOURNAL_INO ||\n\t\tino == EXT3_RESIZE_INO ||\n\t\t(ino >= EXT3_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_find_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "&de"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "842-962",
          "snippet": "static struct buffer_head *ext3_find_entry(struct inode *dir,\n\t\t\t\t\tstruct qstr *entry,\n\t\t\t\t\tstruct ext3_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head * bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tconst u8 *name = entry->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = entry->len;\n\tif (namelen > EXT3_NAME_LEN)\n\t\treturn NULL;\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == 0)) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext3_dx_find_entry(dir, entry, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(\"ext3_find_entry: dx failed, falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tstart = EXT3_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext3_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh && !bh_uptodate_or_lock(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\t\tsubmit_bh(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t  bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\text3_error(sb, __func__, \"reading directory #%lu \"\n\t\t\t\t   \"offset %lu\", dir->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\ti = search_dirblock(bh, dir, entry,\n\t\t\t    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT3_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse (bh_use[ra_ptr]);\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [
            "#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
          ],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\n#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext3_find_entry(struct inode *dir,\n\t\t\t\t\tstruct qstr *entry,\n\t\t\t\t\tstruct ext3_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head * bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tconst u8 *name = entry->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = entry->len;\n\tif (namelen > EXT3_NAME_LEN)\n\t\treturn NULL;\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == 0)) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext3_dx_find_entry(dir, entry, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(\"ext3_find_entry: dx failed, falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tstart = EXT3_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext3_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh && !bh_uptodate_or_lock(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\t\tsubmit_bh(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t  bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\text3_error(sb, __func__, \"reading directory #%lu \"\n\t\t\t\t   \"offset %lu\", dir->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\ti = search_dirblock(bh, dir, entry,\n\t\t\t    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT3_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse (bh_use[ra_ptr]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct dentry *ext3_lookup(struct inode * dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode * inode;\n\tstruct ext3_dir_entry_2 * de;\n\tstruct buffer_head * bh;\n\n\tif (dentry->d_name.len > EXT3_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbh = ext3_find_entry(dir, &dentry->d_name, &de);\n\tinode = NULL;\n\tif (bh) {\n\t\tunsigned long ino = le32_to_cpu(de->inode);\n\t\tbrelse (bh);\n\t\tif (!ext3_valid_inum(dir->i_sb, ino)) {\n\t\t\text3_error(dir->i_sb, \"ext3_lookup\",\n\t\t\t\t   \"bad inode number: %lu\", ino);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t\tinode = ext3_iget(dir->i_sb, ino);\n\t\tif (inode == ERR_PTR(-ESTALE)) {\n\t\t\text3_error(dir->i_sb, __func__,\n\t\t\t\t\t\"deleted inode referenced: %lu\",\n\t\t\t\t\tino);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn d_splice_alias(inode, dentry);\n}"
  },
  {
    "function_name": "ext3_dx_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "964-1012",
    "snippet": "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct dx_hash_info\thinfo;\n\tstruct dx_frame frames[2], *frame;\n\tstruct buffer_head *bh;\n\tunsigned long block;\n\tint retval;\n\n\tif (!(frame = dx_probe(entry, dir, &hinfo, frames, err)))\n\t\treturn NULL;\n\tdo {\n\t\tblock = dx_get_block(frame->at);\n\t\tif (!(bh = ext3_dir_bread (NULL, dir, block, 0, err)))\n\t\t\tgoto errout;\n\n\t\tretval = search_dirblock(bh, dir, entry,\n\t\t\t\t\t block << EXT3_BLOCK_SIZE_BITS(sb),\n\t\t\t\t\t res_dir);\n\t\tif (retval == 1) {\n\t\t\tdx_release(frames);\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tif (retval == -1) {\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto errout;\n\t\t}\n\n\t\t/* Check to see if we should continue to search */\n\t\tretval = ext3_htree_next_block(dir, hinfo.hash, frame,\n\t\t\t\t\t       frames, NULL);\n\t\tif (retval < 0) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t     \"error reading index page in directory #%lu\",\n\t\t\t     dir->i_ino);\n\t\t\t*err = retval;\n\t\t\tgoto errout;\n\t\t}\n\t} while (retval == 1);\n\n\t*err = -ENOENT;\nerrout:\n\tdxtrace(printk(\"%s not found\\n\", entry->name));\n\tdx_release (frames);\n\treturn NULL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline unsigned dx_get_block (struct dx_entry *entry);",
      "static inline unsigned dx_get_hash (struct dx_entry *entry);",
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static void dx_release (struct dx_frame *frames);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dx_release",
          "args": [
            "frames"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "dx_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "467-475",
          "snippet": "static void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_release (struct dx_frame *frames);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_release (struct dx_frame *frames);\n\nstatic void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\"%s not found\\n\", entry->name)"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s not found\\n\"",
            "entry->name"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "sb",
            "__func__",
            "\"error reading index page in directory #%lu\"",
            "dir->i_ino"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_htree_next_block",
          "args": [
            "dir",
            "hinfo.hash",
            "frame",
            "frames",
            "NULL"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_htree_next_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "494-549",
          "snippet": "static int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint err, num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t/*\n\t * Find the next leaf page by incrementing the frame pointer.\n\t * If we run out of entries in the interior node, loop around and\n\t * increment pointer in the parent node.  When we break out of\n\t * this loop, num_frames indicates the number of interior\n\t * nodes need to be read.\n\t */\n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t/*\n\t * If the hash is 1, then continue only if the next page has a\n\t * continuation hash of any value.  This is used for readdir\n\t * handling.  Otherwise, check to see if the hash matches the\n\t * desired contiuation hash.  If it doesn't, return since\n\t * there's no point to read in the successive index pages.\n\t */\n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t/*\n\t * If the hash is HASH_NB_ALWAYS, we always go to the next\n\t * block so no check is necessary\n\t */\n\twhile (num_frames--) {\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(p->at),\n\t\t\t\t\t  0, &err)))\n\t\t\treturn err; /* Failure */\n\t\tp++;\n\t\tbrelse (p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block (struct dx_entry *entry, unsigned value);",
            "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_set_count (struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit (struct dx_entry *entries, unsigned value);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_release (struct dx_frame *frames);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_release (struct dx_frame *frames);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint err, num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t/*\n\t * Find the next leaf page by incrementing the frame pointer.\n\t * If we run out of entries in the interior node, loop around and\n\t * increment pointer in the parent node.  When we break out of\n\t * this loop, num_frames indicates the number of interior\n\t * nodes need to be read.\n\t */\n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t/*\n\t * If the hash is 1, then continue only if the next page has a\n\t * continuation hash of any value.  This is used for readdir\n\t * handling.  Otherwise, check to see if the hash matches the\n\t * desired contiuation hash.  If it doesn't, return since\n\t * there's no point to read in the successive index pages.\n\t */\n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t/*\n\t * If the hash is HASH_NB_ALWAYS, we always go to the next\n\t * block so no check is necessary\n\t */\n\twhile (num_frames--) {\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(p->at),\n\t\t\t\t\t  0, &err)))\n\t\t\treturn err; /* Failure */\n\t\tp++;\n\t\tbrelse (p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_dirblock",
          "args": [
            "bh",
            "dir",
            "entry",
            "block << EXT3_BLOCK_SIZE_BITS(sb)",
            "res_dir"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "search_dirblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "793-828",
          "snippet": "static inline int search_dirblock(struct buffer_head * bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  struct qstr *child,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  struct ext3_dir_entry_2 ** res_dir)\n{\n\tstruct ext3_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\tconst char *name = child->name;\n\tint namelen = child->len;\n\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tdlimit = bh->b_data + dir->i_sb->s_blocksize;\n\twhile ((char *) de < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tif ((char *) de + namelen <= dlimit &&\n\t\t    ext3_match (namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ext3_check_dir_entry(\"ext3_find_entry\",\n\t\t\t\t\t\t  dir, de, bh, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t/* prevent looping on a bad block */\n\t\tde_len = ext3_rec_len_from_disk(de->rec_len);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext3_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int search_dirblock(struct buffer_head * bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  struct qstr *child,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  struct ext3_dir_entry_2 ** res_dir)\n{\n\tstruct ext3_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\tconst char *name = child->name;\n\tint namelen = child->len;\n\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tdlimit = bh->b_data + dir->i_sb->s_blocksize;\n\twhile ((char *) de < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tif ((char *) de + namelen <= dlimit &&\n\t\t    ext3_match (namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ext3_check_dir_entry(\"ext3_find_entry\",\n\t\t\t\t\t\t  dir, de, bh, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t/* prevent looping on a bad block */\n\t\tde_len = ext3_rec_len_from_disk(de->rec_len);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext3_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_dir_bread",
          "args": [
            "NULL",
            "dir",
            "block",
            "0",
            "err"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_dir_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.h",
          "lines": "10-27",
          "snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "frame->at"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "183-186",
          "snippet": "static inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_probe",
          "args": [
            "entry",
            "dir",
            "&hinfo",
            "frames",
            "err"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "dx_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "328-465",
          "snippet": "static struct dx_frame *\ndx_probe(struct qstr *entry, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in, int *err)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct buffer_head *bh;\n\tstruct dx_frame *frame = frame_in;\n\tu32 hash;\n\n\tframe->bh = NULL;\n\tif (!(bh = ext3_dir_bread(NULL, dir, 0, 0, err))) {\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT3_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\tif (entry)\n\t\text3fs_dirhash(entry->name, entry->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"dx entry: limit != root limit\");\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tdxtrace (printk(\"Look up %x\", hash));\n\twhile (1)\n\t{\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q)\n\t\t{\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) // linear search cross check\n\t\t{\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->bh = bh;\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--) return frame;\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(at), 0, err))) {\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tat = entries = ((struct dx_node *) bh->b_data)->entries;\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tframe++;\n\t\tframe->bh = NULL;\n\t}\nfail2:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\nfail:\n\tif (*err == ERR_BAD_DX_DIR)\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Corrupt dir inode %ld, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct dx_frame *\ndx_probe(struct qstr *entry, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in, int *err)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct buffer_head *bh;\n\tstruct dx_frame *frame = frame_in;\n\tu32 hash;\n\n\tframe->bh = NULL;\n\tif (!(bh = ext3_dir_bread(NULL, dir, 0, 0, err))) {\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT3_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\tif (entry)\n\t\text3fs_dirhash(entry->name, entry->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"dx entry: limit != root limit\");\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tdxtrace (printk(\"Look up %x\", hash));\n\twhile (1)\n\t{\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q)\n\t\t{\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) // linear search cross check\n\t\t{\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->bh = bh;\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--) return frame;\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(at), 0, err))) {\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tat = entries = ((struct dx_node *) bh->b_data)->entries;\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tframe++;\n\t\tframe->bh = NULL;\n\t}\nfail2:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\nfail:\n\tif (*err == ERR_BAD_DX_DIR)\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Corrupt dir inode %ld, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_release (struct dx_frame *frames);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct dx_hash_info\thinfo;\n\tstruct dx_frame frames[2], *frame;\n\tstruct buffer_head *bh;\n\tunsigned long block;\n\tint retval;\n\n\tif (!(frame = dx_probe(entry, dir, &hinfo, frames, err)))\n\t\treturn NULL;\n\tdo {\n\t\tblock = dx_get_block(frame->at);\n\t\tif (!(bh = ext3_dir_bread (NULL, dir, block, 0, err)))\n\t\t\tgoto errout;\n\n\t\tretval = search_dirblock(bh, dir, entry,\n\t\t\t\t\t block << EXT3_BLOCK_SIZE_BITS(sb),\n\t\t\t\t\t res_dir);\n\t\tif (retval == 1) {\n\t\t\tdx_release(frames);\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tif (retval == -1) {\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto errout;\n\t\t}\n\n\t\t/* Check to see if we should continue to search */\n\t\tretval = ext3_htree_next_block(dir, hinfo.hash, frame,\n\t\t\t\t\t       frames, NULL);\n\t\tif (retval < 0) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t     \"error reading index page in directory #%lu\",\n\t\t\t     dir->i_ino);\n\t\t\t*err = retval;\n\t\t\tgoto errout;\n\t\t}\n\t} while (retval == 1);\n\n\t*err = -ENOENT;\nerrout:\n\tdxtrace(printk(\"%s not found\\n\", entry->name));\n\tdx_release (frames);\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext3_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "842-962",
    "snippet": "static struct buffer_head *ext3_find_entry(struct inode *dir,\n\t\t\t\t\tstruct qstr *entry,\n\t\t\t\t\tstruct ext3_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head * bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tconst u8 *name = entry->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = entry->len;\n\tif (namelen > EXT3_NAME_LEN)\n\t\treturn NULL;\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == 0)) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext3_dx_find_entry(dir, entry, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(\"ext3_find_entry: dx failed, falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tstart = EXT3_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext3_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh && !bh_uptodate_or_lock(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\t\tsubmit_bh(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t  bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\text3_error(sb, __func__, \"reading directory #%lu \"\n\t\t\t\t   \"offset %lu\", dir->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\ti = search_dirblock(bh, dir, entry,\n\t\t\t    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT3_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse (bh_use[ra_ptr]);\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [
      "#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
    ],
    "globals_used": [
      "static inline unsigned dx_get_block (struct dx_entry *entry);",
      "static inline unsigned dx_get_hash (struct dx_entry *entry);",
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh_use[ra_ptr]"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "dir"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_dirblock",
          "args": [
            "bh",
            "dir",
            "entry",
            "block << EXT3_BLOCK_SIZE_BITS(sb)",
            "res_dir"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "search_dirblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "793-828",
          "snippet": "static inline int search_dirblock(struct buffer_head * bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  struct qstr *child,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  struct ext3_dir_entry_2 ** res_dir)\n{\n\tstruct ext3_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\tconst char *name = child->name;\n\tint namelen = child->len;\n\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tdlimit = bh->b_data + dir->i_sb->s_blocksize;\n\twhile ((char *) de < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tif ((char *) de + namelen <= dlimit &&\n\t\t    ext3_match (namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ext3_check_dir_entry(\"ext3_find_entry\",\n\t\t\t\t\t\t  dir, de, bh, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t/* prevent looping on a bad block */\n\t\tde_len = ext3_rec_len_from_disk(de->rec_len);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext3_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int search_dirblock(struct buffer_head * bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  struct qstr *child,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  struct ext3_dir_entry_2 ** res_dir)\n{\n\tstruct ext3_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\tconst char *name = child->name;\n\tint namelen = child->len;\n\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tdlimit = bh->b_data + dir->i_sb->s_blocksize;\n\twhile ((char *) de < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tif ((char *) de + namelen <= dlimit &&\n\t\t    ext3_match (namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ext3_check_dir_entry(\"ext3_find_entry\",\n\t\t\t\t\t\t  dir, de, bh, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t/* prevent looping on a bad block */\n\t\tde_len = ext3_rec_len_from_disk(de->rec_len);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext3_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "__func__",
            "\"reading directory #%lu \"\n\t\t\t\t   \"offset %lu\"",
            "dir->i_ino",
            "block"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ | REQ_META | REQ_PRIO",
            "bh"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_uptodate_or_lock",
          "args": [
            "bh"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_getblk",
          "args": [
            "NULL",
            "dir",
            "b++",
            "0",
            "&err"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_getblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1062-1126",
          "snippet": "struct buffer_head *ext3_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\tlong block, int create, int *errp)\n{\n\tstruct buffer_head dummy;\n\tint fatal = 0, err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\tbuffer_trace_init(&dummy.b_history);\n\terr = ext3_get_blocks_handle(handle, inode, block, 1,\n\t\t\t\t\t&dummy, create);\n\t/*\n\t * ext3_get_blocks_handle() returns number of blocks\n\t * mapped. 0 in case of a HOLE.\n\t */\n\tif (err > 0) {\n\t\tWARN_ON(err > 1);\n\t\terr = 0;\n\t}\n\t*errp = err;\n\tif (!err && buffer_mapped(&dummy)) {\n\t\tstruct buffer_head *bh;\n\t\tbh = sb_getblk(inode->i_sb, dummy.b_blocknr);\n\t\tif (unlikely(!bh)) {\n\t\t\t*errp = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (buffer_new(&dummy)) {\n\t\t\tJ_ASSERT(create != 0);\n\t\t\tJ_ASSERT(handle != NULL);\n\n\t\t\t/*\n\t\t\t * Now that we do not always journal data, we should\n\t\t\t * keep in mind whether this should always journal the\n\t\t\t * new buffer as metadata.  For now, regular file\n\t\t\t * writes use ext3_get_block instead, so it's not a\n\t\t\t * problem.\n\t\t\t */\n\t\t\tlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\t\tfatal = ext3_journal_get_create_access(handle, bh);\n\t\t\tif (!fatal && !buffer_uptodate(bh)) {\n\t\t\t\tmemset(bh->b_data,0,inode->i_sb->s_blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (!fatal)\n\t\t\t\tfatal = err;\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\t\t}\n\t\tif (fatal) {\n\t\t\t*errp = fatal;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t\treturn bh;\n\t}\nerr:\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstruct buffer_head *ext3_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\tlong block, int create, int *errp)\n{\n\tstruct buffer_head dummy;\n\tint fatal = 0, err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\tbuffer_trace_init(&dummy.b_history);\n\terr = ext3_get_blocks_handle(handle, inode, block, 1,\n\t\t\t\t\t&dummy, create);\n\t/*\n\t * ext3_get_blocks_handle() returns number of blocks\n\t * mapped. 0 in case of a HOLE.\n\t */\n\tif (err > 0) {\n\t\tWARN_ON(err > 1);\n\t\terr = 0;\n\t}\n\t*errp = err;\n\tif (!err && buffer_mapped(&dummy)) {\n\t\tstruct buffer_head *bh;\n\t\tbh = sb_getblk(inode->i_sb, dummy.b_blocknr);\n\t\tif (unlikely(!bh)) {\n\t\t\t*errp = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (buffer_new(&dummy)) {\n\t\t\tJ_ASSERT(create != 0);\n\t\t\tJ_ASSERT(handle != NULL);\n\n\t\t\t/*\n\t\t\t * Now that we do not always journal data, we should\n\t\t\t * keep in mind whether this should always journal the\n\t\t\t * new buffer as metadata.  For now, regular file\n\t\t\t * writes use ext3_get_block instead, so it's not a\n\t\t\t * problem.\n\t\t\t */\n\t\t\tlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\t\tfatal = ext3_journal_get_create_access(handle, bh);\n\t\t\tif (!fatal && !buffer_uptodate(bh)) {\n\t\t\t\tmemset(bh->b_data,0,inode->i_sb->s_blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"call ext3_journal_dirty_metadata\");\n\t\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\t\tif (!fatal)\n\t\t\t\tfatal = err;\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\t\t}\n\t\tif (fatal) {\n\t\t\t*errp = fatal;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t\treturn bh;\n\t}\nerr:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\"ext3_find_entry: dx failed, falling back\\n\")"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ext3_find_entry: dx failed, falling back\\n\""
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_dx_find_entry",
          "args": [
            "dir",
            "entry",
            "res_dir",
            "&err"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_dx_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "964-1012",
          "snippet": "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct dx_hash_info\thinfo;\n\tstruct dx_frame frames[2], *frame;\n\tstruct buffer_head *bh;\n\tunsigned long block;\n\tint retval;\n\n\tif (!(frame = dx_probe(entry, dir, &hinfo, frames, err)))\n\t\treturn NULL;\n\tdo {\n\t\tblock = dx_get_block(frame->at);\n\t\tif (!(bh = ext3_dir_bread (NULL, dir, block, 0, err)))\n\t\t\tgoto errout;\n\n\t\tretval = search_dirblock(bh, dir, entry,\n\t\t\t\t\t block << EXT3_BLOCK_SIZE_BITS(sb),\n\t\t\t\t\t res_dir);\n\t\tif (retval == 1) {\n\t\t\tdx_release(frames);\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tif (retval == -1) {\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto errout;\n\t\t}\n\n\t\t/* Check to see if we should continue to search */\n\t\tretval = ext3_htree_next_block(dir, hinfo.hash, frame,\n\t\t\t\t\t       frames, NULL);\n\t\tif (retval < 0) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t     \"error reading index page in directory #%lu\",\n\t\t\t     dir->i_ino);\n\t\t\t*err = retval;\n\t\t\tgoto errout;\n\t\t}\n\t} while (retval == 1);\n\n\t*err = -ENOENT;\nerrout:\n\tdxtrace(printk(\"%s not found\\n\", entry->name));\n\tdx_release (frames);\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_release (struct dx_frame *frames);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_release (struct dx_frame *frames);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct dx_hash_info\thinfo;\n\tstruct dx_frame frames[2], *frame;\n\tstruct buffer_head *bh;\n\tunsigned long block;\n\tint retval;\n\n\tif (!(frame = dx_probe(entry, dir, &hinfo, frames, err)))\n\t\treturn NULL;\n\tdo {\n\t\tblock = dx_get_block(frame->at);\n\t\tif (!(bh = ext3_dir_bread (NULL, dir, block, 0, err)))\n\t\t\tgoto errout;\n\n\t\tretval = search_dirblock(bh, dir, entry,\n\t\t\t\t\t block << EXT3_BLOCK_SIZE_BITS(sb),\n\t\t\t\t\t res_dir);\n\t\tif (retval == 1) {\n\t\t\tdx_release(frames);\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tif (retval == -1) {\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto errout;\n\t\t}\n\n\t\t/* Check to see if we should continue to search */\n\t\tretval = ext3_htree_next_block(dir, hinfo.hash, frame,\n\t\t\t\t\t       frames, NULL);\n\t\tif (retval < 0) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t     \"error reading index page in directory #%lu\",\n\t\t\t     dir->i_ino);\n\t\t\t*err = retval;\n\t\t\tgoto errout;\n\t\t}\n\t} while (retval == 1);\n\n\t*err = -ENOENT;\nerrout:\n\tdxtrace(printk(\"%s not found\\n\", entry->name));\n\tdx_release (frames);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx",
          "args": [
            "dir"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "49-60",
          "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((EXT3_I(inode)->i_flags & EXT3_INDEX_FL) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((EXT3_I(inode)->i_flags & EXT3_INDEX_FL) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\n#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext3_find_entry(struct inode *dir,\n\t\t\t\t\tstruct qstr *entry,\n\t\t\t\t\tstruct ext3_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head * bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tconst u8 *name = entry->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = entry->len;\n\tif (namelen > EXT3_NAME_LEN)\n\t\treturn NULL;\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == 0)) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext3_dx_find_entry(dir, entry, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(\"ext3_find_entry: dx failed, falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tstart = EXT3_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext3_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh && !bh_uptodate_or_lock(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\t\tsubmit_bh(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t  bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\text3_error(sb, __func__, \"reading directory #%lu \"\n\t\t\t\t   \"offset %lu\", dir->i_ino, block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\ti = search_dirblock(bh, dir, entry,\n\t\t\t    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT3_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse (bh_use[ra_ptr]);\n\treturn ret;\n}"
  },
  {
    "function_name": "search_dirblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "793-828",
    "snippet": "static inline int search_dirblock(struct buffer_head * bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  struct qstr *child,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  struct ext3_dir_entry_2 ** res_dir)\n{\n\tstruct ext3_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\tconst char *name = child->name;\n\tint namelen = child->len;\n\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tdlimit = bh->b_data + dir->i_sb->s_blocksize;\n\twhile ((char *) de < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tif ((char *) de + namelen <= dlimit &&\n\t\t    ext3_match (namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ext3_check_dir_entry(\"ext3_find_entry\",\n\t\t\t\t\t\t  dir, de, bh, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t/* prevent looping on a bad block */\n\t\tde_len = ext3_rec_len_from_disk(de->rec_len);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext3_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_rec_len_from_disk",
          "args": [
            "de->rec_len"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "878-887",
          "snippet": "static inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_check_dir_entry",
          "args": [
            "\"ext3_find_entry\"",
            "dir",
            "de",
            "bh",
            "offset"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_check_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "62-91",
          "snippet": "int ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nint ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_match",
          "args": [
            "namelen",
            "name",
            "de"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "780-788",
          "snippet": "static inline int ext3_match (int len, const char * const name,\n\t\t\t      struct ext3_dir_entry_2 * de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int ext3_match (int len, const char * const name,\n\t\t\t      struct ext3_dir_entry_2 * de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int search_dirblock(struct buffer_head * bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  struct qstr *child,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  struct ext3_dir_entry_2 ** res_dir)\n{\n\tstruct ext3_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\tconst char *name = child->name;\n\tint namelen = child->len;\n\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\tdlimit = bh->b_data + dir->i_sb->s_blocksize;\n\twhile ((char *) de < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tif ((char *) de + namelen <= dlimit &&\n\t\t    ext3_match (namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ext3_check_dir_entry(\"ext3_find_entry\",\n\t\t\t\t\t\t  dir, de, bh, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t/* prevent looping on a bad block */\n\t\tde_len = ext3_rec_len_from_disk(de->rec_len);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext3_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "780-788",
    "snippet": "static inline int ext3_match (int len, const char * const name,\n\t\t\t      struct ext3_dir_entry_2 * de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "de->name",
            "len"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline int ext3_match (int len, const char * const name,\n\t\t\t      struct ext3_dir_entry_2 * de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
  },
  {
    "function_name": "ext3_update_dx_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "767-772",
    "snippet": "static void ext3_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_COMPAT_FEATURE",
          "args": [
            "inode->i_sb",
            "EXT3_FEATURE_COMPAT_DIR_INDEX"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic void ext3_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX))\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n}"
  },
  {
    "function_name": "dx_insert_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "753-765",
    "snippet": "static void dx_insert_block(struct dx_frame *frame, u32 hash, u32 block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tassert(count < dx_get_limit(entries));\n\tassert(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dx_set_count",
          "args": [
            "entries",
            "count + 1"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "213-216",
          "snippet": "static inline void dx_set_count (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block (struct dx_entry *entry, unsigned value);",
            "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_set_count (struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit (struct dx_entry *entries, unsigned value);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\n\nstatic inline void dx_set_count (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_block",
          "args": [
            "new",
            "block"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "188-191",
          "snippet": "static inline void dx_set_block (struct dx_entry *entry, unsigned value)\n{\n\tentry->block = cpu_to_le32(value);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static void dx_set_block (struct dx_entry *entry, unsigned value);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
            "static void dx_set_count (struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit (struct dx_entry *entries, unsigned value);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic inline void dx_set_block (struct dx_entry *entry, unsigned value)\n{\n\tentry->block = cpu_to_le32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_set_hash",
          "args": [
            "new",
            "hash"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "dx_set_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "198-201",
          "snippet": "static inline void dx_set_hash (struct dx_entry *entry, unsigned value)\n{\n\tentry->hash = cpu_to_le32(value);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static void dx_set_block (struct dx_entry *entry, unsigned value);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
            "static void dx_set_count (struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit (struct dx_entry *entries, unsigned value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\n\nstatic inline void dx_set_hash (struct dx_entry *entry, unsigned value)\n{\n\tentry->hash = cpu_to_le32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "new + 1",
            "new",
            "(char *)(entries + count) - (char *)(new)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "old < entries + count"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_limit",
          "args": [
            "entries"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "208-211",
          "snippet": "static inline unsigned dx_get_limit (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\n\nstatic inline unsigned dx_get_limit (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_count",
          "args": [
            "entries"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "203-206",
          "snippet": "static inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\n\nstatic inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic void dx_insert_block(struct dx_frame *frame, u32 hash, u32 block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tassert(count < dx_get_limit(entries));\n\tassert(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}"
  },
  {
    "function_name": "dx_sort_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "725-751",
    "snippet": "static void dx_sort_map (struct dx_map_entry *map, unsigned count)\n{\n        struct dx_map_entry *p, *q, *top = map + count - 1;\n        int more;\n        /* Combsort until bubble sort doesn't suck */\n        while (count > 2)\n\t{\n                count = count*10/13;\n                if (count - 9 < 2) /* 9, 10 -> 11 */\n                        count = 11;\n                for (p = top, q = p - count; q >= map; p--, q--)\n                        if (p->hash < q->hash)\n                                swap(*p, *q);\n        }\n        /* Garden variety bubble sort */\n        do {\n                more = 0;\n                q = top;\n                while (q-- > map)\n\t\t{\n                        if (q[1].hash >= q[0].hash)\n\t\t\t\tcontinue;\n                        swap(*(q+1), *q);\n                        more = 1;\n\t\t}\n\t} while(more);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "*(q+1)",
            "*q"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "swap_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2438-2481",
          "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\t\tstruct dx_hash_info *hinfo, struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\n\nstatic void dx_sort_map (struct dx_map_entry *map, unsigned count)\n{\n        struct dx_map_entry *p, *q, *top = map + count - 1;\n        int more;\n        /* Combsort until bubble sort doesn't suck */\n        while (count > 2)\n\t{\n                count = count*10/13;\n                if (count - 9 < 2) /* 9, 10 -> 11 */\n                        count = 11;\n                for (p = top, q = p - count; q >= map; p--, q--)\n                        if (p->hash < q->hash)\n                                swap(*p, *q);\n        }\n        /* Garden variety bubble sort */\n        do {\n                more = 0;\n                q = top;\n                while (q-- > map)\n\t\t{\n                        if (q[1].hash >= q[0].hash)\n\t\t\t\tcontinue;\n                        swap(*(q+1), *q);\n                        more = 1;\n\t\t}\n\t} while(more);\n}"
  },
  {
    "function_name": "dx_make_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "700-722",
    "snippet": "static int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\tstruct dx_hash_info *hinfo, struct dx_map_entry *map_tail)\n{\n\tint count = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\twhile ((char *) de < base + blocksize)\n\t{\n\t\tif (de->name_len && de->inode) {\n\t\t\text3fs_dirhash(de->name, de->name_len, &h);\n\t\t\tmap_tail--;\n\t\t\tmap_tail->hash = h.hash;\n\t\t\tmap_tail->offs = (u16) ((char *) de - base);\n\t\t\tmap_tail->size = le16_to_cpu(de->rec_len);\n\t\t\tcount++;\n\t\t\tcond_resched();\n\t\t}\n\t\t/* XXX: do we need to check rec_len == 0 case? -Chris */\n\t\tde = ext3_next_entry(de);\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
      "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_next_entry",
          "args": [
            "de"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "171-176",
          "snippet": "static inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *) de - base"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3fs_dirhash",
          "args": [
            "de->name",
            "de->name_len",
            "&h"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "ext3fs_dirhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/hash.c",
          "lines": "137-206",
          "snippet": "int ext3fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i=0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < 4)\n\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT3_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT3_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cryptohash.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cryptohash.h>\n#include \"ext3.h\"\n\nint ext3fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i=0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < 4)\n\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT3_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT3_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int dx_make_map(struct ext3_dir_entry_2 *de, unsigned blocksize,\n\t\tstruct dx_hash_info *hinfo, struct dx_map_entry *map_tail)\n{\n\tint count = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\twhile ((char *) de < base + blocksize)\n\t{\n\t\tif (de->name_len && de->inode) {\n\t\t\text3fs_dirhash(de->name, de->name_len, &h);\n\t\t\tmap_tail--;\n\t\t\tmap_tail->hash = h.hash;\n\t\t\tmap_tail->offs = (u16) ((char *) de - base);\n\t\t\tmap_tail->size = le16_to_cpu(de->rec_len);\n\t\t\tcount++;\n\t\t\tcond_resched();\n\t\t}\n\t\t/* XXX: do we need to check rec_len == 0 case? -Chris */\n\t\tde = ext3_next_entry(de);\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "ext3_htree_fill_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "609-689",
    "snippet": "int ext3_htree_fill_tree(struct file *dir_file, __u32 start_hash,\n\t\t\t __u32 start_minor_hash, __u32 *next_hash)\n{\n\tstruct dx_hash_info hinfo;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct dx_frame frames[2], *frame;\n\tstruct inode *dir;\n\tint block, err;\n\tint count = 0;\n\tint ret;\n\t__u32 hashval;\n\n\tdxtrace(printk(\"In htree_fill_tree, start hash: %x:%x\\n\", start_hash,\n\t\t       start_minor_hash));\n\tdir = file_inode(dir_file);\n\tif (!(EXT3_I(dir)->i_flags & EXT3_INDEX_FL)) {\n\t\thinfo.hash_version = EXT3_SB(dir->i_sb)->s_def_hash_version;\n\t\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\t\thinfo.hash_version +=\n\t\t\t\tEXT3_SB(dir->i_sb)->s_hash_unsigned;\n\t\thinfo.seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\t\tcount = htree_dirblock_to_tree(dir_file, dir, 0, &hinfo,\n\t\t\t\t\t       start_hash, start_minor_hash);\n\t\t*next_hash = ~0;\n\t\treturn count;\n\t}\n\thinfo.hash = start_hash;\n\thinfo.minor_hash = 0;\n\tframe = dx_probe(NULL, file_inode(dir_file), &hinfo, frames, &err);\n\tif (!frame)\n\t\treturn err;\n\n\t/* Add '.' and '..' from the htree header */\n\tif (!start_hash && !start_minor_hash) {\n\t\tde = (struct ext3_dir_entry_2 *) frames[0].bh->b_data;\n\t\tif ((err = ext3_htree_store_dirent(dir_file, 0, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\tif (start_hash < 2 || (start_hash ==2 && start_minor_hash==0)) {\n\t\tde = (struct ext3_dir_entry_2 *) frames[0].bh->b_data;\n\t\tde = ext3_next_entry(de);\n\t\tif ((err = ext3_htree_store_dirent(dir_file, 2, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\n\twhile (1) {\n\t\tblock = dx_get_block(frame->at);\n\t\tret = htree_dirblock_to_tree(dir_file, dir, block, &hinfo,\n\t\t\t\t\t     start_hash, start_minor_hash);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\tcount += ret;\n\t\thashval = ~0;\n\t\tret = ext3_htree_next_block(dir, HASH_NB_ALWAYS,\n\t\t\t\t\t    frame, frames, &hashval);\n\t\t*next_hash = hashval;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\t/*\n\t\t * Stop if:  (a) there are no more entries, or\n\t\t * (b) we have inserted at least one entry and the\n\t\t * next hash value is not a continuation\n\t\t */\n\t\tif ((ret == 0) ||\n\t\t    (count && ((hashval & 1) == 0)))\n\t\t\tbreak;\n\t}\n\tdx_release(frames);\n\tdxtrace(printk(\"Fill tree: returned %d entries, next hash: %x\\n\",\n\t\t       count, *next_hash));\n\treturn count;\nerrout:\n\tdx_release(frames);\n\treturn (err);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline unsigned dx_get_block (struct dx_entry *entry);",
      "static void dx_set_block (struct dx_entry *entry, unsigned value);",
      "static inline unsigned dx_get_hash (struct dx_entry *entry);",
      "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);",
      "static void dx_set_count (struct dx_entry *entries, unsigned value);",
      "static void dx_set_limit (struct dx_entry *entries, unsigned value);",
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static void dx_release (struct dx_frame *frames);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dx_release",
          "args": [
            "frames"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "dx_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "467-475",
          "snippet": "static void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_release (struct dx_frame *frames);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_release (struct dx_frame *frames);\n\nstatic void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\"Fill tree: returned %d entries, next hash: %x\\n\",\n\t\t       count, *next_hash)"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Fill tree: returned %d entries, next hash: %x\\n\"",
            "count",
            "*next_hash"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "__cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "30-75",
          "snippet": "static noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_htree_next_block",
          "args": [
            "dir",
            "HASH_NB_ALWAYS",
            "frame",
            "frames",
            "&hashval"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_htree_next_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "494-549",
          "snippet": "static int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint err, num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t/*\n\t * Find the next leaf page by incrementing the frame pointer.\n\t * If we run out of entries in the interior node, loop around and\n\t * increment pointer in the parent node.  When we break out of\n\t * this loop, num_frames indicates the number of interior\n\t * nodes need to be read.\n\t */\n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t/*\n\t * If the hash is 1, then continue only if the next page has a\n\t * continuation hash of any value.  This is used for readdir\n\t * handling.  Otherwise, check to see if the hash matches the\n\t * desired contiuation hash.  If it doesn't, return since\n\t * there's no point to read in the successive index pages.\n\t */\n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t/*\n\t * If the hash is HASH_NB_ALWAYS, we always go to the next\n\t * block so no check is necessary\n\t */\n\twhile (num_frames--) {\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(p->at),\n\t\t\t\t\t  0, &err)))\n\t\t\treturn err; /* Failure */\n\t\tp++;\n\t\tbrelse (p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dx_set_block (struct dx_entry *entry, unsigned value);",
            "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_set_count (struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit (struct dx_entry *entries, unsigned value);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_release (struct dx_frame *frames);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_release (struct dx_frame *frames);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint err, num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t/*\n\t * Find the next leaf page by incrementing the frame pointer.\n\t * If we run out of entries in the interior node, loop around and\n\t * increment pointer in the parent node.  When we break out of\n\t * this loop, num_frames indicates the number of interior\n\t * nodes need to be read.\n\t */\n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t/*\n\t * If the hash is 1, then continue only if the next page has a\n\t * continuation hash of any value.  This is used for readdir\n\t * handling.  Otherwise, check to see if the hash matches the\n\t * desired contiuation hash.  If it doesn't, return since\n\t * there's no point to read in the successive index pages.\n\t */\n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t/*\n\t * If the hash is HASH_NB_ALWAYS, we always go to the next\n\t * block so no check is necessary\n\t */\n\twhile (num_frames--) {\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(p->at),\n\t\t\t\t\t  0, &err)))\n\t\t\treturn err; /* Failure */\n\t\tp++;\n\t\tbrelse (p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htree_dirblock_to_tree",
          "args": [
            "dir_file",
            "dir",
            "block",
            "&hinfo",
            "start_hash",
            "start_minor_hash"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "htree_dirblock_to_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "557-598",
          "snippet": "static int htree_dirblock_to_tree(struct file *dir_file,\n\t\t\t\t  struct inode *dir, int block,\n\t\t\t\t  struct dx_hash_info *hinfo,\n\t\t\t\t  __u32 start_hash, __u32 start_minor_hash)\n{\n\tstruct buffer_head *bh;\n\tstruct ext3_dir_entry_2 *de, *top;\n\tint err = 0, count = 0;\n\n\tdxtrace(printk(\"In htree dirblock_to_tree: block %d\\n\", block));\n\n\tif (!(bh = ext3_dir_bread(NULL, dir, block, 0, &err)))\n\t\treturn err;\n\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\ttop = (struct ext3_dir_entry_2 *) ((char *) de +\n\t\t\t\t\t   dir->i_sb->s_blocksize -\n\t\t\t\t\t   EXT3_DIR_REC_LEN(0));\n\tfor (; de < top; de = ext3_next_entry(de)) {\n\t\tif (!ext3_check_dir_entry(\"htree_dirblock_to_tree\", dir, de, bh,\n\t\t\t\t\t(block<<EXT3_BLOCK_SIZE_BITS(dir->i_sb))\n\t\t\t\t\t\t+((char *)de - bh->b_data))) {\n\t\t\t/* silently ignore the rest of the block */\n\t\t\tbreak;\n\t\t}\n\t\text3fs_dirhash(de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\tif ((err = ext3_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de)) != 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int htree_dirblock_to_tree(struct file *dir_file,\n\t\t\t\t  struct inode *dir, int block,\n\t\t\t\t  struct dx_hash_info *hinfo,\n\t\t\t\t  __u32 start_hash, __u32 start_minor_hash)\n{\n\tstruct buffer_head *bh;\n\tstruct ext3_dir_entry_2 *de, *top;\n\tint err = 0, count = 0;\n\n\tdxtrace(printk(\"In htree dirblock_to_tree: block %d\\n\", block));\n\n\tif (!(bh = ext3_dir_bread(NULL, dir, block, 0, &err)))\n\t\treturn err;\n\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\ttop = (struct ext3_dir_entry_2 *) ((char *) de +\n\t\t\t\t\t   dir->i_sb->s_blocksize -\n\t\t\t\t\t   EXT3_DIR_REC_LEN(0));\n\tfor (; de < top; de = ext3_next_entry(de)) {\n\t\tif (!ext3_check_dir_entry(\"htree_dirblock_to_tree\", dir, de, bh,\n\t\t\t\t\t(block<<EXT3_BLOCK_SIZE_BITS(dir->i_sb))\n\t\t\t\t\t\t+((char *)de - bh->b_data))) {\n\t\t\t/* silently ignore the rest of the block */\n\t\t\tbreak;\n\t\t}\n\t\text3fs_dirhash(de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\tif ((err = ext3_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de)) != 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "frame->at"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "183-186",
          "snippet": "static inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_htree_store_dirent",
          "args": [
            "dir_file",
            "2",
            "0",
            "de"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_htree_store_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "346-399",
          "snippet": "int ext3_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext3_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname * fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = (struct dir_private_info *) dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nint ext3_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext3_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname * fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = (struct dir_private_info *) dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_next_entry",
          "args": [
            "de"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "171-176",
          "snippet": "static inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_probe",
          "args": [
            "NULL",
            "file_inode(dir_file)",
            "&hinfo",
            "frames",
            "&err"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "dx_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "328-465",
          "snippet": "static struct dx_frame *\ndx_probe(struct qstr *entry, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in, int *err)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct buffer_head *bh;\n\tstruct dx_frame *frame = frame_in;\n\tu32 hash;\n\n\tframe->bh = NULL;\n\tif (!(bh = ext3_dir_bread(NULL, dir, 0, 0, err))) {\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT3_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\tif (entry)\n\t\text3fs_dirhash(entry->name, entry->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"dx entry: limit != root limit\");\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tdxtrace (printk(\"Look up %x\", hash));\n\twhile (1)\n\t{\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q)\n\t\t{\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) // linear search cross check\n\t\t{\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->bh = bh;\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--) return frame;\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(at), 0, err))) {\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tat = entries = ((struct dx_node *) bh->b_data)->entries;\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tframe++;\n\t\tframe->bh = NULL;\n\t}\nfail2:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\nfail:\n\tif (*err == ERR_BAD_DX_DIR)\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Corrupt dir inode %ld, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct dx_frame *\ndx_probe(struct qstr *entry, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in, int *err)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct buffer_head *bh;\n\tstruct dx_frame *frame = frame_in;\n\tu32 hash;\n\n\tframe->bh = NULL;\n\tif (!(bh = ext3_dir_bread(NULL, dir, 0, 0, err))) {\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT3_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\tif (entry)\n\t\text3fs_dirhash(entry->name, entry->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"dx entry: limit != root limit\");\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tdxtrace (printk(\"Look up %x\", hash));\n\twhile (1)\n\t{\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q)\n\t\t{\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) // linear search cross check\n\t\t{\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->bh = bh;\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--) return frame;\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(at), 0, err))) {\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tat = entries = ((struct dx_node *) bh->b_data)->entries;\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tframe++;\n\t\tframe->bh = NULL;\n\t}\nfail2:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\nfail:\n\tif (*err == ERR_BAD_DX_DIR)\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Corrupt dir inode %ld, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "dir_file"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "dir"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\"In htree_fill_tree, start hash: %x:%x\\n\", start_hash,\n\t\t       start_minor_hash)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_release (struct dx_frame *frames);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_htree_fill_tree(struct file *dir_file, __u32 start_hash,\n\t\t\t __u32 start_minor_hash, __u32 *next_hash)\n{\n\tstruct dx_hash_info hinfo;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct dx_frame frames[2], *frame;\n\tstruct inode *dir;\n\tint block, err;\n\tint count = 0;\n\tint ret;\n\t__u32 hashval;\n\n\tdxtrace(printk(\"In htree_fill_tree, start hash: %x:%x\\n\", start_hash,\n\t\t       start_minor_hash));\n\tdir = file_inode(dir_file);\n\tif (!(EXT3_I(dir)->i_flags & EXT3_INDEX_FL)) {\n\t\thinfo.hash_version = EXT3_SB(dir->i_sb)->s_def_hash_version;\n\t\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\t\thinfo.hash_version +=\n\t\t\t\tEXT3_SB(dir->i_sb)->s_hash_unsigned;\n\t\thinfo.seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\t\tcount = htree_dirblock_to_tree(dir_file, dir, 0, &hinfo,\n\t\t\t\t\t       start_hash, start_minor_hash);\n\t\t*next_hash = ~0;\n\t\treturn count;\n\t}\n\thinfo.hash = start_hash;\n\thinfo.minor_hash = 0;\n\tframe = dx_probe(NULL, file_inode(dir_file), &hinfo, frames, &err);\n\tif (!frame)\n\t\treturn err;\n\n\t/* Add '.' and '..' from the htree header */\n\tif (!start_hash && !start_minor_hash) {\n\t\tde = (struct ext3_dir_entry_2 *) frames[0].bh->b_data;\n\t\tif ((err = ext3_htree_store_dirent(dir_file, 0, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\tif (start_hash < 2 || (start_hash ==2 && start_minor_hash==0)) {\n\t\tde = (struct ext3_dir_entry_2 *) frames[0].bh->b_data;\n\t\tde = ext3_next_entry(de);\n\t\tif ((err = ext3_htree_store_dirent(dir_file, 2, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\n\twhile (1) {\n\t\tblock = dx_get_block(frame->at);\n\t\tret = htree_dirblock_to_tree(dir_file, dir, block, &hinfo,\n\t\t\t\t\t     start_hash, start_minor_hash);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\tcount += ret;\n\t\thashval = ~0;\n\t\tret = ext3_htree_next_block(dir, HASH_NB_ALWAYS,\n\t\t\t\t\t    frame, frames, &hashval);\n\t\t*next_hash = hashval;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\t/*\n\t\t * Stop if:  (a) there are no more entries, or\n\t\t * (b) we have inserted at least one entry and the\n\t\t * next hash value is not a continuation\n\t\t */\n\t\tif ((ret == 0) ||\n\t\t    (count && ((hashval & 1) == 0)))\n\t\t\tbreak;\n\t}\n\tdx_release(frames);\n\tdxtrace(printk(\"Fill tree: returned %d entries, next hash: %x\\n\",\n\t\t       count, *next_hash));\n\treturn count;\nerrout:\n\tdx_release(frames);\n\treturn (err);\n}"
  },
  {
    "function_name": "htree_dirblock_to_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "557-598",
    "snippet": "static int htree_dirblock_to_tree(struct file *dir_file,\n\t\t\t\t  struct inode *dir, int block,\n\t\t\t\t  struct dx_hash_info *hinfo,\n\t\t\t\t  __u32 start_hash, __u32 start_minor_hash)\n{\n\tstruct buffer_head *bh;\n\tstruct ext3_dir_entry_2 *de, *top;\n\tint err = 0, count = 0;\n\n\tdxtrace(printk(\"In htree dirblock_to_tree: block %d\\n\", block));\n\n\tif (!(bh = ext3_dir_bread(NULL, dir, block, 0, &err)))\n\t\treturn err;\n\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\ttop = (struct ext3_dir_entry_2 *) ((char *) de +\n\t\t\t\t\t   dir->i_sb->s_blocksize -\n\t\t\t\t\t   EXT3_DIR_REC_LEN(0));\n\tfor (; de < top; de = ext3_next_entry(de)) {\n\t\tif (!ext3_check_dir_entry(\"htree_dirblock_to_tree\", dir, de, bh,\n\t\t\t\t\t(block<<EXT3_BLOCK_SIZE_BITS(dir->i_sb))\n\t\t\t\t\t\t+((char *)de - bh->b_data))) {\n\t\t\t/* silently ignore the rest of the block */\n\t\t\tbreak;\n\t\t}\n\t\text3fs_dirhash(de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\tif ((err = ext3_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de)) != 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_htree_store_dirent",
          "args": [
            "dir_file",
            "hinfo->hash",
            "hinfo->minor_hash",
            "de"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_htree_store_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "346-399",
          "snippet": "int ext3_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext3_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname * fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = (struct dir_private_info *) dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nint ext3_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext3_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname * fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = (struct dir_private_info *) dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3fs_dirhash",
          "args": [
            "de->name",
            "de->name_len",
            "hinfo"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "ext3fs_dirhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/hash.c",
          "lines": "137-206",
          "snippet": "int ext3fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i=0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < 4)\n\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT3_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT3_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cryptohash.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cryptohash.h>\n#include \"ext3.h\"\n\nint ext3fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i=0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < 4)\n\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT3_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT3_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_check_dir_entry",
          "args": [
            "\"htree_dirblock_to_tree\"",
            "dir",
            "de",
            "bh",
            "(block<<EXT3_BLOCK_SIZE_BITS(dir->i_sb))\n\t\t\t\t\t\t+((char *)de - bh->b_data)"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_check_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "62-91",
          "snippet": "int ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nint ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCK_SIZE_BITS",
          "args": [
            "dir->i_sb"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_next_entry",
          "args": [
            "de"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "171-176",
          "snippet": "static inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "0"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_dir_bread",
          "args": [
            "NULL",
            "dir",
            "block",
            "0",
            "&err"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_dir_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.h",
          "lines": "10-27",
          "snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\"In htree dirblock_to_tree: block %d\\n\", block)"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"In htree dirblock_to_tree: block %d\\n\"",
            "block"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int htree_dirblock_to_tree(struct file *dir_file,\n\t\t\t\t  struct inode *dir, int block,\n\t\t\t\t  struct dx_hash_info *hinfo,\n\t\t\t\t  __u32 start_hash, __u32 start_minor_hash)\n{\n\tstruct buffer_head *bh;\n\tstruct ext3_dir_entry_2 *de, *top;\n\tint err = 0, count = 0;\n\n\tdxtrace(printk(\"In htree dirblock_to_tree: block %d\\n\", block));\n\n\tif (!(bh = ext3_dir_bread(NULL, dir, block, 0, &err)))\n\t\treturn err;\n\n\tde = (struct ext3_dir_entry_2 *) bh->b_data;\n\ttop = (struct ext3_dir_entry_2 *) ((char *) de +\n\t\t\t\t\t   dir->i_sb->s_blocksize -\n\t\t\t\t\t   EXT3_DIR_REC_LEN(0));\n\tfor (; de < top; de = ext3_next_entry(de)) {\n\t\tif (!ext3_check_dir_entry(\"htree_dirblock_to_tree\", dir, de, bh,\n\t\t\t\t\t(block<<EXT3_BLOCK_SIZE_BITS(dir->i_sb))\n\t\t\t\t\t\t+((char *)de - bh->b_data))) {\n\t\t\t/* silently ignore the rest of the block */\n\t\t\tbreak;\n\t\t}\n\t\text3fs_dirhash(de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\tif ((err = ext3_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de)) != 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}"
  },
  {
    "function_name": "ext3_htree_next_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "494-549",
    "snippet": "static int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint err, num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t/*\n\t * Find the next leaf page by incrementing the frame pointer.\n\t * If we run out of entries in the interior node, loop around and\n\t * increment pointer in the parent node.  When we break out of\n\t * this loop, num_frames indicates the number of interior\n\t * nodes need to be read.\n\t */\n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t/*\n\t * If the hash is 1, then continue only if the next page has a\n\t * continuation hash of any value.  This is used for readdir\n\t * handling.  Otherwise, check to see if the hash matches the\n\t * desired contiuation hash.  If it doesn't, return since\n\t * there's no point to read in the successive index pages.\n\t */\n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t/*\n\t * If the hash is HASH_NB_ALWAYS, we always go to the next\n\t * block so no check is necessary\n\t */\n\twhile (num_frames--) {\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(p->at),\n\t\t\t\t\t  0, &err)))\n\t\t\treturn err; /* Failure */\n\t\tp++;\n\t\tbrelse (p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dx_set_block (struct dx_entry *entry, unsigned value);",
      "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);",
      "static void dx_set_count (struct dx_entry *entries, unsigned value);",
      "static void dx_set_limit (struct dx_entry *entries, unsigned value);",
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static void dx_release (struct dx_frame *frames);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "p->bh"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_dir_bread",
          "args": [
            "NULL",
            "dir",
            "dx_get_block(p->at)",
            "0",
            "&err"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_dir_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.h",
          "lines": "10-27",
          "snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "p->at"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "183-186",
          "snippet": "static inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_hash",
          "args": [
            "p->at"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "193-196",
          "snippet": "static inline unsigned dx_get_hash (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\n\nstatic inline unsigned dx_get_hash (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_count",
          "args": [
            "p->entries"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "203-206",
          "snippet": "static inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\n\nstatic inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_release (struct dx_frame *frames);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint err, num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t/*\n\t * Find the next leaf page by incrementing the frame pointer.\n\t * If we run out of entries in the interior node, loop around and\n\t * increment pointer in the parent node.  When we break out of\n\t * this loop, num_frames indicates the number of interior\n\t * nodes need to be read.\n\t */\n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t/*\n\t * If the hash is 1, then continue only if the next page has a\n\t * continuation hash of any value.  This is used for readdir\n\t * handling.  Otherwise, check to see if the hash matches the\n\t * desired contiuation hash.  If it doesn't, return since\n\t * there's no point to read in the successive index pages.\n\t */\n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t/*\n\t * If the hash is HASH_NB_ALWAYS, we always go to the next\n\t * block so no check is necessary\n\t */\n\twhile (num_frames--) {\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(p->at),\n\t\t\t\t\t  0, &err)))\n\t\t\treturn err; /* Failure */\n\t\tp++;\n\t\tbrelse (p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "dx_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "467-475",
    "snippet": "static void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dx_release (struct dx_frame *frames);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "frames[0].bh"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_release (struct dx_frame *frames);\n\nstatic void dx_release (struct dx_frame *frames)\n{\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tif (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)\n\t\tbrelse(frames[1].bh);\n\tbrelse(frames[0].bh);\n}"
  },
  {
    "function_name": "dx_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "328-465",
    "snippet": "static struct dx_frame *\ndx_probe(struct qstr *entry, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in, int *err)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct buffer_head *bh;\n\tstruct dx_frame *frame = frame_in;\n\tu32 hash;\n\n\tframe->bh = NULL;\n\tif (!(bh = ext3_dir_bread(NULL, dir, 0, 0, err))) {\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT3_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\tif (entry)\n\t\text3fs_dirhash(entry->name, entry->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"dx entry: limit != root limit\");\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tdxtrace (printk(\"Look up %x\", hash));\n\twhile (1)\n\t{\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q)\n\t\t{\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) // linear search cross check\n\t\t{\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->bh = bh;\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--) return frame;\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(at), 0, err))) {\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tat = entries = ((struct dx_node *) bh->b_data)->entries;\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tframe++;\n\t\tframe->bh = NULL;\n\t}\nfail2:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\nfail:\n\tif (*err == ERR_BAD_DX_DIR)\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Corrupt dir inode %ld, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn NULL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline unsigned dx_get_block (struct dx_entry *entry);",
      "static inline unsigned dx_get_hash (struct dx_entry *entry);",
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);",
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "dir->i_sb",
            "__func__",
            "\"Corrupt dir inode %ld, running e2fsck is \"\n\t\t\t     \"recommended.\"",
            "dir->i_ino"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "frame->bh"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_node_limit",
          "args": [
            "dir"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "dx_node_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "230-234",
          "snippet": "static inline unsigned dx_node_limit (struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(0);\n\treturn entry_space / sizeof(struct dx_entry);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit (struct inode *dir);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline unsigned dx_node_limit (struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(0);\n\treturn entry_space / sizeof(struct dx_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_limit",
          "args": [
            "entries"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "208-211",
          "snippet": "static inline unsigned dx_get_limit (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\n\nstatic inline unsigned dx_get_limit (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_dir_bread",
          "args": [
            "NULL",
            "dir",
            "dx_get_block(at)",
            "0",
            "err"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_dir_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.h",
          "lines": "10-27",
          "snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "at"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "183-186",
          "snippet": "static inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at))"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" %x->%u\\n\"",
            "at == entries? 0: dx_get_hash(at)",
            "dx_get_block(at)"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "__cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "30-75",
          "snippet": "static noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_hash",
          "args": [
            "at"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "193-196",
          "snippet": "static inline unsigned dx_get_hash (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\n\nstatic inline unsigned dx_get_hash (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "at == p - 1"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\",\")"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\",\""
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\".\")"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_get_count",
          "args": [
            "entries"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "203-206",
          "snippet": "static inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\n\nstatic inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dxtrace",
          "args": [
            "printk(\"Look up %x\", hash)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Look up %x\"",
            "hash"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_root_limit",
          "args": [
            "dir",
            "root->info.info_length"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "dx_root_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "223-228",
          "snippet": "static inline unsigned dx_root_limit (struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(1) -\n\t\tEXT3_DIR_REC_LEN(2) - infosize;\n\treturn entry_space / sizeof(struct dx_entry);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_root_limit (struct inode *dir, unsigned infosize);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_root_limit (struct inode *dir, unsigned infosize);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline unsigned dx_root_limit (struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(1) -\n\t\tEXT3_DIR_REC_LEN(2) - infosize;\n\treturn entry_space / sizeof(struct dx_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3fs_dirhash",
          "args": [
            "entry->name",
            "entry->len",
            "hinfo"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "ext3fs_dirhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/hash.c",
          "lines": "137-206",
          "snippet": "int ext3fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i=0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < 4)\n\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT3_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT3_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cryptohash.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cryptohash.h>\n#include \"ext3.h\"\n\nint ext3fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i=0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < 4)\n\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT3_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT3_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct dx_frame *\ndx_probe(struct qstr *entry, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in, int *err)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct buffer_head *bh;\n\tstruct dx_frame *frame = frame_in;\n\tu32 hash;\n\n\tframe->bh = NULL;\n\tif (!(bh = ext3_dir_bread(NULL, dir, 0, 0, err))) {\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT3_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\tif (entry)\n\t\text3fs_dirhash(entry->name, entry->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"dx entry: limit != root limit\");\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tdxtrace (printk(\"Look up %x\", hash));\n\twhile (1)\n\t{\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q)\n\t\t{\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) // linear search cross check\n\t\t{\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->bh = bh;\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--) return frame;\n\t\tif (!(bh = ext3_dir_bread(NULL, dir, dx_get_block(at), 0, err))) {\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tat = entries = ((struct dx_node *) bh->b_data)->entries;\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text3_warning(dir->i_sb, __func__,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tframe++;\n\t\tframe->bh = NULL;\n\t}\nfail2:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\nfail:\n\tif (*err == ERR_BAD_DX_DIR)\n\t\text3_warning(dir->i_sb, __func__,\n\t\t\t     \"Corrupt dir inode %ld, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn NULL;\n}"
  },
  {
    "function_name": "dx_show_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "288-316",
    "snippet": "struct stats dx_show_entries(struct dx_hash_info *hinfo, struct inode *dir,\n\t\t\t     struct dx_entry *entries, int levels)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count = dx_get_count (entries), names = 0, space = 0, i;\n\tunsigned bcount = 0;\n\tstruct buffer_head *bh;\n\tint err;\n\tprintk(\"%i indexed blocks...\\n\", count);\n\tfor (i = 0; i < count; i++, entries++)\n\t{\n\t\tu32 block = dx_get_block(entries), hash = i? dx_get_hash(entries): 0;\n\t\tu32 range = i < count - 1? (dx_get_hash(entries + 1) - hash): ~hash;\n\t\tstruct stats stats;\n\t\tprintk(\"%s%3u:%03u hash %8x/%8x \",levels?\"\":\"   \", i, block, hash, range);\n\t\tif (!(bh = ext3_bread (NULL,dir, block, 0,&err))) continue;\n\t\tstats = levels?\n\t\t   dx_show_entries(hinfo, dir, ((struct dx_node *) bh->b_data)->entries, levels - 1):\n\t\t   dx_show_leaf(hinfo, (struct ext3_dir_entry_2 *) bh->b_data, blocksize, 0);\n\t\tnames += stats.names;\n\t\tspace += stats.space;\n\t\tbcount += stats.bcount;\n\t\tbrelse (bh);\n\t}\n\tif (bcount)\n\t\tprintk(\"%snames %u, fullness %u (%u%%)\\n\", levels?\"\":\"   \",\n\t\t\tnames, space/bcount,(space/bcount)*100/blocksize);\n\treturn (struct stats) { names, space, bcount};\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);",
      "static unsigned dx_node_limit (struct inode *dir);",
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
      "static struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%snames %u, fullness %u (%u%%)\\n\"",
            "levels?\"\":\"   \"",
            "names",
            "space/bcount",
            "(space/bcount)*100/blocksize"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_show_leaf",
          "args": [
            "hinfo",
            "(struct ext3_dir_entry_2 *) bh->b_data",
            "blocksize",
            "0"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "dx_show_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "258-286",
          "snippet": "static struct stats dx_show_leaf(struct dx_hash_info *hinfo, struct ext3_dir_entry_2 *de,\n\t\t\t\t int size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\twhile (len--) printk(\"%c\", *name++);\n\t\t\t\text3fs_dirhash(de->name, de->name_len, &h);\n\t\t\t\tprintk(\":%x.%u \", h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n\t\t\t}\n\t\t\tspace += EXT3_DIR_REC_LEN(de->name_len);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext3_next_entry(de);\n\t}\n\tprintk(\"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct stats dx_show_leaf(struct dx_hash_info *hinfo, struct ext3_dir_entry_2 *de,\n\t\t\t\t int size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\twhile (len--) printk(\"%c\", *name++);\n\t\t\t\text3fs_dirhash(de->name, de->name_len, &h);\n\t\t\t\tprintk(\":%x.%u \", h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n\t\t\t}\n\t\t\tspace += EXT3_DIR_REC_LEN(de->name_len);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext3_next_entry(de);\n\t}\n\tprintk(\"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_show_entries",
          "args": [
            "hinfo",
            "dir",
            "((struct dx_node *) bh->b_data)->entries",
            "levels - 1"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "dx_show_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "288-316",
          "snippet": "struct stats dx_show_entries(struct dx_hash_info *hinfo, struct inode *dir,\n\t\t\t     struct dx_entry *entries, int levels)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count = dx_get_count (entries), names = 0, space = 0, i;\n\tunsigned bcount = 0;\n\tstruct buffer_head *bh;\n\tint err;\n\tprintk(\"%i indexed blocks...\\n\", count);\n\tfor (i = 0; i < count; i++, entries++)\n\t{\n\t\tu32 block = dx_get_block(entries), hash = i? dx_get_hash(entries): 0;\n\t\tu32 range = i < count - 1? (dx_get_hash(entries + 1) - hash): ~hash;\n\t\tstruct stats stats;\n\t\tprintk(\"%s%3u:%03u hash %8x/%8x \",levels?\"\":\"   \", i, block, hash, range);\n\t\tif (!(bh = ext3_bread (NULL,dir, block, 0,&err))) continue;\n\t\tstats = levels?\n\t\t   dx_show_entries(hinfo, dir, ((struct dx_node *) bh->b_data)->entries, levels - 1):\n\t\t   dx_show_leaf(hinfo, (struct ext3_dir_entry_2 *) bh->b_data, blocksize, 0);\n\t\tnames += stats.names;\n\t\tspace += stats.space;\n\t\tbcount += stats.bcount;\n\t\tbrelse (bh);\n\t}\n\tif (bcount)\n\t\tprintk(\"%snames %u, fullness %u (%u%%)\\n\", levels?\"\":\"   \",\n\t\t\tnames, space/bcount,(space/bcount)*100/blocksize);\n\treturn (struct stats) { names, space, bcount};\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ext3_bread",
          "args": [
            "NULL",
            "dir",
            "block",
            "0",
            "&err"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1128-1147",
          "snippet": "struct buffer_head *ext3_bread(handle_t *handle, struct inode *inode,\n\t\t\t       int block, int create, int *err)\n{\n\tstruct buffer_head * bh;\n\n\tbh = ext3_getblk(handle, inode, block, create, err);\n\tif (!bh)\n\t\treturn bh;\n\tif (bh_uptodate_or_lock(bh))\n\t\treturn bh;\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\t*err = -EIO;\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstruct buffer_head *ext3_bread(handle_t *handle, struct inode *inode,\n\t\t\t       int block, int create, int *err)\n{\n\tstruct buffer_head * bh;\n\n\tbh = ext3_getblk(handle, inode, block, create, err);\n\tif (!bh)\n\t\treturn bh;\n\tif (bh_uptodate_or_lock(bh))\n\t\treturn bh;\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\t*err = -EIO;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_hash",
          "args": [
            "entries + 1"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "193-196",
          "snippet": "static inline unsigned dx_get_hash (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\n\nstatic inline unsigned dx_get_hash (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "entries"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "183-186",
          "snippet": "static inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%i indexed blocks...\\n\"",
            "count"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_count",
          "args": [
            "entries"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "203-206",
          "snippet": "static inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\n\nstatic inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic struct ext3_dir_entry_2 *dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstruct stats dx_show_entries(struct dx_hash_info *hinfo, struct inode *dir,\n\t\t\t     struct dx_entry *entries, int levels)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count = dx_get_count (entries), names = 0, space = 0, i;\n\tunsigned bcount = 0;\n\tstruct buffer_head *bh;\n\tint err;\n\tprintk(\"%i indexed blocks...\\n\", count);\n\tfor (i = 0; i < count; i++, entries++)\n\t{\n\t\tu32 block = dx_get_block(entries), hash = i? dx_get_hash(entries): 0;\n\t\tu32 range = i < count - 1? (dx_get_hash(entries + 1) - hash): ~hash;\n\t\tstruct stats stats;\n\t\tprintk(\"%s%3u:%03u hash %8x/%8x \",levels?\"\":\"   \", i, block, hash, range);\n\t\tif (!(bh = ext3_bread (NULL,dir, block, 0,&err))) continue;\n\t\tstats = levels?\n\t\t   dx_show_entries(hinfo, dir, ((struct dx_node *) bh->b_data)->entries, levels - 1):\n\t\t   dx_show_leaf(hinfo, (struct ext3_dir_entry_2 *) bh->b_data, blocksize, 0);\n\t\tnames += stats.names;\n\t\tspace += stats.space;\n\t\tbcount += stats.bcount;\n\t\tbrelse (bh);\n\t}\n\tif (bcount)\n\t\tprintk(\"%snames %u, fullness %u (%u%%)\\n\", levels?\"\":\"   \",\n\t\t\tnames, space/bcount,(space/bcount)*100/blocksize);\n\treturn (struct stats) { names, space, bcount};\n}"
  },
  {
    "function_name": "dx_show_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "258-286",
    "snippet": "static struct stats dx_show_leaf(struct dx_hash_info *hinfo, struct ext3_dir_entry_2 *de,\n\t\t\t\t int size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\twhile (len--) printk(\"%c\", *name++);\n\t\t\t\text3fs_dirhash(de->name, de->name_len, &h);\n\t\t\t\tprintk(\":%x.%u \", h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n\t\t\t}\n\t\t\tspace += EXT3_DIR_REC_LEN(de->name_len);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext3_next_entry(de);\n\t}\n\tprintk(\"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"(%i)\\n\"",
            "names"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_next_entry",
          "args": [
            "de"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "171-176",
          "snippet": "static inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\":%x.%u \"",
            "h.hash",
            "(unsigned) ((char *) de - base)"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "__cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "30-75",
          "snippet": "static noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3fs_dirhash",
          "args": [
            "de->name",
            "de->name_len",
            "&h"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "ext3fs_dirhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/hash.c",
          "lines": "137-206",
          "snippet": "int ext3fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i=0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < 4)\n\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT3_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT3_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cryptohash.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cryptohash.h>\n#include \"ext3.h\"\n\nint ext3fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i=0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < 4)\n\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT3_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT3_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"names: \""
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct stats dx_show_leaf(struct dx_hash_info *hinfo, struct ext3_dir_entry_2 *de,\n\t\t\t\t int size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\twhile (len--) printk(\"%c\", *name++);\n\t\t\t\text3fs_dirhash(de->name, de->name_len, &h);\n\t\t\t\tprintk(\":%x.%u \", h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n\t\t\t}\n\t\t\tspace += EXT3_DIR_REC_LEN(de->name_len);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext3_next_entry(de);\n\t}\n\tprintk(\"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}"
  },
  {
    "function_name": "dx_show_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "240-249",
    "snippet": "static void dx_show_index (char * label, struct dx_entry *entries)\n{\n        int i, n = dx_get_count (entries);\n        printk(\"%s index \", label);\n        for (i = 0; i < n; i++)\n        {\n                printk(\"%x->%u \", i? dx_get_hash(entries + i): 0, dx_get_block(entries + i));\n        }\n        printk(\"\\n\");\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%x->%u \"",
            "i? dx_get_hash(entries + i): 0",
            "dx_get_block(entries + i)"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "__cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "30-75",
          "snippet": "static noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_block",
          "args": [
            "entries + i"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "183-186",
          "snippet": "static inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_hash",
          "args": [
            "entries + i"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "193-196",
          "snippet": "static inline unsigned dx_get_hash (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\n\nstatic inline unsigned dx_get_hash (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s index \"",
            "label"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dx_get_count",
          "args": [
            "entries"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "dx_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "203-206",
          "snippet": "static inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\n\nstatic inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\n\nstatic void dx_show_index (char * label, struct dx_entry *entries)\n{\n        int i, n = dx_get_count (entries);\n        printk(\"%s index \", label);\n        for (i = 0; i < n; i++)\n        {\n                printk(\"%x->%u \", i? dx_get_hash(entries + i): 0, dx_get_block(entries + i));\n        }\n        printk(\"\\n\");\n}"
  },
  {
    "function_name": "dx_node_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "230-234",
    "snippet": "static inline unsigned dx_node_limit (struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(0);\n\treturn entry_space / sizeof(struct dx_entry);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_node_limit (struct inode *dir);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "0"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline unsigned dx_node_limit (struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(0);\n\treturn entry_space / sizeof(struct dx_entry);\n}"
  },
  {
    "function_name": "dx_root_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "223-228",
    "snippet": "static inline unsigned dx_root_limit (struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(1) -\n\t\tEXT3_DIR_REC_LEN(2) - infosize;\n\treturn entry_space / sizeof(struct dx_entry);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_root_limit (struct inode *dir, unsigned infosize);",
      "static unsigned dx_node_limit (struct inode *dir);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "2"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_root_limit (struct inode *dir, unsigned infosize);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic inline unsigned dx_root_limit (struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(1) -\n\t\tEXT3_DIR_REC_LEN(2) - infosize;\n\treturn entry_space / sizeof(struct dx_entry);\n}"
  },
  {
    "function_name": "dx_set_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "218-221",
    "snippet": "static inline void dx_set_limit (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dx_set_block (struct dx_entry *entry, unsigned value);",
      "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);",
      "static void dx_set_count (struct dx_entry *entries, unsigned value);",
      "static void dx_set_limit (struct dx_entry *entries, unsigned value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "value"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\n\nstatic inline void dx_set_limit (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}"
  },
  {
    "function_name": "dx_set_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "213-216",
    "snippet": "static inline void dx_set_count (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dx_set_block (struct dx_entry *entry, unsigned value);",
      "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);",
      "static void dx_set_count (struct dx_entry *entries, unsigned value);",
      "static void dx_set_limit (struct dx_entry *entries, unsigned value);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "value"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\n\nstatic inline void dx_set_count (struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}"
  },
  {
    "function_name": "dx_get_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "208-211",
    "snippet": "static inline unsigned dx_get_limit (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "((struct dx_countlimit *) entries)->limit"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\n\nstatic inline unsigned dx_get_limit (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}"
  },
  {
    "function_name": "dx_get_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "203-206",
    "snippet": "static inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned dx_get_count (struct dx_entry *entries);",
      "static unsigned dx_get_limit (struct dx_entry *entries);",
      "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
      "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "((struct dx_countlimit *) entries)->count"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\n\nstatic inline unsigned dx_get_count (struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}"
  },
  {
    "function_name": "dx_set_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "198-201",
    "snippet": "static inline void dx_set_hash (struct dx_entry *entry, unsigned value)\n{\n\tentry->hash = cpu_to_le32(value);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline unsigned dx_get_block (struct dx_entry *entry);",
      "static void dx_set_block (struct dx_entry *entry, unsigned value);",
      "static inline unsigned dx_get_hash (struct dx_entry *entry);",
      "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
      "static void dx_set_count (struct dx_entry *entries, unsigned value);",
      "static void dx_set_limit (struct dx_entry *entries, unsigned value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "value"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\n\nstatic inline void dx_set_hash (struct dx_entry *entry, unsigned value)\n{\n\tentry->hash = cpu_to_le32(value);\n}"
  },
  {
    "function_name": "dx_get_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "193-196",
    "snippet": "static inline unsigned dx_get_hash (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline unsigned dx_get_block (struct dx_entry *entry);",
      "static inline unsigned dx_get_hash (struct dx_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->hash"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\n\nstatic inline unsigned dx_get_hash (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}"
  },
  {
    "function_name": "dx_set_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "188-191",
    "snippet": "static inline void dx_set_block (struct dx_entry *entry, unsigned value)\n{\n\tentry->block = cpu_to_le32(value);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline unsigned dx_get_block (struct dx_entry *entry);",
      "static void dx_set_block (struct dx_entry *entry, unsigned value);",
      "static inline unsigned dx_get_hash (struct dx_entry *entry);",
      "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
      "static void dx_set_count (struct dx_entry *entries, unsigned value);",
      "static void dx_set_limit (struct dx_entry *entries, unsigned value);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "value"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic inline void dx_set_block (struct dx_entry *entry, unsigned value)\n{\n\tentry->block = cpu_to_le32(value);\n}"
  },
  {
    "function_name": "dx_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "183-186",
    "snippet": "static inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline unsigned dx_get_block (struct dx_entry *entry);",
      "static inline unsigned dx_get_hash (struct dx_entry *entry);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->block"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x00ffffff;\n}"
  },
  {
    "function_name": "ext3_next_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "171-176",
    "snippet": "static inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_rec_len_from_disk",
          "args": [
            "p->rec_len"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "878-887",
          "snippet": "static inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline struct ext3_dir_entry_2 *\next3_next_entry(struct ext3_dir_entry_2 *p)\n{\n\treturn (struct ext3_dir_entry_2 *)((char *)p +\n\t\text3_rec_len_from_disk(p->rec_len));\n}"
  },
  {
    "function_name": "ext3_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
    "lines": "40-58",
    "snippet": "static struct buffer_head *ext3_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tu32 *block, int *err)\n{\n\tstruct buffer_head *bh;\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tif ((bh = ext3_dir_bread(handle, inode, *block, 1, err))) {\n\t\tinode->i_size += inode->i_sb->s_blocksize;\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t\t*err = ext3_journal_get_write_access(handle, bh);\n\t\tif (*err) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\treturn bh;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"namei.h\"",
      "#include \"ext3.h\"",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
      "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
      "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
      "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_dir_bread",
          "args": [
            "handle",
            "inode",
            "*block",
            "1",
            "err"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_dir_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.h",
          "lines": "10-27",
          "snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct buffer_head *ext3_dir_bread(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int block, int create,\n\t\t\t\t\t\t int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext3_bread(handle, inode, block, create, err);\n\n\tif (!bh && !(*err)) {\n\t\t*err = -EIO;\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"Directory hole detected on inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstatic struct buffer_head *ext3_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tu32 *block, int *err)\n{\n\tstruct buffer_head *bh;\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tif ((bh = ext3_dir_bread(handle, inode, *block, 1, err))) {\n\t\tinode->i_size += inode->i_sb->s_blocksize;\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t\t*err = ext3_journal_get_write_access(handle, bh);\n\t\tif (*err) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\treturn bh;\n}"
  }
]