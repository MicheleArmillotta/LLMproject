[
  {
    "function_name": "reiserfs_delete_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "1233-2262",
    "snippet": "int reiserfs_delete_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path, const struct cpu_key *item_key,\n\t\t\t struct inode *inode, struct buffer_head *un_bh)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct tree_balance s_del_balance;\n\tstruct item_head s_ih;\n\tstruct item_head *q_ih;\n\tint quota_cut_bytes;\n\tint ret_value, del_size, removed;\n\tint depth;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tchar mode;\n\tint iter = 0;\n#endif\n\n\tBUG_ON(!th->t_trans_id);\n\n\tinit_tb_struct(th, &s_del_balance, sb, path,\n\t\t       0 /*size is unknown */ );\n\n\twhile (1) {\n\t\tremoved = 0;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\titer++;\n\t\tmode =\n#endif\n\t\t    prepare_for_delete_or_cut(th, inode, path,\n\t\t\t\t\t      item_key, &removed,\n\t\t\t\t\t      &del_size,\n\t\t\t\t\t      max_reiserfs_offset(inode));\n\n\t\tRFALSE(mode != M_DELETE, \"PAP-5320: mode must be M_DELETE\");\n\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n\t\ts_del_balance.insert_size[0] = del_size;\n\n\t\tret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);\n\t\tif (ret_value != REPEAT_SEARCH)\n\t\t\tbreak;\n\n\t\tPROC_INFO_INC(sb, delete_item_restarted);\n\n\t\t/* file system changed, repeat search */\n\t\tret_value =\n\t\t    search_for_position_by_key(sb, item_key, path);\n\t\tif (ret_value == IO_ERROR)\n\t\t\tbreak;\n\t\tif (ret_value == FILE_NOT_FOUND) {\n\t\t\treiserfs_warning(sb, \"vs-5340\",\n\t\t\t\t\t \"no items of the file %K found\",\n\t\t\t\t\t item_key);\n\t\t\tbreak;\n\t\t}\n\t}\t\t\t/* while (1) */\n\n\tif (ret_value != CARRY_ON) {\n\t\tunfix_nodes(&s_del_balance);\n\t\treturn 0;\n\t}\n\n\t/* reiserfs_delete_item returns item length when success */\n\tret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);\n\tq_ih = tp_item_head(path);\n\tquota_cut_bytes = ih_item_len(q_ih);\n\n\t/*\n\t * hack so the quota code doesn't have to guess if the file has a\n\t * tail.  On tail insert, we allocate quota for 1 unformatted node.\n\t * We test the offset because the tail might have been\n\t * split into multiple items, and we only want to decrement for\n\t * the unfm node once\n\t */\n\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(q_ih)) {\n\t\tif ((le_ih_k_offset(q_ih) & (sb->s_blocksize - 1)) == 1) {\n\t\t\tquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\n\t\t} else {\n\t\t\tquota_cut_bytes = 0;\n\t\t}\n\t}\n\n\tif (un_bh) {\n\t\tint off;\n\t\tchar *data;\n\n\t\t/*\n\t\t * We are in direct2indirect conversion, so move tail contents\n\t\t * to the unformatted node\n\t\t */\n\t\t/*\n\t\t * note, we do the copy before preparing the buffer because we\n\t\t * don't care about the contents of the unformatted node yet.\n\t\t * the only thing we really care about is the direct item's\n\t\t * data is in the unformatted node.\n\t\t *\n\t\t * Otherwise, we would have to call\n\t\t * reiserfs_prepare_for_journal on the unformatted node,\n\t\t * which might schedule, meaning we'd have to loop all the\n\t\t * way back up to the start of the while loop.\n\t\t *\n\t\t * The unformatted node must be dirtied later on.  We can't be\n\t\t * sure here if the entire tail has been deleted yet.\n\t\t *\n\t\t * un_bh is from the page cache (all unformatted nodes are\n\t\t * from the page cache) and might be a highmem page.  So, we\n\t\t * can't use un_bh->b_data.\n\t\t * -clm\n\t\t */\n\n\t\tdata = kmap_atomic(un_bh->b_page);\n\t\toff = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));\n\t\tmemcpy(data + off,\n\t\t       ih_item_body(PATH_PLAST_BUFFER(path), &s_ih),\n\t\t       ret_value);\n\t\tkunmap_atomic(data);\n\t}\n\n\t/* Perform balancing after all resources have been collected at once. */\n\tdo_balance(&s_del_balance, NULL, NULL, M_DELETE);\n\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota delete_item(): freeing %u, id=%u type=%c\",\n\t\t       quota_cut_bytes, inode->i_uid, head2type(&s_ih));\n#endif\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_space_nodirty(inode, quota_cut_bytes);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\t/* Return deleted body length */\n\treturn ret_value;\n}\n\n/*\n * Summary Of Mechanisms For Handling Collisions Between Processes:\n *\n *  deletion of the body of the object is performed by iput(), with the\n *  result that if multiple processes are operating on a file, the\n *  deletion of the body of the file is deferred until the last process\n *  that has an open inode performs its iput().\n *\n *  writes and truncates are protected from collisions by use of\n *  semaphores.\n *\n *  creates, linking, and mknod are protected from collisions with other\n *  processes by making the reiserfs_add_entry() the last step in the\n *  creation, and then rolling back all changes if there was a collision.\n *  - Hans\n*/\n\n/* this deletes item which never gets split */\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct tree_balance tb;\n\tINITIALIZE_PATH(path);\n\tint item_len = 0;\n\tint tb_init = 0;\n\tstruct cpu_key cpu_key;\n\tint retval;\n\tint quota_cut_bytes = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tle_key2cpu_key(&cpu_key, key);\n\n\twhile (1) {\n\t\tretval = search_item(th->t_super, &cpu_key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(th->t_super, \"vs-5350\",\n\t\t\t\t       \"i/o failure occurred trying \"\n\t\t\t\t       \"to delete %K\", &cpu_key);\n\t\t\tbreak;\n\t\t}\n\t\tif (retval != ITEM_FOUND) {\n\t\t\tpathrelse(&path);\n\t\t\t/*\n\t\t\t * No need for a warning, if there is just no free\n\t\t\t * space to insert '..' item into the\n\t\t\t * newly-created subdir\n\t\t\t */\n\t\t\tif (!\n\t\t\t    ((unsigned long long)\n\t\t\t     GET_HASH_VALUE(le_key_k_offset\n\t\t\t\t\t    (le_key_version(key), key)) == 0\n\t\t\t     && (unsigned long long)\n\t\t\t     GET_GENERATION_NUMBER(le_key_k_offset\n\t\t\t\t\t\t   (le_key_version(key),\n\t\t\t\t\t\t    key)) == 1))\n\t\t\t\treiserfs_warning(th->t_super, \"vs-5355\",\n\t\t\t\t\t\t \"%k not found\", key);\n\t\t\tbreak;\n\t\t}\n\t\tif (!tb_init) {\n\t\t\ttb_init = 1;\n\t\t\titem_len = ih_item_len(tp_item_head(&path));\n\t\t\tinit_tb_struct(th, &tb, th->t_super, &path,\n\t\t\t\t       -(IH_SIZE + item_len));\n\t\t}\n\t\tquota_cut_bytes = ih_item_len(tp_item_head(&path));\n\n\t\tretval = fix_nodes(M_DELETE, &tb, NULL, NULL);\n\t\tif (retval == REPEAT_SEARCH) {\n\t\t\tPROC_INFO_INC(th->t_super, delete_solid_item_restarted);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (retval == CARRY_ON) {\n\t\t\tdo_balance(&tb, NULL, NULL, M_DELETE);\n\t\t\t/*\n\t\t\t * Should we count quota for item? (we don't\n\t\t\t * count quotas for save-links)\n\t\t\t */\n\t\t\tif (inode) {\n\t\t\t\tint depth;\n#ifdef REISERQUOTA_DEBUG\n\t\t\t\treiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"reiserquota delete_solid_item(): freeing %u id=%u type=%c\",\n\t\t\t\t\t       quota_cut_bytes, inode->i_uid,\n\t\t\t\t\t       key2type(key));\n#endif\n\t\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t\t\t quota_cut_bytes);\n\t\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* IO_ERROR, NO_DISK_SPACE, etc */\n\t\treiserfs_warning(th->t_super, \"vs-5360\",\n\t\t\t\t \"could not delete %K due to fix_nodes failure\",\n\t\t\t\t &cpu_key);\n\t\tunfix_nodes(&tb);\n\t\tbreak;\n\t}\n\n\treiserfs_check_path(&path);\n}\n\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode)\n{\n\tint err;\n\tinode->i_size = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\t/* for directory this deletes item containing \".\" and \"..\" */\n\terr =\n\t    reiserfs_do_truncate(th, inode, NULL, 0 /*no timestamp updates */ );\n\tif (err)\n\t\treturn err;\n\n#if defined( USE_INODE_GENERATION_COUNTER )\n\tif (!old_format_only(th->t_super)) {\n\t\t__le32 *inode_generation;\n\n\t\tinode_generation =\n\t\t    &REISERFS_SB(th->t_super)->s_rs->s_inode_generation;\n\t\tle32_add_cpu(inode_generation, 1);\n\t}\n/* USE_INODE_GENERATION_COUNTER */\n#endif\n\treiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\n\n\treturn err;\n}\n\nstatic void unmap_buffers(struct page *page, loff_t pos)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct buffer_head *next;\n\tunsigned long tail_index;\n\tunsigned long cur_index;\n\n\tif (page) {\n\t\tif (page_has_buffers(page)) {\n\t\t\ttail_index = pos & (PAGE_CACHE_SIZE - 1);\n\t\t\tcur_index = 0;\n\t\t\thead = page_buffers(page);\n\t\t\tbh = head;\n\t\t\tdo {\n\t\t\t\tnext = bh->b_this_page;\n\n\t\t\t\t/*\n\t\t\t\t * we want to unmap the buffers that contain\n\t\t\t\t * the tail, and all the buffers after it\n\t\t\t\t * (since the tail must be at the end of the\n\t\t\t\t * file).  We don't want to unmap file data\n\t\t\t\t * before the tail, since it might be dirty\n\t\t\t\t * and waiting to reach disk\n\t\t\t\t */\n\t\t\t\tcur_index += bh->b_size;\n\t\t\t\tif (cur_index > tail_index) {\n\t\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t\t}\n\t\t\t\tbh = next;\n\t\t\t} while (bh != head);\n\t\t}\n\t}\n}\n\nstatic int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct page *page,\n\t\t\t\t    struct treepath *path,\n\t\t\t\t    const struct cpu_key *item_key,\n\t\t\t\t    loff_t new_file_size, char *mode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint block_size = sb->s_blocksize;\n\tint cut_bytes;\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(new_file_size != inode->i_size);\n\n\t/*\n\t * the page being sent in could be NULL if there was an i/o error\n\t * reading in the last block.  The user will hit problems trying to\n\t * read the file, but for now we just skip the indirect2direct\n\t */\n\tif (atomic_read(&inode->i_count) > 1 ||\n\t    !tail_has_to_be_packed(inode) ||\n\t    !page || (REISERFS_I(inode)->i_flags & i_nopack_mask)) {\n\t\t/* leave tail in an unformatted node */\n\t\t*mode = M_SKIP_BALANCING;\n\t\tcut_bytes =\n\t\t    block_size - (new_file_size & (block_size - 1));\n\t\tpathrelse(path);\n\t\treturn cut_bytes;\n\t}\n\n\t/* Perform the conversion to a direct_item. */\n\treturn indirect2direct(th, inode, page, path, item_key,\n\t\t\t       new_file_size, mode);\n}\n\n/*\n * we did indirect_to_direct conversion. And we have inserted direct\n * item successesfully, but there were no disk space to cut unfm\n * pointer being converted. Therefore we have to delete inserted\n * direct item(s)\n */\nstatic void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,\n\t\t\t\t\t struct inode *inode, struct treepath *path)\n{\n\tstruct cpu_key tail_key;\n\tint tail_len;\n\tint removed;\n\tBUG_ON(!th->t_trans_id);\n\n\tmake_cpu_key(&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);\n\ttail_key.key_length = 4;\n\n\ttail_len =\n\t    (cpu_key_k_offset(&tail_key) & (inode->i_sb->s_blocksize - 1)) - 1;\n\twhile (tail_len) {\n\t\t/* look for the last byte of the tail */\n\t\tif (search_for_position_by_key(inode->i_sb, &tail_key, path) ==\n\t\t    POSITION_NOT_FOUND)\n\t\t\treiserfs_panic(inode->i_sb, \"vs-5615\",\n\t\t\t\t       \"found invalid item\");\n\t\tRFALSE(path->pos_in_item !=\n\t\t       ih_item_len(tp_item_head(path)) - 1,\n\t\t       \"vs-5616: appended bytes found\");\n\t\tPATH_LAST_POSITION(path)--;\n\n\t\tremoved =\n\t\t    reiserfs_delete_item(th, path, &tail_key, inode,\n\t\t\t\t\t NULL /*unbh not needed */ );\n\t\tRFALSE(removed <= 0\n\t\t       || removed > tail_len,\n\t\t       \"vs-5617: there was tail %d bytes, removed item length %d bytes\",\n\t\t       tail_len, removed);\n\t\ttail_len -= removed;\n\t\tset_cpu_key_k_offset(&tail_key,\n\t\t\t\t     cpu_key_k_offset(&tail_key) - removed);\n\t}\n\treiserfs_warning(inode->i_sb, \"reiserfs-5091\", \"indirect_to_direct \"\n\t\t\t \"conversion has been rolled back due to \"\n\t\t\t \"lack of disk space\");\n\tmark_inode_dirty(inode);\n}\n\n/* (Truncate or cut entry) or delete object item. Returns < 0 on failure */\nint reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,\n\t\t\t   struct treepath *path,\n\t\t\t   struct cpu_key *item_key,\n\t\t\t   struct inode *inode,\n\t\t\t   struct page *page, loff_t new_file_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\t/*\n\t * Every function which is going to call do_balance must first\n\t * create a tree_balance structure.  Then it must fill up this\n\t * structure by using the init_tb_struct and fix_nodes functions.\n\t * After that we can make tree balancing.\n\t */\n\tstruct tree_balance s_cut_balance;\n\tstruct item_head *p_le_ih;\n\tint cut_size = 0;\t/* Amount to be cut. */\n\tint ret_value = CARRY_ON;\n\tint removed = 0;\t/* Number of the removed unformatted nodes. */\n\tint is_inode_locked = 0;\n\tchar mode;\t\t/* Mode of the balance. */\n\tint retval2 = -1;\n\tint quota_cut_bytes;\n\tloff_t tail_pos = 0;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tinit_tb_struct(th, &s_cut_balance, inode->i_sb, path,\n\t\t       cut_size);\n\n\t/*\n\t * Repeat this loop until we either cut the item without needing\n\t * to balance, or we fix_nodes without schedule occurring\n\t */\n\twhile (1) {\n\t\t/*\n\t\t * Determine the balance mode, position of the first byte to\n\t\t * be cut, and size to be cut.  In case of the indirect item\n\t\t * free unformatted nodes which are pointed to by the cut\n\t\t * pointers.\n\t\t */\n\n\t\tmode =\n\t\t    prepare_for_delete_or_cut(th, inode, path,\n\t\t\t\t\t      item_key, &removed,\n\t\t\t\t\t      &cut_size, new_file_size);\n\t\tif (mode == M_CONVERT) {\n\t\t\t/*\n\t\t\t * convert last unformatted node to direct item or\n\t\t\t * leave tail in the unformatted node\n\t\t\t */\n\t\t\tRFALSE(ret_value != CARRY_ON,\n\t\t\t       \"PAP-5570: can not convert twice\");\n\n\t\t\tret_value =\n\t\t\t    maybe_indirect_to_direct(th, inode, page,\n\t\t\t\t\t\t     path, item_key,\n\t\t\t\t\t\t     new_file_size, &mode);\n\t\t\tif (mode == M_SKIP_BALANCING)\n\t\t\t\t/* tail has been left in the unformatted node */\n\t\t\t\treturn ret_value;\n\n\t\t\tis_inode_locked = 1;\n\n\t\t\t/*\n\t\t\t * removing of last unformatted node will\n\t\t\t * change value we have to return to truncate.\n\t\t\t * Save it\n\t\t\t */\n\t\t\tretval2 = ret_value;\n\n\t\t\t/*\n\t\t\t * So, we have performed the first part of the\n\t\t\t * conversion:\n\t\t\t * inserting the new direct item.  Now we are\n\t\t\t * removing the last unformatted node pointer.\n\t\t\t * Set key to search for it.\n\t\t\t */\n\t\t\tset_cpu_key_k_type(item_key, TYPE_INDIRECT);\n\t\t\titem_key->key_length = 4;\n\t\t\tnew_file_size -=\n\t\t\t    (new_file_size & (sb->s_blocksize - 1));\n\t\t\ttail_pos = new_file_size;\n\t\t\tset_cpu_key_k_offset(item_key, new_file_size + 1);\n\t\t\tif (search_for_position_by_key\n\t\t\t    (sb, item_key,\n\t\t\t     path) == POSITION_NOT_FOUND) {\n\t\t\t\tprint_block(PATH_PLAST_BUFFER(path), 3,\n\t\t\t\t\t    PATH_LAST_POSITION(path) - 1,\n\t\t\t\t\t    PATH_LAST_POSITION(path) + 1);\n\t\t\t\treiserfs_panic(sb, \"PAP-5580\", \"item to \"\n\t\t\t\t\t       \"convert does not exist (%K)\",\n\t\t\t\t\t       item_key);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (cut_size == 0) {\n\t\t\tpathrelse(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\ts_cut_balance.insert_size[0] = cut_size;\n\n\t\tret_value = fix_nodes(mode, &s_cut_balance, NULL, NULL);\n\t\tif (ret_value != REPEAT_SEARCH)\n\t\t\tbreak;\n\n\t\tPROC_INFO_INC(sb, cut_from_item_restarted);\n\n\t\tret_value =\n\t\t    search_for_position_by_key(sb, item_key, path);\n\t\tif (ret_value == POSITION_FOUND)\n\t\t\tcontinue;\n\n\t\treiserfs_warning(sb, \"PAP-5610\", \"item %K not found\",\n\t\t\t\t item_key);\n\t\tunfix_nodes(&s_cut_balance);\n\t\treturn (ret_value == IO_ERROR) ? -EIO : -ENOENT;\n\t}\t\t\t/* while */\n\n\t/* check fix_nodes results (IO_ERROR or NO_DISK_SPACE) */\n\tif (ret_value != CARRY_ON) {\n\t\tif (is_inode_locked) {\n\t\t\t/*\n\t\t\t * FIXME: this seems to be not needed: we are always\n\t\t\t * able to cut item\n\t\t\t */\n\t\t\tindirect_to_direct_roll_back(th, inode, path);\n\t\t}\n\t\tif (ret_value == NO_DISK_SPACE)\n\t\t\treiserfs_warning(sb, \"reiserfs-5092\",\n\t\t\t\t\t \"NO_DISK_SPACE\");\n\t\tunfix_nodes(&s_cut_balance);\n\t\treturn -EIO;\n\t}\n\n\t/* go ahead and perform balancing */\n\n\tRFALSE(mode == M_PASTE || mode == M_INSERT, \"invalid mode\");\n\n\t/* Calculate number of bytes that need to be cut from the item. */\n\tquota_cut_bytes =\n\t    (mode ==\n\t     M_DELETE) ? ih_item_len(tp_item_head(path)) : -s_cut_balance.\n\t    insert_size[0];\n\tif (retval2 == -1)\n\t\tret_value = calc_deleted_bytes_number(&s_cut_balance, mode);\n\telse\n\t\tret_value = retval2;\n\n\t/*\n\t * For direct items, we only change the quota when deleting the last\n\t * item.\n\t */\n\tp_le_ih = tp_item_head(s_cut_balance.tb_path);\n\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_le_ih)) {\n\t\tif (mode == M_DELETE &&\n\t\t    (le_ih_k_offset(p_le_ih) & (sb->s_blocksize - 1)) ==\n\t\t    1) {\n\t\t\t/* FIXME: this is to keep 3.5 happy */\n\t\t\tREISERFS_I(inode)->i_first_direct_byte = U32_MAX;\n\t\t\tquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\n\t\t} else {\n\t\t\tquota_cut_bytes = 0;\n\t\t}\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\tif (is_inode_locked) {\n\t\tstruct item_head *le_ih =\n\t\t    tp_item_head(s_cut_balance.tb_path);\n\t\t/*\n\t\t * we are going to complete indirect2direct conversion. Make\n\t\t * sure, that we exactly remove last unformatted node pointer\n\t\t * of the item\n\t\t */\n\t\tif (!is_indirect_le_ih(le_ih))\n\t\t\treiserfs_panic(sb, \"vs-5652\",\n\t\t\t\t       \"item must be indirect %h\", le_ih);\n\n\t\tif (mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)\n\t\t\treiserfs_panic(sb, \"vs-5653\", \"completing \"\n\t\t\t\t       \"indirect2direct conversion indirect \"\n\t\t\t\t       \"item %h being deleted must be of \"\n\t\t\t\t       \"4 byte long\", le_ih);\n\n\t\tif (mode == M_CUT\n\t\t    && s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {\n\t\t\treiserfs_panic(sb, \"vs-5654\", \"can not complete \"\n\t\t\t\t       \"indirect2direct conversion of %h \"\n\t\t\t\t       \"(CUT, insert_size==%d)\",\n\t\t\t\t       le_ih, s_cut_balance.insert_size[0]);\n\t\t}\n\t\t/*\n\t\t * it would be useful to make sure, that right neighboring\n\t\t * item is direct item of this file\n\t\t */\n\t}\n#endif\n\n\tdo_balance(&s_cut_balance, NULL, NULL, mode);\n\tif (is_inode_locked) {\n\t\t/*\n\t\t * we've done an indirect->direct conversion.  when the\n\t\t * data block was freed, it was removed from the list of\n\t\t * blocks that must be flushed before the transaction\n\t\t * commits, make sure to unmap and invalidate it\n\t\t */\n\t\tunmap_buffers(page, tail_pos);\n\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\t}\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota cut_from_item(): freeing %u id=%u type=%c\",\n\t\t       quota_cut_bytes, inode->i_uid, '?');\n#endif\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tdquot_free_space_nodirty(inode, quota_cut_bytes);\n\treiserfs_write_lock_nested(sb, depth);\n\treturn ret_value;\n}\n\nstatic void truncate_directory(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode)\n{\n\tBUG_ON(!th->t_trans_id);\n\tif (inode->i_nlink)\n\t\treiserfs_error(inode->i_sb, \"vs-5655\", \"link count != 0\");\n\n\tset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), DOT_OFFSET);\n\tset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_DIRENTRY);\n\treiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\n\treiserfs_update_sd(th, inode);\n\tset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), SD_OFFSET);\n\tset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_STAT_DATA);\n}\n\n/*\n * Truncate file to the new size. Note, this must be called with a\n * transaction already started\n */\nint reiserfs_do_truncate(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode,\t/* ->i_size contains new size */\n\t\t\t struct page *page,\t/* up to date for last block */\n\t\t\t /*\n\t\t\t  * when it is called by file_release to convert\n\t\t\t  * the tail - no timestamps should be updated\n\t\t\t  */\n\t\t\t int update_timestamps\n    )\n{\n\tINITIALIZE_PATH(s_search_path);\t/* Path to the current object item. */\n\tstruct item_head *p_le_ih;\t/* Pointer to an item header. */\n\n\t/* Key to search for a previous file item. */\n\tstruct cpu_key s_item_key;\n\tloff_t file_size,\t/* Old file size. */\n\t new_file_size;\t/* New file size. */\n\tint deleted;\t\t/* Number of deleted or truncated bytes. */\n\tint retval;\n\tint err = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\tif (!\n\t    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)\n\t     || S_ISLNK(inode->i_mode)))\n\t\treturn 0;\n\n\t/* deletion of directory - no need to update timestamps */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\ttruncate_directory(th, inode);\n\t\treturn 0;\n\t}\n\n\t/* Get new file size. */\n\tnew_file_size = inode->i_size;\n\n\t/* FIXME: note, that key type is unimportant here */\n\tmake_cpu_key(&s_item_key, inode, max_reiserfs_offset(inode),\n\t\t     TYPE_DIRECT, 3);\n\n\tretval =\n\t    search_for_position_by_key(inode->i_sb, &s_item_key,\n\t\t\t\t       &s_search_path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(inode->i_sb, \"vs-5657\",\n\t\t\t       \"i/o failure occurred trying to truncate %K\",\n\t\t\t       &s_item_key);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\tif (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {\n\t\treiserfs_error(inode->i_sb, \"PAP-5660\",\n\t\t\t       \"wrong result %d of search for %K\", retval,\n\t\t\t       &s_item_key);\n\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\ts_search_path.pos_in_item--;\n\n\t/* Get real file size (total length of all file items) */\n\tp_le_ih = tp_item_head(&s_search_path);\n\tif (is_statdata_le_ih(p_le_ih))\n\t\tfile_size = 0;\n\telse {\n\t\tloff_t offset = le_ih_k_offset(p_le_ih);\n\t\tint bytes =\n\t\t    op_bytes_number(p_le_ih, inode->i_sb->s_blocksize);\n\n\t\t/*\n\t\t * this may mismatch with real file size: if last direct item\n\t\t * had no padding zeros and last unformatted node had no free\n\t\t * space, this file would have this file size\n\t\t */\n\t\tfile_size = offset + bytes - 1;\n\t}\n\t/*\n\t * are we doing a full truncate or delete, if so\n\t * kick in the reada code\n\t */\n\tif (new_file_size == 0)\n\t\ts_search_path.reada = PATH_READA | PATH_READA_BACK;\n\n\tif (file_size == 0 || file_size < new_file_size) {\n\t\tgoto update_and_out;\n\t}\n\n\t/* Update key to search for the last file item. */\n\tset_cpu_key_k_offset(&s_item_key, file_size);\n\n\tdo {\n\t\t/* Cut or delete file item. */\n\t\tdeleted =\n\t\t    reiserfs_cut_from_item(th, &s_search_path, &s_item_key,\n\t\t\t\t\t   inode, page, new_file_size);\n\t\tif (deleted < 0) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-5665\",\n\t\t\t\t\t \"reiserfs_cut_from_item failed\");\n\t\t\treiserfs_check_path(&s_search_path);\n\t\t\treturn 0;\n\t\t}\n\n\t\tRFALSE(deleted > file_size,\n\t\t       \"PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K\",\n\t\t       deleted, file_size, &s_item_key);\n\n\t\t/* Change key to search the last file item. */\n\t\tfile_size -= deleted;\n\n\t\tset_cpu_key_k_offset(&s_item_key, file_size);\n\n\t\t/*\n\t\t * While there are bytes to truncate and previous\n\t\t * file item is presented in the tree.\n\t\t */\n\n\t\t/*\n\t\t * This loop could take a really long time, and could log\n\t\t * many more blocks than a transaction can hold.  So, we do\n\t\t * a polite journal end here, and if the transaction needs\n\t\t * ending, we make sure the file is consistent before ending\n\t\t * the current trans and starting a new one\n\t\t */\n\t\tif (journal_transaction_should_end(th, 0) ||\n\t\t    reiserfs_transaction_free_space(th) <= JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {\n\t\t\tpathrelse(&s_search_path);\n\n\t\t\tif (update_timestamps) {\n\t\t\t\tinode->i_mtime = CURRENT_TIME_SEC;\n\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\t}\n\t\t\treiserfs_update_sd(th, inode);\n\n\t\t\terr = journal_end(th);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = journal_begin(th, inode->i_sb,\n\t\t\t\t\t    JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD + JOURNAL_PER_BALANCE_CNT * 4) ;\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\treiserfs_update_inode_transaction(inode);\n\t\t}\n\t} while (file_size > ROUND_UP(new_file_size) &&\n\t\t search_for_position_by_key(inode->i_sb, &s_item_key,\n\t\t\t\t\t    &s_search_path) == POSITION_FOUND);\n\n\tRFALSE(file_size > ROUND_UP(new_file_size),\n\t       \"PAP-5680: truncate did not finish: new_file_size %lld, current %lld, oid %d\",\n\t       new_file_size, file_size, s_item_key.on_disk_key.k_objectid);\n\nupdate_and_out:\n\tif (update_timestamps) {\n\t\t/* this is truncate, not file closing */\n\t\tinode->i_mtime = CURRENT_TIME_SEC;\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t}\n\treiserfs_update_sd(th, inode);\n\nout:\n\tpathrelse(&s_search_path);\n\treturn err;\n}\n\n#ifdef CONFIG_REISERFS_CHECK\n/* this makes sure, that we __append__, not overwrite or add holes */\nstatic void check_research_for_paste(struct treepath *path,\n\t\t\t\t     const struct cpu_key *key)\n{\n\tstruct item_head *found_ih = tp_item_head(path);\n\n\tif (is_direct_le_ih(found_ih)) {\n\t\tif (le_ih_k_offset(found_ih) +\n\t\t    op_bytes_number(found_ih,\n\t\t\t\t    get_last_bh(path)->b_size) !=\n\t\t    cpu_key_k_offset(key)\n\t\t    || op_bytes_number(found_ih,\n\t\t\t\t       get_last_bh(path)->b_size) !=\n\t\t    pos_in_item(path))\n\t\t\treiserfs_panic(NULL, \"PAP-5720\", \"found direct item \"\n\t\t\t\t       \"%h or position (%d) does not match \"\n\t\t\t\t       \"to key %K\", found_ih,\n\t\t\t\t       pos_in_item(path), key);\n\t}\n\tif (is_indirect_le_ih(found_ih)) {\n\t\tif (le_ih_k_offset(found_ih) +\n\t\t    op_bytes_number(found_ih,\n\t\t\t\t    get_last_bh(path)->b_size) !=\n\t\t    cpu_key_k_offset(key)\n\t\t    || I_UNFM_NUM(found_ih) != pos_in_item(path)\n\t\t    || get_ih_free_space(found_ih) != 0)\n\t\t\treiserfs_panic(NULL, \"PAP-5730\", \"found indirect \"\n\t\t\t\t       \"item (%h) or position (%d) does not \"\n\t\t\t\t       \"match to key (%K)\",\n\t\t\t\t       found_ih, pos_in_item(path), key);\n\t}\n}\n#endif\t\t\t\t/* config reiserfs check */\n\n/*\n * Paste bytes to the existing item.\n * Returns bytes number pasted into the item.\n */\nint reiserfs_paste_into_item(struct reiserfs_transaction_handle *th,\n\t\t\t     /* Path to the pasted item. */\n\t\t\t     struct treepath *search_path,\n\t\t\t     /* Key to search for the needed item. */\n\t\t\t     const struct cpu_key *key,\n\t\t\t     /* Inode item belongs to */\n\t\t\t     struct inode *inode,\n\t\t\t     /* Pointer to the bytes to paste. */\n\t\t\t     const char *body,\n\t\t\t     /* Size of pasted bytes. */\n\t\t\t     int pasted_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct tree_balance s_paste_balance;\n\tint retval;\n\tint fs_gen;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tfs_gen = get_generation(inode->i_sb);\n\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota paste_into_item(): allocating %u id=%u type=%c\",\n\t\t       pasted_size, inode->i_uid,\n\t\t       key2type(&key->on_disk_key));\n#endif\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tretval = dquot_alloc_space_nodirty(inode, pasted_size);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (retval) {\n\t\tpathrelse(search_path);\n\t\treturn retval;\n\t}\n\tinit_tb_struct(th, &s_paste_balance, th->t_super, search_path,\n\t\t       pasted_size);\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\ts_paste_balance.key = key->on_disk_key;\n#endif\n\n\t/* DQUOT_* can schedule, must check before the fix_nodes */\n\tif (fs_changed(fs_gen, inode->i_sb)) {\n\t\tgoto search_again;\n\t}\n\n\twhile ((retval =\n\t\tfix_nodes(M_PASTE, &s_paste_balance, NULL,\n\t\t\t  body)) == REPEAT_SEARCH) {\nsearch_again:\n\t\t/* file system changed while we were in the fix_nodes */\n\t\tPROC_INFO_INC(th->t_super, paste_into_item_restarted);\n\t\tretval =\n\t\t    search_for_position_by_key(th->t_super, key,\n\t\t\t\t\t       search_path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"PAP-5710\",\n\t\t\t\t\t \"entry or pasted byte (%K) exists\",\n\t\t\t\t\t key);\n\t\t\tretval = -EEXIST;\n\t\t\tgoto error_out;\n\t\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t\tcheck_research_for_paste(search_path, key);\n#endif\n\t}\n\n\t/*\n\t * Perform balancing after all resources are collected by fix_nodes,\n\t * and accessing them will not risk triggering schedule.\n\t */\n\tif (retval == CARRY_ON) {\n\t\tdo_balance(&s_paste_balance, NULL /*ih */ , body, M_PASTE);\n\t\treturn 0;\n\t}\n\tretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\nerror_out:\n\t/* this also releases the path */\n\tunfix_nodes(&s_paste_balance);\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota paste_into_item(): freeing %u id=%u type=%c\",\n\t\t       pasted_size, inode->i_uid,\n\t\t       key2type(&key->on_disk_key));\n#endif\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tdquot_free_space_nodirty(inode, pasted_size);\n\treiserfs_write_lock_nested(sb, depth);\n\treturn retval;\n}\n\n/*\n * Insert new item into the buffer at the path.\n * th   - active transaction handle\n * path - path to the inserted item\n * ih   - pointer to the item header to insert\n * body - pointer to the bytes to insert\n */\nint reiserfs_insert_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path, const struct cpu_key *key,\n\t\t\t struct item_head *ih, struct inode *inode,\n\t\t\t const char *body)\n{\n\tstruct tree_balance s_ins_balance;\n\tint retval;\n\tint fs_gen = 0;\n\tint quota_bytes = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tif (inode) {\t\t/* Do we count quotas for item? */\n\t\tint depth;\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\tquota_bytes = ih_item_len(ih);\n\n\t\t/*\n\t\t * hack so the quota code doesn't have to guess\n\t\t * if the file has a tail, links are always tails,\n\t\t * so there's no guessing needed\n\t\t */\n\t\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(ih))\n\t\t\tquota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE;\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota insert_item(): allocating %u id=%u type=%c\",\n\t\t\t       quota_bytes, inode->i_uid, head2type(ih));\n#endif\n\t\t/*\n\t\t * We can't dirty inode here. It would be immediately\n\t\t * written but appropriate stat item isn't inserted yet...\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tretval = dquot_alloc_space_nodirty(inode, quota_bytes);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\tif (retval) {\n\t\t\tpathrelse(path);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tinit_tb_struct(th, &s_ins_balance, th->t_super, path,\n\t\t       IH_SIZE + ih_item_len(ih));\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\ts_ins_balance.key = key->on_disk_key;\n#endif\n\t/*\n\t * DQUOT_* can schedule, must check to be sure calling\n\t * fix_nodes is safe\n\t */\n\tif (inode && fs_changed(fs_gen, inode->i_sb)) {\n\t\tgoto search_again;\n\t}\n\n\twhile ((retval =\n\t\tfix_nodes(M_INSERT, &s_ins_balance, ih,\n\t\t\t  body)) == REPEAT_SEARCH) {\nsearch_again:\n\t\t/* file system changed while we were in the fix_nodes */\n\t\tPROC_INFO_INC(th->t_super, insert_item_restarted);\n\t\tretval = search_item(th->t_super, key, path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tif (retval == ITEM_FOUND) {\n\t\t\treiserfs_warning(th->t_super, \"PAP-5760\",\n\t\t\t\t\t \"key %K already exists in the tree\",\n\t\t\t\t\t key);\n\t\t\tretval = -EEXIST;\n\t\t\tgoto error_out;\n\t\t}\n\t}\n\n\t/* make balancing after all resources will be collected at a time */\n\tif (retval == CARRY_ON) {\n\t\tdo_balance(&s_ins_balance, ih, body, M_INSERT);\n\t\treturn 0;\n\t}\n\n\tretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\nerror_out:\n\t/* also releases the path */\n\tunfix_nodes(&s_ins_balance);\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota insert_item(): freeing %u id=%u type=%c\",\n\t\t       quota_bytes, inode->i_uid, head2type(ih));\n#endif\n\tif (inode) {\n\t\tint depth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tdquot_free_space_nodirty(inode, quota_bytes);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD (2 * JOURNAL_PER_BALANCE_CNT + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "inode->i_sb",
            "depth"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "inode",
            "quota_bytes"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "inode->i_sb"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_debug",
          "args": [
            "th->t_super",
            "REISERFS_DEBUG_CODE",
            "\"reiserquota insert_item(): freeing %u id=%u type=%c\"",
            "quota_bytes",
            "inode->i_uid",
            "head2type(ih)"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "297-307",
          "snippet": "void reiserfs_debug(struct super_block *s, int level, const char *fmt, ...)\n{\n#ifdef CONFIG_REISERFS_CHECK\n\tdo_reiserfs_warning(fmt);\n\tif (s)\n\t\tprintk(KERN_DEBUG \"REISERFS debug (device %s): %s\\n\",\n\t\t       s->s_id, error_buf);\n\telse\n\t\tprintk(KERN_DEBUG \"REISERFS debug: %s\\n\", error_buf);\n#endif\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_debug(struct super_block *s, int level, const char *fmt, ...)\n{\n#ifdef CONFIG_REISERFS_CHECK\n\tdo_reiserfs_warning(fmt);\n\tif (s)\n\t\tprintk(KERN_DEBUG \"REISERFS debug (device %s): %s\\n\",\n\t\t       s->s_id, error_buf);\n\telse\n\t\tprintk(KERN_DEBUG \"REISERFS debug: %s\\n\", error_buf);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "head2type",
          "args": [
            "ih"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "head2type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "1211-1222",
          "snippet": "char head2type(struct item_head *ih)\n{\n\tif (is_direntry_le_ih(ih))\n\t\treturn 'd';\n\tif (is_direct_le_ih(ih))\n\t\treturn 'D';\n\tif (is_indirect_le_ih(ih))\n\t\treturn 'i';\n\tif (is_statdata_le_ih(ih))\n\t\treturn 's';\n\treturn 'u';\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nchar head2type(struct item_head *ih)\n{\n\tif (is_direntry_le_ih(ih))\n\t\treturn 'd';\n\tif (is_direct_le_ih(ih))\n\t\treturn 'D';\n\tif (is_indirect_le_ih(ih))\n\t\treturn 'i';\n\tif (is_statdata_le_ih(ih))\n\t\treturn 's';\n\treturn 'u';\n}"
        }
      },
      {
        "call_info": {
          "callee": "unfix_nodes",
          "args": [
            "&s_ins_balance"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "unfix_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "2781-2825",
          "snippet": "void unfix_nodes(struct tree_balance *tb)\n{\n\tint i;\n\n\t/* Release path buffers. */\n\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\n\t/* brelse all resources collected for balancing */\n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->L[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->R[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FR[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFR[i]);\n\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\t}\n\n\t/* deal with list of allocated (used and unused) nodes */\n\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\tif (tb->FEB[i]) {\n\t\t\tb_blocknr_t blocknr = tb->FEB[i]->b_blocknr;\n\t\t\t/*\n\t\t\t * de-allocated block which was not used by\n\t\t\t * balancing and bforget about buffer for it\n\t\t\t */\n\t\t\tbrelse(tb->FEB[i]);\n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t\tif (tb->used[i]) {\n\t\t\t/* release used as new nodes including a new root */\n\t\t\tbrelse(tb->used[i]);\n\t\t}\n\t}\n\n\tkfree(tb->vn_buf);\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nvoid unfix_nodes(struct tree_balance *tb)\n{\n\tint i;\n\n\t/* Release path buffers. */\n\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\n\t/* brelse all resources collected for balancing */\n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->L[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->R[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FR[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFR[i]);\n\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\t}\n\n\t/* deal with list of allocated (used and unused) nodes */\n\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\tif (tb->FEB[i]) {\n\t\t\tb_blocknr_t blocknr = tb->FEB[i]->b_blocknr;\n\t\t\t/*\n\t\t\t * de-allocated block which was not used by\n\t\t\t * balancing and bforget about buffer for it\n\t\t\t */\n\t\t\tbrelse(tb->FEB[i]);\n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t\tif (tb->used[i]) {\n\t\t\t/* release used as new nodes including a new root */\n\t\t\tbrelse(tb->used[i]);\n\t\t}\n\t}\n\n\tkfree(tb->vn_buf);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_balance",
          "args": [
            "&s_ins_balance",
            "ih",
            "body",
            "M_INSERT"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "do_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1858-1911",
          "snippet": "void do_balance(struct tree_balance *tb, struct item_head *ih,\n\t\tconst char *body, int flag)\n{\n\tint child_pos;\t\t/* position of a child node in its parent */\n\tint h;\t\t\t/* level of the tree being processed */\n\n\t/*\n\t * in our processing of one level we sometimes determine what\n\t * must be inserted into the next higher level.  This insertion\n\t * consists of a key or two keys and their corresponding\n\t * pointers\n\t */\n\tstruct item_head insert_key[2];\n\n\t/* inserted node-ptrs for the next level */\n\tstruct buffer_head *insert_ptr[2];\n\n\ttb->tb_mode = flag;\n\ttb->need_balance_dirty = 0;\n\n\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\treiserfs_panic(tb->tb_sb, \"clm-6000\", \"fs generation has \"\n\t\t\t       \"changed\");\n\t}\n\t/* if we have no real work to do  */\n\tif (!tb->insert_size[0]) {\n\t\treiserfs_warning(tb->tb_sb, \"PAP-12350\",\n\t\t\t\t \"insert_size == 0, mode == %c\", flag);\n\t\tunfix_nodes(tb);\n\t\treturn;\n\t}\n\n\tatomic_inc(&fs_generation(tb->tb_sb));\n\tdo_balance_starts(tb);\n\n\t/*\n\t * balance_leaf returns 0 except if combining L R and S into\n\t * one node.  see balance_internal() for explanation of this\n\t * line of code.\n\t */\n\tchild_pos = PATH_H_B_ITEM_ORDER(tb->tb_path, 0) +\n\t    balance_leaf(tb, ih, body, flag, insert_key, insert_ptr);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tcheck_after_balance_leaf(tb);\n#endif\n\n\t/* Balance internal level of the tree. */\n\tfor (h = 1; h < MAX_HEIGHT && tb->insert_size[h]; h++)\n\t\tchild_pos = balance_internal(tb, h, child_pos, insert_key,\n\t\t\t\t\t     insert_ptr);\n\n\tdo_balance_completed(tb);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nvoid do_balance(struct tree_balance *tb, struct item_head *ih,\n\t\tconst char *body, int flag)\n{\n\tint child_pos;\t\t/* position of a child node in its parent */\n\tint h;\t\t\t/* level of the tree being processed */\n\n\t/*\n\t * in our processing of one level we sometimes determine what\n\t * must be inserted into the next higher level.  This insertion\n\t * consists of a key or two keys and their corresponding\n\t * pointers\n\t */\n\tstruct item_head insert_key[2];\n\n\t/* inserted node-ptrs for the next level */\n\tstruct buffer_head *insert_ptr[2];\n\n\ttb->tb_mode = flag;\n\ttb->need_balance_dirty = 0;\n\n\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\treiserfs_panic(tb->tb_sb, \"clm-6000\", \"fs generation has \"\n\t\t\t       \"changed\");\n\t}\n\t/* if we have no real work to do  */\n\tif (!tb->insert_size[0]) {\n\t\treiserfs_warning(tb->tb_sb, \"PAP-12350\",\n\t\t\t\t \"insert_size == 0, mode == %c\", flag);\n\t\tunfix_nodes(tb);\n\t\treturn;\n\t}\n\n\tatomic_inc(&fs_generation(tb->tb_sb));\n\tdo_balance_starts(tb);\n\n\t/*\n\t * balance_leaf returns 0 except if combining L R and S into\n\t * one node.  see balance_internal() for explanation of this\n\t * line of code.\n\t */\n\tchild_pos = PATH_H_B_ITEM_ORDER(tb->tb_path, 0) +\n\t    balance_leaf(tb, ih, body, flag, insert_key, insert_ptr);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tcheck_after_balance_leaf(tb);\n#endif\n\n\t/* Balance internal level of the tree. */\n\tfor (h = 1; h < MAX_HEIGHT && tb->insert_size[h]; h++)\n\t\tchild_pos = balance_internal(tb, h, child_pos, insert_key,\n\t\t\t\t\t     insert_ptr);\n\n\tdo_balance_completed(tb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "th->t_super",
            "\"PAP-5760\"",
            "\"key %K already exists in the tree\"",
            "key"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_item",
          "args": [
            "th->t_super",
            "key",
            "path"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "th->t_super",
            "insert_item_restarted"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fix_nodes",
          "args": [
            "M_INSERT",
            "&s_ins_balance",
            "ih",
            "body"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "fix_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "2549-2779",
          "snippet": "int fix_nodes(int op_mode, struct tree_balance *tb,\n\t      struct item_head *ins_ih, const void *data)\n{\n\tint ret, h, item_num = PATH_LAST_POSITION(tb->tb_path);\n\tint pos_in_item;\n\n\t/*\n\t * we set wait_tb_buffers_run when we have to restore any dirty\n\t * bits cleared during wait_tb_buffers_run\n\t */\n\tint wait_tb_buffers_run = 0;\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\n\t++REISERFS_SB(tb->tb_sb)->s_fix_nodes;\n\n\tpos_in_item = tb->tb_path->pos_in_item;\n\n\ttb->fs_gen = get_generation(tb->tb_sb);\n\n\t/*\n\t * we prepare and log the super here so it will already be in the\n\t * transaction when do_balance needs to change it.\n\t * This way do_balance won't have to schedule when trying to prepare\n\t * the super for logging\n\t */\n\treiserfs_prepare_for_journal(tb->tb_sb,\n\t\t\t\t     SB_BUFFER_WITH_SB(tb->tb_sb), 1);\n\tjournal_mark_dirty(tb->transaction_handle,\n\t\t\t   SB_BUFFER_WITH_SB(tb->tb_sb));\n\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\treturn REPEAT_SEARCH;\n\n\t/* if it possible in indirect_to_direct conversion */\n\tif (buffer_locked(tbS0)) {\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(tbS0);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\treturn REPEAT_SEARCH;\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\tif (REISERFS_SB(tb->tb_sb)->cur_tb) {\n\t\tprint_cur_tb(\"fix_nodes\");\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8305\",\n\t\t\t       \"there is pending do_balance\");\n\t}\n\n\tif (!buffer_uptodate(tbS0) || !B_IS_IN_TREE(tbS0))\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8320\", \"S[0] (%b %z) is \"\n\t\t\t       \"not uptodate at the beginning of fix_nodes \"\n\t\t\t       \"or not in tree (mode %c)\",\n\t\t\t       tbS0, tbS0, op_mode);\n\n\t/* Check parameters. */\n\tswitch (op_mode) {\n\tcase M_INSERT:\n\t\tif (item_num <= 0 || item_num > B_NR_ITEMS(tbS0))\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-8330\", \"Incorrect \"\n\t\t\t\t       \"item number %d (in S0 - %d) in case \"\n\t\t\t\t       \"of insert\", item_num,\n\t\t\t\t       B_NR_ITEMS(tbS0));\n\t\tbreak;\n\tcase M_PASTE:\n\tcase M_DELETE:\n\tcase M_CUT:\n\t\tif (item_num < 0 || item_num >= B_NR_ITEMS(tbS0)) {\n\t\t\tprint_block(tbS0, 0, -1, -1);\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-8335\", \"Incorrect \"\n\t\t\t\t       \"item number(%d); mode = %c \"\n\t\t\t\t       \"insert_size = %d\",\n\t\t\t\t       item_num, op_mode,\n\t\t\t\t       tb->insert_size[0]);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8340\", \"Incorrect mode \"\n\t\t\t       \"of operation\");\n\t}\n#endif\n\n\tif (get_mem_for_virtual_node(tb) == REPEAT_SEARCH)\n\t\t/* FIXME: maybe -ENOMEM when tb->vn_buf == 0? Now just repeat */\n\t\treturn REPEAT_SEARCH;\n\n\t/* Starting from the leaf level; for all levels h of the tree. */\n\tfor (h = 0; h < MAX_HEIGHT && tb->insert_size[h]; h++) {\n\t\tret = get_direct_parent(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\tret = check_balance(op_mode, tb, h, item_num,\n\t\t\t\t    pos_in_item, ins_ih, data);\n\t\tif (ret != CARRY_ON) {\n\t\t\tif (ret == NO_BALANCING_NEEDED) {\n\t\t\t\t/* No balancing for higher levels needed. */\n\t\t\t\tret = get_neighbors(tb, h);\n\t\t\t\tif (ret != CARRY_ON)\n\t\t\t\t\tgoto repeat;\n\t\t\t\tif (h != MAX_HEIGHT - 1)\n\t\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t\t\t/*\n\t\t\t\t * ok, analysis and resource gathering\n\t\t\t\t * are complete\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tret = get_neighbors(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\t/*\n\t\t * No disk space, or schedule occurred and analysis may be\n\t\t * invalid and needs to be redone.\n\t\t */\n\t\tret = get_empty_nodes(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\t/*\n\t\t * We have a positive insert size but no nodes exist on this\n\t\t * level, this means that we are creating a new root.\n\t\t */\n\t\tif (!PATH_H_PBUFFER(tb->tb_path, h)) {\n\n\t\t\tRFALSE(tb->blknum[h] != 1,\n\t\t\t       \"PAP-8350: creating new empty root\");\n\n\t\t\tif (h < MAX_HEIGHT - 1)\n\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t} else if (!PATH_H_PBUFFER(tb->tb_path, h + 1)) {\n\t\t\t/*\n\t\t\t * The tree needs to be grown, so this node S[h]\n\t\t\t * which is the root node is split into two nodes,\n\t\t\t * and a new node (S[h+1]) will be created to\n\t\t\t * become the root node.\n\t\t\t */\n\t\t\tif (tb->blknum[h] > 1) {\n\n\t\t\t\tRFALSE(h == MAX_HEIGHT - 1,\n\t\t\t\t       \"PAP-8355: attempt to create too high of a tree\");\n\n\t\t\t\ttb->insert_size[h + 1] =\n\t\t\t\t    (DC_SIZE +\n\t\t\t\t     KEY_SIZE) * (tb->blknum[h] - 1) +\n\t\t\t\t    DC_SIZE;\n\t\t\t} else if (h < MAX_HEIGHT - 1)\n\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t} else\n\t\t\ttb->insert_size[h + 1] =\n\t\t\t    (DC_SIZE + KEY_SIZE) * (tb->blknum[h] - 1);\n\t}\n\n\tret = wait_tb_buffers_until_unlocked(tb);\n\tif (ret == CARRY_ON) {\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\twait_tb_buffers_run = 1;\n\t\t\tret = REPEAT_SEARCH;\n\t\t\tgoto repeat;\n\t\t} else {\n\t\t\treturn CARRY_ON;\n\t\t}\n\t} else {\n\t\twait_tb_buffers_run = 1;\n\t\tgoto repeat;\n\t}\n\nrepeat:\n\t/*\n\t * fix_nodes was unable to perform its calculation due to\n\t * filesystem got changed under us, lack of free disk space or i/o\n\t * failure. If the first is the case - the search will be\n\t * repeated. For now - free all resources acquired so far except\n\t * for the new allocated nodes\n\t */\n\t{\n\t\tint i;\n\n\t\t/* Release path buffers. */\n\t\tif (wait_tb_buffers_run) {\n\t\t\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\t\t} else {\n\t\t\tpathrelse(tb->tb_path);\n\t\t}\n\t\t/* brelse all resources collected for balancing */\n\t\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\t\tif (wait_tb_buffers_run) {\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->L[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->R[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->FL[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->FR[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->\n\t\t\t\t\t\t\t\t CFL[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->\n\t\t\t\t\t\t\t\t CFR[i]);\n\t\t\t}\n\n\t\t\tbrelse(tb->L[i]);\n\t\t\tbrelse(tb->R[i]);\n\t\t\tbrelse(tb->FL[i]);\n\t\t\tbrelse(tb->FR[i]);\n\t\t\tbrelse(tb->CFL[i]);\n\t\t\tbrelse(tb->CFR[i]);\n\n\t\t\ttb->L[i] = NULL;\n\t\t\ttb->R[i] = NULL;\n\t\t\ttb->FL[i] = NULL;\n\t\t\ttb->FR[i] = NULL;\n\t\t\ttb->CFL[i] = NULL;\n\t\t\ttb->CFR[i] = NULL;\n\t\t}\n\n\t\tif (wait_tb_buffers_run) {\n\t\t\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\t\t\tif (tb->FEB[i])\n\t\t\t\t\treiserfs_restore_prepared_buffer\n\t\t\t\t\t    (tb->tb_sb, tb->FEB[i]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nint fix_nodes(int op_mode, struct tree_balance *tb,\n\t      struct item_head *ins_ih, const void *data)\n{\n\tint ret, h, item_num = PATH_LAST_POSITION(tb->tb_path);\n\tint pos_in_item;\n\n\t/*\n\t * we set wait_tb_buffers_run when we have to restore any dirty\n\t * bits cleared during wait_tb_buffers_run\n\t */\n\tint wait_tb_buffers_run = 0;\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\n\t++REISERFS_SB(tb->tb_sb)->s_fix_nodes;\n\n\tpos_in_item = tb->tb_path->pos_in_item;\n\n\ttb->fs_gen = get_generation(tb->tb_sb);\n\n\t/*\n\t * we prepare and log the super here so it will already be in the\n\t * transaction when do_balance needs to change it.\n\t * This way do_balance won't have to schedule when trying to prepare\n\t * the super for logging\n\t */\n\treiserfs_prepare_for_journal(tb->tb_sb,\n\t\t\t\t     SB_BUFFER_WITH_SB(tb->tb_sb), 1);\n\tjournal_mark_dirty(tb->transaction_handle,\n\t\t\t   SB_BUFFER_WITH_SB(tb->tb_sb));\n\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\treturn REPEAT_SEARCH;\n\n\t/* if it possible in indirect_to_direct conversion */\n\tif (buffer_locked(tbS0)) {\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(tbS0);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\treturn REPEAT_SEARCH;\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\tif (REISERFS_SB(tb->tb_sb)->cur_tb) {\n\t\tprint_cur_tb(\"fix_nodes\");\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8305\",\n\t\t\t       \"there is pending do_balance\");\n\t}\n\n\tif (!buffer_uptodate(tbS0) || !B_IS_IN_TREE(tbS0))\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8320\", \"S[0] (%b %z) is \"\n\t\t\t       \"not uptodate at the beginning of fix_nodes \"\n\t\t\t       \"or not in tree (mode %c)\",\n\t\t\t       tbS0, tbS0, op_mode);\n\n\t/* Check parameters. */\n\tswitch (op_mode) {\n\tcase M_INSERT:\n\t\tif (item_num <= 0 || item_num > B_NR_ITEMS(tbS0))\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-8330\", \"Incorrect \"\n\t\t\t\t       \"item number %d (in S0 - %d) in case \"\n\t\t\t\t       \"of insert\", item_num,\n\t\t\t\t       B_NR_ITEMS(tbS0));\n\t\tbreak;\n\tcase M_PASTE:\n\tcase M_DELETE:\n\tcase M_CUT:\n\t\tif (item_num < 0 || item_num >= B_NR_ITEMS(tbS0)) {\n\t\t\tprint_block(tbS0, 0, -1, -1);\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-8335\", \"Incorrect \"\n\t\t\t\t       \"item number(%d); mode = %c \"\n\t\t\t\t       \"insert_size = %d\",\n\t\t\t\t       item_num, op_mode,\n\t\t\t\t       tb->insert_size[0]);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8340\", \"Incorrect mode \"\n\t\t\t       \"of operation\");\n\t}\n#endif\n\n\tif (get_mem_for_virtual_node(tb) == REPEAT_SEARCH)\n\t\t/* FIXME: maybe -ENOMEM when tb->vn_buf == 0? Now just repeat */\n\t\treturn REPEAT_SEARCH;\n\n\t/* Starting from the leaf level; for all levels h of the tree. */\n\tfor (h = 0; h < MAX_HEIGHT && tb->insert_size[h]; h++) {\n\t\tret = get_direct_parent(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\tret = check_balance(op_mode, tb, h, item_num,\n\t\t\t\t    pos_in_item, ins_ih, data);\n\t\tif (ret != CARRY_ON) {\n\t\t\tif (ret == NO_BALANCING_NEEDED) {\n\t\t\t\t/* No balancing for higher levels needed. */\n\t\t\t\tret = get_neighbors(tb, h);\n\t\t\t\tif (ret != CARRY_ON)\n\t\t\t\t\tgoto repeat;\n\t\t\t\tif (h != MAX_HEIGHT - 1)\n\t\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t\t\t/*\n\t\t\t\t * ok, analysis and resource gathering\n\t\t\t\t * are complete\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tret = get_neighbors(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\t/*\n\t\t * No disk space, or schedule occurred and analysis may be\n\t\t * invalid and needs to be redone.\n\t\t */\n\t\tret = get_empty_nodes(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\t/*\n\t\t * We have a positive insert size but no nodes exist on this\n\t\t * level, this means that we are creating a new root.\n\t\t */\n\t\tif (!PATH_H_PBUFFER(tb->tb_path, h)) {\n\n\t\t\tRFALSE(tb->blknum[h] != 1,\n\t\t\t       \"PAP-8350: creating new empty root\");\n\n\t\t\tif (h < MAX_HEIGHT - 1)\n\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t} else if (!PATH_H_PBUFFER(tb->tb_path, h + 1)) {\n\t\t\t/*\n\t\t\t * The tree needs to be grown, so this node S[h]\n\t\t\t * which is the root node is split into two nodes,\n\t\t\t * and a new node (S[h+1]) will be created to\n\t\t\t * become the root node.\n\t\t\t */\n\t\t\tif (tb->blknum[h] > 1) {\n\n\t\t\t\tRFALSE(h == MAX_HEIGHT - 1,\n\t\t\t\t       \"PAP-8355: attempt to create too high of a tree\");\n\n\t\t\t\ttb->insert_size[h + 1] =\n\t\t\t\t    (DC_SIZE +\n\t\t\t\t     KEY_SIZE) * (tb->blknum[h] - 1) +\n\t\t\t\t    DC_SIZE;\n\t\t\t} else if (h < MAX_HEIGHT - 1)\n\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t} else\n\t\t\ttb->insert_size[h + 1] =\n\t\t\t    (DC_SIZE + KEY_SIZE) * (tb->blknum[h] - 1);\n\t}\n\n\tret = wait_tb_buffers_until_unlocked(tb);\n\tif (ret == CARRY_ON) {\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\twait_tb_buffers_run = 1;\n\t\t\tret = REPEAT_SEARCH;\n\t\t\tgoto repeat;\n\t\t} else {\n\t\t\treturn CARRY_ON;\n\t\t}\n\t} else {\n\t\twait_tb_buffers_run = 1;\n\t\tgoto repeat;\n\t}\n\nrepeat:\n\t/*\n\t * fix_nodes was unable to perform its calculation due to\n\t * filesystem got changed under us, lack of free disk space or i/o\n\t * failure. If the first is the case - the search will be\n\t * repeated. For now - free all resources acquired so far except\n\t * for the new allocated nodes\n\t */\n\t{\n\t\tint i;\n\n\t\t/* Release path buffers. */\n\t\tif (wait_tb_buffers_run) {\n\t\t\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\t\t} else {\n\t\t\tpathrelse(tb->tb_path);\n\t\t}\n\t\t/* brelse all resources collected for balancing */\n\t\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\t\tif (wait_tb_buffers_run) {\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->L[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->R[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->FL[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->FR[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->\n\t\t\t\t\t\t\t\t CFL[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->\n\t\t\t\t\t\t\t\t CFR[i]);\n\t\t\t}\n\n\t\t\tbrelse(tb->L[i]);\n\t\t\tbrelse(tb->R[i]);\n\t\t\tbrelse(tb->FL[i]);\n\t\t\tbrelse(tb->FR[i]);\n\t\t\tbrelse(tb->CFL[i]);\n\t\t\tbrelse(tb->CFR[i]);\n\n\t\t\ttb->L[i] = NULL;\n\t\t\ttb->R[i] = NULL;\n\t\t\ttb->FL[i] = NULL;\n\t\t\ttb->FR[i] = NULL;\n\t\t\ttb->CFL[i] = NULL;\n\t\t\ttb->CFR[i] = NULL;\n\t\t}\n\n\t\tif (wait_tb_buffers_run) {\n\t\t\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\t\t\tif (tb->FEB[i])\n\t\t\t\t\treiserfs_restore_prepared_buffer\n\t\t\t\t\t    (tb->tb_sb, tb->FEB[i]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_changed",
          "args": [
            "fs_gen",
            "inode->i_sb"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_tb_struct",
          "args": [
            "th",
            "&s_ins_balance",
            "th->t_super",
            "path",
            "IH_SIZE + ih_item_len(ih)"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "init_tb_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "1172-1187",
          "snippet": "static void init_tb_struct(struct reiserfs_transaction_handle *th,\n\t\t\t   struct tree_balance *tb,\n\t\t\t   struct super_block *sb,\n\t\t\t   struct treepath *path, int size)\n{\n\n\tBUG_ON(!th->t_trans_id);\n\n\tmemset(tb, '\\0', sizeof(struct tree_balance));\n\ttb->transaction_handle = th;\n\ttb->tb_sb = sb;\n\ttb->tb_path = path;\n\tPATH_OFFSET_PBUFFER(path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;\n\tPATH_OFFSET_POSITION(path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;\n\ttb->insert_size[0] = size;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic void init_tb_struct(struct reiserfs_transaction_handle *th,\n\t\t\t   struct tree_balance *tb,\n\t\t\t   struct super_block *sb,\n\t\t\t   struct treepath *path, int size)\n{\n\n\tBUG_ON(!th->t_trans_id);\n\n\tmemset(tb, '\\0', sizeof(struct tree_balance));\n\ttb->transaction_handle = th;\n\ttb->tb_sb = sb;\n\ttb->tb_path = path;\n\tPATH_OFFSET_PBUFFER(path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;\n\tPATH_OFFSET_POSITION(path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;\n\ttb->insert_size[0] = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "path"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_space_nodirty",
          "args": [
            "inode",
            "quota_bytes"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direct_le_ih",
          "args": [
            "ih"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "is_direct_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1567-1570",
          "snippet": "static inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_generation",
          "args": [
            "inode->i_sb"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "inode",
            "pasted_size"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key2type",
          "args": [
            "&key->on_disk_key"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "key2type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "1198-1209",
          "snippet": "char key2type(struct reiserfs_key *ih)\n{\n\tif (is_direntry_le_key(2, ih))\n\t\treturn 'd';\n\tif (is_direct_le_key(2, ih))\n\t\treturn 'D';\n\tif (is_indirect_le_key(2, ih))\n\t\treturn 'i';\n\tif (is_statdata_le_key(2, ih))\n\t\treturn 's';\n\treturn 'u';\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nchar key2type(struct reiserfs_key *ih)\n{\n\tif (is_direntry_le_key(2, ih))\n\t\treturn 'd';\n\tif (is_direct_le_key(2, ih))\n\t\treturn 'D';\n\tif (is_indirect_le_key(2, ih))\n\t\treturn 'i';\n\tif (is_statdata_le_key(2, ih))\n\t\treturn 's';\n\treturn 'u';\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_research_for_paste",
          "args": [
            "search_path",
            "key"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_for_position_by_key",
          "args": [
            "th->t_super",
            "key",
            "search_path"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "search_for_position_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "830-903",
          "snippet": "int search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "th->t_super",
            "paste_into_item_restarted"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_changed",
          "args": [
            "fs_gen",
            "inode->i_sb"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_space_nodirty",
          "args": [
            "inode",
            "pasted_size"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_generation",
          "args": [
            "inode->i_sb"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "NULL",
            "\"PAP-5730\"",
            "\"found indirect \"\n\t\t\t\t       \"item (%h) or position (%d) does not \"\n\t\t\t\t       \"match to key (%K)\"",
            "found_ih",
            "pos_in_item(path)",
            "key"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "path"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ih_free_space",
          "args": [
            "found_ih"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "path"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_UNFM_NUM",
          "args": [
            "found_ih"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_key_k_offset",
          "args": [
            "key"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_key_k_offset_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1603-1606",
          "snippet": "static inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "op_bytes_number",
          "args": [
            "found_ih",
            "get_last_bh(path)->b_size"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_last_bh",
          "args": [
            "path"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "found_ih"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "found_ih"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "path"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "path"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_bytes_number",
          "args": [
            "found_ih",
            "get_last_bh(path)->b_size"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_last_bh",
          "args": [
            "path"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_bytes_number",
          "args": [
            "found_ih",
            "get_last_bh(path)->b_size"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_last_bh",
          "args": [
            "path"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "path"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "th",
            "inode"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "file_size > ROUND_UP(new_file_size)",
            "\"PAP-5680: truncate did not finish: new_file_size %lld, current %lld, oid %d\"",
            "new_file_size",
            "file_size",
            "s_item_key.on_disk_key.k_objectid"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND_UP",
          "args": [
            "new_file_size"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND_UP",
          "args": [
            "new_file_size"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "inode"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "th",
            "inode->i_sb",
            "JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD + JOURNAL_PER_BALANCE_CNT * 4"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "th"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_transaction_free_space",
          "args": [
            "th"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_transaction_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2906-2909",
          "snippet": "static inline int reiserfs_transaction_free_space(struct reiserfs_transaction_handle *th)\n{\n\treturn th->t_blocks_allocated - th->t_blocks_logged;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\n\nstatic inline int reiserfs_transaction_free_space(struct reiserfs_transaction_handle *th)\n{\n\treturn th->t_blocks_allocated - th->t_blocks_logged;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_transaction_should_end",
          "args": [
            "th",
            "0"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "journal_transaction_should_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2911-2931",
          "snippet": "int journal_transaction_should_end(struct reiserfs_transaction_handle *th,\n\t\t\t\t   int new_alloc)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\n\ttime_t now = get_seconds();\n\t/* cannot restart while nested */\n\tBUG_ON(!th->t_trans_id);\n\tif (th->t_refcount > 1)\n\t\treturn 0;\n\tif (journal->j_must_wait > 0 ||\n\t    (journal->j_len_alloc + new_alloc) >= journal->j_max_batch ||\n\t    atomic_read(&journal->j_jlock) ||\n\t    (now - journal->j_trans_start_time) > journal->j_max_trans_age ||\n\t    journal->j_cnode_free < (journal->j_trans_max * 3)) {\n\t\treturn 1;\n\t}\n\n\tjournal->j_len_alloc += new_alloc;\n\tth->t_blocks_allocated += new_alloc ;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_transaction_should_end(struct reiserfs_transaction_handle *th,\n\t\t\t\t   int new_alloc)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\n\ttime_t now = get_seconds();\n\t/* cannot restart while nested */\n\tBUG_ON(!th->t_trans_id);\n\tif (th->t_refcount > 1)\n\t\treturn 0;\n\tif (journal->j_must_wait > 0 ||\n\t    (journal->j_len_alloc + new_alloc) >= journal->j_max_batch ||\n\t    atomic_read(&journal->j_jlock) ||\n\t    (now - journal->j_trans_start_time) > journal->j_max_trans_age ||\n\t    journal->j_cnode_free < (journal->j_trans_max * 3)) {\n\t\treturn 1;\n\t}\n\n\tjournal->j_len_alloc += new_alloc;\n\tth->t_blocks_allocated += new_alloc ;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_offset",
          "args": [
            "&s_item_key",
            "file_size"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1593-1596",
          "snippet": "static inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "deleted > file_size",
            "\"PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K\"",
            "deleted",
            "file_size",
            "&s_item_key"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_check_path",
          "args": [
            "&s_search_path"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "346-351",
          "snippet": "int reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "inode->i_sb",
            "\"vs-5665\"",
            "\"reiserfs_cut_from_item failed\""
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_cut_from_item",
          "args": [
            "th",
            "&s_search_path",
            "&s_item_key",
            "inode",
            "page",
            "new_file_size"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_bytes_number",
          "args": [
            "p_le_ih",
            "inode->i_sb->s_blocksize"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_statdata_le_ih",
          "args": [
            "p_le_ih"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "is_statdata_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1577-1580",
          "snippet": "static inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "inode->i_sb",
            "\"PAP-5660\"",
            "\"wrong result %d of search for %K\"",
            "retval",
            "&s_item_key"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_cpu_key",
          "args": [
            "&s_item_key",
            "inode",
            "max_reiserfs_offset(inode)",
            "TYPE_DIRECT",
            "3"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "126-133",
          "snippet": "void make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_reiserfs_offset",
          "args": [
            "inode"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "max_reiserfs_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2280-2286",
          "snippet": "static inline loff_t max_reiserfs_offset(struct inode *inode)\n{\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)\n\t\treturn (loff_t) U32_MAX;\n\n\treturn (loff_t) ((~(__u64) 0) >> 4);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t max_reiserfs_offset(struct inode *inode)\n{\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)\n\t\treturn (loff_t) U32_MAX;\n\n\treturn (loff_t) ((~(__u64) 0) >> 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_directory",
          "args": [
            "th",
            "inode"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "s_search_path"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_le_key_k_type",
          "args": [
            "KEY_FORMAT_3_5",
            "INODE_PKEY(inode)",
            "TYPE_STAT_DATA"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1526-1534",
          "snippet": "static inline void set_le_key_k_type(int version, struct reiserfs_key *key,\n\t\t\t\t     int type)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\ttype = type2uniqueness(type);\n\t\tkey->u.k_offset_v1.k_uniqueness = cpu_to_le32(type);\n\t} else\n\t       set_offset_v2_k_type(&key->u.k_offset_v2, type);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void set_le_key_k_type(int version, struct reiserfs_key *key,\n\t\t\t\t     int type)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\ttype = type2uniqueness(type);\n\t\tkey->u.k_offset_v1.k_uniqueness = cpu_to_le32(type);\n\t} else\n\t       set_offset_v2_k_type(&key->u.k_offset_v2, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_le_key_k_offset",
          "args": [
            "KEY_FORMAT_3_5",
            "INODE_PKEY(inode)",
            "SD_OFFSET"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1500-1507",
          "snippet": "static inline void set_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tif (version == KEY_FORMAT_3_5)\n\t\tkey->u.k_offset_v1.k_offset = cpu_to_le32(offset);\n\telse\n\t\tset_offset_v2_k_offset(&key->u.k_offset_v2, offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tif (version == KEY_FORMAT_3_5)\n\t\tkey->u.k_offset_v1.k_offset = cpu_to_le32(offset);\n\telse\n\t\tset_offset_v2_k_offset(&key->u.k_offset_v2, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_delete_solid_item",
          "args": [
            "th",
            "inode",
            "INODE_PKEY(inode)"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "inode->i_sb",
            "\"vs-5655\"",
            "\"link count != 0\""
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "inode",
            "quota_cut_bytes"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_buffers",
          "args": [
            "page",
            "tail_pos"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "le_ih"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_deleted_bytes_number",
          "args": [
            "&s_cut_balance",
            "mode"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "calc_deleted_bytes_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "1146-1170",
          "snippet": "static int calc_deleted_bytes_number(struct tree_balance *tb, char mode)\n{\n\tint del_size;\n\tstruct item_head *p_le_ih = tp_item_head(tb->tb_path);\n\n\tif (is_statdata_le_ih(p_le_ih))\n\t\treturn 0;\n\n\tdel_size =\n\t    (mode ==\n\t     M_DELETE) ? ih_item_len(p_le_ih) : -tb->insert_size[0];\n\tif (is_direntry_le_ih(p_le_ih)) {\n\t\t/*\n\t\t * return EMPTY_DIR_SIZE; We delete emty directories only.\n\t\t * we can't use EMPTY_DIR_SIZE, as old format dirs have a\n\t\t * different empty size.  ick. FIXME, is this right?\n\t\t */\n\t\treturn del_size;\n\t}\n\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tdel_size = (del_size / UNFM_P_SIZE) *\n\t\t\t\t(PATH_PLAST_BUFFER(tb->tb_path)->b_size);\n\treturn del_size;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int calc_deleted_bytes_number(struct tree_balance *tb, char mode)\n{\n\tint del_size;\n\tstruct item_head *p_le_ih = tp_item_head(tb->tb_path);\n\n\tif (is_statdata_le_ih(p_le_ih))\n\t\treturn 0;\n\n\tdel_size =\n\t    (mode ==\n\t     M_DELETE) ? ih_item_len(p_le_ih) : -tb->insert_size[0];\n\tif (is_direntry_le_ih(p_le_ih)) {\n\t\t/*\n\t\t * return EMPTY_DIR_SIZE; We delete emty directories only.\n\t\t * we can't use EMPTY_DIR_SIZE, as old format dirs have a\n\t\t * different empty size.  ick. FIXME, is this right?\n\t\t */\n\t\treturn del_size;\n\t}\n\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tdel_size = (del_size / UNFM_P_SIZE) *\n\t\t\t\t(PATH_PLAST_BUFFER(tb->tb_path)->b_size);\n\treturn del_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "tp_item_head(path)"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "mode == M_PASTE || mode == M_INSERT",
            "\"invalid mode\""
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"reiserfs-5092\"",
            "\"NO_DISK_SPACE\""
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indirect_to_direct_roll_back",
          "args": [
            "th",
            "inode",
            "path"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "cut_from_item_restarted"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_block",
          "args": [
            "PATH_PLAST_BUFFER(path)",
            "3",
            "PATH_LAST_POSITION(path) - 1",
            "PATH_LAST_POSITION(path) + 1"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "print_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "593-617",
          "snippet": "void print_block(struct buffer_head *bh, ...)\n{\n\tva_list args;\n\tint mode, first, last;\n\n\tif (!bh) {\n\t\tprintk(\"print_block: buffer is NULL\\n\");\n\t\treturn;\n\t}\n\n\tva_start(args, bh);\n\n\tmode = va_arg(args, int);\n\tfirst = va_arg(args, int);\n\tlast = va_arg(args, int);\n\tif (print_leaf(bh, mode, first, last))\n\t\tif (print_internal(bh, first, last))\n\t\t\tif (print_super_block(bh))\n\t\t\t\tif (print_desc_block(bh))\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"Block %llu contains unformatted data\\n\",\n\t\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid print_block(struct buffer_head *bh, ...)\n{\n\tva_list args;\n\tint mode, first, last;\n\n\tif (!bh) {\n\t\tprintk(\"print_block: buffer is NULL\\n\");\n\t\treturn;\n\t}\n\n\tva_start(args, bh);\n\n\tmode = va_arg(args, int);\n\tfirst = va_arg(args, int);\n\tlast = va_arg(args, int);\n\tif (print_leaf(bh, mode, first, last))\n\t\tif (print_internal(bh, first, last))\n\t\t\tif (print_super_block(bh))\n\t\t\t\tif (print_desc_block(bh))\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"Block %llu contains unformatted data\\n\",\n\t\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "path"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "path"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "path"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_type",
          "args": [
            "item_key",
            "TYPE_INDIRECT"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1598-1601",
          "snippet": "static inline void set_cpu_key_k_type(struct cpu_key *key, int type)\n{\n\tkey->on_disk_key.k_type = type;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void set_cpu_key_k_type(struct cpu_key *key, int type)\n{\n\tkey->on_disk_key.k_type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_indirect_to_direct",
          "args": [
            "th",
            "inode",
            "page",
            "path",
            "item_key",
            "new_file_size",
            "&mode"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "ret_value != CARRY_ON",
            "\"PAP-5570: can not convert twice\""
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_for_delete_or_cut",
          "args": [
            "th",
            "inode",
            "path",
            "item_key",
            "&removed",
            "&cut_size",
            "new_file_size"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_for_delete_or_cut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "1016-1143",
          "snippet": "static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode,\n\t\t\t\t      struct treepath *path,\n\t\t\t\t      const struct cpu_key *item_key,\n\t\t\t\t      /*\n\t\t\t\t       * Number of unformatted nodes\n\t\t\t\t       * which were removed from end\n\t\t\t\t       * of the file.\n\t\t\t\t       */\n\t\t\t\t      int *removed,\n\t\t\t\t      int *cut_size,\n\t\t\t\t      /* MAX_KEY_OFFSET in case of delete. */\n\t\t\t\t      unsigned long long new_file_length\n    )\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct item_head *p_le_ih = tp_item_head(path);\n\tstruct buffer_head *bh = PATH_PLAST_BUFFER(path);\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* Stat_data item. */\n\tif (is_statdata_le_ih(p_le_ih)) {\n\n\t\tRFALSE(new_file_length != max_reiserfs_offset(inode),\n\t\t       \"PAP-5210: mode must be M_DELETE\");\n\n\t\t*cut_size = -(IH_SIZE + ih_item_len(p_le_ih));\n\t\treturn M_DELETE;\n\t}\n\n\t/* Directory item. */\n\tif (is_direntry_le_ih(p_le_ih))\n\t\treturn prepare_for_direntry_item(path, p_le_ih, inode,\n\t\t\t\t\t\t new_file_length,\n\t\t\t\t\t\t cut_size);\n\n\t/* Direct item. */\n\tif (is_direct_le_ih(p_le_ih))\n\t\treturn prepare_for_direct_item(path, p_le_ih, inode,\n\t\t\t\t\t       new_file_length, cut_size);\n\n\t/* Case of an indirect item. */\n\t{\n\t    int blk_size = sb->s_blocksize;\n\t    struct item_head s_ih;\n\t    int need_re_search;\n\t    int delete = 0;\n\t    int result = M_CUT;\n\t    int pos = 0;\n\n\t    if ( new_file_length == max_reiserfs_offset (inode) ) {\n\t\t/*\n\t\t * prepare_for_delete_or_cut() is called by\n\t\t * reiserfs_delete_item()\n\t\t */\n\t\tnew_file_length = 0;\n\t\tdelete = 1;\n\t    }\n\n\t    do {\n\t\tneed_re_search = 0;\n\t\t*cut_size = 0;\n\t\tbh = PATH_PLAST_BUFFER(path);\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n\t\tpos = I_UNFM_NUM(&s_ih);\n\n\t\twhile (le_ih_k_offset (&s_ih) + (pos - 1) * blk_size > new_file_length) {\n\t\t    __le32 *unfm;\n\t\t    __u32 block;\n\n\t\t    /*\n\t\t     * Each unformatted block deletion may involve\n\t\t     * one additional bitmap block into the transaction,\n\t\t     * thereby the initial journal space reservation\n\t\t     * might not be enough.\n\t\t     */\n\t\t    if (!delete && (*cut_size) != 0 &&\n\t\t\treiserfs_transaction_free_space(th) < JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD)\n\t\t\tbreak;\n\n\t\t    unfm = (__le32 *)ih_item_body(bh, &s_ih) + pos - 1;\n\t\t    block = get_block_num(unfm, 0);\n\n\t\t    if (block != 0) {\n\t\t\treiserfs_prepare_for_journal(sb, bh, 1);\n\t\t\tput_block_num(unfm, 0, 0);\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_free_block(th, inode, block, 1);\n\t\t    }\n\n\t\t    reiserfs_cond_resched(sb);\n\n\t\t    if (item_moved (&s_ih, path))  {\n\t\t\tneed_re_search = 1;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    pos --;\n\t\t    (*removed)++;\n\t\t    (*cut_size) -= UNFM_P_SIZE;\n\n\t\t    if (pos == 0) {\n\t\t\t(*cut_size) -= IH_SIZE;\n\t\t\tresult = M_DELETE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t/*\n\t\t * a trick.  If the buffer has been logged, this will\n\t\t * do nothing.  If we've broken the loop without logging\n\t\t * it, it will restore the buffer\n\t\t */\n\t\treiserfs_restore_prepared_buffer(sb, bh);\n\t    } while (need_re_search &&\n\t\t     search_for_position_by_key(sb, item_key, path) == POSITION_FOUND);\n\t    pos_in_item(path) = pos * UNFM_P_SIZE;\n\n\t    if (*cut_size == 0) {\n\t\t/*\n\t\t * Nothing was cut. maybe convert last unformatted node to the\n\t\t * direct item?\n\t\t */\n\t\tresult = M_CONVERT;\n\t    }\n\t    return result;\n\t}\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD (2 * JOURNAL_PER_BALANCE_CNT + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\n#define JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD (2 * JOURNAL_PER_BALANCE_CNT + 1)\n\nstatic char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode,\n\t\t\t\t      struct treepath *path,\n\t\t\t\t      const struct cpu_key *item_key,\n\t\t\t\t      /*\n\t\t\t\t       * Number of unformatted nodes\n\t\t\t\t       * which were removed from end\n\t\t\t\t       * of the file.\n\t\t\t\t       */\n\t\t\t\t      int *removed,\n\t\t\t\t      int *cut_size,\n\t\t\t\t      /* MAX_KEY_OFFSET in case of delete. */\n\t\t\t\t      unsigned long long new_file_length\n    )\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct item_head *p_le_ih = tp_item_head(path);\n\tstruct buffer_head *bh = PATH_PLAST_BUFFER(path);\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* Stat_data item. */\n\tif (is_statdata_le_ih(p_le_ih)) {\n\n\t\tRFALSE(new_file_length != max_reiserfs_offset(inode),\n\t\t       \"PAP-5210: mode must be M_DELETE\");\n\n\t\t*cut_size = -(IH_SIZE + ih_item_len(p_le_ih));\n\t\treturn M_DELETE;\n\t}\n\n\t/* Directory item. */\n\tif (is_direntry_le_ih(p_le_ih))\n\t\treturn prepare_for_direntry_item(path, p_le_ih, inode,\n\t\t\t\t\t\t new_file_length,\n\t\t\t\t\t\t cut_size);\n\n\t/* Direct item. */\n\tif (is_direct_le_ih(p_le_ih))\n\t\treturn prepare_for_direct_item(path, p_le_ih, inode,\n\t\t\t\t\t       new_file_length, cut_size);\n\n\t/* Case of an indirect item. */\n\t{\n\t    int blk_size = sb->s_blocksize;\n\t    struct item_head s_ih;\n\t    int need_re_search;\n\t    int delete = 0;\n\t    int result = M_CUT;\n\t    int pos = 0;\n\n\t    if ( new_file_length == max_reiserfs_offset (inode) ) {\n\t\t/*\n\t\t * prepare_for_delete_or_cut() is called by\n\t\t * reiserfs_delete_item()\n\t\t */\n\t\tnew_file_length = 0;\n\t\tdelete = 1;\n\t    }\n\n\t    do {\n\t\tneed_re_search = 0;\n\t\t*cut_size = 0;\n\t\tbh = PATH_PLAST_BUFFER(path);\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n\t\tpos = I_UNFM_NUM(&s_ih);\n\n\t\twhile (le_ih_k_offset (&s_ih) + (pos - 1) * blk_size > new_file_length) {\n\t\t    __le32 *unfm;\n\t\t    __u32 block;\n\n\t\t    /*\n\t\t     * Each unformatted block deletion may involve\n\t\t     * one additional bitmap block into the transaction,\n\t\t     * thereby the initial journal space reservation\n\t\t     * might not be enough.\n\t\t     */\n\t\t    if (!delete && (*cut_size) != 0 &&\n\t\t\treiserfs_transaction_free_space(th) < JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD)\n\t\t\tbreak;\n\n\t\t    unfm = (__le32 *)ih_item_body(bh, &s_ih) + pos - 1;\n\t\t    block = get_block_num(unfm, 0);\n\n\t\t    if (block != 0) {\n\t\t\treiserfs_prepare_for_journal(sb, bh, 1);\n\t\t\tput_block_num(unfm, 0, 0);\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_free_block(th, inode, block, 1);\n\t\t    }\n\n\t\t    reiserfs_cond_resched(sb);\n\n\t\t    if (item_moved (&s_ih, path))  {\n\t\t\tneed_re_search = 1;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    pos --;\n\t\t    (*removed)++;\n\t\t    (*cut_size) -= UNFM_P_SIZE;\n\n\t\t    if (pos == 0) {\n\t\t\t(*cut_size) -= IH_SIZE;\n\t\t\tresult = M_DELETE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t/*\n\t\t * a trick.  If the buffer has been logged, this will\n\t\t * do nothing.  If we've broken the loop without logging\n\t\t * it, it will restore the buffer\n\t\t */\n\t\treiserfs_restore_prepared_buffer(sb, bh);\n\t    } while (need_re_search &&\n\t\t     search_for_position_by_key(sb, item_key, path) == POSITION_FOUND);\n\t    pos_in_item(path) = pos * UNFM_P_SIZE;\n\n\t    if (*cut_size == 0) {\n\t\t/*\n\t\t * Nothing was cut. maybe convert last unformatted node to the\n\t\t * direct item?\n\t\t */\n\t\tresult = M_CONVERT;\n\t    }\n\t    return result;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "inode->i_sb",
            "\"reiserfs-5091\"",
            "\"indirect_to_direct \"\n\t\t\t \"conversion has been rolled back due to \"\n\t\t\t \"lack of disk space\""
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "removed <= 0\n\t\t       || removed > tail_len",
            "\"vs-5617: there was tail %d bytes, removed item length %d bytes\"",
            "tail_len",
            "removed"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_delete_item",
          "args": [
            "th",
            "path",
            "&tail_key",
            "inode",
            "NULL/*unbh not needed */"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_delete_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "1233-2262",
          "snippet": "int reiserfs_delete_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path, const struct cpu_key *item_key,\n\t\t\t struct inode *inode, struct buffer_head *un_bh)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct tree_balance s_del_balance;\n\tstruct item_head s_ih;\n\tstruct item_head *q_ih;\n\tint quota_cut_bytes;\n\tint ret_value, del_size, removed;\n\tint depth;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tchar mode;\n\tint iter = 0;\n#endif\n\n\tBUG_ON(!th->t_trans_id);\n\n\tinit_tb_struct(th, &s_del_balance, sb, path,\n\t\t       0 /*size is unknown */ );\n\n\twhile (1) {\n\t\tremoved = 0;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\titer++;\n\t\tmode =\n#endif\n\t\t    prepare_for_delete_or_cut(th, inode, path,\n\t\t\t\t\t      item_key, &removed,\n\t\t\t\t\t      &del_size,\n\t\t\t\t\t      max_reiserfs_offset(inode));\n\n\t\tRFALSE(mode != M_DELETE, \"PAP-5320: mode must be M_DELETE\");\n\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n\t\ts_del_balance.insert_size[0] = del_size;\n\n\t\tret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);\n\t\tif (ret_value != REPEAT_SEARCH)\n\t\t\tbreak;\n\n\t\tPROC_INFO_INC(sb, delete_item_restarted);\n\n\t\t/* file system changed, repeat search */\n\t\tret_value =\n\t\t    search_for_position_by_key(sb, item_key, path);\n\t\tif (ret_value == IO_ERROR)\n\t\t\tbreak;\n\t\tif (ret_value == FILE_NOT_FOUND) {\n\t\t\treiserfs_warning(sb, \"vs-5340\",\n\t\t\t\t\t \"no items of the file %K found\",\n\t\t\t\t\t item_key);\n\t\t\tbreak;\n\t\t}\n\t}\t\t\t/* while (1) */\n\n\tif (ret_value != CARRY_ON) {\n\t\tunfix_nodes(&s_del_balance);\n\t\treturn 0;\n\t}\n\n\t/* reiserfs_delete_item returns item length when success */\n\tret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);\n\tq_ih = tp_item_head(path);\n\tquota_cut_bytes = ih_item_len(q_ih);\n\n\t/*\n\t * hack so the quota code doesn't have to guess if the file has a\n\t * tail.  On tail insert, we allocate quota for 1 unformatted node.\n\t * We test the offset because the tail might have been\n\t * split into multiple items, and we only want to decrement for\n\t * the unfm node once\n\t */\n\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(q_ih)) {\n\t\tif ((le_ih_k_offset(q_ih) & (sb->s_blocksize - 1)) == 1) {\n\t\t\tquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\n\t\t} else {\n\t\t\tquota_cut_bytes = 0;\n\t\t}\n\t}\n\n\tif (un_bh) {\n\t\tint off;\n\t\tchar *data;\n\n\t\t/*\n\t\t * We are in direct2indirect conversion, so move tail contents\n\t\t * to the unformatted node\n\t\t */\n\t\t/*\n\t\t * note, we do the copy before preparing the buffer because we\n\t\t * don't care about the contents of the unformatted node yet.\n\t\t * the only thing we really care about is the direct item's\n\t\t * data is in the unformatted node.\n\t\t *\n\t\t * Otherwise, we would have to call\n\t\t * reiserfs_prepare_for_journal on the unformatted node,\n\t\t * which might schedule, meaning we'd have to loop all the\n\t\t * way back up to the start of the while loop.\n\t\t *\n\t\t * The unformatted node must be dirtied later on.  We can't be\n\t\t * sure here if the entire tail has been deleted yet.\n\t\t *\n\t\t * un_bh is from the page cache (all unformatted nodes are\n\t\t * from the page cache) and might be a highmem page.  So, we\n\t\t * can't use un_bh->b_data.\n\t\t * -clm\n\t\t */\n\n\t\tdata = kmap_atomic(un_bh->b_page);\n\t\toff = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));\n\t\tmemcpy(data + off,\n\t\t       ih_item_body(PATH_PLAST_BUFFER(path), &s_ih),\n\t\t       ret_value);\n\t\tkunmap_atomic(data);\n\t}\n\n\t/* Perform balancing after all resources have been collected at once. */\n\tdo_balance(&s_del_balance, NULL, NULL, M_DELETE);\n\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota delete_item(): freeing %u, id=%u type=%c\",\n\t\t       quota_cut_bytes, inode->i_uid, head2type(&s_ih));\n#endif\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_space_nodirty(inode, quota_cut_bytes);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\t/* Return deleted body length */\n\treturn ret_value;\n}\n\n/*\n * Summary Of Mechanisms For Handling Collisions Between Processes:\n *\n *  deletion of the body of the object is performed by iput(), with the\n *  result that if multiple processes are operating on a file, the\n *  deletion of the body of the file is deferred until the last process\n *  that has an open inode performs its iput().\n *\n *  writes and truncates are protected from collisions by use of\n *  semaphores.\n *\n *  creates, linking, and mknod are protected from collisions with other\n *  processes by making the reiserfs_add_entry() the last step in the\n *  creation, and then rolling back all changes if there was a collision.\n *  - Hans\n*/\n\n/* this deletes item which never gets split */\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct tree_balance tb;\n\tINITIALIZE_PATH(path);\n\tint item_len = 0;\n\tint tb_init = 0;\n\tstruct cpu_key cpu_key;\n\tint retval;\n\tint quota_cut_bytes = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tle_key2cpu_key(&cpu_key, key);\n\n\twhile (1) {\n\t\tretval = search_item(th->t_super, &cpu_key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(th->t_super, \"vs-5350\",\n\t\t\t\t       \"i/o failure occurred trying \"\n\t\t\t\t       \"to delete %K\", &cpu_key);\n\t\t\tbreak;\n\t\t}\n\t\tif (retval != ITEM_FOUND) {\n\t\t\tpathrelse(&path);\n\t\t\t/*\n\t\t\t * No need for a warning, if there is just no free\n\t\t\t * space to insert '..' item into the\n\t\t\t * newly-created subdir\n\t\t\t */\n\t\t\tif (!\n\t\t\t    ((unsigned long long)\n\t\t\t     GET_HASH_VALUE(le_key_k_offset\n\t\t\t\t\t    (le_key_version(key), key)) == 0\n\t\t\t     && (unsigned long long)\n\t\t\t     GET_GENERATION_NUMBER(le_key_k_offset\n\t\t\t\t\t\t   (le_key_version(key),\n\t\t\t\t\t\t    key)) == 1))\n\t\t\t\treiserfs_warning(th->t_super, \"vs-5355\",\n\t\t\t\t\t\t \"%k not found\", key);\n\t\t\tbreak;\n\t\t}\n\t\tif (!tb_init) {\n\t\t\ttb_init = 1;\n\t\t\titem_len = ih_item_len(tp_item_head(&path));\n\t\t\tinit_tb_struct(th, &tb, th->t_super, &path,\n\t\t\t\t       -(IH_SIZE + item_len));\n\t\t}\n\t\tquota_cut_bytes = ih_item_len(tp_item_head(&path));\n\n\t\tretval = fix_nodes(M_DELETE, &tb, NULL, NULL);\n\t\tif (retval == REPEAT_SEARCH) {\n\t\t\tPROC_INFO_INC(th->t_super, delete_solid_item_restarted);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (retval == CARRY_ON) {\n\t\t\tdo_balance(&tb, NULL, NULL, M_DELETE);\n\t\t\t/*\n\t\t\t * Should we count quota for item? (we don't\n\t\t\t * count quotas for save-links)\n\t\t\t */\n\t\t\tif (inode) {\n\t\t\t\tint depth;\n#ifdef REISERQUOTA_DEBUG\n\t\t\t\treiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"reiserquota delete_solid_item(): freeing %u id=%u type=%c\",\n\t\t\t\t\t       quota_cut_bytes, inode->i_uid,\n\t\t\t\t\t       key2type(key));\n#endif\n\t\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t\t\t quota_cut_bytes);\n\t\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* IO_ERROR, NO_DISK_SPACE, etc */\n\t\treiserfs_warning(th->t_super, \"vs-5360\",\n\t\t\t\t \"could not delete %K due to fix_nodes failure\",\n\t\t\t\t &cpu_key);\n\t\tunfix_nodes(&tb);\n\t\tbreak;\n\t}\n\n\treiserfs_check_path(&path);\n}\n\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode)\n{\n\tint err;\n\tinode->i_size = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\t/* for directory this deletes item containing \".\" and \"..\" */\n\terr =\n\t    reiserfs_do_truncate(th, inode, NULL, 0 /*no timestamp updates */ );\n\tif (err)\n\t\treturn err;\n\n#if defined( USE_INODE_GENERATION_COUNTER )\n\tif (!old_format_only(th->t_super)) {\n\t\t__le32 *inode_generation;\n\n\t\tinode_generation =\n\t\t    &REISERFS_SB(th->t_super)->s_rs->s_inode_generation;\n\t\tle32_add_cpu(inode_generation, 1);\n\t}\n/* USE_INODE_GENERATION_COUNTER */\n#endif\n\treiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\n\n\treturn err;\n}\n\nstatic void unmap_buffers(struct page *page, loff_t pos)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct buffer_head *next;\n\tunsigned long tail_index;\n\tunsigned long cur_index;\n\n\tif (page) {\n\t\tif (page_has_buffers(page)) {\n\t\t\ttail_index = pos & (PAGE_CACHE_SIZE - 1);\n\t\t\tcur_index = 0;\n\t\t\thead = page_buffers(page);\n\t\t\tbh = head;\n\t\t\tdo {\n\t\t\t\tnext = bh->b_this_page;\n\n\t\t\t\t/*\n\t\t\t\t * we want to unmap the buffers that contain\n\t\t\t\t * the tail, and all the buffers after it\n\t\t\t\t * (since the tail must be at the end of the\n\t\t\t\t * file).  We don't want to unmap file data\n\t\t\t\t * before the tail, since it might be dirty\n\t\t\t\t * and waiting to reach disk\n\t\t\t\t */\n\t\t\t\tcur_index += bh->b_size;\n\t\t\t\tif (cur_index > tail_index) {\n\t\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t\t}\n\t\t\t\tbh = next;\n\t\t\t} while (bh != head);\n\t\t}\n\t}\n}\n\nstatic int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct page *page,\n\t\t\t\t    struct treepath *path,\n\t\t\t\t    const struct cpu_key *item_key,\n\t\t\t\t    loff_t new_file_size, char *mode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint block_size = sb->s_blocksize;\n\tint cut_bytes;\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(new_file_size != inode->i_size);\n\n\t/*\n\t * the page being sent in could be NULL if there was an i/o error\n\t * reading in the last block.  The user will hit problems trying to\n\t * read the file, but for now we just skip the indirect2direct\n\t */\n\tif (atomic_read(&inode->i_count) > 1 ||\n\t    !tail_has_to_be_packed(inode) ||\n\t    !page || (REISERFS_I(inode)->i_flags & i_nopack_mask)) {\n\t\t/* leave tail in an unformatted node */\n\t\t*mode = M_SKIP_BALANCING;\n\t\tcut_bytes =\n\t\t    block_size - (new_file_size & (block_size - 1));\n\t\tpathrelse(path);\n\t\treturn cut_bytes;\n\t}\n\n\t/* Perform the conversion to a direct_item. */\n\treturn indirect2direct(th, inode, page, path, item_key,\n\t\t\t       new_file_size, mode);\n}\n\n/*\n * we did indirect_to_direct conversion. And we have inserted direct\n * item successesfully, but there were no disk space to cut unfm\n * pointer being converted. Therefore we have to delete inserted\n * direct item(s)\n */\nstatic void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,\n\t\t\t\t\t struct inode *inode, struct treepath *path)\n{\n\tstruct cpu_key tail_key;\n\tint tail_len;\n\tint removed;\n\tBUG_ON(!th->t_trans_id);\n\n\tmake_cpu_key(&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);\n\ttail_key.key_length = 4;\n\n\ttail_len =\n\t    (cpu_key_k_offset(&tail_key) & (inode->i_sb->s_blocksize - 1)) - 1;\n\twhile (tail_len) {\n\t\t/* look for the last byte of the tail */\n\t\tif (search_for_position_by_key(inode->i_sb, &tail_key, path) ==\n\t\t    POSITION_NOT_FOUND)\n\t\t\treiserfs_panic(inode->i_sb, \"vs-5615\",\n\t\t\t\t       \"found invalid item\");\n\t\tRFALSE(path->pos_in_item !=\n\t\t       ih_item_len(tp_item_head(path)) - 1,\n\t\t       \"vs-5616: appended bytes found\");\n\t\tPATH_LAST_POSITION(path)--;\n\n\t\tremoved =\n\t\t    reiserfs_delete_item(th, path, &tail_key, inode,\n\t\t\t\t\t NULL /*unbh not needed */ );\n\t\tRFALSE(removed <= 0\n\t\t       || removed > tail_len,\n\t\t       \"vs-5617: there was tail %d bytes, removed item length %d bytes\",\n\t\t       tail_len, removed);\n\t\ttail_len -= removed;\n\t\tset_cpu_key_k_offset(&tail_key,\n\t\t\t\t     cpu_key_k_offset(&tail_key) - removed);\n\t}\n\treiserfs_warning(inode->i_sb, \"reiserfs-5091\", \"indirect_to_direct \"\n\t\t\t \"conversion has been rolled back due to \"\n\t\t\t \"lack of disk space\");\n\tmark_inode_dirty(inode);\n}\n\n/* (Truncate or cut entry) or delete object item. Returns < 0 on failure */\nint reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,\n\t\t\t   struct treepath *path,\n\t\t\t   struct cpu_key *item_key,\n\t\t\t   struct inode *inode,\n\t\t\t   struct page *page, loff_t new_file_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\t/*\n\t * Every function which is going to call do_balance must first\n\t * create a tree_balance structure.  Then it must fill up this\n\t * structure by using the init_tb_struct and fix_nodes functions.\n\t * After that we can make tree balancing.\n\t */\n\tstruct tree_balance s_cut_balance;\n\tstruct item_head *p_le_ih;\n\tint cut_size = 0;\t/* Amount to be cut. */\n\tint ret_value = CARRY_ON;\n\tint removed = 0;\t/* Number of the removed unformatted nodes. */\n\tint is_inode_locked = 0;\n\tchar mode;\t\t/* Mode of the balance. */\n\tint retval2 = -1;\n\tint quota_cut_bytes;\n\tloff_t tail_pos = 0;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tinit_tb_struct(th, &s_cut_balance, inode->i_sb, path,\n\t\t       cut_size);\n\n\t/*\n\t * Repeat this loop until we either cut the item without needing\n\t * to balance, or we fix_nodes without schedule occurring\n\t */\n\twhile (1) {\n\t\t/*\n\t\t * Determine the balance mode, position of the first byte to\n\t\t * be cut, and size to be cut.  In case of the indirect item\n\t\t * free unformatted nodes which are pointed to by the cut\n\t\t * pointers.\n\t\t */\n\n\t\tmode =\n\t\t    prepare_for_delete_or_cut(th, inode, path,\n\t\t\t\t\t      item_key, &removed,\n\t\t\t\t\t      &cut_size, new_file_size);\n\t\tif (mode == M_CONVERT) {\n\t\t\t/*\n\t\t\t * convert last unformatted node to direct item or\n\t\t\t * leave tail in the unformatted node\n\t\t\t */\n\t\t\tRFALSE(ret_value != CARRY_ON,\n\t\t\t       \"PAP-5570: can not convert twice\");\n\n\t\t\tret_value =\n\t\t\t    maybe_indirect_to_direct(th, inode, page,\n\t\t\t\t\t\t     path, item_key,\n\t\t\t\t\t\t     new_file_size, &mode);\n\t\t\tif (mode == M_SKIP_BALANCING)\n\t\t\t\t/* tail has been left in the unformatted node */\n\t\t\t\treturn ret_value;\n\n\t\t\tis_inode_locked = 1;\n\n\t\t\t/*\n\t\t\t * removing of last unformatted node will\n\t\t\t * change value we have to return to truncate.\n\t\t\t * Save it\n\t\t\t */\n\t\t\tretval2 = ret_value;\n\n\t\t\t/*\n\t\t\t * So, we have performed the first part of the\n\t\t\t * conversion:\n\t\t\t * inserting the new direct item.  Now we are\n\t\t\t * removing the last unformatted node pointer.\n\t\t\t * Set key to search for it.\n\t\t\t */\n\t\t\tset_cpu_key_k_type(item_key, TYPE_INDIRECT);\n\t\t\titem_key->key_length = 4;\n\t\t\tnew_file_size -=\n\t\t\t    (new_file_size & (sb->s_blocksize - 1));\n\t\t\ttail_pos = new_file_size;\n\t\t\tset_cpu_key_k_offset(item_key, new_file_size + 1);\n\t\t\tif (search_for_position_by_key\n\t\t\t    (sb, item_key,\n\t\t\t     path) == POSITION_NOT_FOUND) {\n\t\t\t\tprint_block(PATH_PLAST_BUFFER(path), 3,\n\t\t\t\t\t    PATH_LAST_POSITION(path) - 1,\n\t\t\t\t\t    PATH_LAST_POSITION(path) + 1);\n\t\t\t\treiserfs_panic(sb, \"PAP-5580\", \"item to \"\n\t\t\t\t\t       \"convert does not exist (%K)\",\n\t\t\t\t\t       item_key);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (cut_size == 0) {\n\t\t\tpathrelse(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\ts_cut_balance.insert_size[0] = cut_size;\n\n\t\tret_value = fix_nodes(mode, &s_cut_balance, NULL, NULL);\n\t\tif (ret_value != REPEAT_SEARCH)\n\t\t\tbreak;\n\n\t\tPROC_INFO_INC(sb, cut_from_item_restarted);\n\n\t\tret_value =\n\t\t    search_for_position_by_key(sb, item_key, path);\n\t\tif (ret_value == POSITION_FOUND)\n\t\t\tcontinue;\n\n\t\treiserfs_warning(sb, \"PAP-5610\", \"item %K not found\",\n\t\t\t\t item_key);\n\t\tunfix_nodes(&s_cut_balance);\n\t\treturn (ret_value == IO_ERROR) ? -EIO : -ENOENT;\n\t}\t\t\t/* while */\n\n\t/* check fix_nodes results (IO_ERROR or NO_DISK_SPACE) */\n\tif (ret_value != CARRY_ON) {\n\t\tif (is_inode_locked) {\n\t\t\t/*\n\t\t\t * FIXME: this seems to be not needed: we are always\n\t\t\t * able to cut item\n\t\t\t */\n\t\t\tindirect_to_direct_roll_back(th, inode, path);\n\t\t}\n\t\tif (ret_value == NO_DISK_SPACE)\n\t\t\treiserfs_warning(sb, \"reiserfs-5092\",\n\t\t\t\t\t \"NO_DISK_SPACE\");\n\t\tunfix_nodes(&s_cut_balance);\n\t\treturn -EIO;\n\t}\n\n\t/* go ahead and perform balancing */\n\n\tRFALSE(mode == M_PASTE || mode == M_INSERT, \"invalid mode\");\n\n\t/* Calculate number of bytes that need to be cut from the item. */\n\tquota_cut_bytes =\n\t    (mode ==\n\t     M_DELETE) ? ih_item_len(tp_item_head(path)) : -s_cut_balance.\n\t    insert_size[0];\n\tif (retval2 == -1)\n\t\tret_value = calc_deleted_bytes_number(&s_cut_balance, mode);\n\telse\n\t\tret_value = retval2;\n\n\t/*\n\t * For direct items, we only change the quota when deleting the last\n\t * item.\n\t */\n\tp_le_ih = tp_item_head(s_cut_balance.tb_path);\n\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_le_ih)) {\n\t\tif (mode == M_DELETE &&\n\t\t    (le_ih_k_offset(p_le_ih) & (sb->s_blocksize - 1)) ==\n\t\t    1) {\n\t\t\t/* FIXME: this is to keep 3.5 happy */\n\t\t\tREISERFS_I(inode)->i_first_direct_byte = U32_MAX;\n\t\t\tquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\n\t\t} else {\n\t\t\tquota_cut_bytes = 0;\n\t\t}\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\tif (is_inode_locked) {\n\t\tstruct item_head *le_ih =\n\t\t    tp_item_head(s_cut_balance.tb_path);\n\t\t/*\n\t\t * we are going to complete indirect2direct conversion. Make\n\t\t * sure, that we exactly remove last unformatted node pointer\n\t\t * of the item\n\t\t */\n\t\tif (!is_indirect_le_ih(le_ih))\n\t\t\treiserfs_panic(sb, \"vs-5652\",\n\t\t\t\t       \"item must be indirect %h\", le_ih);\n\n\t\tif (mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)\n\t\t\treiserfs_panic(sb, \"vs-5653\", \"completing \"\n\t\t\t\t       \"indirect2direct conversion indirect \"\n\t\t\t\t       \"item %h being deleted must be of \"\n\t\t\t\t       \"4 byte long\", le_ih);\n\n\t\tif (mode == M_CUT\n\t\t    && s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {\n\t\t\treiserfs_panic(sb, \"vs-5654\", \"can not complete \"\n\t\t\t\t       \"indirect2direct conversion of %h \"\n\t\t\t\t       \"(CUT, insert_size==%d)\",\n\t\t\t\t       le_ih, s_cut_balance.insert_size[0]);\n\t\t}\n\t\t/*\n\t\t * it would be useful to make sure, that right neighboring\n\t\t * item is direct item of this file\n\t\t */\n\t}\n#endif\n\n\tdo_balance(&s_cut_balance, NULL, NULL, mode);\n\tif (is_inode_locked) {\n\t\t/*\n\t\t * we've done an indirect->direct conversion.  when the\n\t\t * data block was freed, it was removed from the list of\n\t\t * blocks that must be flushed before the transaction\n\t\t * commits, make sure to unmap and invalidate it\n\t\t */\n\t\tunmap_buffers(page, tail_pos);\n\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\t}\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota cut_from_item(): freeing %u id=%u type=%c\",\n\t\t       quota_cut_bytes, inode->i_uid, '?');\n#endif\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tdquot_free_space_nodirty(inode, quota_cut_bytes);\n\treiserfs_write_lock_nested(sb, depth);\n\treturn ret_value;\n}\n\nstatic void truncate_directory(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode)\n{\n\tBUG_ON(!th->t_trans_id);\n\tif (inode->i_nlink)\n\t\treiserfs_error(inode->i_sb, \"vs-5655\", \"link count != 0\");\n\n\tset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), DOT_OFFSET);\n\tset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_DIRENTRY);\n\treiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\n\treiserfs_update_sd(th, inode);\n\tset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), SD_OFFSET);\n\tset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_STAT_DATA);\n}\n\n/*\n * Truncate file to the new size. Note, this must be called with a\n * transaction already started\n */\nint reiserfs_do_truncate(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode,\t/* ->i_size contains new size */\n\t\t\t struct page *page,\t/* up to date for last block */\n\t\t\t /*\n\t\t\t  * when it is called by file_release to convert\n\t\t\t  * the tail - no timestamps should be updated\n\t\t\t  */\n\t\t\t int update_timestamps\n    )\n{\n\tINITIALIZE_PATH(s_search_path);\t/* Path to the current object item. */\n\tstruct item_head *p_le_ih;\t/* Pointer to an item header. */\n\n\t/* Key to search for a previous file item. */\n\tstruct cpu_key s_item_key;\n\tloff_t file_size,\t/* Old file size. */\n\t new_file_size;\t/* New file size. */\n\tint deleted;\t\t/* Number of deleted or truncated bytes. */\n\tint retval;\n\tint err = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\tif (!\n\t    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)\n\t     || S_ISLNK(inode->i_mode)))\n\t\treturn 0;\n\n\t/* deletion of directory - no need to update timestamps */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\ttruncate_directory(th, inode);\n\t\treturn 0;\n\t}\n\n\t/* Get new file size. */\n\tnew_file_size = inode->i_size;\n\n\t/* FIXME: note, that key type is unimportant here */\n\tmake_cpu_key(&s_item_key, inode, max_reiserfs_offset(inode),\n\t\t     TYPE_DIRECT, 3);\n\n\tretval =\n\t    search_for_position_by_key(inode->i_sb, &s_item_key,\n\t\t\t\t       &s_search_path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(inode->i_sb, \"vs-5657\",\n\t\t\t       \"i/o failure occurred trying to truncate %K\",\n\t\t\t       &s_item_key);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\tif (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {\n\t\treiserfs_error(inode->i_sb, \"PAP-5660\",\n\t\t\t       \"wrong result %d of search for %K\", retval,\n\t\t\t       &s_item_key);\n\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\ts_search_path.pos_in_item--;\n\n\t/* Get real file size (total length of all file items) */\n\tp_le_ih = tp_item_head(&s_search_path);\n\tif (is_statdata_le_ih(p_le_ih))\n\t\tfile_size = 0;\n\telse {\n\t\tloff_t offset = le_ih_k_offset(p_le_ih);\n\t\tint bytes =\n\t\t    op_bytes_number(p_le_ih, inode->i_sb->s_blocksize);\n\n\t\t/*\n\t\t * this may mismatch with real file size: if last direct item\n\t\t * had no padding zeros and last unformatted node had no free\n\t\t * space, this file would have this file size\n\t\t */\n\t\tfile_size = offset + bytes - 1;\n\t}\n\t/*\n\t * are we doing a full truncate or delete, if so\n\t * kick in the reada code\n\t */\n\tif (new_file_size == 0)\n\t\ts_search_path.reada = PATH_READA | PATH_READA_BACK;\n\n\tif (file_size == 0 || file_size < new_file_size) {\n\t\tgoto update_and_out;\n\t}\n\n\t/* Update key to search for the last file item. */\n\tset_cpu_key_k_offset(&s_item_key, file_size);\n\n\tdo {\n\t\t/* Cut or delete file item. */\n\t\tdeleted =\n\t\t    reiserfs_cut_from_item(th, &s_search_path, &s_item_key,\n\t\t\t\t\t   inode, page, new_file_size);\n\t\tif (deleted < 0) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-5665\",\n\t\t\t\t\t \"reiserfs_cut_from_item failed\");\n\t\t\treiserfs_check_path(&s_search_path);\n\t\t\treturn 0;\n\t\t}\n\n\t\tRFALSE(deleted > file_size,\n\t\t       \"PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K\",\n\t\t       deleted, file_size, &s_item_key);\n\n\t\t/* Change key to search the last file item. */\n\t\tfile_size -= deleted;\n\n\t\tset_cpu_key_k_offset(&s_item_key, file_size);\n\n\t\t/*\n\t\t * While there are bytes to truncate and previous\n\t\t * file item is presented in the tree.\n\t\t */\n\n\t\t/*\n\t\t * This loop could take a really long time, and could log\n\t\t * many more blocks than a transaction can hold.  So, we do\n\t\t * a polite journal end here, and if the transaction needs\n\t\t * ending, we make sure the file is consistent before ending\n\t\t * the current trans and starting a new one\n\t\t */\n\t\tif (journal_transaction_should_end(th, 0) ||\n\t\t    reiserfs_transaction_free_space(th) <= JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {\n\t\t\tpathrelse(&s_search_path);\n\n\t\t\tif (update_timestamps) {\n\t\t\t\tinode->i_mtime = CURRENT_TIME_SEC;\n\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\t}\n\t\t\treiserfs_update_sd(th, inode);\n\n\t\t\terr = journal_end(th);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = journal_begin(th, inode->i_sb,\n\t\t\t\t\t    JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD + JOURNAL_PER_BALANCE_CNT * 4) ;\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\treiserfs_update_inode_transaction(inode);\n\t\t}\n\t} while (file_size > ROUND_UP(new_file_size) &&\n\t\t search_for_position_by_key(inode->i_sb, &s_item_key,\n\t\t\t\t\t    &s_search_path) == POSITION_FOUND);\n\n\tRFALSE(file_size > ROUND_UP(new_file_size),\n\t       \"PAP-5680: truncate did not finish: new_file_size %lld, current %lld, oid %d\",\n\t       new_file_size, file_size, s_item_key.on_disk_key.k_objectid);\n\nupdate_and_out:\n\tif (update_timestamps) {\n\t\t/* this is truncate, not file closing */\n\t\tinode->i_mtime = CURRENT_TIME_SEC;\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t}\n\treiserfs_update_sd(th, inode);\n\nout:\n\tpathrelse(&s_search_path);\n\treturn err;\n}\n\n#ifdef CONFIG_REISERFS_CHECK\n/* this makes sure, that we __append__, not overwrite or add holes */\nstatic void check_research_for_paste(struct treepath *path,\n\t\t\t\t     const struct cpu_key *key)\n{\n\tstruct item_head *found_ih = tp_item_head(path);\n\n\tif (is_direct_le_ih(found_ih)) {\n\t\tif (le_ih_k_offset(found_ih) +\n\t\t    op_bytes_number(found_ih,\n\t\t\t\t    get_last_bh(path)->b_size) !=\n\t\t    cpu_key_k_offset(key)\n\t\t    || op_bytes_number(found_ih,\n\t\t\t\t       get_last_bh(path)->b_size) !=\n\t\t    pos_in_item(path))\n\t\t\treiserfs_panic(NULL, \"PAP-5720\", \"found direct item \"\n\t\t\t\t       \"%h or position (%d) does not match \"\n\t\t\t\t       \"to key %K\", found_ih,\n\t\t\t\t       pos_in_item(path), key);\n\t}\n\tif (is_indirect_le_ih(found_ih)) {\n\t\tif (le_ih_k_offset(found_ih) +\n\t\t    op_bytes_number(found_ih,\n\t\t\t\t    get_last_bh(path)->b_size) !=\n\t\t    cpu_key_k_offset(key)\n\t\t    || I_UNFM_NUM(found_ih) != pos_in_item(path)\n\t\t    || get_ih_free_space(found_ih) != 0)\n\t\t\treiserfs_panic(NULL, \"PAP-5730\", \"found indirect \"\n\t\t\t\t       \"item (%h) or position (%d) does not \"\n\t\t\t\t       \"match to key (%K)\",\n\t\t\t\t       found_ih, pos_in_item(path), key);\n\t}\n}\n#endif\t\t\t\t/* config reiserfs check */\n\n/*\n * Paste bytes to the existing item.\n * Returns bytes number pasted into the item.\n */\nint reiserfs_paste_into_item(struct reiserfs_transaction_handle *th,\n\t\t\t     /* Path to the pasted item. */\n\t\t\t     struct treepath *search_path,\n\t\t\t     /* Key to search for the needed item. */\n\t\t\t     const struct cpu_key *key,\n\t\t\t     /* Inode item belongs to */\n\t\t\t     struct inode *inode,\n\t\t\t     /* Pointer to the bytes to paste. */\n\t\t\t     const char *body,\n\t\t\t     /* Size of pasted bytes. */\n\t\t\t     int pasted_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct tree_balance s_paste_balance;\n\tint retval;\n\tint fs_gen;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tfs_gen = get_generation(inode->i_sb);\n\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota paste_into_item(): allocating %u id=%u type=%c\",\n\t\t       pasted_size, inode->i_uid,\n\t\t       key2type(&key->on_disk_key));\n#endif\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tretval = dquot_alloc_space_nodirty(inode, pasted_size);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (retval) {\n\t\tpathrelse(search_path);\n\t\treturn retval;\n\t}\n\tinit_tb_struct(th, &s_paste_balance, th->t_super, search_path,\n\t\t       pasted_size);\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\ts_paste_balance.key = key->on_disk_key;\n#endif\n\n\t/* DQUOT_* can schedule, must check before the fix_nodes */\n\tif (fs_changed(fs_gen, inode->i_sb)) {\n\t\tgoto search_again;\n\t}\n\n\twhile ((retval =\n\t\tfix_nodes(M_PASTE, &s_paste_balance, NULL,\n\t\t\t  body)) == REPEAT_SEARCH) {\nsearch_again:\n\t\t/* file system changed while we were in the fix_nodes */\n\t\tPROC_INFO_INC(th->t_super, paste_into_item_restarted);\n\t\tretval =\n\t\t    search_for_position_by_key(th->t_super, key,\n\t\t\t\t\t       search_path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"PAP-5710\",\n\t\t\t\t\t \"entry or pasted byte (%K) exists\",\n\t\t\t\t\t key);\n\t\t\tretval = -EEXIST;\n\t\t\tgoto error_out;\n\t\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t\tcheck_research_for_paste(search_path, key);\n#endif\n\t}\n\n\t/*\n\t * Perform balancing after all resources are collected by fix_nodes,\n\t * and accessing them will not risk triggering schedule.\n\t */\n\tif (retval == CARRY_ON) {\n\t\tdo_balance(&s_paste_balance, NULL /*ih */ , body, M_PASTE);\n\t\treturn 0;\n\t}\n\tretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\nerror_out:\n\t/* this also releases the path */\n\tunfix_nodes(&s_paste_balance);\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota paste_into_item(): freeing %u id=%u type=%c\",\n\t\t       pasted_size, inode->i_uid,\n\t\t       key2type(&key->on_disk_key));\n#endif\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tdquot_free_space_nodirty(inode, pasted_size);\n\treiserfs_write_lock_nested(sb, depth);\n\treturn retval;\n}\n\n/*\n * Insert new item into the buffer at the path.\n * th   - active transaction handle\n * path - path to the inserted item\n * ih   - pointer to the item header to insert\n * body - pointer to the bytes to insert\n */\nint reiserfs_insert_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path, const struct cpu_key *key,\n\t\t\t struct item_head *ih, struct inode *inode,\n\t\t\t const char *body)\n{\n\tstruct tree_balance s_ins_balance;\n\tint retval;\n\tint fs_gen = 0;\n\tint quota_bytes = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tif (inode) {\t\t/* Do we count quotas for item? */\n\t\tint depth;\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\tquota_bytes = ih_item_len(ih);\n\n\t\t/*\n\t\t * hack so the quota code doesn't have to guess\n\t\t * if the file has a tail, links are always tails,\n\t\t * so there's no guessing needed\n\t\t */\n\t\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(ih))\n\t\t\tquota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE;\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota insert_item(): allocating %u id=%u type=%c\",\n\t\t\t       quota_bytes, inode->i_uid, head2type(ih));\n#endif\n\t\t/*\n\t\t * We can't dirty inode here. It would be immediately\n\t\t * written but appropriate stat item isn't inserted yet...\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tretval = dquot_alloc_space_nodirty(inode, quota_bytes);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\tif (retval) {\n\t\t\tpathrelse(path);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tinit_tb_struct(th, &s_ins_balance, th->t_super, path,\n\t\t       IH_SIZE + ih_item_len(ih));\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\ts_ins_balance.key = key->on_disk_key;\n#endif\n\t/*\n\t * DQUOT_* can schedule, must check to be sure calling\n\t * fix_nodes is safe\n\t */\n\tif (inode && fs_changed(fs_gen, inode->i_sb)) {\n\t\tgoto search_again;\n\t}\n\n\twhile ((retval =\n\t\tfix_nodes(M_INSERT, &s_ins_balance, ih,\n\t\t\t  body)) == REPEAT_SEARCH) {\nsearch_again:\n\t\t/* file system changed while we were in the fix_nodes */\n\t\tPROC_INFO_INC(th->t_super, insert_item_restarted);\n\t\tretval = search_item(th->t_super, key, path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tif (retval == ITEM_FOUND) {\n\t\t\treiserfs_warning(th->t_super, \"PAP-5760\",\n\t\t\t\t\t \"key %K already exists in the tree\",\n\t\t\t\t\t key);\n\t\t\tretval = -EEXIST;\n\t\t\tgoto error_out;\n\t\t}\n\t}\n\n\t/* make balancing after all resources will be collected at a time */\n\tif (retval == CARRY_ON) {\n\t\tdo_balance(&s_ins_balance, ih, body, M_INSERT);\n\t\treturn 0;\n\t}\n\n\tretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\nerror_out:\n\t/* also releases the path */\n\tunfix_nodes(&s_ins_balance);\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota insert_item(): freeing %u id=%u type=%c\",\n\t\t       quota_bytes, inode->i_uid, head2type(ih));\n#endif\n\tif (inode) {\n\t\tint depth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tdquot_free_space_nodirty(inode, quota_bytes);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t}\n\treturn retval;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "path"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "path->pos_in_item !=\n\t\t       ih_item_len(tp_item_head(path)) - 1",
            "\"vs-5616: appended bytes found\""
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "tp_item_head(path)"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "inode->i_sb",
            "\"vs-5615\"",
            "\"found invalid item\""
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indirect2direct",
          "args": [
            "th",
            "inode",
            "page",
            "path",
            "item_key",
            "new_file_size",
            "mode"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "indirect2direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/tail_conversion.c",
          "lines": "201-317",
          "snippet": "int indirect2direct(struct reiserfs_transaction_handle *th,\n\t\t    struct inode *inode, struct page *page,\n\t\t    struct treepath *path,\t/* path to the indirect item. */\n\t\t    const struct cpu_key *item_key,\t/* Key to look for\n\t\t\t\t\t\t\t * unformatted node\n\t\t\t\t\t\t\t * pointer to be cut. */\n\t\t    loff_t n_new_file_size,\t/* New file size. */\n\t\t    char *mode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct item_head s_ih;\n\tunsigned long block_size = sb->s_blocksize;\n\tchar *tail;\n\tint tail_len, round_tail_len;\n\tloff_t pos, pos1;\t/* position of first byte of the tail */\n\tstruct cpu_key key;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tREISERFS_SB(sb)->s_indirect2direct++;\n\n\t*mode = M_SKIP_BALANCING;\n\n\t/* store item head path points to. */\n\tcopy_item_head(&s_ih, tp_item_head(path));\n\n\ttail_len = (n_new_file_size & (block_size - 1));\n\tif (get_inode_sd_version(inode) == STAT_DATA_V2)\n\t\tround_tail_len = ROUND_UP(tail_len);\n\telse\n\t\tround_tail_len = tail_len;\n\n\tpos =\n\t    le_ih_k_offset(&s_ih) - 1 + (ih_item_len(&s_ih) / UNFM_P_SIZE -\n\t\t\t\t\t 1) * sb->s_blocksize;\n\tpos1 = pos;\n\n\t/*\n\t * we are protected by i_mutex. The tail can not disapper, not\n\t * append can be done either\n\t * we are in truncate or packing tail in file_release\n\t */\n\n\ttail = (char *)kmap(page);\t/* this can schedule */\n\n\tif (path_changed(&s_ih, path)) {\n\t\t/* re-search indirect item */\n\t\tif (search_for_position_by_key(sb, item_key, path)\n\t\t    == POSITION_NOT_FOUND)\n\t\t\treiserfs_panic(sb, \"PAP-5520\",\n\t\t\t\t       \"item to be converted %K does not exist\",\n\t\t\t\t       item_key);\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n#ifdef CONFIG_REISERFS_CHECK\n\t\tpos = le_ih_k_offset(&s_ih) - 1 +\n\t\t    (ih_item_len(&s_ih) / UNFM_P_SIZE -\n\t\t     1) * sb->s_blocksize;\n\t\tif (pos != pos1)\n\t\t\treiserfs_panic(sb, \"vs-5530\", \"tail position \"\n\t\t\t\t       \"changed while we were reading it\");\n#endif\n\t}\n\n\t/* Set direct item header to insert. */\n\tmake_le_item_head(&s_ih, NULL, get_inode_item_key_version(inode),\n\t\t\t  pos1 + 1, TYPE_DIRECT, round_tail_len,\n\t\t\t  0xffff /*ih_free_space */ );\n\n\t/*\n\t * we want a pointer to the first byte of the tail in the page.\n\t * the page was locked and this part of the page was up to date when\n\t * indirect2direct was called, so we know the bytes are still valid\n\t */\n\ttail = tail + (pos & (PAGE_CACHE_SIZE - 1));\n\n\tPATH_LAST_POSITION(path)++;\n\n\tkey = *item_key;\n\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\tkey.key_length = 4;\n\t/* Insert tail as new direct item in the tree */\n\tif (reiserfs_insert_item(th, path, &key, &s_ih, inode,\n\t\t\t\t tail ? tail : NULL) < 0) {\n\t\t/*\n\t\t * No disk memory. So we can not convert last unformatted node\n\t\t * to the direct item.  In this case we used to adjust\n\t\t * indirect items's ih_free_space. Now ih_free_space is not\n\t\t * used, it would be ideal to write zeros to corresponding\n\t\t * unformatted node. For now i_size is considered as guard for\n\t\t * going out of file size\n\t\t */\n\t\tkunmap(page);\n\t\treturn block_size - round_tail_len;\n\t}\n\tkunmap(page);\n\n\t/* make sure to get the i_blocks changes from reiserfs_insert_item */\n\treiserfs_update_sd(th, inode);\n\n\t/*\n\t * note: we have now the same as in above direct2indirect\n\t * conversion: there are two keys which have matching first three\n\t * key components. They only differ by the fourth one.\n\t */\n\n\t/*\n\t * We have inserted new direct item and must remove last\n\t * unformatted node.\n\t */\n\t*mode = M_CUT;\n\n\t/* we store position of first direct item in the in-core inode */\n\t/* mark_file_with_tail (inode, pos1 + 1); */\n\tREISERFS_I(inode)->i_first_direct_byte = pos1 + 1;\n\n\treturn block_size - round_tail_len;\n}",
          "includes": [
            "#include \"reiserfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/time.h>\n\nint indirect2direct(struct reiserfs_transaction_handle *th,\n\t\t    struct inode *inode, struct page *page,\n\t\t    struct treepath *path,\t/* path to the indirect item. */\n\t\t    const struct cpu_key *item_key,\t/* Key to look for\n\t\t\t\t\t\t\t * unformatted node\n\t\t\t\t\t\t\t * pointer to be cut. */\n\t\t    loff_t n_new_file_size,\t/* New file size. */\n\t\t    char *mode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct item_head s_ih;\n\tunsigned long block_size = sb->s_blocksize;\n\tchar *tail;\n\tint tail_len, round_tail_len;\n\tloff_t pos, pos1;\t/* position of first byte of the tail */\n\tstruct cpu_key key;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tREISERFS_SB(sb)->s_indirect2direct++;\n\n\t*mode = M_SKIP_BALANCING;\n\n\t/* store item head path points to. */\n\tcopy_item_head(&s_ih, tp_item_head(path));\n\n\ttail_len = (n_new_file_size & (block_size - 1));\n\tif (get_inode_sd_version(inode) == STAT_DATA_V2)\n\t\tround_tail_len = ROUND_UP(tail_len);\n\telse\n\t\tround_tail_len = tail_len;\n\n\tpos =\n\t    le_ih_k_offset(&s_ih) - 1 + (ih_item_len(&s_ih) / UNFM_P_SIZE -\n\t\t\t\t\t 1) * sb->s_blocksize;\n\tpos1 = pos;\n\n\t/*\n\t * we are protected by i_mutex. The tail can not disapper, not\n\t * append can be done either\n\t * we are in truncate or packing tail in file_release\n\t */\n\n\ttail = (char *)kmap(page);\t/* this can schedule */\n\n\tif (path_changed(&s_ih, path)) {\n\t\t/* re-search indirect item */\n\t\tif (search_for_position_by_key(sb, item_key, path)\n\t\t    == POSITION_NOT_FOUND)\n\t\t\treiserfs_panic(sb, \"PAP-5520\",\n\t\t\t\t       \"item to be converted %K does not exist\",\n\t\t\t\t       item_key);\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n#ifdef CONFIG_REISERFS_CHECK\n\t\tpos = le_ih_k_offset(&s_ih) - 1 +\n\t\t    (ih_item_len(&s_ih) / UNFM_P_SIZE -\n\t\t     1) * sb->s_blocksize;\n\t\tif (pos != pos1)\n\t\t\treiserfs_panic(sb, \"vs-5530\", \"tail position \"\n\t\t\t\t       \"changed while we were reading it\");\n#endif\n\t}\n\n\t/* Set direct item header to insert. */\n\tmake_le_item_head(&s_ih, NULL, get_inode_item_key_version(inode),\n\t\t\t  pos1 + 1, TYPE_DIRECT, round_tail_len,\n\t\t\t  0xffff /*ih_free_space */ );\n\n\t/*\n\t * we want a pointer to the first byte of the tail in the page.\n\t * the page was locked and this part of the page was up to date when\n\t * indirect2direct was called, so we know the bytes are still valid\n\t */\n\ttail = tail + (pos & (PAGE_CACHE_SIZE - 1));\n\n\tPATH_LAST_POSITION(path)++;\n\n\tkey = *item_key;\n\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\tkey.key_length = 4;\n\t/* Insert tail as new direct item in the tree */\n\tif (reiserfs_insert_item(th, path, &key, &s_ih, inode,\n\t\t\t\t tail ? tail : NULL) < 0) {\n\t\t/*\n\t\t * No disk memory. So we can not convert last unformatted node\n\t\t * to the direct item.  In this case we used to adjust\n\t\t * indirect items's ih_free_space. Now ih_free_space is not\n\t\t * used, it would be ideal to write zeros to corresponding\n\t\t * unformatted node. For now i_size is considered as guard for\n\t\t * going out of file size\n\t\t */\n\t\tkunmap(page);\n\t\treturn block_size - round_tail_len;\n\t}\n\tkunmap(page);\n\n\t/* make sure to get the i_blocks changes from reiserfs_insert_item */\n\treiserfs_update_sd(th, inode);\n\n\t/*\n\t * note: we have now the same as in above direct2indirect\n\t * conversion: there are two keys which have matching first three\n\t * key components. They only differ by the fourth one.\n\t */\n\n\t/*\n\t * We have inserted new direct item and must remove last\n\t * unformatted node.\n\t */\n\t*mode = M_CUT;\n\n\t/* we store position of first direct item in the in-core inode */\n\t/* mark_file_with_tail (inode, pos1 + 1); */\n\tREISERFS_I(inode)->i_first_direct_byte = pos1 + 1;\n\n\treturn block_size - round_tail_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tail_has_to_be_packed",
          "args": [
            "inode"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_file_size != inode->i_size"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_unmap_buffer",
          "args": [
            "bh"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_unmap_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/tail_conversion.c",
          "lines": "166-191",
          "snippet": "void reiserfs_unmap_buffer(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\tBUG();\n\t}\n\tclear_buffer_dirty(bh);\n\t/*\n\t * Remove the buffer from whatever list it belongs to. We are mostly\n\t * interested in removing it from per-sb j_dirty_buffers list, to avoid\n\t * BUG() on attempt to write not mapped buffer\n\t */\n\tif ((!list_empty(&bh->b_assoc_buffers) || bh->b_private) && bh->b_page) {\n\t\tstruct inode *inode = bh->b_page->mapping->host;\n\t\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\treiserfs_free_jh(bh);\n\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t}\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"reiserfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/time.h>\n\nvoid reiserfs_unmap_buffer(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\tBUG();\n\t}\n\tclear_buffer_dirty(bh);\n\t/*\n\t * Remove the buffer from whatever list it belongs to. We are mostly\n\t * interested in removing it from per-sb j_dirty_buffers list, to avoid\n\t * BUG() on attempt to write not mapped buffer\n\t */\n\tif ((!list_empty(&bh->b_assoc_buffers) || bh->b_private) && bh->b_page) {\n\t\tstruct inode *inode = bh->b_page->mapping->host;\n\t\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\treiserfs_free_jh(bh);\n\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t}\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_delete_solid_item",
          "args": [
            "th",
            "inode",
            "INODE_PKEY(inode)"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "inode_generation",
            "1"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "th->t_super"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "th->t_super"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_do_truncate",
          "args": [
            "th",
            "inode",
            "NULL",
            "0/*no timestamp updates */"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "inode",
            "quota_cut_bytes"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "th->t_super",
            "delete_solid_item_restarted"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "tp_item_head(&path)"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "tp_item_head(&path)"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_GENERATION_NUMBER",
          "args": [
            "le_key_k_offset\n\t\t\t\t\t\t   (le_key_version(key),\n\t\t\t\t\t\t    key)"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_key_k_offset",
          "args": [
            "le_key_version(key)",
            "key"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1473-1479",
          "snippet": "static inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_key_version",
          "args": [
            "key"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2980-2991",
          "snippet": "static inline int le_key_version(const struct reiserfs_key *key)\n{\n\tint type;\n\n\ttype = offset_v2_k_type(&(key->u.k_offset_v2));\n\tif (type != TYPE_DIRECT && type != TYPE_INDIRECT\n\t    && type != TYPE_DIRENTRY)\n\t\treturn KEY_FORMAT_3_5;\n\n\treturn KEY_FORMAT_3_6;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_DIRENTRY 3",
            "#define TYPE_DIRECT 2",
            "#define TYPE_INDIRECT 1",
            "#define KEY_FORMAT_3_6 1",
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_DIRENTRY 3\n#define TYPE_DIRECT 2\n#define TYPE_INDIRECT 1\n#define KEY_FORMAT_3_6 1\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int le_key_version(const struct reiserfs_key *key)\n{\n\tint type;\n\n\ttype = offset_v2_k_type(&(key->u.k_offset_v2));\n\tif (type != TYPE_DIRECT && type != TYPE_INDIRECT\n\t    && type != TYPE_DIRENTRY)\n\t\treturn KEY_FORMAT_3_5;\n\n\treturn KEY_FORMAT_3_6;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_HASH_VALUE",
          "args": [
            "le_key_k_offset\n\t\t\t\t\t    (le_key_version(key), key)"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_item",
          "args": [
            "th->t_super",
            "&cpu_key",
            "&path"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_key2cpu_key",
          "args": [
            "&cpu_key",
            "key"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "le_key2cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "114-125",
          "snippet": "inline void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from)\n{\n\tint version;\n\tto->on_disk_key.k_dir_id = le32_to_cpu(from->k_dir_id);\n\tto->on_disk_key.k_objectid = le32_to_cpu(from->k_objectid);\n\n\t/* find out version of the key */\n\tversion = le_key_version(from);\n\tto->version = version;\n\tto->on_disk_key.k_offset = le_key_k_offset(version, from);\n\tto->on_disk_key.k_type = le_key_k_type(version, from);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from)\n{\n\tint version;\n\tto->on_disk_key.k_dir_id = le32_to_cpu(from->k_dir_id);\n\tto->on_disk_key.k_objectid = le32_to_cpu(from->k_objectid);\n\n\t/* find out version of the key */\n\tversion = le_key_version(from);\n\tto->version = version;\n\tto->on_disk_key.k_offset = le_key_k_offset(version, from);\n\tto->on_disk_key.k_type = le_key_k_type(version, from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "inode",
            "quota_cut_bytes"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "data"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + off",
            "ih_item_body(PATH_PLAST_BUFFER(path), &s_ih)",
            "ret_value"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_body",
          "args": [
            "PATH_PLAST_BUFFER(path)",
            "&s_ih"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "ih_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2213-2217",
          "snippet": "static inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "path"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "un_bh->b_page"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "q_ih"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "delete_item_restarted"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_item_head",
          "args": [
            "&s_ih",
            "tp_item_head(path)"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "copy_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "29-33",
          "snippet": "inline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "mode != M_DELETE",
            "\"PAP-5320: mode must be M_DELETE\""
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\n#define JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD (2 * JOURNAL_PER_BALANCE_CNT + 1)\n\nint reiserfs_delete_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path, const struct cpu_key *item_key,\n\t\t\t struct inode *inode, struct buffer_head *un_bh)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct tree_balance s_del_balance;\n\tstruct item_head s_ih;\n\tstruct item_head *q_ih;\n\tint quota_cut_bytes;\n\tint ret_value, del_size, removed;\n\tint depth;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tchar mode;\n\tint iter = 0;\n#endif\n\n\tBUG_ON(!th->t_trans_id);\n\n\tinit_tb_struct(th, &s_del_balance, sb, path,\n\t\t       0 /*size is unknown */ );\n\n\twhile (1) {\n\t\tremoved = 0;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\titer++;\n\t\tmode =\n#endif\n\t\t    prepare_for_delete_or_cut(th, inode, path,\n\t\t\t\t\t      item_key, &removed,\n\t\t\t\t\t      &del_size,\n\t\t\t\t\t      max_reiserfs_offset(inode));\n\n\t\tRFALSE(mode != M_DELETE, \"PAP-5320: mode must be M_DELETE\");\n\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n\t\ts_del_balance.insert_size[0] = del_size;\n\n\t\tret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);\n\t\tif (ret_value != REPEAT_SEARCH)\n\t\t\tbreak;\n\n\t\tPROC_INFO_INC(sb, delete_item_restarted);\n\n\t\t/* file system changed, repeat search */\n\t\tret_value =\n\t\t    search_for_position_by_key(sb, item_key, path);\n\t\tif (ret_value == IO_ERROR)\n\t\t\tbreak;\n\t\tif (ret_value == FILE_NOT_FOUND) {\n\t\t\treiserfs_warning(sb, \"vs-5340\",\n\t\t\t\t\t \"no items of the file %K found\",\n\t\t\t\t\t item_key);\n\t\t\tbreak;\n\t\t}\n\t}\t\t\t/* while (1) */\n\n\tif (ret_value != CARRY_ON) {\n\t\tunfix_nodes(&s_del_balance);\n\t\treturn 0;\n\t}\n\n\t/* reiserfs_delete_item returns item length when success */\n\tret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);\n\tq_ih = tp_item_head(path);\n\tquota_cut_bytes = ih_item_len(q_ih);\n\n\t/*\n\t * hack so the quota code doesn't have to guess if the file has a\n\t * tail.  On tail insert, we allocate quota for 1 unformatted node.\n\t * We test the offset because the tail might have been\n\t * split into multiple items, and we only want to decrement for\n\t * the unfm node once\n\t */\n\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(q_ih)) {\n\t\tif ((le_ih_k_offset(q_ih) & (sb->s_blocksize - 1)) == 1) {\n\t\t\tquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\n\t\t} else {\n\t\t\tquota_cut_bytes = 0;\n\t\t}\n\t}\n\n\tif (un_bh) {\n\t\tint off;\n\t\tchar *data;\n\n\t\t/*\n\t\t * We are in direct2indirect conversion, so move tail contents\n\t\t * to the unformatted node\n\t\t */\n\t\t/*\n\t\t * note, we do the copy before preparing the buffer because we\n\t\t * don't care about the contents of the unformatted node yet.\n\t\t * the only thing we really care about is the direct item's\n\t\t * data is in the unformatted node.\n\t\t *\n\t\t * Otherwise, we would have to call\n\t\t * reiserfs_prepare_for_journal on the unformatted node,\n\t\t * which might schedule, meaning we'd have to loop all the\n\t\t * way back up to the start of the while loop.\n\t\t *\n\t\t * The unformatted node must be dirtied later on.  We can't be\n\t\t * sure here if the entire tail has been deleted yet.\n\t\t *\n\t\t * un_bh is from the page cache (all unformatted nodes are\n\t\t * from the page cache) and might be a highmem page.  So, we\n\t\t * can't use un_bh->b_data.\n\t\t * -clm\n\t\t */\n\n\t\tdata = kmap_atomic(un_bh->b_page);\n\t\toff = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));\n\t\tmemcpy(data + off,\n\t\t       ih_item_body(PATH_PLAST_BUFFER(path), &s_ih),\n\t\t       ret_value);\n\t\tkunmap_atomic(data);\n\t}\n\n\t/* Perform balancing after all resources have been collected at once. */\n\tdo_balance(&s_del_balance, NULL, NULL, M_DELETE);\n\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota delete_item(): freeing %u, id=%u type=%c\",\n\t\t       quota_cut_bytes, inode->i_uid, head2type(&s_ih));\n#endif\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_space_nodirty(inode, quota_cut_bytes);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\t/* Return deleted body length */\n\treturn ret_value;\n}\n\n/*\n * Summary Of Mechanisms For Handling Collisions Between Processes:\n *\n *  deletion of the body of the object is performed by iput(), with the\n *  result that if multiple processes are operating on a file, the\n *  deletion of the body of the file is deferred until the last process\n *  that has an open inode performs its iput().\n *\n *  writes and truncates are protected from collisions by use of\n *  semaphores.\n *\n *  creates, linking, and mknod are protected from collisions with other\n *  processes by making the reiserfs_add_entry() the last step in the\n *  creation, and then rolling back all changes if there was a collision.\n *  - Hans\n*/\n\n/* this deletes item which never gets split */\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct tree_balance tb;\n\tINITIALIZE_PATH(path);\n\tint item_len = 0;\n\tint tb_init = 0;\n\tstruct cpu_key cpu_key;\n\tint retval;\n\tint quota_cut_bytes = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tle_key2cpu_key(&cpu_key, key);\n\n\twhile (1) {\n\t\tretval = search_item(th->t_super, &cpu_key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(th->t_super, \"vs-5350\",\n\t\t\t\t       \"i/o failure occurred trying \"\n\t\t\t\t       \"to delete %K\", &cpu_key);\n\t\t\tbreak;\n\t\t}\n\t\tif (retval != ITEM_FOUND) {\n\t\t\tpathrelse(&path);\n\t\t\t/*\n\t\t\t * No need for a warning, if there is just no free\n\t\t\t * space to insert '..' item into the\n\t\t\t * newly-created subdir\n\t\t\t */\n\t\t\tif (!\n\t\t\t    ((unsigned long long)\n\t\t\t     GET_HASH_VALUE(le_key_k_offset\n\t\t\t\t\t    (le_key_version(key), key)) == 0\n\t\t\t     && (unsigned long long)\n\t\t\t     GET_GENERATION_NUMBER(le_key_k_offset\n\t\t\t\t\t\t   (le_key_version(key),\n\t\t\t\t\t\t    key)) == 1))\n\t\t\t\treiserfs_warning(th->t_super, \"vs-5355\",\n\t\t\t\t\t\t \"%k not found\", key);\n\t\t\tbreak;\n\t\t}\n\t\tif (!tb_init) {\n\t\t\ttb_init = 1;\n\t\t\titem_len = ih_item_len(tp_item_head(&path));\n\t\t\tinit_tb_struct(th, &tb, th->t_super, &path,\n\t\t\t\t       -(IH_SIZE + item_len));\n\t\t}\n\t\tquota_cut_bytes = ih_item_len(tp_item_head(&path));\n\n\t\tretval = fix_nodes(M_DELETE, &tb, NULL, NULL);\n\t\tif (retval == REPEAT_SEARCH) {\n\t\t\tPROC_INFO_INC(th->t_super, delete_solid_item_restarted);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (retval == CARRY_ON) {\n\t\t\tdo_balance(&tb, NULL, NULL, M_DELETE);\n\t\t\t/*\n\t\t\t * Should we count quota for item? (we don't\n\t\t\t * count quotas for save-links)\n\t\t\t */\n\t\t\tif (inode) {\n\t\t\t\tint depth;\n#ifdef REISERQUOTA_DEBUG\n\t\t\t\treiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"reiserquota delete_solid_item(): freeing %u id=%u type=%c\",\n\t\t\t\t\t       quota_cut_bytes, inode->i_uid,\n\t\t\t\t\t       key2type(key));\n#endif\n\t\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t\t\t quota_cut_bytes);\n\t\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* IO_ERROR, NO_DISK_SPACE, etc */\n\t\treiserfs_warning(th->t_super, \"vs-5360\",\n\t\t\t\t \"could not delete %K due to fix_nodes failure\",\n\t\t\t\t &cpu_key);\n\t\tunfix_nodes(&tb);\n\t\tbreak;\n\t}\n\n\treiserfs_check_path(&path);\n}\n\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode)\n{\n\tint err;\n\tinode->i_size = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\t/* for directory this deletes item containing \".\" and \"..\" */\n\terr =\n\t    reiserfs_do_truncate(th, inode, NULL, 0 /*no timestamp updates */ );\n\tif (err)\n\t\treturn err;\n\n#if defined( USE_INODE_GENERATION_COUNTER )\n\tif (!old_format_only(th->t_super)) {\n\t\t__le32 *inode_generation;\n\n\t\tinode_generation =\n\t\t    &REISERFS_SB(th->t_super)->s_rs->s_inode_generation;\n\t\tle32_add_cpu(inode_generation, 1);\n\t}\n/* USE_INODE_GENERATION_COUNTER */\n#endif\n\treiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\n\n\treturn err;\n}\n\nstatic void unmap_buffers(struct page *page, loff_t pos)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct buffer_head *next;\n\tunsigned long tail_index;\n\tunsigned long cur_index;\n\n\tif (page) {\n\t\tif (page_has_buffers(page)) {\n\t\t\ttail_index = pos & (PAGE_CACHE_SIZE - 1);\n\t\t\tcur_index = 0;\n\t\t\thead = page_buffers(page);\n\t\t\tbh = head;\n\t\t\tdo {\n\t\t\t\tnext = bh->b_this_page;\n\n\t\t\t\t/*\n\t\t\t\t * we want to unmap the buffers that contain\n\t\t\t\t * the tail, and all the buffers after it\n\t\t\t\t * (since the tail must be at the end of the\n\t\t\t\t * file).  We don't want to unmap file data\n\t\t\t\t * before the tail, since it might be dirty\n\t\t\t\t * and waiting to reach disk\n\t\t\t\t */\n\t\t\t\tcur_index += bh->b_size;\n\t\t\t\tif (cur_index > tail_index) {\n\t\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t\t}\n\t\t\t\tbh = next;\n\t\t\t} while (bh != head);\n\t\t}\n\t}\n}\n\nstatic int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct page *page,\n\t\t\t\t    struct treepath *path,\n\t\t\t\t    const struct cpu_key *item_key,\n\t\t\t\t    loff_t new_file_size, char *mode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint block_size = sb->s_blocksize;\n\tint cut_bytes;\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(new_file_size != inode->i_size);\n\n\t/*\n\t * the page being sent in could be NULL if there was an i/o error\n\t * reading in the last block.  The user will hit problems trying to\n\t * read the file, but for now we just skip the indirect2direct\n\t */\n\tif (atomic_read(&inode->i_count) > 1 ||\n\t    !tail_has_to_be_packed(inode) ||\n\t    !page || (REISERFS_I(inode)->i_flags & i_nopack_mask)) {\n\t\t/* leave tail in an unformatted node */\n\t\t*mode = M_SKIP_BALANCING;\n\t\tcut_bytes =\n\t\t    block_size - (new_file_size & (block_size - 1));\n\t\tpathrelse(path);\n\t\treturn cut_bytes;\n\t}\n\n\t/* Perform the conversion to a direct_item. */\n\treturn indirect2direct(th, inode, page, path, item_key,\n\t\t\t       new_file_size, mode);\n}\n\n/*\n * we did indirect_to_direct conversion. And we have inserted direct\n * item successesfully, but there were no disk space to cut unfm\n * pointer being converted. Therefore we have to delete inserted\n * direct item(s)\n */\nstatic void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,\n\t\t\t\t\t struct inode *inode, struct treepath *path)\n{\n\tstruct cpu_key tail_key;\n\tint tail_len;\n\tint removed;\n\tBUG_ON(!th->t_trans_id);\n\n\tmake_cpu_key(&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);\n\ttail_key.key_length = 4;\n\n\ttail_len =\n\t    (cpu_key_k_offset(&tail_key) & (inode->i_sb->s_blocksize - 1)) - 1;\n\twhile (tail_len) {\n\t\t/* look for the last byte of the tail */\n\t\tif (search_for_position_by_key(inode->i_sb, &tail_key, path) ==\n\t\t    POSITION_NOT_FOUND)\n\t\t\treiserfs_panic(inode->i_sb, \"vs-5615\",\n\t\t\t\t       \"found invalid item\");\n\t\tRFALSE(path->pos_in_item !=\n\t\t       ih_item_len(tp_item_head(path)) - 1,\n\t\t       \"vs-5616: appended bytes found\");\n\t\tPATH_LAST_POSITION(path)--;\n\n\t\tremoved =\n\t\t    reiserfs_delete_item(th, path, &tail_key, inode,\n\t\t\t\t\t NULL /*unbh not needed */ );\n\t\tRFALSE(removed <= 0\n\t\t       || removed > tail_len,\n\t\t       \"vs-5617: there was tail %d bytes, removed item length %d bytes\",\n\t\t       tail_len, removed);\n\t\ttail_len -= removed;\n\t\tset_cpu_key_k_offset(&tail_key,\n\t\t\t\t     cpu_key_k_offset(&tail_key) - removed);\n\t}\n\treiserfs_warning(inode->i_sb, \"reiserfs-5091\", \"indirect_to_direct \"\n\t\t\t \"conversion has been rolled back due to \"\n\t\t\t \"lack of disk space\");\n\tmark_inode_dirty(inode);\n}\n\n/* (Truncate or cut entry) or delete object item. Returns < 0 on failure */\nint reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,\n\t\t\t   struct treepath *path,\n\t\t\t   struct cpu_key *item_key,\n\t\t\t   struct inode *inode,\n\t\t\t   struct page *page, loff_t new_file_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\t/*\n\t * Every function which is going to call do_balance must first\n\t * create a tree_balance structure.  Then it must fill up this\n\t * structure by using the init_tb_struct and fix_nodes functions.\n\t * After that we can make tree balancing.\n\t */\n\tstruct tree_balance s_cut_balance;\n\tstruct item_head *p_le_ih;\n\tint cut_size = 0;\t/* Amount to be cut. */\n\tint ret_value = CARRY_ON;\n\tint removed = 0;\t/* Number of the removed unformatted nodes. */\n\tint is_inode_locked = 0;\n\tchar mode;\t\t/* Mode of the balance. */\n\tint retval2 = -1;\n\tint quota_cut_bytes;\n\tloff_t tail_pos = 0;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tinit_tb_struct(th, &s_cut_balance, inode->i_sb, path,\n\t\t       cut_size);\n\n\t/*\n\t * Repeat this loop until we either cut the item without needing\n\t * to balance, or we fix_nodes without schedule occurring\n\t */\n\twhile (1) {\n\t\t/*\n\t\t * Determine the balance mode, position of the first byte to\n\t\t * be cut, and size to be cut.  In case of the indirect item\n\t\t * free unformatted nodes which are pointed to by the cut\n\t\t * pointers.\n\t\t */\n\n\t\tmode =\n\t\t    prepare_for_delete_or_cut(th, inode, path,\n\t\t\t\t\t      item_key, &removed,\n\t\t\t\t\t      &cut_size, new_file_size);\n\t\tif (mode == M_CONVERT) {\n\t\t\t/*\n\t\t\t * convert last unformatted node to direct item or\n\t\t\t * leave tail in the unformatted node\n\t\t\t */\n\t\t\tRFALSE(ret_value != CARRY_ON,\n\t\t\t       \"PAP-5570: can not convert twice\");\n\n\t\t\tret_value =\n\t\t\t    maybe_indirect_to_direct(th, inode, page,\n\t\t\t\t\t\t     path, item_key,\n\t\t\t\t\t\t     new_file_size, &mode);\n\t\t\tif (mode == M_SKIP_BALANCING)\n\t\t\t\t/* tail has been left in the unformatted node */\n\t\t\t\treturn ret_value;\n\n\t\t\tis_inode_locked = 1;\n\n\t\t\t/*\n\t\t\t * removing of last unformatted node will\n\t\t\t * change value we have to return to truncate.\n\t\t\t * Save it\n\t\t\t */\n\t\t\tretval2 = ret_value;\n\n\t\t\t/*\n\t\t\t * So, we have performed the first part of the\n\t\t\t * conversion:\n\t\t\t * inserting the new direct item.  Now we are\n\t\t\t * removing the last unformatted node pointer.\n\t\t\t * Set key to search for it.\n\t\t\t */\n\t\t\tset_cpu_key_k_type(item_key, TYPE_INDIRECT);\n\t\t\titem_key->key_length = 4;\n\t\t\tnew_file_size -=\n\t\t\t    (new_file_size & (sb->s_blocksize - 1));\n\t\t\ttail_pos = new_file_size;\n\t\t\tset_cpu_key_k_offset(item_key, new_file_size + 1);\n\t\t\tif (search_for_position_by_key\n\t\t\t    (sb, item_key,\n\t\t\t     path) == POSITION_NOT_FOUND) {\n\t\t\t\tprint_block(PATH_PLAST_BUFFER(path), 3,\n\t\t\t\t\t    PATH_LAST_POSITION(path) - 1,\n\t\t\t\t\t    PATH_LAST_POSITION(path) + 1);\n\t\t\t\treiserfs_panic(sb, \"PAP-5580\", \"item to \"\n\t\t\t\t\t       \"convert does not exist (%K)\",\n\t\t\t\t\t       item_key);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (cut_size == 0) {\n\t\t\tpathrelse(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\ts_cut_balance.insert_size[0] = cut_size;\n\n\t\tret_value = fix_nodes(mode, &s_cut_balance, NULL, NULL);\n\t\tif (ret_value != REPEAT_SEARCH)\n\t\t\tbreak;\n\n\t\tPROC_INFO_INC(sb, cut_from_item_restarted);\n\n\t\tret_value =\n\t\t    search_for_position_by_key(sb, item_key, path);\n\t\tif (ret_value == POSITION_FOUND)\n\t\t\tcontinue;\n\n\t\treiserfs_warning(sb, \"PAP-5610\", \"item %K not found\",\n\t\t\t\t item_key);\n\t\tunfix_nodes(&s_cut_balance);\n\t\treturn (ret_value == IO_ERROR) ? -EIO : -ENOENT;\n\t}\t\t\t/* while */\n\n\t/* check fix_nodes results (IO_ERROR or NO_DISK_SPACE) */\n\tif (ret_value != CARRY_ON) {\n\t\tif (is_inode_locked) {\n\t\t\t/*\n\t\t\t * FIXME: this seems to be not needed: we are always\n\t\t\t * able to cut item\n\t\t\t */\n\t\t\tindirect_to_direct_roll_back(th, inode, path);\n\t\t}\n\t\tif (ret_value == NO_DISK_SPACE)\n\t\t\treiserfs_warning(sb, \"reiserfs-5092\",\n\t\t\t\t\t \"NO_DISK_SPACE\");\n\t\tunfix_nodes(&s_cut_balance);\n\t\treturn -EIO;\n\t}\n\n\t/* go ahead and perform balancing */\n\n\tRFALSE(mode == M_PASTE || mode == M_INSERT, \"invalid mode\");\n\n\t/* Calculate number of bytes that need to be cut from the item. */\n\tquota_cut_bytes =\n\t    (mode ==\n\t     M_DELETE) ? ih_item_len(tp_item_head(path)) : -s_cut_balance.\n\t    insert_size[0];\n\tif (retval2 == -1)\n\t\tret_value = calc_deleted_bytes_number(&s_cut_balance, mode);\n\telse\n\t\tret_value = retval2;\n\n\t/*\n\t * For direct items, we only change the quota when deleting the last\n\t * item.\n\t */\n\tp_le_ih = tp_item_head(s_cut_balance.tb_path);\n\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_le_ih)) {\n\t\tif (mode == M_DELETE &&\n\t\t    (le_ih_k_offset(p_le_ih) & (sb->s_blocksize - 1)) ==\n\t\t    1) {\n\t\t\t/* FIXME: this is to keep 3.5 happy */\n\t\t\tREISERFS_I(inode)->i_first_direct_byte = U32_MAX;\n\t\t\tquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\n\t\t} else {\n\t\t\tquota_cut_bytes = 0;\n\t\t}\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\tif (is_inode_locked) {\n\t\tstruct item_head *le_ih =\n\t\t    tp_item_head(s_cut_balance.tb_path);\n\t\t/*\n\t\t * we are going to complete indirect2direct conversion. Make\n\t\t * sure, that we exactly remove last unformatted node pointer\n\t\t * of the item\n\t\t */\n\t\tif (!is_indirect_le_ih(le_ih))\n\t\t\treiserfs_panic(sb, \"vs-5652\",\n\t\t\t\t       \"item must be indirect %h\", le_ih);\n\n\t\tif (mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)\n\t\t\treiserfs_panic(sb, \"vs-5653\", \"completing \"\n\t\t\t\t       \"indirect2direct conversion indirect \"\n\t\t\t\t       \"item %h being deleted must be of \"\n\t\t\t\t       \"4 byte long\", le_ih);\n\n\t\tif (mode == M_CUT\n\t\t    && s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {\n\t\t\treiserfs_panic(sb, \"vs-5654\", \"can not complete \"\n\t\t\t\t       \"indirect2direct conversion of %h \"\n\t\t\t\t       \"(CUT, insert_size==%d)\",\n\t\t\t\t       le_ih, s_cut_balance.insert_size[0]);\n\t\t}\n\t\t/*\n\t\t * it would be useful to make sure, that right neighboring\n\t\t * item is direct item of this file\n\t\t */\n\t}\n#endif\n\n\tdo_balance(&s_cut_balance, NULL, NULL, mode);\n\tif (is_inode_locked) {\n\t\t/*\n\t\t * we've done an indirect->direct conversion.  when the\n\t\t * data block was freed, it was removed from the list of\n\t\t * blocks that must be flushed before the transaction\n\t\t * commits, make sure to unmap and invalidate it\n\t\t */\n\t\tunmap_buffers(page, tail_pos);\n\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\t}\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota cut_from_item(): freeing %u id=%u type=%c\",\n\t\t       quota_cut_bytes, inode->i_uid, '?');\n#endif\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tdquot_free_space_nodirty(inode, quota_cut_bytes);\n\treiserfs_write_lock_nested(sb, depth);\n\treturn ret_value;\n}\n\nstatic void truncate_directory(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode)\n{\n\tBUG_ON(!th->t_trans_id);\n\tif (inode->i_nlink)\n\t\treiserfs_error(inode->i_sb, \"vs-5655\", \"link count != 0\");\n\n\tset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), DOT_OFFSET);\n\tset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_DIRENTRY);\n\treiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\n\treiserfs_update_sd(th, inode);\n\tset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), SD_OFFSET);\n\tset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_STAT_DATA);\n}\n\n/*\n * Truncate file to the new size. Note, this must be called with a\n * transaction already started\n */\nint reiserfs_do_truncate(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode,\t/* ->i_size contains new size */\n\t\t\t struct page *page,\t/* up to date for last block */\n\t\t\t /*\n\t\t\t  * when it is called by file_release to convert\n\t\t\t  * the tail - no timestamps should be updated\n\t\t\t  */\n\t\t\t int update_timestamps\n    )\n{\n\tINITIALIZE_PATH(s_search_path);\t/* Path to the current object item. */\n\tstruct item_head *p_le_ih;\t/* Pointer to an item header. */\n\n\t/* Key to search for a previous file item. */\n\tstruct cpu_key s_item_key;\n\tloff_t file_size,\t/* Old file size. */\n\t new_file_size;\t/* New file size. */\n\tint deleted;\t\t/* Number of deleted or truncated bytes. */\n\tint retval;\n\tint err = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\tif (!\n\t    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)\n\t     || S_ISLNK(inode->i_mode)))\n\t\treturn 0;\n\n\t/* deletion of directory - no need to update timestamps */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\ttruncate_directory(th, inode);\n\t\treturn 0;\n\t}\n\n\t/* Get new file size. */\n\tnew_file_size = inode->i_size;\n\n\t/* FIXME: note, that key type is unimportant here */\n\tmake_cpu_key(&s_item_key, inode, max_reiserfs_offset(inode),\n\t\t     TYPE_DIRECT, 3);\n\n\tretval =\n\t    search_for_position_by_key(inode->i_sb, &s_item_key,\n\t\t\t\t       &s_search_path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(inode->i_sb, \"vs-5657\",\n\t\t\t       \"i/o failure occurred trying to truncate %K\",\n\t\t\t       &s_item_key);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\tif (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {\n\t\treiserfs_error(inode->i_sb, \"PAP-5660\",\n\t\t\t       \"wrong result %d of search for %K\", retval,\n\t\t\t       &s_item_key);\n\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\ts_search_path.pos_in_item--;\n\n\t/* Get real file size (total length of all file items) */\n\tp_le_ih = tp_item_head(&s_search_path);\n\tif (is_statdata_le_ih(p_le_ih))\n\t\tfile_size = 0;\n\telse {\n\t\tloff_t offset = le_ih_k_offset(p_le_ih);\n\t\tint bytes =\n\t\t    op_bytes_number(p_le_ih, inode->i_sb->s_blocksize);\n\n\t\t/*\n\t\t * this may mismatch with real file size: if last direct item\n\t\t * had no padding zeros and last unformatted node had no free\n\t\t * space, this file would have this file size\n\t\t */\n\t\tfile_size = offset + bytes - 1;\n\t}\n\t/*\n\t * are we doing a full truncate or delete, if so\n\t * kick in the reada code\n\t */\n\tif (new_file_size == 0)\n\t\ts_search_path.reada = PATH_READA | PATH_READA_BACK;\n\n\tif (file_size == 0 || file_size < new_file_size) {\n\t\tgoto update_and_out;\n\t}\n\n\t/* Update key to search for the last file item. */\n\tset_cpu_key_k_offset(&s_item_key, file_size);\n\n\tdo {\n\t\t/* Cut or delete file item. */\n\t\tdeleted =\n\t\t    reiserfs_cut_from_item(th, &s_search_path, &s_item_key,\n\t\t\t\t\t   inode, page, new_file_size);\n\t\tif (deleted < 0) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-5665\",\n\t\t\t\t\t \"reiserfs_cut_from_item failed\");\n\t\t\treiserfs_check_path(&s_search_path);\n\t\t\treturn 0;\n\t\t}\n\n\t\tRFALSE(deleted > file_size,\n\t\t       \"PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K\",\n\t\t       deleted, file_size, &s_item_key);\n\n\t\t/* Change key to search the last file item. */\n\t\tfile_size -= deleted;\n\n\t\tset_cpu_key_k_offset(&s_item_key, file_size);\n\n\t\t/*\n\t\t * While there are bytes to truncate and previous\n\t\t * file item is presented in the tree.\n\t\t */\n\n\t\t/*\n\t\t * This loop could take a really long time, and could log\n\t\t * many more blocks than a transaction can hold.  So, we do\n\t\t * a polite journal end here, and if the transaction needs\n\t\t * ending, we make sure the file is consistent before ending\n\t\t * the current trans and starting a new one\n\t\t */\n\t\tif (journal_transaction_should_end(th, 0) ||\n\t\t    reiserfs_transaction_free_space(th) <= JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {\n\t\t\tpathrelse(&s_search_path);\n\n\t\t\tif (update_timestamps) {\n\t\t\t\tinode->i_mtime = CURRENT_TIME_SEC;\n\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\t}\n\t\t\treiserfs_update_sd(th, inode);\n\n\t\t\terr = journal_end(th);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = journal_begin(th, inode->i_sb,\n\t\t\t\t\t    JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD + JOURNAL_PER_BALANCE_CNT * 4) ;\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\treiserfs_update_inode_transaction(inode);\n\t\t}\n\t} while (file_size > ROUND_UP(new_file_size) &&\n\t\t search_for_position_by_key(inode->i_sb, &s_item_key,\n\t\t\t\t\t    &s_search_path) == POSITION_FOUND);\n\n\tRFALSE(file_size > ROUND_UP(new_file_size),\n\t       \"PAP-5680: truncate did not finish: new_file_size %lld, current %lld, oid %d\",\n\t       new_file_size, file_size, s_item_key.on_disk_key.k_objectid);\n\nupdate_and_out:\n\tif (update_timestamps) {\n\t\t/* this is truncate, not file closing */\n\t\tinode->i_mtime = CURRENT_TIME_SEC;\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t}\n\treiserfs_update_sd(th, inode);\n\nout:\n\tpathrelse(&s_search_path);\n\treturn err;\n}\n\n#ifdef CONFIG_REISERFS_CHECK\n/* this makes sure, that we __append__, not overwrite or add holes */\nstatic void check_research_for_paste(struct treepath *path,\n\t\t\t\t     const struct cpu_key *key)\n{\n\tstruct item_head *found_ih = tp_item_head(path);\n\n\tif (is_direct_le_ih(found_ih)) {\n\t\tif (le_ih_k_offset(found_ih) +\n\t\t    op_bytes_number(found_ih,\n\t\t\t\t    get_last_bh(path)->b_size) !=\n\t\t    cpu_key_k_offset(key)\n\t\t    || op_bytes_number(found_ih,\n\t\t\t\t       get_last_bh(path)->b_size) !=\n\t\t    pos_in_item(path))\n\t\t\treiserfs_panic(NULL, \"PAP-5720\", \"found direct item \"\n\t\t\t\t       \"%h or position (%d) does not match \"\n\t\t\t\t       \"to key %K\", found_ih,\n\t\t\t\t       pos_in_item(path), key);\n\t}\n\tif (is_indirect_le_ih(found_ih)) {\n\t\tif (le_ih_k_offset(found_ih) +\n\t\t    op_bytes_number(found_ih,\n\t\t\t\t    get_last_bh(path)->b_size) !=\n\t\t    cpu_key_k_offset(key)\n\t\t    || I_UNFM_NUM(found_ih) != pos_in_item(path)\n\t\t    || get_ih_free_space(found_ih) != 0)\n\t\t\treiserfs_panic(NULL, \"PAP-5730\", \"found indirect \"\n\t\t\t\t       \"item (%h) or position (%d) does not \"\n\t\t\t\t       \"match to key (%K)\",\n\t\t\t\t       found_ih, pos_in_item(path), key);\n\t}\n}\n#endif\t\t\t\t/* config reiserfs check */\n\n/*\n * Paste bytes to the existing item.\n * Returns bytes number pasted into the item.\n */\nint reiserfs_paste_into_item(struct reiserfs_transaction_handle *th,\n\t\t\t     /* Path to the pasted item. */\n\t\t\t     struct treepath *search_path,\n\t\t\t     /* Key to search for the needed item. */\n\t\t\t     const struct cpu_key *key,\n\t\t\t     /* Inode item belongs to */\n\t\t\t     struct inode *inode,\n\t\t\t     /* Pointer to the bytes to paste. */\n\t\t\t     const char *body,\n\t\t\t     /* Size of pasted bytes. */\n\t\t\t     int pasted_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct tree_balance s_paste_balance;\n\tint retval;\n\tint fs_gen;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tfs_gen = get_generation(inode->i_sb);\n\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota paste_into_item(): allocating %u id=%u type=%c\",\n\t\t       pasted_size, inode->i_uid,\n\t\t       key2type(&key->on_disk_key));\n#endif\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tretval = dquot_alloc_space_nodirty(inode, pasted_size);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (retval) {\n\t\tpathrelse(search_path);\n\t\treturn retval;\n\t}\n\tinit_tb_struct(th, &s_paste_balance, th->t_super, search_path,\n\t\t       pasted_size);\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\ts_paste_balance.key = key->on_disk_key;\n#endif\n\n\t/* DQUOT_* can schedule, must check before the fix_nodes */\n\tif (fs_changed(fs_gen, inode->i_sb)) {\n\t\tgoto search_again;\n\t}\n\n\twhile ((retval =\n\t\tfix_nodes(M_PASTE, &s_paste_balance, NULL,\n\t\t\t  body)) == REPEAT_SEARCH) {\nsearch_again:\n\t\t/* file system changed while we were in the fix_nodes */\n\t\tPROC_INFO_INC(th->t_super, paste_into_item_restarted);\n\t\tretval =\n\t\t    search_for_position_by_key(th->t_super, key,\n\t\t\t\t\t       search_path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"PAP-5710\",\n\t\t\t\t\t \"entry or pasted byte (%K) exists\",\n\t\t\t\t\t key);\n\t\t\tretval = -EEXIST;\n\t\t\tgoto error_out;\n\t\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t\tcheck_research_for_paste(search_path, key);\n#endif\n\t}\n\n\t/*\n\t * Perform balancing after all resources are collected by fix_nodes,\n\t * and accessing them will not risk triggering schedule.\n\t */\n\tif (retval == CARRY_ON) {\n\t\tdo_balance(&s_paste_balance, NULL /*ih */ , body, M_PASTE);\n\t\treturn 0;\n\t}\n\tretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\nerror_out:\n\t/* this also releases the path */\n\tunfix_nodes(&s_paste_balance);\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota paste_into_item(): freeing %u id=%u type=%c\",\n\t\t       pasted_size, inode->i_uid,\n\t\t       key2type(&key->on_disk_key));\n#endif\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tdquot_free_space_nodirty(inode, pasted_size);\n\treiserfs_write_lock_nested(sb, depth);\n\treturn retval;\n}\n\n/*\n * Insert new item into the buffer at the path.\n * th   - active transaction handle\n * path - path to the inserted item\n * ih   - pointer to the item header to insert\n * body - pointer to the bytes to insert\n */\nint reiserfs_insert_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path, const struct cpu_key *key,\n\t\t\t struct item_head *ih, struct inode *inode,\n\t\t\t const char *body)\n{\n\tstruct tree_balance s_ins_balance;\n\tint retval;\n\tint fs_gen = 0;\n\tint quota_bytes = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tif (inode) {\t\t/* Do we count quotas for item? */\n\t\tint depth;\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\tquota_bytes = ih_item_len(ih);\n\n\t\t/*\n\t\t * hack so the quota code doesn't have to guess\n\t\t * if the file has a tail, links are always tails,\n\t\t * so there's no guessing needed\n\t\t */\n\t\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(ih))\n\t\t\tquota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE;\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota insert_item(): allocating %u id=%u type=%c\",\n\t\t\t       quota_bytes, inode->i_uid, head2type(ih));\n#endif\n\t\t/*\n\t\t * We can't dirty inode here. It would be immediately\n\t\t * written but appropriate stat item isn't inserted yet...\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tretval = dquot_alloc_space_nodirty(inode, quota_bytes);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\tif (retval) {\n\t\t\tpathrelse(path);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tinit_tb_struct(th, &s_ins_balance, th->t_super, path,\n\t\t       IH_SIZE + ih_item_len(ih));\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\ts_ins_balance.key = key->on_disk_key;\n#endif\n\t/*\n\t * DQUOT_* can schedule, must check to be sure calling\n\t * fix_nodes is safe\n\t */\n\tif (inode && fs_changed(fs_gen, inode->i_sb)) {\n\t\tgoto search_again;\n\t}\n\n\twhile ((retval =\n\t\tfix_nodes(M_INSERT, &s_ins_balance, ih,\n\t\t\t  body)) == REPEAT_SEARCH) {\nsearch_again:\n\t\t/* file system changed while we were in the fix_nodes */\n\t\tPROC_INFO_INC(th->t_super, insert_item_restarted);\n\t\tretval = search_item(th->t_super, key, path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tif (retval == ITEM_FOUND) {\n\t\t\treiserfs_warning(th->t_super, \"PAP-5760\",\n\t\t\t\t\t \"key %K already exists in the tree\",\n\t\t\t\t\t key);\n\t\t\tretval = -EEXIST;\n\t\t\tgoto error_out;\n\t\t}\n\t}\n\n\t/* make balancing after all resources will be collected at a time */\n\tif (retval == CARRY_ON) {\n\t\tdo_balance(&s_ins_balance, ih, body, M_INSERT);\n\t\treturn 0;\n\t}\n\n\tretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\nerror_out:\n\t/* also releases the path */\n\tunfix_nodes(&s_ins_balance);\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota insert_item(): freeing %u id=%u type=%c\",\n\t\t       quota_bytes, inode->i_uid, head2type(ih));\n#endif\n\tif (inode) {\n\t\tint depth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tdquot_free_space_nodirty(inode, quota_bytes);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "head2type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "1211-1222",
    "snippet": "char head2type(struct item_head *ih)\n{\n\tif (is_direntry_le_ih(ih))\n\t\treturn 'd';\n\tif (is_direct_le_ih(ih))\n\t\treturn 'D';\n\tif (is_indirect_le_ih(ih))\n\t\treturn 'i';\n\tif (is_statdata_le_ih(ih))\n\t\treturn 's';\n\treturn 'u';\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_statdata_le_ih",
          "args": [
            "ih"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "is_statdata_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1577-1580",
          "snippet": "static inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "ih"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direct_le_ih",
          "args": [
            "ih"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "is_direct_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1567-1570",
          "snippet": "static inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "ih"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nchar head2type(struct item_head *ih)\n{\n\tif (is_direntry_le_ih(ih))\n\t\treturn 'd';\n\tif (is_direct_le_ih(ih))\n\t\treturn 'D';\n\tif (is_indirect_le_ih(ih))\n\t\treturn 'i';\n\tif (is_statdata_le_ih(ih))\n\t\treturn 's';\n\treturn 'u';\n}"
  },
  {
    "function_name": "key2type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "1198-1209",
    "snippet": "char key2type(struct reiserfs_key *ih)\n{\n\tif (is_direntry_le_key(2, ih))\n\t\treturn 'd';\n\tif (is_direct_le_key(2, ih))\n\t\treturn 'D';\n\tif (is_indirect_le_key(2, ih))\n\t\treturn 'i';\n\tif (is_statdata_le_key(2, ih))\n\t\treturn 's';\n\treturn 'u';\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_statdata_le_key",
          "args": [
            "2",
            "ih"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "is_statdata_le_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1556-1559",
          "snippet": "static inline int is_statdata_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_STAT_DATA;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_STAT_DATA 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_STAT_DATA 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int is_statdata_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_STAT_DATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_indirect_le_key",
          "args": [
            "2",
            "ih"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1551-1554",
          "snippet": "static inline int is_indirect_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_INDIRECT;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_INDIRECT 1"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_INDIRECT 1\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int is_indirect_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_INDIRECT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direct_le_key",
          "args": [
            "2",
            "ih"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "is_direct_le_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1546-1549",
          "snippet": "static inline int is_direct_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRECT;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_DIRECT 2"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_DIRECT 2\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int is_direct_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRECT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_key",
          "args": [
            "2",
            "ih"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1541-1544",
          "snippet": "static inline int is_direntry_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRENTRY;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_DIRENTRY 3"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_DIRENTRY 3\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int is_direntry_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRENTRY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nchar key2type(struct reiserfs_key *ih)\n{\n\tif (is_direntry_le_key(2, ih))\n\t\treturn 'd';\n\tif (is_direct_le_key(2, ih))\n\t\treturn 'D';\n\tif (is_indirect_le_key(2, ih))\n\t\treturn 'i';\n\tif (is_statdata_le_key(2, ih))\n\t\treturn 's';\n\treturn 'u';\n}"
  },
  {
    "function_name": "padd_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "1189-1195",
    "snippet": "void padd_item(char *item, int total_length, int length)\n{\n\tint i;\n\n\tfor (i = total_length; i > length;)\n\t\titem[--i] = 0;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid padd_item(char *item, int total_length, int length)\n{\n\tint i;\n\n\tfor (i = total_length; i > length;)\n\t\titem[--i] = 0;\n}"
  },
  {
    "function_name": "init_tb_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "1172-1187",
    "snippet": "static void init_tb_struct(struct reiserfs_transaction_handle *th,\n\t\t\t   struct tree_balance *tb,\n\t\t\t   struct super_block *sb,\n\t\t\t   struct treepath *path, int size)\n{\n\n\tBUG_ON(!th->t_trans_id);\n\n\tmemset(tb, '\\0', sizeof(struct tree_balance));\n\ttb->transaction_handle = th;\n\ttb->tb_sb = sb;\n\ttb->tb_path = path;\n\tPATH_OFFSET_PBUFFER(path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;\n\tPATH_OFFSET_POSITION(path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;\n\ttb->insert_size[0] = size;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PATH_OFFSET_POSITION",
          "args": [
            "path",
            "ILLEGAL_PATH_ELEMENT_OFFSET"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "path",
            "ILLEGAL_PATH_ELEMENT_OFFSET"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tb",
            "'\\0'",
            "sizeof(struct tree_balance)"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic void init_tb_struct(struct reiserfs_transaction_handle *th,\n\t\t\t   struct tree_balance *tb,\n\t\t\t   struct super_block *sb,\n\t\t\t   struct treepath *path, int size)\n{\n\n\tBUG_ON(!th->t_trans_id);\n\n\tmemset(tb, '\\0', sizeof(struct tree_balance));\n\ttb->transaction_handle = th;\n\ttb->tb_sb = sb;\n\ttb->tb_path = path;\n\tPATH_OFFSET_PBUFFER(path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;\n\tPATH_OFFSET_POSITION(path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;\n\ttb->insert_size[0] = size;\n}"
  },
  {
    "function_name": "calc_deleted_bytes_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "1146-1170",
    "snippet": "static int calc_deleted_bytes_number(struct tree_balance *tb, char mode)\n{\n\tint del_size;\n\tstruct item_head *p_le_ih = tp_item_head(tb->tb_path);\n\n\tif (is_statdata_le_ih(p_le_ih))\n\t\treturn 0;\n\n\tdel_size =\n\t    (mode ==\n\t     M_DELETE) ? ih_item_len(p_le_ih) : -tb->insert_size[0];\n\tif (is_direntry_le_ih(p_le_ih)) {\n\t\t/*\n\t\t * return EMPTY_DIR_SIZE; We delete emty directories only.\n\t\t * we can't use EMPTY_DIR_SIZE, as old format dirs have a\n\t\t * different empty size.  ick. FIXME, is this right?\n\t\t */\n\t\treturn del_size;\n\t}\n\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tdel_size = (del_size / UNFM_P_SIZE) *\n\t\t\t\t(PATH_PLAST_BUFFER(tb->tb_path)->b_size);\n\treturn del_size;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "p_le_ih"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "p_le_ih"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "p_le_ih"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_statdata_le_ih",
          "args": [
            "p_le_ih"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "is_statdata_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1577-1580",
          "snippet": "static inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "tb->tb_path"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int calc_deleted_bytes_number(struct tree_balance *tb, char mode)\n{\n\tint del_size;\n\tstruct item_head *p_le_ih = tp_item_head(tb->tb_path);\n\n\tif (is_statdata_le_ih(p_le_ih))\n\t\treturn 0;\n\n\tdel_size =\n\t    (mode ==\n\t     M_DELETE) ? ih_item_len(p_le_ih) : -tb->insert_size[0];\n\tif (is_direntry_le_ih(p_le_ih)) {\n\t\t/*\n\t\t * return EMPTY_DIR_SIZE; We delete emty directories only.\n\t\t * we can't use EMPTY_DIR_SIZE, as old format dirs have a\n\t\t * different empty size.  ick. FIXME, is this right?\n\t\t */\n\t\treturn del_size;\n\t}\n\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tdel_size = (del_size / UNFM_P_SIZE) *\n\t\t\t\t(PATH_PLAST_BUFFER(tb->tb_path)->b_size);\n\treturn del_size;\n}"
  },
  {
    "function_name": "prepare_for_delete_or_cut",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "1016-1143",
    "snippet": "static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode,\n\t\t\t\t      struct treepath *path,\n\t\t\t\t      const struct cpu_key *item_key,\n\t\t\t\t      /*\n\t\t\t\t       * Number of unformatted nodes\n\t\t\t\t       * which were removed from end\n\t\t\t\t       * of the file.\n\t\t\t\t       */\n\t\t\t\t      int *removed,\n\t\t\t\t      int *cut_size,\n\t\t\t\t      /* MAX_KEY_OFFSET in case of delete. */\n\t\t\t\t      unsigned long long new_file_length\n    )\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct item_head *p_le_ih = tp_item_head(path);\n\tstruct buffer_head *bh = PATH_PLAST_BUFFER(path);\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* Stat_data item. */\n\tif (is_statdata_le_ih(p_le_ih)) {\n\n\t\tRFALSE(new_file_length != max_reiserfs_offset(inode),\n\t\t       \"PAP-5210: mode must be M_DELETE\");\n\n\t\t*cut_size = -(IH_SIZE + ih_item_len(p_le_ih));\n\t\treturn M_DELETE;\n\t}\n\n\t/* Directory item. */\n\tif (is_direntry_le_ih(p_le_ih))\n\t\treturn prepare_for_direntry_item(path, p_le_ih, inode,\n\t\t\t\t\t\t new_file_length,\n\t\t\t\t\t\t cut_size);\n\n\t/* Direct item. */\n\tif (is_direct_le_ih(p_le_ih))\n\t\treturn prepare_for_direct_item(path, p_le_ih, inode,\n\t\t\t\t\t       new_file_length, cut_size);\n\n\t/* Case of an indirect item. */\n\t{\n\t    int blk_size = sb->s_blocksize;\n\t    struct item_head s_ih;\n\t    int need_re_search;\n\t    int delete = 0;\n\t    int result = M_CUT;\n\t    int pos = 0;\n\n\t    if ( new_file_length == max_reiserfs_offset (inode) ) {\n\t\t/*\n\t\t * prepare_for_delete_or_cut() is called by\n\t\t * reiserfs_delete_item()\n\t\t */\n\t\tnew_file_length = 0;\n\t\tdelete = 1;\n\t    }\n\n\t    do {\n\t\tneed_re_search = 0;\n\t\t*cut_size = 0;\n\t\tbh = PATH_PLAST_BUFFER(path);\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n\t\tpos = I_UNFM_NUM(&s_ih);\n\n\t\twhile (le_ih_k_offset (&s_ih) + (pos - 1) * blk_size > new_file_length) {\n\t\t    __le32 *unfm;\n\t\t    __u32 block;\n\n\t\t    /*\n\t\t     * Each unformatted block deletion may involve\n\t\t     * one additional bitmap block into the transaction,\n\t\t     * thereby the initial journal space reservation\n\t\t     * might not be enough.\n\t\t     */\n\t\t    if (!delete && (*cut_size) != 0 &&\n\t\t\treiserfs_transaction_free_space(th) < JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD)\n\t\t\tbreak;\n\n\t\t    unfm = (__le32 *)ih_item_body(bh, &s_ih) + pos - 1;\n\t\t    block = get_block_num(unfm, 0);\n\n\t\t    if (block != 0) {\n\t\t\treiserfs_prepare_for_journal(sb, bh, 1);\n\t\t\tput_block_num(unfm, 0, 0);\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_free_block(th, inode, block, 1);\n\t\t    }\n\n\t\t    reiserfs_cond_resched(sb);\n\n\t\t    if (item_moved (&s_ih, path))  {\n\t\t\tneed_re_search = 1;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    pos --;\n\t\t    (*removed)++;\n\t\t    (*cut_size) -= UNFM_P_SIZE;\n\n\t\t    if (pos == 0) {\n\t\t\t(*cut_size) -= IH_SIZE;\n\t\t\tresult = M_DELETE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t/*\n\t\t * a trick.  If the buffer has been logged, this will\n\t\t * do nothing.  If we've broken the loop without logging\n\t\t * it, it will restore the buffer\n\t\t */\n\t\treiserfs_restore_prepared_buffer(sb, bh);\n\t    } while (need_re_search &&\n\t\t     search_for_position_by_key(sb, item_key, path) == POSITION_FOUND);\n\t    pos_in_item(path) = pos * UNFM_P_SIZE;\n\n\t    if (*cut_size == 0) {\n\t\t/*\n\t\t * Nothing was cut. maybe convert last unformatted node to the\n\t\t * direct item?\n\t\t */\n\t\tresult = M_CONVERT;\n\t    }\n\t    return result;\n\t}\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD (2 * JOURNAL_PER_BALANCE_CNT + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "path"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_for_position_by_key",
          "args": [
            "sb",
            "item_key",
            "path"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "search_for_position_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "830-903",
          "snippet": "int search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_restore_prepared_buffer",
          "args": [
            "sb",
            "bh"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_restore_prepared_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3920-3942",
          "snippet": "void reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_moved",
          "args": [
            "&s_ih",
            "path"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_cond_resched",
          "args": [
            "sb"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "843-852",
          "snippet": "static inline void reiserfs_cond_resched(struct super_block *s)\n{\n\tif (need_resched()) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "void reiserfs_write_lock_nested(struct super_block *s, int depth);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void reiserfs_cond_resched(struct super_block *s)\n{\n\tif (need_resched()) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_free_block",
          "args": [
            "th",
            "inode",
            "block",
            "1"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "467-488",
          "snippet": "void reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "th",
            "bh"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_block_num",
          "args": [
            "unfm",
            "0",
            "0"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "sb",
            "bh",
            "1"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_block_num",
          "args": [
            "unfm",
            "0"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_body",
          "args": [
            "bh",
            "&s_ih"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "ih_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2213-2217",
          "snippet": "static inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_transaction_free_space",
          "args": [
            "th"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_transaction_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2906-2909",
          "snippet": "static inline int reiserfs_transaction_free_space(struct reiserfs_transaction_handle *th)\n{\n\treturn th->t_blocks_allocated - th->t_blocks_logged;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\n\nstatic inline int reiserfs_transaction_free_space(struct reiserfs_transaction_handle *th)\n{\n\treturn th->t_blocks_allocated - th->t_blocks_logged;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "&s_ih"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "I_UNFM_NUM",
          "args": [
            "&s_ih"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_item_head",
          "args": [
            "&s_ih",
            "tp_item_head(path)"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "copy_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "29-33",
          "snippet": "inline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "path"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "path"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_reiserfs_offset",
          "args": [
            "inode"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "max_reiserfs_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2280-2286",
          "snippet": "static inline loff_t max_reiserfs_offset(struct inode *inode)\n{\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)\n\t\treturn (loff_t) U32_MAX;\n\n\treturn (loff_t) ((~(__u64) 0) >> 4);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t max_reiserfs_offset(struct inode *inode)\n{\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)\n\t\treturn (loff_t) U32_MAX;\n\n\treturn (loff_t) ((~(__u64) 0) >> 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_for_direct_item",
          "args": [
            "path",
            "p_le_ih",
            "inode",
            "new_file_length",
            "cut_size"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_for_direct_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "931-970",
          "snippet": "static inline int prepare_for_direct_item(struct treepath *path,\n\t\t\t\t\t  struct item_head *le_ih,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  loff_t new_file_length, int *cut_size)\n{\n\tloff_t round_len;\n\n\tif (new_file_length == max_reiserfs_offset(inode)) {\n\t\t/* item has to be deleted */\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\n\t}\n\t/* new file gets truncated */\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_6) {\n\t\tround_len = ROUND_UP(new_file_length);\n\t\t/* this was new_file_length < le_ih ... */\n\t\tif (round_len < le_ih_k_offset(le_ih)) {\n\t\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\t\treturn M_DELETE;\t/* Delete this item. */\n\t\t}\n\t\t/* Calculate first position and size for cutting from item. */\n\t\tpos_in_item(path) = round_len - (le_ih_k_offset(le_ih) - 1);\n\t\t*cut_size = -(ih_item_len(le_ih) - pos_in_item(path));\n\n\t\treturn M_CUT;\t/* Cut from this item. */\n\t}\n\n\t/* old file: items may have any length */\n\n\tif (new_file_length < le_ih_k_offset(le_ih)) {\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\t/* Delete this item. */\n\t}\n\n\t/* Calculate first position and size for cutting from item. */\n\t*cut_size = -(ih_item_len(le_ih) -\n\t\t      (pos_in_item(path) =\n\t\t       new_file_length + 1 - le_ih_k_offset(le_ih)));\n\treturn M_CUT;\t\t/* Cut from this item. */\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int prepare_for_direct_item(struct treepath *path,\n\t\t\t\t\t  struct item_head *le_ih,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  loff_t new_file_length, int *cut_size)\n{\n\tloff_t round_len;\n\n\tif (new_file_length == max_reiserfs_offset(inode)) {\n\t\t/* item has to be deleted */\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\n\t}\n\t/* new file gets truncated */\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_6) {\n\t\tround_len = ROUND_UP(new_file_length);\n\t\t/* this was new_file_length < le_ih ... */\n\t\tif (round_len < le_ih_k_offset(le_ih)) {\n\t\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\t\treturn M_DELETE;\t/* Delete this item. */\n\t\t}\n\t\t/* Calculate first position and size for cutting from item. */\n\t\tpos_in_item(path) = round_len - (le_ih_k_offset(le_ih) - 1);\n\t\t*cut_size = -(ih_item_len(le_ih) - pos_in_item(path));\n\n\t\treturn M_CUT;\t/* Cut from this item. */\n\t}\n\n\t/* old file: items may have any length */\n\n\tif (new_file_length < le_ih_k_offset(le_ih)) {\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\t/* Delete this item. */\n\t}\n\n\t/* Calculate first position and size for cutting from item. */\n\t*cut_size = -(ih_item_len(le_ih) -\n\t\t      (pos_in_item(path) =\n\t\t       new_file_length + 1 - le_ih_k_offset(le_ih)));\n\treturn M_CUT;\t\t/* Cut from this item. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direct_le_ih",
          "args": [
            "p_le_ih"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "is_direct_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1567-1570",
          "snippet": "static inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_for_direntry_item",
          "args": [
            "path",
            "p_le_ih",
            "inode",
            "new_file_length",
            "cut_size"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_for_direntry_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "972-1001",
          "snippet": "static inline int prepare_for_direntry_item(struct treepath *path,\n\t\t\t\t\t    struct item_head *le_ih,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    loff_t new_file_length,\n\t\t\t\t\t    int *cut_size)\n{\n\tif (le_ih_k_offset(le_ih) == DOT_OFFSET &&\n\t    new_file_length == max_reiserfs_offset(inode)) {\n\t\tRFALSE(ih_entry_count(le_ih) != 2,\n\t\t       \"PAP-5220: incorrect empty directory item (%h)\", le_ih);\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\t/* Delete the directory item containing \".\" and \"..\" entry. */\n\t\treturn M_DELETE;\n\t}\n\n\tif (ih_entry_count(le_ih) == 1) {\n\t\t/*\n\t\t * Delete the directory item such as there is one record only\n\t\t * in this item\n\t\t */\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\n\t}\n\n\t/* Cut one record from the directory item. */\n\t*cut_size =\n\t    -(DEH_SIZE +\n\t      entry_length(get_last_bh(path), le_ih, pos_in_item(path)));\n\treturn M_CUT;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int prepare_for_direntry_item(struct treepath *path,\n\t\t\t\t\t    struct item_head *le_ih,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    loff_t new_file_length,\n\t\t\t\t\t    int *cut_size)\n{\n\tif (le_ih_k_offset(le_ih) == DOT_OFFSET &&\n\t    new_file_length == max_reiserfs_offset(inode)) {\n\t\tRFALSE(ih_entry_count(le_ih) != 2,\n\t\t       \"PAP-5220: incorrect empty directory item (%h)\", le_ih);\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\t/* Delete the directory item containing \".\" and \"..\" entry. */\n\t\treturn M_DELETE;\n\t}\n\n\tif (ih_entry_count(le_ih) == 1) {\n\t\t/*\n\t\t * Delete the directory item such as there is one record only\n\t\t * in this item\n\t\t */\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\n\t}\n\n\t/* Cut one record from the directory item. */\n\t*cut_size =\n\t    -(DEH_SIZE +\n\t      entry_length(get_last_bh(path), le_ih, pos_in_item(path)));\n\treturn M_CUT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "p_le_ih"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "p_le_ih"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "new_file_length != max_reiserfs_offset(inode)",
            "\"PAP-5210: mode must be M_DELETE\""
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_statdata_le_ih",
          "args": [
            "p_le_ih"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "is_statdata_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1577-1580",
          "snippet": "static inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "path"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\n#define JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD (2 * JOURNAL_PER_BALANCE_CNT + 1)\n\nstatic char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode,\n\t\t\t\t      struct treepath *path,\n\t\t\t\t      const struct cpu_key *item_key,\n\t\t\t\t      /*\n\t\t\t\t       * Number of unformatted nodes\n\t\t\t\t       * which were removed from end\n\t\t\t\t       * of the file.\n\t\t\t\t       */\n\t\t\t\t      int *removed,\n\t\t\t\t      int *cut_size,\n\t\t\t\t      /* MAX_KEY_OFFSET in case of delete. */\n\t\t\t\t      unsigned long long new_file_length\n    )\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct item_head *p_le_ih = tp_item_head(path);\n\tstruct buffer_head *bh = PATH_PLAST_BUFFER(path);\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* Stat_data item. */\n\tif (is_statdata_le_ih(p_le_ih)) {\n\n\t\tRFALSE(new_file_length != max_reiserfs_offset(inode),\n\t\t       \"PAP-5210: mode must be M_DELETE\");\n\n\t\t*cut_size = -(IH_SIZE + ih_item_len(p_le_ih));\n\t\treturn M_DELETE;\n\t}\n\n\t/* Directory item. */\n\tif (is_direntry_le_ih(p_le_ih))\n\t\treturn prepare_for_direntry_item(path, p_le_ih, inode,\n\t\t\t\t\t\t new_file_length,\n\t\t\t\t\t\t cut_size);\n\n\t/* Direct item. */\n\tif (is_direct_le_ih(p_le_ih))\n\t\treturn prepare_for_direct_item(path, p_le_ih, inode,\n\t\t\t\t\t       new_file_length, cut_size);\n\n\t/* Case of an indirect item. */\n\t{\n\t    int blk_size = sb->s_blocksize;\n\t    struct item_head s_ih;\n\t    int need_re_search;\n\t    int delete = 0;\n\t    int result = M_CUT;\n\t    int pos = 0;\n\n\t    if ( new_file_length == max_reiserfs_offset (inode) ) {\n\t\t/*\n\t\t * prepare_for_delete_or_cut() is called by\n\t\t * reiserfs_delete_item()\n\t\t */\n\t\tnew_file_length = 0;\n\t\tdelete = 1;\n\t    }\n\n\t    do {\n\t\tneed_re_search = 0;\n\t\t*cut_size = 0;\n\t\tbh = PATH_PLAST_BUFFER(path);\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n\t\tpos = I_UNFM_NUM(&s_ih);\n\n\t\twhile (le_ih_k_offset (&s_ih) + (pos - 1) * blk_size > new_file_length) {\n\t\t    __le32 *unfm;\n\t\t    __u32 block;\n\n\t\t    /*\n\t\t     * Each unformatted block deletion may involve\n\t\t     * one additional bitmap block into the transaction,\n\t\t     * thereby the initial journal space reservation\n\t\t     * might not be enough.\n\t\t     */\n\t\t    if (!delete && (*cut_size) != 0 &&\n\t\t\treiserfs_transaction_free_space(th) < JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD)\n\t\t\tbreak;\n\n\t\t    unfm = (__le32 *)ih_item_body(bh, &s_ih) + pos - 1;\n\t\t    block = get_block_num(unfm, 0);\n\n\t\t    if (block != 0) {\n\t\t\treiserfs_prepare_for_journal(sb, bh, 1);\n\t\t\tput_block_num(unfm, 0, 0);\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_free_block(th, inode, block, 1);\n\t\t    }\n\n\t\t    reiserfs_cond_resched(sb);\n\n\t\t    if (item_moved (&s_ih, path))  {\n\t\t\tneed_re_search = 1;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    pos --;\n\t\t    (*removed)++;\n\t\t    (*cut_size) -= UNFM_P_SIZE;\n\n\t\t    if (pos == 0) {\n\t\t\t(*cut_size) -= IH_SIZE;\n\t\t\tresult = M_DELETE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t/*\n\t\t * a trick.  If the buffer has been logged, this will\n\t\t * do nothing.  If we've broken the loop without logging\n\t\t * it, it will restore the buffer\n\t\t */\n\t\treiserfs_restore_prepared_buffer(sb, bh);\n\t    } while (need_re_search &&\n\t\t     search_for_position_by_key(sb, item_key, path) == POSITION_FOUND);\n\t    pos_in_item(path) = pos * UNFM_P_SIZE;\n\n\t    if (*cut_size == 0) {\n\t\t/*\n\t\t * Nothing was cut. maybe convert last unformatted node to the\n\t\t * direct item?\n\t\t */\n\t\tresult = M_CONVERT;\n\t    }\n\t    return result;\n\t}\n}"
  },
  {
    "function_name": "prepare_for_direntry_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "972-1001",
    "snippet": "static inline int prepare_for_direntry_item(struct treepath *path,\n\t\t\t\t\t    struct item_head *le_ih,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    loff_t new_file_length,\n\t\t\t\t\t    int *cut_size)\n{\n\tif (le_ih_k_offset(le_ih) == DOT_OFFSET &&\n\t    new_file_length == max_reiserfs_offset(inode)) {\n\t\tRFALSE(ih_entry_count(le_ih) != 2,\n\t\t       \"PAP-5220: incorrect empty directory item (%h)\", le_ih);\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\t/* Delete the directory item containing \".\" and \"..\" entry. */\n\t\treturn M_DELETE;\n\t}\n\n\tif (ih_entry_count(le_ih) == 1) {\n\t\t/*\n\t\t * Delete the directory item such as there is one record only\n\t\t * in this item\n\t\t */\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\n\t}\n\n\t/* Cut one record from the directory item. */\n\t*cut_size =\n\t    -(DEH_SIZE +\n\t      entry_length(get_last_bh(path), le_ih, pos_in_item(path)));\n\treturn M_CUT;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "entry_length",
          "args": [
            "get_last_bh(path)",
            "le_ih",
            "pos_in_item(path)"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "entry_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2252-2262",
          "snippet": "static inline int entry_length(const struct buffer_head *bh,\n\t\t\t       const struct item_head *ih, int pos_in_item)\n{\n\tstruct reiserfs_de_head *deh;\n\n\tdeh = B_I_DEH(bh, ih) + pos_in_item;\n\tif (pos_in_item)\n\t\treturn deh_location(deh - 1) - deh_location(deh);\n\n\treturn ih_item_len(ih) - deh_location(deh);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline int entry_length(const struct buffer_head *bh,\n\t\t\t       const struct item_head *ih, int pos_in_item)\n{\n\tstruct reiserfs_de_head *deh;\n\n\tdeh = B_I_DEH(bh, ih) + pos_in_item;\n\tif (pos_in_item)\n\t\treturn deh_location(deh - 1) - deh_location(deh);\n\n\treturn ih_item_len(ih) - deh_location(deh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "path"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_last_bh",
          "args": [
            "path"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "le_ih"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "le_ih"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "le_ih"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "ih_entry_count(le_ih) != 2",
            "\"PAP-5220: incorrect empty directory item (%h)\"",
            "le_ih"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "le_ih"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_reiserfs_offset",
          "args": [
            "inode"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "max_reiserfs_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2280-2286",
          "snippet": "static inline loff_t max_reiserfs_offset(struct inode *inode)\n{\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)\n\t\treturn (loff_t) U32_MAX;\n\n\treturn (loff_t) ((~(__u64) 0) >> 4);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t max_reiserfs_offset(struct inode *inode)\n{\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)\n\t\treturn (loff_t) U32_MAX;\n\n\treturn (loff_t) ((~(__u64) 0) >> 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "le_ih"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int prepare_for_direntry_item(struct treepath *path,\n\t\t\t\t\t    struct item_head *le_ih,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    loff_t new_file_length,\n\t\t\t\t\t    int *cut_size)\n{\n\tif (le_ih_k_offset(le_ih) == DOT_OFFSET &&\n\t    new_file_length == max_reiserfs_offset(inode)) {\n\t\tRFALSE(ih_entry_count(le_ih) != 2,\n\t\t       \"PAP-5220: incorrect empty directory item (%h)\", le_ih);\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\t/* Delete the directory item containing \".\" and \"..\" entry. */\n\t\treturn M_DELETE;\n\t}\n\n\tif (ih_entry_count(le_ih) == 1) {\n\t\t/*\n\t\t * Delete the directory item such as there is one record only\n\t\t * in this item\n\t\t */\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\n\t}\n\n\t/* Cut one record from the directory item. */\n\t*cut_size =\n\t    -(DEH_SIZE +\n\t      entry_length(get_last_bh(path), le_ih, pos_in_item(path)));\n\treturn M_CUT;\n}"
  },
  {
    "function_name": "prepare_for_direct_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "931-970",
    "snippet": "static inline int prepare_for_direct_item(struct treepath *path,\n\t\t\t\t\t  struct item_head *le_ih,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  loff_t new_file_length, int *cut_size)\n{\n\tloff_t round_len;\n\n\tif (new_file_length == max_reiserfs_offset(inode)) {\n\t\t/* item has to be deleted */\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\n\t}\n\t/* new file gets truncated */\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_6) {\n\t\tround_len = ROUND_UP(new_file_length);\n\t\t/* this was new_file_length < le_ih ... */\n\t\tif (round_len < le_ih_k_offset(le_ih)) {\n\t\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\t\treturn M_DELETE;\t/* Delete this item. */\n\t\t}\n\t\t/* Calculate first position and size for cutting from item. */\n\t\tpos_in_item(path) = round_len - (le_ih_k_offset(le_ih) - 1);\n\t\t*cut_size = -(ih_item_len(le_ih) - pos_in_item(path));\n\n\t\treturn M_CUT;\t/* Cut from this item. */\n\t}\n\n\t/* old file: items may have any length */\n\n\tif (new_file_length < le_ih_k_offset(le_ih)) {\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\t/* Delete this item. */\n\t}\n\n\t/* Calculate first position and size for cutting from item. */\n\t*cut_size = -(ih_item_len(le_ih) -\n\t\t      (pos_in_item(path) =\n\t\t       new_file_length + 1 - le_ih_k_offset(le_ih)));\n\treturn M_CUT;\t\t/* Cut from this item. */\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "le_ih"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "path"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "le_ih"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "le_ih"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "path"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "le_ih"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "path"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "le_ih"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND_UP",
          "args": [
            "new_file_length"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_inode_item_key_version",
          "args": [
            "inode"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "le_ih"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_reiserfs_offset",
          "args": [
            "inode"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "max_reiserfs_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2280-2286",
          "snippet": "static inline loff_t max_reiserfs_offset(struct inode *inode)\n{\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)\n\t\treturn (loff_t) U32_MAX;\n\n\treturn (loff_t) ((~(__u64) 0) >> 4);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t max_reiserfs_offset(struct inode *inode)\n{\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)\n\t\treturn (loff_t) U32_MAX;\n\n\treturn (loff_t) ((~(__u64) 0) >> 4);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int prepare_for_direct_item(struct treepath *path,\n\t\t\t\t\t  struct item_head *le_ih,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  loff_t new_file_length, int *cut_size)\n{\n\tloff_t round_len;\n\n\tif (new_file_length == max_reiserfs_offset(inode)) {\n\t\t/* item has to be deleted */\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\n\t}\n\t/* new file gets truncated */\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_6) {\n\t\tround_len = ROUND_UP(new_file_length);\n\t\t/* this was new_file_length < le_ih ... */\n\t\tif (round_len < le_ih_k_offset(le_ih)) {\n\t\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\t\treturn M_DELETE;\t/* Delete this item. */\n\t\t}\n\t\t/* Calculate first position and size for cutting from item. */\n\t\tpos_in_item(path) = round_len - (le_ih_k_offset(le_ih) - 1);\n\t\t*cut_size = -(ih_item_len(le_ih) - pos_in_item(path));\n\n\t\treturn M_CUT;\t/* Cut from this item. */\n\t}\n\n\t/* old file: items may have any length */\n\n\tif (new_file_length < le_ih_k_offset(le_ih)) {\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\t/* Delete this item. */\n\t}\n\n\t/* Calculate first position and size for cutting from item. */\n\t*cut_size = -(ih_item_len(le_ih) -\n\t\t      (pos_in_item(path) =\n\t\t       new_file_length + 1 - le_ih_k_offset(le_ih)));\n\treturn M_CUT;\t\t/* Cut from this item. */\n}"
  },
  {
    "function_name": "comp_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "906-922",
    "snippet": "int comp_items(const struct item_head *stored_ih, const struct treepath *path)\n{\n\tstruct buffer_head *bh = PATH_PLAST_BUFFER(path);\n\tstruct item_head *ih;\n\n\t/* Last buffer at the path is not in the tree. */\n\tif (!B_IS_IN_TREE(bh))\n\t\treturn 1;\n\n\t/* Last path position is invalid. */\n\tif (PATH_LAST_POSITION(path) >= B_NR_ITEMS(bh))\n\t\treturn 1;\n\n\t/* we need only to know, whether it is the same item */\n\tih = tp_item_head(path);\n\treturn memcmp(stored_ih, ih, IH_SIZE);\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "stored_ih",
            "ih",
            "IH_SIZE"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "path"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "path"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_IS_IN_TREE",
          "args": [
            "bh"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "B_IS_IN_TREE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "19-26",
          "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "path"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path)\n{\n\tstruct buffer_head *bh = PATH_PLAST_BUFFER(path);\n\tstruct item_head *ih;\n\n\t/* Last buffer at the path is not in the tree. */\n\tif (!B_IS_IN_TREE(bh))\n\t\treturn 1;\n\n\t/* Last path position is invalid. */\n\tif (PATH_LAST_POSITION(path) >= B_NR_ITEMS(bh))\n\t\treturn 1;\n\n\t/* we need only to know, whether it is the same item */\n\tih = tp_item_head(path);\n\treturn memcmp(stored_ih, ih, IH_SIZE);\n}"
  },
  {
    "function_name": "search_for_position_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "830-903",
    "snippet": "int search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "p_le_ih"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "search_path"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "p_le_ih"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "search_path"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "p_le_ih"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "search_path"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "search_path"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_bytes_number",
          "args": [
            "p_le_ih",
            "blk_size"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_key_k_offset",
          "args": [
            "p_cpu_key"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_key_k_offset_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1603-1606",
          "snippet": "static inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "p_le_ih"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "comp_short_keys",
          "args": [
            "&p_le_ih->ih_key",
            "p_cpu_key"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "comp_short_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "43-58",
          "snippet": "inline int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key)\n{\n\t__u32 n;\n\tn = le32_to_cpu(le_key->k_dir_id);\n\tif (n < cpu_key->on_disk_key.k_dir_id)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_dir_id)\n\t\treturn 1;\n\tn = le32_to_cpu(le_key->k_objectid);\n\tif (n < cpu_key->on_disk_key.k_objectid)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_objectid)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key)\n{\n\t__u32 n;\n\tn = le32_to_cpu(le_key->k_dir_id);\n\tif (n < cpu_key->on_disk_key.k_dir_id)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_dir_id)\n\t\treturn 1;\n\tn = le32_to_cpu(le_key->k_objectid);\n\tif (n < cpu_key->on_disk_key.k_objectid)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_objectid)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "PATH_PLAST_BUFFER(search_path)",
            "--PATH_LAST_POSITION(search_path)"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "copy_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "29-33",
          "snippet": "inline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "search_path"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "search_path"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!PATH_LAST_POSITION(search_path)",
            "\"PAP-5170: position equals zero\""
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "search_path"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pos_in_item",
          "args": [
            "search_path"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path)))",
            "\"PAP-5165: item length equals zero\""
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "search_path"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "search_path"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_item",
          "args": [
            "sb",
            "p_cpu_key",
            "search_path"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_by_entry_key",
          "args": [
            "sb",
            "p_cpu_key",
            "search_path",
            "&de"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "search_by_entry_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "120-175",
          "snippet": "int search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nint search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_cpu_key",
          "args": [
            "p_cpu_key"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}"
  },
  {
    "function_name": "search_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "587-811",
    "snippet": "int search_by_key(struct super_block *sb, const struct cpu_key *key,\n\t\t  struct treepath *search_path, int stop_level)\n{\n\tb_blocknr_t block_number;\n\tint expected_level;\n\tstruct buffer_head *bh;\n\tstruct path_element *last_element;\n\tint node_level, retval;\n\tint right_neighbor_of_leaf_node;\n\tint fs_gen;\n\tstruct buffer_head *reada_bh[SEARCH_BY_KEY_READA];\n\tb_blocknr_t reada_blocks[SEARCH_BY_KEY_READA];\n\tint reada_count = 0;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tint repeat_counter = 0;\n#endif\n\n\tPROC_INFO_INC(sb, search_by_key);\n\n\t/*\n\t * As we add each node to a path we increase its count.  This means\n\t * that we must be careful to release all nodes in a path before we\n\t * either discard the path struct or re-use the path struct, as we\n\t * do here.\n\t */\n\n\tpathrelse(search_path);\n\n\tright_neighbor_of_leaf_node = 0;\n\n\t/*\n\t * With each iteration of this loop we search through the items in the\n\t * current node, and calculate the next current node(next path element)\n\t * for the next iteration of this loop..\n\t */\n\tblock_number = SB_ROOT_BLOCK(sb);\n\texpected_level = -1;\n\twhile (1) {\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (!(++repeat_counter % 50000))\n\t\t\treiserfs_warning(sb, \"PAP-5100\",\n\t\t\t\t\t \"%s: there were %d iterations of \"\n\t\t\t\t\t \"while loop looking for key %K\",\n\t\t\t\t\t current->comm, repeat_counter,\n\t\t\t\t\t key);\n#endif\n\n\t\t/* prep path to have another element added to it. */\n\t\tlast_element =\n\t\t    PATH_OFFSET_PELEMENT(search_path,\n\t\t\t\t\t ++search_path->path_length);\n\t\tfs_gen = get_generation(sb);\n\n\t\t/*\n\t\t * Read the next tree node, and set the last element\n\t\t * in the path to have a pointer to it.\n\t\t */\n\t\tif ((bh = last_element->pe_buffer =\n\t\t     sb_getblk(sb, block_number))) {\n\n\t\t\t/*\n\t\t\t * We'll need to drop the lock if we encounter any\n\t\t\t * buffers that need to be read. If all of them are\n\t\t\t * already up to date, we don't need to drop the lock.\n\t\t\t */\n\t\t\tint depth = -1;\n\n\t\t\tif (!buffer_uptodate(bh) && reada_count > 1)\n\t\t\t\tdepth = search_by_key_reada(sb, reada_bh,\n\t\t\t\t\t\t    reada_blocks, reada_count);\n\n\t\t\tif (!buffer_uptodate(bh) && depth == -1)\n\t\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\twait_on_buffer(bh);\n\n\t\t\tif (depth != -1)\n\t\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tgoto io_error;\n\t\t} else {\nio_error:\n\t\t\tsearch_path->path_length--;\n\t\t\tpathrelse(search_path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\treada_count = 0;\n\t\tif (expected_level == -1)\n\t\t\texpected_level = SB_TREE_HEIGHT(sb);\n\t\texpected_level--;\n\n\t\t/*\n\t\t * It is possible that schedule occurred. We must check\n\t\t * whether the key to search is still in the tree rooted\n\t\t * from the current buffer. If not then repeat search\n\t\t * from the root.\n\t\t */\n\t\tif (fs_changed(fs_gen, sb) &&\n\t\t    (!B_IS_IN_TREE(bh) ||\n\t\t     B_LEVEL(bh) != expected_level ||\n\t\t     !key_in_buffer(search_path, key, sb))) {\n\t\t\tPROC_INFO_INC(sb, search_by_key_fs_changed);\n\t\t\tPROC_INFO_INC(sb, search_by_key_restarted);\n\t\t\tPROC_INFO_INC(sb,\n\t\t\t\t      sbk_restarted[expected_level - 1]);\n\t\t\tpathrelse(search_path);\n\n\t\t\t/*\n\t\t\t * Get the root block number so that we can\n\t\t\t * repeat the search starting from the root.\n\t\t\t */\n\t\t\tblock_number = SB_ROOT_BLOCK(sb);\n\t\t\texpected_level = -1;\n\t\t\tright_neighbor_of_leaf_node = 0;\n\n\t\t\t/* repeat search from the root */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * only check that the key is in the buffer if key is not\n\t\t * equal to the MAX_KEY. Latter case is only possible in\n\t\t * \"finish_unfinished()\" processing during mount.\n\t\t */\n\t\tRFALSE(comp_keys(&MAX_KEY, key) &&\n\t\t       !key_in_buffer(search_path, key, sb),\n\t\t       \"PAP-5130: key is not in the buffer\");\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (REISERFS_SB(sb)->cur_tb) {\n\t\t\tprint_cur_tb(\"5140\");\n\t\t\treiserfs_panic(sb, \"PAP-5140\",\n\t\t\t\t       \"schedule occurred in do_balance!\");\n\t\t}\n#endif\n\n\t\t/*\n\t\t * make sure, that the node contents look like a node of\n\t\t * certain level\n\t\t */\n\t\tif (!is_tree_node(bh, expected_level)) {\n\t\t\treiserfs_error(sb, \"vs-5150\",\n\t\t\t\t       \"invalid format found in block %ld. \"\n\t\t\t\t       \"Fsck?\", bh->b_blocknr);\n\t\t\tpathrelse(search_path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* ok, we have acquired next formatted node in the tree */\n\t\tnode_level = B_LEVEL(bh);\n\n\t\tPROC_INFO_BH_STAT(sb, bh, node_level - 1);\n\n\t\tRFALSE(node_level < stop_level,\n\t\t       \"vs-5152: tree level (%d) is less than stop level (%d)\",\n\t\t       node_level, stop_level);\n\n\t\tretval = bin_search(key, item_head(bh, 0),\n\t\t\t\t      B_NR_ITEMS(bh),\n\t\t\t\t      (node_level ==\n\t\t\t\t       DISK_LEAF_NODE_LEVEL) ? IH_SIZE :\n\t\t\t\t      KEY_SIZE,\n\t\t\t\t      &last_element->pe_position);\n\t\tif (node_level == stop_level) {\n\t\t\treturn retval;\n\t\t}\n\n\t\t/* we are not in the stop level */\n\t\t/*\n\t\t * item has been found, so we choose the pointer which\n\t\t * is to the right of the found one\n\t\t */\n\t\tif (retval == ITEM_FOUND)\n\t\t\tlast_element->pe_position++;\n\n\t\t/*\n\t\t * if item was not found we choose the position which is to\n\t\t * the left of the found item. This requires no code,\n\t\t * bin_search did it already.\n\t\t */\n\n\t\t/*\n\t\t * So we have chosen a position in the current node which is\n\t\t * an internal node.  Now we calculate child block number by\n\t\t * position in the node.\n\t\t */\n\t\tblock_number =\n\t\t    B_N_CHILD_NUM(bh, last_element->pe_position);\n\n\t\t/*\n\t\t * if we are going to read leaf nodes, try for read\n\t\t * ahead as well\n\t\t */\n\t\tif ((search_path->reada & PATH_READA) &&\n\t\t    node_level == DISK_LEAF_NODE_LEVEL + 1) {\n\t\t\tint pos = last_element->pe_position;\n\t\t\tint limit = B_NR_ITEMS(bh);\n\t\t\tstruct reiserfs_key *le_key;\n\n\t\t\tif (search_path->reada & PATH_READA_BACK)\n\t\t\t\tlimit = 0;\n\t\t\twhile (reada_count < SEARCH_BY_KEY_READA) {\n\t\t\t\tif (pos == limit)\n\t\t\t\t\tbreak;\n\t\t\t\treada_blocks[reada_count++] =\n\t\t\t\t    B_N_CHILD_NUM(bh, pos);\n\t\t\t\tif (search_path->reada & PATH_READA_BACK)\n\t\t\t\t\tpos--;\n\t\t\t\telse\n\t\t\t\t\tpos++;\n\n\t\t\t\t/*\n\t\t\t\t * check to make sure we're in the same object\n\t\t\t\t */\n\t\t\t\tle_key = internal_key(bh, pos);\n\t\t\t\tif (le32_to_cpu(le_key->k_objectid) !=\n\t\t\t\t    key->on_disk_key.k_objectid) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define SEARCH_BY_KEY_READA 16"
    ],
    "globals_used": [
      "static const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "le_key->k_objectid"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "bh",
            "pos"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_N_CHILD_NUM",
          "args": [
            "bh",
            "pos"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD_NUM",
          "args": [
            "bh",
            "last_element->pe_position"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin_search",
          "args": [
            "key",
            "item_head(bh, 0)",
            "B_NR_ITEMS(bh)",
            "(node_level ==\n\t\t\t\t       DISK_LEAF_NODE_LEVEL) ? IH_SIZE :\n\t\t\t\t      KEY_SIZE",
            "&last_element->pe_position"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "bin_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "153-192",
          "snippet": "static inline int bin_search(const void *key,\t/* Key to search for. */\n\t\t\t     const void *base,\t/* First item in the array. */\n\t\t\t     int num,\t/* Number of items in the array. */\n\t\t\t     /*\n\t\t\t      * Item size in the array.  searched. Lest the\n\t\t\t      * reader be confused, note that this is crafted\n\t\t\t      * as a general function, and when it is applied\n\t\t\t      * specifically to the array of item headers in a\n\t\t\t      * node, width is actually the item header size\n\t\t\t      * not the item size.\n\t\t\t      */\n\t\t\t     int width,\n\t\t\t     int *pos /* Number of the searched for element. */\n    )\n{\n\tint rbound, lbound, j;\n\n\tfor (j = ((rbound = num - 1) + (lbound = 0)) / 2;\n\t     lbound <= rbound; j = (rbound + lbound) / 2)\n\t\tswitch (comp_keys\n\t\t\t((struct reiserfs_key *)((char *)base + j * width),\n\t\t\t (struct cpu_key *)key)) {\n\t\tcase -1:\n\t\t\tlbound = j + 1;\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\trbound = j - 1;\n\t\t\tcontinue;\n\t\tcase 0:\n\t\t\t*pos = j;\n\t\t\treturn ITEM_FOUND;\t/* Key found in the array.  */\n\t\t}\n\n\t/*\n\t * bin_search did not find given key, it returns position of key,\n\t * that is minimal and greater than the given one.\n\t */\n\t*pos = lbound;\n\treturn ITEM_NOT_FOUND;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int bin_search(const void *key,\t/* Key to search for. */\n\t\t\t     const void *base,\t/* First item in the array. */\n\t\t\t     int num,\t/* Number of items in the array. */\n\t\t\t     /*\n\t\t\t      * Item size in the array.  searched. Lest the\n\t\t\t      * reader be confused, note that this is crafted\n\t\t\t      * as a general function, and when it is applied\n\t\t\t      * specifically to the array of item headers in a\n\t\t\t      * node, width is actually the item header size\n\t\t\t      * not the item size.\n\t\t\t      */\n\t\t\t     int width,\n\t\t\t     int *pos /* Number of the searched for element. */\n    )\n{\n\tint rbound, lbound, j;\n\n\tfor (j = ((rbound = num - 1) + (lbound = 0)) / 2;\n\t     lbound <= rbound; j = (rbound + lbound) / 2)\n\t\tswitch (comp_keys\n\t\t\t((struct reiserfs_key *)((char *)base + j * width),\n\t\t\t (struct cpu_key *)key)) {\n\t\tcase -1:\n\t\t\tlbound = j + 1;\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\trbound = j - 1;\n\t\t\tcontinue;\n\t\tcase 0:\n\t\t\t*pos = j;\n\t\t\treturn ITEM_FOUND;\t/* Key found in the array.  */\n\t\t}\n\n\t/*\n\t * bin_search did not find given key, it returns position of key,\n\t * that is minimal and greater than the given one.\n\t */\n\t*pos = lbound;\n\treturn ITEM_NOT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "bh",
            "0"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "copy_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "29-33",
          "snippet": "inline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "node_level < stop_level",
            "\"vs-5152: tree level (%d) is less than stop level (%d)\"",
            "node_level",
            "stop_level"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_BH_STAT",
          "args": [
            "sb",
            "bh",
            "node_level - 1"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_LEVEL",
          "args": [
            "bh"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "search_path"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "sb",
            "\"vs-5150\"",
            "\"invalid format found in block %ld. \"\n\t\t\t\t       \"Fsck?\"",
            "bh->b_blocknr"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_tree_node",
          "args": [
            "bh",
            "expected_level"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "is_tree_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "502-514",
          "snippet": "static int is_tree_node(struct buffer_head *bh, int level)\n{\n\tif (B_LEVEL(bh) != level) {\n\t\treiserfs_warning(NULL, \"reiserfs-5090\", \"node level %d does \"\n\t\t\t\t \"not match to the expected one %d\",\n\t\t\t\t B_LEVEL(bh), level);\n\t\treturn 0;\n\t}\n\tif (level == DISK_LEAF_NODE_LEVEL)\n\t\treturn is_leaf(bh->b_data, bh->b_size, bh);\n\n\treturn is_internal(bh->b_data, bh->b_size, bh);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int is_tree_node(struct buffer_head *bh, int level)\n{\n\tif (B_LEVEL(bh) != level) {\n\t\treiserfs_warning(NULL, \"reiserfs-5090\", \"node level %d does \"\n\t\t\t\t \"not match to the expected one %d\",\n\t\t\t\t B_LEVEL(bh), level);\n\t\treturn 0;\n\t}\n\tif (level == DISK_LEAF_NODE_LEVEL)\n\t\treturn is_leaf(bh->b_data, bh->b_size, bh);\n\n\treturn is_internal(bh->b_data, bh->b_size, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb",
            "\"PAP-5140\"",
            "\"schedule occurred in do_balance!\""
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_cur_tb",
          "args": [
            "\"5140\""
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "print_cur_tb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "708-711",
          "snippet": "void print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char print_tb_buf[2048];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char print_tb_buf[2048];\n\nvoid print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "comp_keys(&MAX_KEY, key) &&\n\t\t       !key_in_buffer(search_path, key, sb)",
            "\"PAP-5130: key is not in the buffer\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_in_buffer",
          "args": [
            "search_path",
            "key",
            "sb"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "key_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "320-344",
          "snippet": "static inline int key_in_buffer(\n\t\t\t\t/* Path which should be checked. */\n\t\t\t\tstruct treepath *chk_path,\n\t\t\t\t/* Key which should be checked. */\n\t\t\t\tconst struct cpu_key *key,\n\t\t\t\tstruct super_block *sb\n    )\n{\n\n\tRFALSE(!key || chk_path->path_length < FIRST_PATH_ELEMENT_OFFSET\n\t       || chk_path->path_length > MAX_HEIGHT,\n\t       \"PAP-5050: pointer to the key(%p) is NULL or invalid path length(%d)\",\n\t       key, chk_path->path_length);\n\tRFALSE(!PATH_PLAST_BUFFER(chk_path)->b_bdev,\n\t       \"PAP-5060: device must not be NODEV\");\n\n\tif (comp_keys(get_lkey(chk_path, sb), key) == 1)\n\t\t/* left delimiting key is bigger, that the key we look for */\n\t\treturn 0;\n\t/*  if ( comp_keys(key, get_rkey(chk_path, sb)) != -1 ) */\n\tif (comp_keys(get_rkey(chk_path, sb), key) != 1)\n\t\t/* key must be less than right delimitiing key */\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int key_in_buffer(\n\t\t\t\t/* Path which should be checked. */\n\t\t\t\tstruct treepath *chk_path,\n\t\t\t\t/* Key which should be checked. */\n\t\t\t\tconst struct cpu_key *key,\n\t\t\t\tstruct super_block *sb\n    )\n{\n\n\tRFALSE(!key || chk_path->path_length < FIRST_PATH_ELEMENT_OFFSET\n\t       || chk_path->path_length > MAX_HEIGHT,\n\t       \"PAP-5050: pointer to the key(%p) is NULL or invalid path length(%d)\",\n\t       key, chk_path->path_length);\n\tRFALSE(!PATH_PLAST_BUFFER(chk_path)->b_bdev,\n\t       \"PAP-5060: device must not be NODEV\");\n\n\tif (comp_keys(get_lkey(chk_path, sb), key) == 1)\n\t\t/* left delimiting key is bigger, that the key we look for */\n\t\treturn 0;\n\t/*  if ( comp_keys(key, get_rkey(chk_path, sb)) != -1 ) */\n\tif (comp_keys(get_rkey(chk_path, sb), key) != 1)\n\t\t/* key must be less than right delimitiing key */\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "comp_keys",
          "args": [
            "&MAX_KEY",
            "key"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "comp_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "67-95",
          "snippet": "static inline int comp_keys(const struct reiserfs_key *le_key,\n\t\t\t    const struct cpu_key *cpu_key)\n{\n\tint retval;\n\n\tretval = comp_short_keys(le_key, cpu_key);\n\tif (retval)\n\t\treturn retval;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) <\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn -1;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) >\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn 1;\n\n\tif (cpu_key->key_length == 3)\n\t\treturn 0;\n\n\t/* this part is needed only when tail conversion is in progress */\n\tif (le_key_k_type(le_key_version(le_key), le_key) <\n\t    cpu_key_k_type(cpu_key))\n\t\treturn -1;\n\n\tif (le_key_k_type(le_key_version(le_key), le_key) >\n\t    cpu_key_k_type(cpu_key))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int comp_keys(const struct reiserfs_key *le_key,\n\t\t\t    const struct cpu_key *cpu_key)\n{\n\tint retval;\n\n\tretval = comp_short_keys(le_key, cpu_key);\n\tif (retval)\n\t\treturn retval;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) <\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn -1;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) >\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn 1;\n\n\tif (cpu_key->key_length == 3)\n\t\treturn 0;\n\n\t/* this part is needed only when tail conversion is in progress */\n\tif (le_key_k_type(le_key_version(le_key), le_key) <\n\t    cpu_key_k_type(cpu_key))\n\t\treturn -1;\n\n\tif (le_key_k_type(le_key_version(le_key), le_key) >\n\t    cpu_key_k_type(cpu_key))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ROOT_BLOCK",
          "args": [
            "sb"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "sbk_restarted[expected_level - 1]"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "search_by_key_restarted"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "search_by_key_fs_changed"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_LEVEL",
          "args": [
            "bh"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_IS_IN_TREE",
          "args": [
            "bh"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "B_IS_IN_TREE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "19-26",
          "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_changed",
          "args": [
            "fs_gen",
            "sb"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_TREE_HEIGHT",
          "args": [
            "sb"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "sb",
            "depth"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "1",
            "&bh"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "sb"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_by_key_reada",
          "args": [
            "sb",
            "reada_bh",
            "reada_blocks",
            "reada_count"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "search_by_key_reada",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "528-559",
          "snippet": "static int search_by_key_reada(struct super_block *s,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tb_blocknr_t *b, int num)\n{\n\tint i, j;\n\tint depth = -1;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbh[i] = sb_getblk(s, b[i]);\n\t}\n\t/*\n\t * We are going to read some blocks on which we\n\t * have a reference. It's safe, though we might be\n\t * reading blocks concurrently changed if we release\n\t * the lock. But it's still fine because we check later\n\t * if the tree changed\n\t */\n\tfor (j = 0; j < i; j++) {\n\t\t/*\n\t\t * note, this needs attention if we are getting rid of the BKL\n\t\t * you have to make sure the prepared bit isn't set on this\n\t\t * buffer\n\t\t */\n\t\tif (!buffer_uptodate(bh[j])) {\n\t\t\tif (depth == -1)\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tll_rw_block(READA, 1, bh + j);\n\t\t}\n\t\tbrelse(bh[j]);\n\t}\n\treturn depth;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int search_by_key_reada(struct super_block *s,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tb_blocknr_t *b, int num)\n{\n\tint i, j;\n\tint depth = -1;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbh[i] = sb_getblk(s, b[i]);\n\t}\n\t/*\n\t * We are going to read some blocks on which we\n\t * have a reference. It's safe, though we might be\n\t * reading blocks concurrently changed if we release\n\t * the lock. But it's still fine because we check later\n\t * if the tree changed\n\t */\n\tfor (j = 0; j < i; j++) {\n\t\t/*\n\t\t * note, this needs attention if we are getting rid of the BKL\n\t\t * you have to make sure the prepared bit isn't set on this\n\t\t * buffer\n\t\t */\n\t\tif (!buffer_uptodate(bh[j])) {\n\t\t\tif (depth == -1)\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tll_rw_block(READA, 1, bh + j);\n\t\t}\n\t\tbrelse(bh[j]);\n\t}\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "block_number"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_generation",
          "args": [
            "sb"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PELEMENT",
          "args": [
            "search_path",
            "++search_path->path_length"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"PAP-5100\"",
            "\"%s: there were %d iterations of \"\n\t\t\t\t\t \"while loop looking for key %K\"",
            "current->comm",
            "repeat_counter",
            "key"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ROOT_BLOCK",
          "args": [
            "sb"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "search_by_key"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\n#define SEARCH_BY_KEY_READA 16\n\nstatic const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};\n\nint search_by_key(struct super_block *sb, const struct cpu_key *key,\n\t\t  struct treepath *search_path, int stop_level)\n{\n\tb_blocknr_t block_number;\n\tint expected_level;\n\tstruct buffer_head *bh;\n\tstruct path_element *last_element;\n\tint node_level, retval;\n\tint right_neighbor_of_leaf_node;\n\tint fs_gen;\n\tstruct buffer_head *reada_bh[SEARCH_BY_KEY_READA];\n\tb_blocknr_t reada_blocks[SEARCH_BY_KEY_READA];\n\tint reada_count = 0;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tint repeat_counter = 0;\n#endif\n\n\tPROC_INFO_INC(sb, search_by_key);\n\n\t/*\n\t * As we add each node to a path we increase its count.  This means\n\t * that we must be careful to release all nodes in a path before we\n\t * either discard the path struct or re-use the path struct, as we\n\t * do here.\n\t */\n\n\tpathrelse(search_path);\n\n\tright_neighbor_of_leaf_node = 0;\n\n\t/*\n\t * With each iteration of this loop we search through the items in the\n\t * current node, and calculate the next current node(next path element)\n\t * for the next iteration of this loop..\n\t */\n\tblock_number = SB_ROOT_BLOCK(sb);\n\texpected_level = -1;\n\twhile (1) {\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (!(++repeat_counter % 50000))\n\t\t\treiserfs_warning(sb, \"PAP-5100\",\n\t\t\t\t\t \"%s: there were %d iterations of \"\n\t\t\t\t\t \"while loop looking for key %K\",\n\t\t\t\t\t current->comm, repeat_counter,\n\t\t\t\t\t key);\n#endif\n\n\t\t/* prep path to have another element added to it. */\n\t\tlast_element =\n\t\t    PATH_OFFSET_PELEMENT(search_path,\n\t\t\t\t\t ++search_path->path_length);\n\t\tfs_gen = get_generation(sb);\n\n\t\t/*\n\t\t * Read the next tree node, and set the last element\n\t\t * in the path to have a pointer to it.\n\t\t */\n\t\tif ((bh = last_element->pe_buffer =\n\t\t     sb_getblk(sb, block_number))) {\n\n\t\t\t/*\n\t\t\t * We'll need to drop the lock if we encounter any\n\t\t\t * buffers that need to be read. If all of them are\n\t\t\t * already up to date, we don't need to drop the lock.\n\t\t\t */\n\t\t\tint depth = -1;\n\n\t\t\tif (!buffer_uptodate(bh) && reada_count > 1)\n\t\t\t\tdepth = search_by_key_reada(sb, reada_bh,\n\t\t\t\t\t\t    reada_blocks, reada_count);\n\n\t\t\tif (!buffer_uptodate(bh) && depth == -1)\n\t\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\twait_on_buffer(bh);\n\n\t\t\tif (depth != -1)\n\t\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tgoto io_error;\n\t\t} else {\nio_error:\n\t\t\tsearch_path->path_length--;\n\t\t\tpathrelse(search_path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\treada_count = 0;\n\t\tif (expected_level == -1)\n\t\t\texpected_level = SB_TREE_HEIGHT(sb);\n\t\texpected_level--;\n\n\t\t/*\n\t\t * It is possible that schedule occurred. We must check\n\t\t * whether the key to search is still in the tree rooted\n\t\t * from the current buffer. If not then repeat search\n\t\t * from the root.\n\t\t */\n\t\tif (fs_changed(fs_gen, sb) &&\n\t\t    (!B_IS_IN_TREE(bh) ||\n\t\t     B_LEVEL(bh) != expected_level ||\n\t\t     !key_in_buffer(search_path, key, sb))) {\n\t\t\tPROC_INFO_INC(sb, search_by_key_fs_changed);\n\t\t\tPROC_INFO_INC(sb, search_by_key_restarted);\n\t\t\tPROC_INFO_INC(sb,\n\t\t\t\t      sbk_restarted[expected_level - 1]);\n\t\t\tpathrelse(search_path);\n\n\t\t\t/*\n\t\t\t * Get the root block number so that we can\n\t\t\t * repeat the search starting from the root.\n\t\t\t */\n\t\t\tblock_number = SB_ROOT_BLOCK(sb);\n\t\t\texpected_level = -1;\n\t\t\tright_neighbor_of_leaf_node = 0;\n\n\t\t\t/* repeat search from the root */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * only check that the key is in the buffer if key is not\n\t\t * equal to the MAX_KEY. Latter case is only possible in\n\t\t * \"finish_unfinished()\" processing during mount.\n\t\t */\n\t\tRFALSE(comp_keys(&MAX_KEY, key) &&\n\t\t       !key_in_buffer(search_path, key, sb),\n\t\t       \"PAP-5130: key is not in the buffer\");\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (REISERFS_SB(sb)->cur_tb) {\n\t\t\tprint_cur_tb(\"5140\");\n\t\t\treiserfs_panic(sb, \"PAP-5140\",\n\t\t\t\t       \"schedule occurred in do_balance!\");\n\t\t}\n#endif\n\n\t\t/*\n\t\t * make sure, that the node contents look like a node of\n\t\t * certain level\n\t\t */\n\t\tif (!is_tree_node(bh, expected_level)) {\n\t\t\treiserfs_error(sb, \"vs-5150\",\n\t\t\t\t       \"invalid format found in block %ld. \"\n\t\t\t\t       \"Fsck?\", bh->b_blocknr);\n\t\t\tpathrelse(search_path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* ok, we have acquired next formatted node in the tree */\n\t\tnode_level = B_LEVEL(bh);\n\n\t\tPROC_INFO_BH_STAT(sb, bh, node_level - 1);\n\n\t\tRFALSE(node_level < stop_level,\n\t\t       \"vs-5152: tree level (%d) is less than stop level (%d)\",\n\t\t       node_level, stop_level);\n\n\t\tretval = bin_search(key, item_head(bh, 0),\n\t\t\t\t      B_NR_ITEMS(bh),\n\t\t\t\t      (node_level ==\n\t\t\t\t       DISK_LEAF_NODE_LEVEL) ? IH_SIZE :\n\t\t\t\t      KEY_SIZE,\n\t\t\t\t      &last_element->pe_position);\n\t\tif (node_level == stop_level) {\n\t\t\treturn retval;\n\t\t}\n\n\t\t/* we are not in the stop level */\n\t\t/*\n\t\t * item has been found, so we choose the pointer which\n\t\t * is to the right of the found one\n\t\t */\n\t\tif (retval == ITEM_FOUND)\n\t\t\tlast_element->pe_position++;\n\n\t\t/*\n\t\t * if item was not found we choose the position which is to\n\t\t * the left of the found item. This requires no code,\n\t\t * bin_search did it already.\n\t\t */\n\n\t\t/*\n\t\t * So we have chosen a position in the current node which is\n\t\t * an internal node.  Now we calculate child block number by\n\t\t * position in the node.\n\t\t */\n\t\tblock_number =\n\t\t    B_N_CHILD_NUM(bh, last_element->pe_position);\n\n\t\t/*\n\t\t * if we are going to read leaf nodes, try for read\n\t\t * ahead as well\n\t\t */\n\t\tif ((search_path->reada & PATH_READA) &&\n\t\t    node_level == DISK_LEAF_NODE_LEVEL + 1) {\n\t\t\tint pos = last_element->pe_position;\n\t\t\tint limit = B_NR_ITEMS(bh);\n\t\t\tstruct reiserfs_key *le_key;\n\n\t\t\tif (search_path->reada & PATH_READA_BACK)\n\t\t\t\tlimit = 0;\n\t\t\twhile (reada_count < SEARCH_BY_KEY_READA) {\n\t\t\t\tif (pos == limit)\n\t\t\t\t\tbreak;\n\t\t\t\treada_blocks[reada_count++] =\n\t\t\t\t    B_N_CHILD_NUM(bh, pos);\n\t\t\t\tif (search_path->reada & PATH_READA_BACK)\n\t\t\t\t\tpos--;\n\t\t\t\telse\n\t\t\t\t\tpos++;\n\n\t\t\t\t/*\n\t\t\t\t * check to make sure we're in the same object\n\t\t\t\t */\n\t\t\t\tle_key = internal_key(bh, pos);\n\t\t\t\tif (le32_to_cpu(le_key->k_objectid) !=\n\t\t\t\t    key->on_disk_key.k_objectid) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "search_by_key_reada",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "528-559",
    "snippet": "static int search_by_key_reada(struct super_block *s,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tb_blocknr_t *b, int num)\n{\n\tint i, j;\n\tint depth = -1;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbh[i] = sb_getblk(s, b[i]);\n\t}\n\t/*\n\t * We are going to read some blocks on which we\n\t * have a reference. It's safe, though we might be\n\t * reading blocks concurrently changed if we release\n\t * the lock. But it's still fine because we check later\n\t * if the tree changed\n\t */\n\tfor (j = 0; j < i; j++) {\n\t\t/*\n\t\t * note, this needs attention if we are getting rid of the BKL\n\t\t * you have to make sure the prepared bit isn't set on this\n\t\t * buffer\n\t\t */\n\t\tif (!buffer_uptodate(bh[j])) {\n\t\t\tif (depth == -1)\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tll_rw_block(READA, 1, bh + j);\n\t\t}\n\t\tbrelse(bh[j]);\n\t}\n\treturn depth;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh[j]"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READA",
            "1",
            "bh + j"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "s"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh[j]"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "s",
            "b[i]"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int search_by_key_reada(struct super_block *s,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tb_blocknr_t *b, int num)\n{\n\tint i, j;\n\tint depth = -1;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbh[i] = sb_getblk(s, b[i]);\n\t}\n\t/*\n\t * We are going to read some blocks on which we\n\t * have a reference. It's safe, though we might be\n\t * reading blocks concurrently changed if we release\n\t * the lock. But it's still fine because we check later\n\t * if the tree changed\n\t */\n\tfor (j = 0; j < i; j++) {\n\t\t/*\n\t\t * note, this needs attention if we are getting rid of the BKL\n\t\t * you have to make sure the prepared bit isn't set on this\n\t\t * buffer\n\t\t */\n\t\tif (!buffer_uptodate(bh[j])) {\n\t\t\tif (depth == -1)\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tll_rw_block(READA, 1, bh + j);\n\t\t}\n\t\tbrelse(bh[j]);\n\t}\n\treturn depth;\n}"
  },
  {
    "function_name": "is_tree_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "502-514",
    "snippet": "static int is_tree_node(struct buffer_head *bh, int level)\n{\n\tif (B_LEVEL(bh) != level) {\n\t\treiserfs_warning(NULL, \"reiserfs-5090\", \"node level %d does \"\n\t\t\t\t \"not match to the expected one %d\",\n\t\t\t\t B_LEVEL(bh), level);\n\t\treturn 0;\n\t}\n\tif (level == DISK_LEAF_NODE_LEVEL)\n\t\treturn is_leaf(bh->b_data, bh->b_size, bh);\n\n\treturn is_internal(bh->b_data, bh->b_size, bh);\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_internal",
          "args": [
            "bh->b_data",
            "bh->b_size",
            "bh"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "is_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "464-496",
          "snippet": "static int is_internal(char *buf, int blocksize, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tint nr;\n\tint used_space;\n\n\tblkh = (struct block_head *)buf;\n\tnr = blkh_level(blkh);\n\tif (nr <= DISK_LEAF_NODE_LEVEL || nr > MAX_HEIGHT) {\n\t\t/* this level is not possible for internal nodes */\n\t\treiserfs_warning(NULL, \"reiserfs-5087\",\n\t\t\t\t \"this should be caught earlier\");\n\t\treturn 0;\n\t}\n\n\tnr = blkh_nr_item(blkh);\n\t/* for internal which is not root we might check min number of keys */\n\tif (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5088\",\n\t\t\t\t \"number of key seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\n\tused_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);\n\tif (used_space != blocksize - blkh_free_space(blkh)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5089\",\n\t\t\t\t \"free space seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\n\t/* one may imagine many more checks */\n\treturn 1;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int is_internal(char *buf, int blocksize, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tint nr;\n\tint used_space;\n\n\tblkh = (struct block_head *)buf;\n\tnr = blkh_level(blkh);\n\tif (nr <= DISK_LEAF_NODE_LEVEL || nr > MAX_HEIGHT) {\n\t\t/* this level is not possible for internal nodes */\n\t\treiserfs_warning(NULL, \"reiserfs-5087\",\n\t\t\t\t \"this should be caught earlier\");\n\t\treturn 0;\n\t}\n\n\tnr = blkh_nr_item(blkh);\n\t/* for internal which is not root we might check min number of keys */\n\tif (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5088\",\n\t\t\t\t \"number of key seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\n\tused_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);\n\tif (used_space != blocksize - blkh_free_space(blkh)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5089\",\n\t\t\t\t \"free space seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\n\t/* one may imagine many more checks */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_leaf",
          "args": [
            "bh->b_data",
            "bh->b_size",
            "bh"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "is_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "389-461",
          "snippet": "static int is_leaf(char *buf, int blocksize, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint used_space;\n\tint prev_location;\n\tint i;\n\tint nr;\n\n\tblkh = (struct block_head *)buf;\n\tif (blkh_level(blkh) != DISK_LEAF_NODE_LEVEL) {\n\t\treiserfs_warning(NULL, \"reiserfs-5080\",\n\t\t\t\t \"this should be caught earlier\");\n\t\treturn 0;\n\t}\n\n\tnr = blkh_nr_item(blkh);\n\tif (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN))) {\n\t\t/* item number is too big or too small */\n\t\treiserfs_warning(NULL, \"reiserfs-5081\",\n\t\t\t\t \"nr_item seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\tih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;\n\tused_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location(ih));\n\n\t/* free space does not match to calculated amount of use space */\n\tif (used_space != blocksize - blkh_free_space(blkh)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5082\",\n\t\t\t\t \"free space seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\t/*\n\t * FIXME: it is_leaf will hit performance too much - we may have\n\t * return 1 here\n\t */\n\n\t/* check tables of item heads */\n\tih = (struct item_head *)(buf + BLKH_SIZE);\n\tprev_location = blocksize;\n\tfor (i = 0; i < nr; i++, ih++) {\n\t\tif (le_ih_k_type(ih) == TYPE_ANY) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5083\",\n\t\t\t\t\t \"wrong item type for item %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ih_location(ih) >= blocksize\n\t\t    || ih_location(ih) < IH_SIZE * nr) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5084\",\n\t\t\t\t\t \"item location seems wrong: %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ih_item_len(ih) < 1\n\t\t    || ih_item_len(ih) > MAX_ITEM_LEN(blocksize)) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5085\",\n\t\t\t\t\t \"item length seems wrong: %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (prev_location - ih_location(ih) != ih_item_len(ih)) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5086\",\n\t\t\t\t\t \"item location seems wrong \"\n\t\t\t\t\t \"(second one): %h\", ih);\n\t\t\treturn 0;\n\t\t}\n\t\tprev_location = ih_location(ih);\n\t}\n\n\t/* one may imagine many more checks */\n\treturn 1;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int is_leaf(char *buf, int blocksize, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint used_space;\n\tint prev_location;\n\tint i;\n\tint nr;\n\n\tblkh = (struct block_head *)buf;\n\tif (blkh_level(blkh) != DISK_LEAF_NODE_LEVEL) {\n\t\treiserfs_warning(NULL, \"reiserfs-5080\",\n\t\t\t\t \"this should be caught earlier\");\n\t\treturn 0;\n\t}\n\n\tnr = blkh_nr_item(blkh);\n\tif (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN))) {\n\t\t/* item number is too big or too small */\n\t\treiserfs_warning(NULL, \"reiserfs-5081\",\n\t\t\t\t \"nr_item seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\tih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;\n\tused_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location(ih));\n\n\t/* free space does not match to calculated amount of use space */\n\tif (used_space != blocksize - blkh_free_space(blkh)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5082\",\n\t\t\t\t \"free space seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\t/*\n\t * FIXME: it is_leaf will hit performance too much - we may have\n\t * return 1 here\n\t */\n\n\t/* check tables of item heads */\n\tih = (struct item_head *)(buf + BLKH_SIZE);\n\tprev_location = blocksize;\n\tfor (i = 0; i < nr; i++, ih++) {\n\t\tif (le_ih_k_type(ih) == TYPE_ANY) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5083\",\n\t\t\t\t\t \"wrong item type for item %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ih_location(ih) >= blocksize\n\t\t    || ih_location(ih) < IH_SIZE * nr) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5084\",\n\t\t\t\t\t \"item location seems wrong: %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ih_item_len(ih) < 1\n\t\t    || ih_item_len(ih) > MAX_ITEM_LEN(blocksize)) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5085\",\n\t\t\t\t\t \"item length seems wrong: %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (prev_location - ih_location(ih) != ih_item_len(ih)) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5086\",\n\t\t\t\t\t \"item location seems wrong \"\n\t\t\t\t\t \"(second one): %h\", ih);\n\t\t\treturn 0;\n\t\t}\n\t\tprev_location = ih_location(ih);\n\t}\n\n\t/* one may imagine many more checks */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "NULL",
            "\"reiserfs-5090\"",
            "\"node level %d does \"\n\t\t\t\t \"not match to the expected one %d\"",
            "B_LEVEL(bh)",
            "level"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_LEVEL",
          "args": [
            "bh"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_LEVEL",
          "args": [
            "bh"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int is_tree_node(struct buffer_head *bh, int level)\n{\n\tif (B_LEVEL(bh) != level) {\n\t\treiserfs_warning(NULL, \"reiserfs-5090\", \"node level %d does \"\n\t\t\t\t \"not match to the expected one %d\",\n\t\t\t\t B_LEVEL(bh), level);\n\t\treturn 0;\n\t}\n\tif (level == DISK_LEAF_NODE_LEVEL)\n\t\treturn is_leaf(bh->b_data, bh->b_size, bh);\n\n\treturn is_internal(bh->b_data, bh->b_size, bh);\n}"
  },
  {
    "function_name": "is_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "464-496",
    "snippet": "static int is_internal(char *buf, int blocksize, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tint nr;\n\tint used_space;\n\n\tblkh = (struct block_head *)buf;\n\tnr = blkh_level(blkh);\n\tif (nr <= DISK_LEAF_NODE_LEVEL || nr > MAX_HEIGHT) {\n\t\t/* this level is not possible for internal nodes */\n\t\treiserfs_warning(NULL, \"reiserfs-5087\",\n\t\t\t\t \"this should be caught earlier\");\n\t\treturn 0;\n\t}\n\n\tnr = blkh_nr_item(blkh);\n\t/* for internal which is not root we might check min number of keys */\n\tif (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5088\",\n\t\t\t\t \"number of key seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\n\tused_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);\n\tif (used_space != blocksize - blkh_free_space(blkh)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5089\",\n\t\t\t\t \"free space seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\n\t/* one may imagine many more checks */\n\treturn 1;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "NULL",
            "\"reiserfs-5089\"",
            "\"free space seems wrong: %z\"",
            "bh"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blkh_free_space",
          "args": [
            "blkh"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "NULL",
            "\"reiserfs-5087\"",
            "\"this should be caught earlier\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_level",
          "args": [
            "blkh"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int is_internal(char *buf, int blocksize, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tint nr;\n\tint used_space;\n\n\tblkh = (struct block_head *)buf;\n\tnr = blkh_level(blkh);\n\tif (nr <= DISK_LEAF_NODE_LEVEL || nr > MAX_HEIGHT) {\n\t\t/* this level is not possible for internal nodes */\n\t\treiserfs_warning(NULL, \"reiserfs-5087\",\n\t\t\t\t \"this should be caught earlier\");\n\t\treturn 0;\n\t}\n\n\tnr = blkh_nr_item(blkh);\n\t/* for internal which is not root we might check min number of keys */\n\tif (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5088\",\n\t\t\t\t \"number of key seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\n\tused_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);\n\tif (used_space != blocksize - blkh_free_space(blkh)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5089\",\n\t\t\t\t \"free space seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\n\t/* one may imagine many more checks */\n\treturn 1;\n}"
  },
  {
    "function_name": "is_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "389-461",
    "snippet": "static int is_leaf(char *buf, int blocksize, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint used_space;\n\tint prev_location;\n\tint i;\n\tint nr;\n\n\tblkh = (struct block_head *)buf;\n\tif (blkh_level(blkh) != DISK_LEAF_NODE_LEVEL) {\n\t\treiserfs_warning(NULL, \"reiserfs-5080\",\n\t\t\t\t \"this should be caught earlier\");\n\t\treturn 0;\n\t}\n\n\tnr = blkh_nr_item(blkh);\n\tif (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN))) {\n\t\t/* item number is too big or too small */\n\t\treiserfs_warning(NULL, \"reiserfs-5081\",\n\t\t\t\t \"nr_item seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\tih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;\n\tused_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location(ih));\n\n\t/* free space does not match to calculated amount of use space */\n\tif (used_space != blocksize - blkh_free_space(blkh)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5082\",\n\t\t\t\t \"free space seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\t/*\n\t * FIXME: it is_leaf will hit performance too much - we may have\n\t * return 1 here\n\t */\n\n\t/* check tables of item heads */\n\tih = (struct item_head *)(buf + BLKH_SIZE);\n\tprev_location = blocksize;\n\tfor (i = 0; i < nr; i++, ih++) {\n\t\tif (le_ih_k_type(ih) == TYPE_ANY) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5083\",\n\t\t\t\t\t \"wrong item type for item %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ih_location(ih) >= blocksize\n\t\t    || ih_location(ih) < IH_SIZE * nr) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5084\",\n\t\t\t\t\t \"item location seems wrong: %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ih_item_len(ih) < 1\n\t\t    || ih_item_len(ih) > MAX_ITEM_LEN(blocksize)) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5085\",\n\t\t\t\t\t \"item length seems wrong: %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (prev_location - ih_location(ih) != ih_item_len(ih)) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5086\",\n\t\t\t\t\t \"item location seems wrong \"\n\t\t\t\t\t \"(second one): %h\", ih);\n\t\t\treturn 0;\n\t\t}\n\t\tprev_location = ih_location(ih);\n\t}\n\n\t/* one may imagine many more checks */\n\treturn 1;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "NULL",
            "\"reiserfs-5086\"",
            "\"item location seems wrong \"\n\t\t\t\t\t \"(second one): %h\"",
            "ih"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_ITEM_LEN",
          "args": [
            "blocksize"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_ih_k_type",
          "args": [
            "ih"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1495-1498",
          "snippet": "static inline loff_t le_ih_k_type(const struct item_head *ih)\n{\n\treturn le_key_k_type(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_type(const struct item_head *ih)\n{\n\treturn le_key_k_type(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "blkh_free_space",
          "args": [
            "blkh"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "NULL",
            "\"reiserfs-5080\"",
            "\"this should be caught earlier\""
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_level",
          "args": [
            "blkh"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int is_leaf(char *buf, int blocksize, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint used_space;\n\tint prev_location;\n\tint i;\n\tint nr;\n\n\tblkh = (struct block_head *)buf;\n\tif (blkh_level(blkh) != DISK_LEAF_NODE_LEVEL) {\n\t\treiserfs_warning(NULL, \"reiserfs-5080\",\n\t\t\t\t \"this should be caught earlier\");\n\t\treturn 0;\n\t}\n\n\tnr = blkh_nr_item(blkh);\n\tif (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN))) {\n\t\t/* item number is too big or too small */\n\t\treiserfs_warning(NULL, \"reiserfs-5081\",\n\t\t\t\t \"nr_item seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\tih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;\n\tused_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location(ih));\n\n\t/* free space does not match to calculated amount of use space */\n\tif (used_space != blocksize - blkh_free_space(blkh)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5082\",\n\t\t\t\t \"free space seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\t/*\n\t * FIXME: it is_leaf will hit performance too much - we may have\n\t * return 1 here\n\t */\n\n\t/* check tables of item heads */\n\tih = (struct item_head *)(buf + BLKH_SIZE);\n\tprev_location = blocksize;\n\tfor (i = 0; i < nr; i++, ih++) {\n\t\tif (le_ih_k_type(ih) == TYPE_ANY) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5083\",\n\t\t\t\t\t \"wrong item type for item %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ih_location(ih) >= blocksize\n\t\t    || ih_location(ih) < IH_SIZE * nr) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5084\",\n\t\t\t\t\t \"item location seems wrong: %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ih_item_len(ih) < 1\n\t\t    || ih_item_len(ih) > MAX_ITEM_LEN(blocksize)) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5085\",\n\t\t\t\t\t \"item length seems wrong: %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (prev_location - ih_location(ih) != ih_item_len(ih)) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5086\",\n\t\t\t\t\t \"item location seems wrong \"\n\t\t\t\t\t \"(second one): %h\", ih);\n\t\t\treturn 0;\n\t\t}\n\t\tprev_location = ih_location(ih);\n\t}\n\n\t/* one may imagine many more checks */\n\treturn 1;\n}"
  },
  {
    "function_name": "pathrelse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "376-387",
    "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "PATH_OFFSET_PBUFFER(search_path, path_offset--)"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "search_path",
            "path_offset--"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "path_offset < ILLEGAL_PATH_ELEMENT_OFFSET",
            "\"PAP-5090: invalid path offset\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
  },
  {
    "function_name": "pathrelse_and_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "358-373",
    "snippet": "void pathrelse_and_restore(struct super_block *sb,\n\t\t\t   struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"clm-4000: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {\n\t\tstruct buffer_head *bh;\n\t\tbh = PATH_OFFSET_PBUFFER(search_path, path_offset--);\n\t\treiserfs_restore_prepared_buffer(sb, bh);\n\t\tbrelse(bh);\n\t}\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_restore_prepared_buffer",
          "args": [
            "sb",
            "bh"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_restore_prepared_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3920-3942",
          "snippet": "void reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "search_path",
            "path_offset--"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "path_offset < ILLEGAL_PATH_ELEMENT_OFFSET",
            "\"clm-4000: invalid path offset\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse_and_restore(struct super_block *sb,\n\t\t\t   struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"clm-4000: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {\n\t\tstruct buffer_head *bh;\n\t\tbh = PATH_OFFSET_PBUFFER(search_path, path_offset--);\n\t\treiserfs_restore_prepared_buffer(sb, bh);\n\t\tbrelse(bh);\n\t}\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
  },
  {
    "function_name": "reiserfs_check_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "346-351",
    "snippet": "int reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET",
            "\"path not properly relsed\""
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}"
  },
  {
    "function_name": "key_in_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "320-344",
    "snippet": "static inline int key_in_buffer(\n\t\t\t\t/* Path which should be checked. */\n\t\t\t\tstruct treepath *chk_path,\n\t\t\t\t/* Key which should be checked. */\n\t\t\t\tconst struct cpu_key *key,\n\t\t\t\tstruct super_block *sb\n    )\n{\n\n\tRFALSE(!key || chk_path->path_length < FIRST_PATH_ELEMENT_OFFSET\n\t       || chk_path->path_length > MAX_HEIGHT,\n\t       \"PAP-5050: pointer to the key(%p) is NULL or invalid path length(%d)\",\n\t       key, chk_path->path_length);\n\tRFALSE(!PATH_PLAST_BUFFER(chk_path)->b_bdev,\n\t       \"PAP-5060: device must not be NODEV\");\n\n\tif (comp_keys(get_lkey(chk_path, sb), key) == 1)\n\t\t/* left delimiting key is bigger, that the key we look for */\n\t\treturn 0;\n\t/*  if ( comp_keys(key, get_rkey(chk_path, sb)) != -1 ) */\n\tif (comp_keys(get_rkey(chk_path, sb), key) != 1)\n\t\t/* key must be less than right delimitiing key */\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "comp_keys",
          "args": [
            "get_rkey(chk_path, sb)",
            "key"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "comp_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "67-95",
          "snippet": "static inline int comp_keys(const struct reiserfs_key *le_key,\n\t\t\t    const struct cpu_key *cpu_key)\n{\n\tint retval;\n\n\tretval = comp_short_keys(le_key, cpu_key);\n\tif (retval)\n\t\treturn retval;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) <\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn -1;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) >\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn 1;\n\n\tif (cpu_key->key_length == 3)\n\t\treturn 0;\n\n\t/* this part is needed only when tail conversion is in progress */\n\tif (le_key_k_type(le_key_version(le_key), le_key) <\n\t    cpu_key_k_type(cpu_key))\n\t\treturn -1;\n\n\tif (le_key_k_type(le_key_version(le_key), le_key) >\n\t    cpu_key_k_type(cpu_key))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int comp_keys(const struct reiserfs_key *le_key,\n\t\t\t    const struct cpu_key *cpu_key)\n{\n\tint retval;\n\n\tretval = comp_short_keys(le_key, cpu_key);\n\tif (retval)\n\t\treturn retval;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) <\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn -1;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) >\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn 1;\n\n\tif (cpu_key->key_length == 3)\n\t\treturn 0;\n\n\t/* this part is needed only when tail conversion is in progress */\n\tif (le_key_k_type(le_key_version(le_key), le_key) <\n\t    cpu_key_k_type(cpu_key))\n\t\treturn -1;\n\n\tif (le_key_k_type(le_key_version(le_key), le_key) >\n\t    cpu_key_k_type(cpu_key))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rkey",
          "args": [
            "chk_path",
            "sb"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "get_rkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "261-309",
          "snippet": "inline const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t\t   const struct super_block *sb)\n{\n\tint position, path_offset = chk_path->path_length;\n\tstruct buffer_head *parent;\n\n\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5030: invalid offset in the path\");\n\n\twhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),\n\t\t       \"PAP-5040: parent is not uptodate\");\n\n\t\t/* Parent at the path is not in the tree now. */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)))\n\t\t\treturn &MIN_KEY;\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(chk_path,\n\t\t\t\t\t  path_offset)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn &MIN_KEY;\n\t\t/*\n\t\t * Check whether parent at the path really points\n\t\t * to the child.\n\t\t */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(chk_path,\n\t\t\t\t\tpath_offset + 1)->b_blocknr)\n\t\t\treturn &MIN_KEY;\n\n\t\t/*\n\t\t * Return delimiting key if position in the parent\n\t\t * is not the last one.\n\t\t */\n\t\tif (position != B_NR_ITEMS(parent))\n\t\t\treturn internal_key(parent, position);\n\t}\n\n\t/* Return MAX_KEY if we are in the root of the buffer tree. */\n\tif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\n\t    b_blocknr == SB_ROOT_BLOCK(sb))\n\t\treturn &MAX_KEY;\n\treturn &MIN_KEY;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };",
            "static const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nconst struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };\nstatic const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};\n\ninline const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t\t   const struct super_block *sb)\n{\n\tint position, path_offset = chk_path->path_length;\n\tstruct buffer_head *parent;\n\n\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5030: invalid offset in the path\");\n\n\twhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),\n\t\t       \"PAP-5040: parent is not uptodate\");\n\n\t\t/* Parent at the path is not in the tree now. */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)))\n\t\t\treturn &MIN_KEY;\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(chk_path,\n\t\t\t\t\t  path_offset)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn &MIN_KEY;\n\t\t/*\n\t\t * Check whether parent at the path really points\n\t\t * to the child.\n\t\t */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(chk_path,\n\t\t\t\t\tpath_offset + 1)->b_blocknr)\n\t\t\treturn &MIN_KEY;\n\n\t\t/*\n\t\t * Return delimiting key if position in the parent\n\t\t * is not the last one.\n\t\t */\n\t\tif (position != B_NR_ITEMS(parent))\n\t\t\treturn internal_key(parent, position);\n\t}\n\n\t/* Return MAX_KEY if we are in the root of the buffer tree. */\n\tif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\n\t    b_blocknr == SB_ROOT_BLOCK(sb))\n\t\treturn &MAX_KEY;\n\treturn &MIN_KEY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lkey",
          "args": [
            "chk_path",
            "sb"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "get_lkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "214-258",
          "snippet": "static inline const struct reiserfs_key *get_lkey(const struct treepath *chk_path,\n\t\t\t\t\t\t  const struct super_block *sb)\n{\n\tint position, path_offset = chk_path->path_length;\n\tstruct buffer_head *parent;\n\n\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5010: invalid offset in the path\");\n\n\t/* While not higher in path than first element. */\n\twhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),\n\t\t       \"PAP-5020: parent is not uptodate\");\n\n\t\t/* Parent at the path is not in the tree now. */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)))\n\t\t\treturn &MAX_KEY;\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(chk_path,\n\t\t\t\t\t  path_offset)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn &MAX_KEY;\n\t\t/* Check whether parent at the path really points to the child. */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(chk_path,\n\t\t\t\t\tpath_offset + 1)->b_blocknr)\n\t\t\treturn &MAX_KEY;\n\t\t/*\n\t\t * Return delimiting key if position in the parent\n\t\t * is not equal to zero.\n\t\t */\n\t\tif (position)\n\t\t\treturn internal_key(parent, position - 1);\n\t}\n\t/* Return MIN_KEY if we are in the root of the buffer tree. */\n\tif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\n\t    b_blocknr == SB_ROOT_BLOCK(sb))\n\t\treturn &MIN_KEY;\n\treturn &MAX_KEY;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };",
            "static const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nconst struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };\nstatic const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};\n\nstatic inline const struct reiserfs_key *get_lkey(const struct treepath *chk_path,\n\t\t\t\t\t\t  const struct super_block *sb)\n{\n\tint position, path_offset = chk_path->path_length;\n\tstruct buffer_head *parent;\n\n\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5010: invalid offset in the path\");\n\n\t/* While not higher in path than first element. */\n\twhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),\n\t\t       \"PAP-5020: parent is not uptodate\");\n\n\t\t/* Parent at the path is not in the tree now. */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)))\n\t\t\treturn &MAX_KEY;\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(chk_path,\n\t\t\t\t\t  path_offset)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn &MAX_KEY;\n\t\t/* Check whether parent at the path really points to the child. */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(chk_path,\n\t\t\t\t\tpath_offset + 1)->b_blocknr)\n\t\t\treturn &MAX_KEY;\n\t\t/*\n\t\t * Return delimiting key if position in the parent\n\t\t * is not equal to zero.\n\t\t */\n\t\tif (position)\n\t\t\treturn internal_key(parent, position - 1);\n\t}\n\t/* Return MIN_KEY if we are in the root of the buffer tree. */\n\tif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\n\t    b_blocknr == SB_ROOT_BLOCK(sb))\n\t\treturn &MIN_KEY;\n\treturn &MAX_KEY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!PATH_PLAST_BUFFER(chk_path)->b_bdev",
            "\"PAP-5060: device must not be NODEV\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "chk_path"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!key || chk_path->path_length < FIRST_PATH_ELEMENT_OFFSET\n\t       || chk_path->path_length > MAX_HEIGHT",
            "\"PAP-5050: pointer to the key(%p) is NULL or invalid path length(%d)\"",
            "key",
            "chk_path->path_length"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int key_in_buffer(\n\t\t\t\t/* Path which should be checked. */\n\t\t\t\tstruct treepath *chk_path,\n\t\t\t\t/* Key which should be checked. */\n\t\t\t\tconst struct cpu_key *key,\n\t\t\t\tstruct super_block *sb\n    )\n{\n\n\tRFALSE(!key || chk_path->path_length < FIRST_PATH_ELEMENT_OFFSET\n\t       || chk_path->path_length > MAX_HEIGHT,\n\t       \"PAP-5050: pointer to the key(%p) is NULL or invalid path length(%d)\",\n\t       key, chk_path->path_length);\n\tRFALSE(!PATH_PLAST_BUFFER(chk_path)->b_bdev,\n\t       \"PAP-5060: device must not be NODEV\");\n\n\tif (comp_keys(get_lkey(chk_path, sb), key) == 1)\n\t\t/* left delimiting key is bigger, that the key we look for */\n\t\treturn 0;\n\t/*  if ( comp_keys(key, get_rkey(chk_path, sb)) != -1 ) */\n\tif (comp_keys(get_rkey(chk_path, sb), key) != 1)\n\t\t/* key must be less than right delimitiing key */\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "get_rkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "261-309",
    "snippet": "inline const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t\t   const struct super_block *sb)\n{\n\tint position, path_offset = chk_path->path_length;\n\tstruct buffer_head *parent;\n\n\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5030: invalid offset in the path\");\n\n\twhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),\n\t\t       \"PAP-5040: parent is not uptodate\");\n\n\t\t/* Parent at the path is not in the tree now. */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)))\n\t\t\treturn &MIN_KEY;\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(chk_path,\n\t\t\t\t\t  path_offset)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn &MIN_KEY;\n\t\t/*\n\t\t * Check whether parent at the path really points\n\t\t * to the child.\n\t\t */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(chk_path,\n\t\t\t\t\tpath_offset + 1)->b_blocknr)\n\t\t\treturn &MIN_KEY;\n\n\t\t/*\n\t\t * Return delimiting key if position in the parent\n\t\t * is not the last one.\n\t\t */\n\t\tif (position != B_NR_ITEMS(parent))\n\t\t\treturn internal_key(parent, position);\n\t}\n\n\t/* Return MAX_KEY if we are in the root of the buffer tree. */\n\tif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\n\t    b_blocknr == SB_ROOT_BLOCK(sb))\n\t\treturn &MAX_KEY;\n\treturn &MIN_KEY;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };",
      "static const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SB_ROOT_BLOCK",
          "args": [
            "sb"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "chk_path",
            "FIRST_PATH_ELEMENT_OFFSET"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "parent",
            "position"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "parent"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "chk_path",
            "path_offset + 1"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD_NUM",
          "args": [
            "parent",
            "position"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "parent"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_POSITION",
          "args": [
            "chk_path",
            "path_offset"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_IS_IN_TREE",
          "args": [
            "parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "B_IS_IN_TREE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "19-26",
          "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "chk_path",
            "path_offset"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset))",
            "\"PAP-5040: parent is not uptodate\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "PATH_OFFSET_PBUFFER(chk_path, path_offset)"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "chk_path",
            "path_offset"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "path_offset < FIRST_PATH_ELEMENT_OFFSET",
            "\"PAP-5030: invalid offset in the path\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nconst struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };\nstatic const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};\n\ninline const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t\t   const struct super_block *sb)\n{\n\tint position, path_offset = chk_path->path_length;\n\tstruct buffer_head *parent;\n\n\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5030: invalid offset in the path\");\n\n\twhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),\n\t\t       \"PAP-5040: parent is not uptodate\");\n\n\t\t/* Parent at the path is not in the tree now. */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)))\n\t\t\treturn &MIN_KEY;\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(chk_path,\n\t\t\t\t\t  path_offset)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn &MIN_KEY;\n\t\t/*\n\t\t * Check whether parent at the path really points\n\t\t * to the child.\n\t\t */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(chk_path,\n\t\t\t\t\tpath_offset + 1)->b_blocknr)\n\t\t\treturn &MIN_KEY;\n\n\t\t/*\n\t\t * Return delimiting key if position in the parent\n\t\t * is not the last one.\n\t\t */\n\t\tif (position != B_NR_ITEMS(parent))\n\t\t\treturn internal_key(parent, position);\n\t}\n\n\t/* Return MAX_KEY if we are in the root of the buffer tree. */\n\tif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\n\t    b_blocknr == SB_ROOT_BLOCK(sb))\n\t\treturn &MAX_KEY;\n\treturn &MIN_KEY;\n}"
  },
  {
    "function_name": "get_lkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "214-258",
    "snippet": "static inline const struct reiserfs_key *get_lkey(const struct treepath *chk_path,\n\t\t\t\t\t\t  const struct super_block *sb)\n{\n\tint position, path_offset = chk_path->path_length;\n\tstruct buffer_head *parent;\n\n\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5010: invalid offset in the path\");\n\n\t/* While not higher in path than first element. */\n\twhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),\n\t\t       \"PAP-5020: parent is not uptodate\");\n\n\t\t/* Parent at the path is not in the tree now. */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)))\n\t\t\treturn &MAX_KEY;\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(chk_path,\n\t\t\t\t\t  path_offset)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn &MAX_KEY;\n\t\t/* Check whether parent at the path really points to the child. */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(chk_path,\n\t\t\t\t\tpath_offset + 1)->b_blocknr)\n\t\t\treturn &MAX_KEY;\n\t\t/*\n\t\t * Return delimiting key if position in the parent\n\t\t * is not equal to zero.\n\t\t */\n\t\tif (position)\n\t\t\treturn internal_key(parent, position - 1);\n\t}\n\t/* Return MIN_KEY if we are in the root of the buffer tree. */\n\tif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\n\t    b_blocknr == SB_ROOT_BLOCK(sb))\n\t\treturn &MIN_KEY;\n\treturn &MAX_KEY;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };",
      "static const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SB_ROOT_BLOCK",
          "args": [
            "sb"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "chk_path",
            "FIRST_PATH_ELEMENT_OFFSET"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "parent",
            "position - 1"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "chk_path",
            "path_offset + 1"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD_NUM",
          "args": [
            "parent",
            "position"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "parent"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_POSITION",
          "args": [
            "chk_path",
            "path_offset"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_IS_IN_TREE",
          "args": [
            "parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "B_IS_IN_TREE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "19-26",
          "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "chk_path",
            "path_offset"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset))",
            "\"PAP-5020: parent is not uptodate\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "PATH_OFFSET_PBUFFER(chk_path, path_offset)"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "chk_path",
            "path_offset"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "path_offset < FIRST_PATH_ELEMENT_OFFSET",
            "\"PAP-5010: invalid offset in the path\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nconst struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };\nstatic const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};\n\nstatic inline const struct reiserfs_key *get_lkey(const struct treepath *chk_path,\n\t\t\t\t\t\t  const struct super_block *sb)\n{\n\tint position, path_offset = chk_path->path_length;\n\tstruct buffer_head *parent;\n\n\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5010: invalid offset in the path\");\n\n\t/* While not higher in path than first element. */\n\twhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),\n\t\t       \"PAP-5020: parent is not uptodate\");\n\n\t\t/* Parent at the path is not in the tree now. */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)))\n\t\t\treturn &MAX_KEY;\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(chk_path,\n\t\t\t\t\t  path_offset)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn &MAX_KEY;\n\t\t/* Check whether parent at the path really points to the child. */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(chk_path,\n\t\t\t\t\tpath_offset + 1)->b_blocknr)\n\t\t\treturn &MAX_KEY;\n\t\t/*\n\t\t * Return delimiting key if position in the parent\n\t\t * is not equal to zero.\n\t\t */\n\t\tif (position)\n\t\t\treturn internal_key(parent, position - 1);\n\t}\n\t/* Return MIN_KEY if we are in the root of the buffer tree. */\n\tif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\n\t    b_blocknr == SB_ROOT_BLOCK(sb))\n\t\treturn &MIN_KEY;\n\treturn &MAX_KEY;\n}"
  },
  {
    "function_name": "bin_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "153-192",
    "snippet": "static inline int bin_search(const void *key,\t/* Key to search for. */\n\t\t\t     const void *base,\t/* First item in the array. */\n\t\t\t     int num,\t/* Number of items in the array. */\n\t\t\t     /*\n\t\t\t      * Item size in the array.  searched. Lest the\n\t\t\t      * reader be confused, note that this is crafted\n\t\t\t      * as a general function, and when it is applied\n\t\t\t      * specifically to the array of item headers in a\n\t\t\t      * node, width is actually the item header size\n\t\t\t      * not the item size.\n\t\t\t      */\n\t\t\t     int width,\n\t\t\t     int *pos /* Number of the searched for element. */\n    )\n{\n\tint rbound, lbound, j;\n\n\tfor (j = ((rbound = num - 1) + (lbound = 0)) / 2;\n\t     lbound <= rbound; j = (rbound + lbound) / 2)\n\t\tswitch (comp_keys\n\t\t\t((struct reiserfs_key *)((char *)base + j * width),\n\t\t\t (struct cpu_key *)key)) {\n\t\tcase -1:\n\t\t\tlbound = j + 1;\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\trbound = j - 1;\n\t\t\tcontinue;\n\t\tcase 0:\n\t\t\t*pos = j;\n\t\t\treturn ITEM_FOUND;\t/* Key found in the array.  */\n\t\t}\n\n\t/*\n\t * bin_search did not find given key, it returns position of key,\n\t * that is minimal and greater than the given one.\n\t */\n\t*pos = lbound;\n\treturn ITEM_NOT_FOUND;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "comp_keys",
          "args": [
            "(struct reiserfs_key *)((char *)base + j * width)",
            "(struct cpu_key *)key"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "comp_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "67-95",
          "snippet": "static inline int comp_keys(const struct reiserfs_key *le_key,\n\t\t\t    const struct cpu_key *cpu_key)\n{\n\tint retval;\n\n\tretval = comp_short_keys(le_key, cpu_key);\n\tif (retval)\n\t\treturn retval;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) <\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn -1;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) >\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn 1;\n\n\tif (cpu_key->key_length == 3)\n\t\treturn 0;\n\n\t/* this part is needed only when tail conversion is in progress */\n\tif (le_key_k_type(le_key_version(le_key), le_key) <\n\t    cpu_key_k_type(cpu_key))\n\t\treturn -1;\n\n\tif (le_key_k_type(le_key_version(le_key), le_key) >\n\t    cpu_key_k_type(cpu_key))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int comp_keys(const struct reiserfs_key *le_key,\n\t\t\t    const struct cpu_key *cpu_key)\n{\n\tint retval;\n\n\tretval = comp_short_keys(le_key, cpu_key);\n\tif (retval)\n\t\treturn retval;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) <\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn -1;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) >\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn 1;\n\n\tif (cpu_key->key_length == 3)\n\t\treturn 0;\n\n\t/* this part is needed only when tail conversion is in progress */\n\tif (le_key_k_type(le_key_version(le_key), le_key) <\n\t    cpu_key_k_type(cpu_key))\n\t\treturn -1;\n\n\tif (le_key_k_type(le_key_version(le_key), le_key) >\n\t    cpu_key_k_type(cpu_key))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int bin_search(const void *key,\t/* Key to search for. */\n\t\t\t     const void *base,\t/* First item in the array. */\n\t\t\t     int num,\t/* Number of items in the array. */\n\t\t\t     /*\n\t\t\t      * Item size in the array.  searched. Lest the\n\t\t\t      * reader be confused, note that this is crafted\n\t\t\t      * as a general function, and when it is applied\n\t\t\t      * specifically to the array of item headers in a\n\t\t\t      * node, width is actually the item header size\n\t\t\t      * not the item size.\n\t\t\t      */\n\t\t\t     int width,\n\t\t\t     int *pos /* Number of the searched for element. */\n    )\n{\n\tint rbound, lbound, j;\n\n\tfor (j = ((rbound = num - 1) + (lbound = 0)) / 2;\n\t     lbound <= rbound; j = (rbound + lbound) / 2)\n\t\tswitch (comp_keys\n\t\t\t((struct reiserfs_key *)((char *)base + j * width),\n\t\t\t (struct cpu_key *)key)) {\n\t\tcase -1:\n\t\t\tlbound = j + 1;\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\trbound = j - 1;\n\t\t\tcontinue;\n\t\tcase 0:\n\t\t\t*pos = j;\n\t\t\treturn ITEM_FOUND;\t/* Key found in the array.  */\n\t\t}\n\n\t/*\n\t * bin_search did not find given key, it returns position of key,\n\t * that is minimal and greater than the given one.\n\t */\n\t*pos = lbound;\n\treturn ITEM_NOT_FOUND;\n}"
  },
  {
    "function_name": "comp_le_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "131-135",
    "snippet": "inline int comp_le_keys(const struct reiserfs_key *k1,\n\t\t\tconst struct reiserfs_key *k2)\n{\n\treturn memcmp(k1, k2, sizeof(struct reiserfs_key));\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "k1",
            "k2",
            "sizeof(struct reiserfs_key)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int comp_le_keys(const struct reiserfs_key *k1,\n\t\t\tconst struct reiserfs_key *k2)\n{\n\treturn memcmp(k1, k2, sizeof(struct reiserfs_key));\n}"
  },
  {
    "function_name": "le_key2cpu_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "114-125",
    "snippet": "inline void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from)\n{\n\tint version;\n\tto->on_disk_key.k_dir_id = le32_to_cpu(from->k_dir_id);\n\tto->on_disk_key.k_objectid = le32_to_cpu(from->k_objectid);\n\n\t/* find out version of the key */\n\tversion = le_key_version(from);\n\tto->version = version;\n\tto->on_disk_key.k_offset = le_key_k_offset(version, from);\n\tto->on_disk_key.k_type = le_key_k_type(version, from);\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le_key_k_type",
          "args": [
            "version",
            "from"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1486-1493",
          "snippet": "static inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_key_k_offset",
          "args": [
            "version",
            "from"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1473-1479",
          "snippet": "static inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_key_version",
          "args": [
            "from"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2980-2991",
          "snippet": "static inline int le_key_version(const struct reiserfs_key *key)\n{\n\tint type;\n\n\ttype = offset_v2_k_type(&(key->u.k_offset_v2));\n\tif (type != TYPE_DIRECT && type != TYPE_INDIRECT\n\t    && type != TYPE_DIRENTRY)\n\t\treturn KEY_FORMAT_3_5;\n\n\treturn KEY_FORMAT_3_6;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_DIRENTRY 3",
            "#define TYPE_DIRECT 2",
            "#define TYPE_INDIRECT 1",
            "#define KEY_FORMAT_3_6 1",
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_DIRENTRY 3\n#define TYPE_DIRECT 2\n#define TYPE_INDIRECT 1\n#define KEY_FORMAT_3_6 1\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int le_key_version(const struct reiserfs_key *key)\n{\n\tint type;\n\n\ttype = offset_v2_k_type(&(key->u.k_offset_v2));\n\tif (type != TYPE_DIRECT && type != TYPE_INDIRECT\n\t    && type != TYPE_DIRENTRY)\n\t\treturn KEY_FORMAT_3_5;\n\n\treturn KEY_FORMAT_3_6;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "from->k_objectid"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from)\n{\n\tint version;\n\tto->on_disk_key.k_dir_id = le32_to_cpu(from->k_dir_id);\n\tto->on_disk_key.k_objectid = le32_to_cpu(from->k_objectid);\n\n\t/* find out version of the key */\n\tversion = le_key_version(from);\n\tto->version = version;\n\tto->on_disk_key.k_offset = le_key_k_offset(version, from);\n\tto->on_disk_key.k_type = le_key_k_type(version, from);\n}"
  },
  {
    "function_name": "comp_short_le_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "97-112",
    "snippet": "inline int comp_short_le_keys(const struct reiserfs_key *key1,\n\t\t\t      const struct reiserfs_key *key2)\n{\n\t__u32 *k1_u32, *k2_u32;\n\tint key_length = REISERFS_SHORT_KEY_LEN;\n\n\tk1_u32 = (__u32 *) key1;\n\tk2_u32 = (__u32 *) key2;\n\tfor (; key_length--; ++k1_u32, ++k2_u32) {\n\t\tif (le32_to_cpu(*k1_u32) < le32_to_cpu(*k2_u32))\n\t\t\treturn -1;\n\t\tif (le32_to_cpu(*k1_u32) > le32_to_cpu(*k2_u32))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*k2_u32"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int comp_short_le_keys(const struct reiserfs_key *key1,\n\t\t\t      const struct reiserfs_key *key2)\n{\n\t__u32 *k1_u32, *k2_u32;\n\tint key_length = REISERFS_SHORT_KEY_LEN;\n\n\tk1_u32 = (__u32 *) key1;\n\tk2_u32 = (__u32 *) key2;\n\tfor (; key_length--; ++k1_u32, ++k2_u32) {\n\t\tif (le32_to_cpu(*k1_u32) < le32_to_cpu(*k2_u32))\n\t\t\treturn -1;\n\t\tif (le32_to_cpu(*k1_u32) > le32_to_cpu(*k2_u32))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "comp_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "67-95",
    "snippet": "static inline int comp_keys(const struct reiserfs_key *le_key,\n\t\t\t    const struct cpu_key *cpu_key)\n{\n\tint retval;\n\n\tretval = comp_short_keys(le_key, cpu_key);\n\tif (retval)\n\t\treturn retval;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) <\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn -1;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) >\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn 1;\n\n\tif (cpu_key->key_length == 3)\n\t\treturn 0;\n\n\t/* this part is needed only when tail conversion is in progress */\n\tif (le_key_k_type(le_key_version(le_key), le_key) <\n\t    cpu_key_k_type(cpu_key))\n\t\treturn -1;\n\n\tif (le_key_k_type(le_key_version(le_key), le_key) >\n\t    cpu_key_k_type(cpu_key))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_key_k_type",
          "args": [
            "cpu_key"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1588-1591",
          "snippet": "static inline loff_t cpu_key_k_type(const struct cpu_key *key)\n{\n\treturn key->on_disk_key.k_type;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t cpu_key_k_type(const struct cpu_key *key)\n{\n\treturn key->on_disk_key.k_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_key_k_type",
          "args": [
            "le_key_version(le_key)",
            "le_key"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1486-1493",
          "snippet": "static inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_key_version",
          "args": [
            "le_key"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2980-2991",
          "snippet": "static inline int le_key_version(const struct reiserfs_key *key)\n{\n\tint type;\n\n\ttype = offset_v2_k_type(&(key->u.k_offset_v2));\n\tif (type != TYPE_DIRECT && type != TYPE_INDIRECT\n\t    && type != TYPE_DIRENTRY)\n\t\treturn KEY_FORMAT_3_5;\n\n\treturn KEY_FORMAT_3_6;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_DIRENTRY 3",
            "#define TYPE_DIRECT 2",
            "#define TYPE_INDIRECT 1",
            "#define KEY_FORMAT_3_6 1",
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_DIRENTRY 3\n#define TYPE_DIRECT 2\n#define TYPE_INDIRECT 1\n#define KEY_FORMAT_3_6 1\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int le_key_version(const struct reiserfs_key *key)\n{\n\tint type;\n\n\ttype = offset_v2_k_type(&(key->u.k_offset_v2));\n\tif (type != TYPE_DIRECT && type != TYPE_INDIRECT\n\t    && type != TYPE_DIRENTRY)\n\t\treturn KEY_FORMAT_3_5;\n\n\treturn KEY_FORMAT_3_6;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_key_k_offset",
          "args": [
            "cpu_key"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_key_k_offset_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1603-1606",
          "snippet": "static inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_key_k_offset",
          "args": [
            "le_key_version(le_key)",
            "le_key"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1473-1479",
          "snippet": "static inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "comp_short_keys",
          "args": [
            "le_key",
            "cpu_key"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "comp_short_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "43-58",
          "snippet": "inline int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key)\n{\n\t__u32 n;\n\tn = le32_to_cpu(le_key->k_dir_id);\n\tif (n < cpu_key->on_disk_key.k_dir_id)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_dir_id)\n\t\treturn 1;\n\tn = le32_to_cpu(le_key->k_objectid);\n\tif (n < cpu_key->on_disk_key.k_objectid)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_objectid)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key)\n{\n\t__u32 n;\n\tn = le32_to_cpu(le_key->k_dir_id);\n\tif (n < cpu_key->on_disk_key.k_dir_id)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_dir_id)\n\t\treturn 1;\n\tn = le32_to_cpu(le_key->k_objectid);\n\tif (n < cpu_key->on_disk_key.k_objectid)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_objectid)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int comp_keys(const struct reiserfs_key *le_key,\n\t\t\t    const struct cpu_key *cpu_key)\n{\n\tint retval;\n\n\tretval = comp_short_keys(le_key, cpu_key);\n\tif (retval)\n\t\treturn retval;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) <\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn -1;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) >\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn 1;\n\n\tif (cpu_key->key_length == 3)\n\t\treturn 0;\n\n\t/* this part is needed only when tail conversion is in progress */\n\tif (le_key_k_type(le_key_version(le_key), le_key) <\n\t    cpu_key_k_type(cpu_key))\n\t\treturn -1;\n\n\tif (le_key_k_type(le_key_version(le_key), le_key) >\n\t    cpu_key_k_type(cpu_key))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "comp_short_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "43-58",
    "snippet": "inline int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key)\n{\n\t__u32 n;\n\tn = le32_to_cpu(le_key->k_dir_id);\n\tif (n < cpu_key->on_disk_key.k_dir_id)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_dir_id)\n\t\treturn 1;\n\tn = le32_to_cpu(le_key->k_objectid);\n\tif (n < cpu_key->on_disk_key.k_objectid)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_objectid)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "le_key->k_objectid"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key)\n{\n\t__u32 n;\n\tn = le32_to_cpu(le_key->k_dir_id);\n\tif (n < cpu_key->on_disk_key.k_dir_id)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_dir_id)\n\t\treturn 1;\n\tn = le32_to_cpu(le_key->k_objectid);\n\tif (n < cpu_key->on_disk_key.k_objectid)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_objectid)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_item_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "29-33",
    "snippet": "inline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "to",
            "from",
            "IH_SIZE"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}"
  },
  {
    "function_name": "B_IS_IN_TREE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
    "lines": "19-26",
    "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "B_LEVEL",
          "args": [
            "bh"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "B_LEVEL(bh) > MAX_HEIGHT",
            "\"PAP-1010: block (%b) has too big level (%z)\"",
            "bh",
            "bh"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_LEVEL",
          "args": [
            "bh"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
  }
]