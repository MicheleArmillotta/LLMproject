[
  {
    "function_name": "reiserfs_resize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/resize.c",
    "lines": "19-229",
    "snippet": "int reiserfs_resize(struct super_block *s, unsigned long block_count_new)\n{\n\tint err = 0;\n\tstruct reiserfs_super_block *sb;\n\tstruct reiserfs_bitmap_info *bitmap;\n\tstruct reiserfs_bitmap_info *info;\n\tstruct reiserfs_bitmap_info *old_bitmap = SB_AP_BITMAP(s);\n\tstruct buffer_head *bh;\n\tstruct reiserfs_transaction_handle th;\n\tunsigned int bmap_nr_new, bmap_nr;\n\tunsigned int block_r_new, block_r;\n\n\tstruct reiserfs_list_bitmap *jb;\n\tstruct reiserfs_list_bitmap jbitmap[JOURNAL_NUM_BITMAPS];\n\n\tunsigned long int block_count, free_blocks;\n\tint i;\n\tint copy_size;\n\tint depth;\n\n\tsb = SB_DISK_SUPER_BLOCK(s);\n\n\tif (SB_BLOCK_COUNT(s) >= block_count_new) {\n\t\tprintk(\"can\\'t shrink filesystem on-line\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check the device size */\n\tdepth = reiserfs_write_unlock_nested(s);\n\tbh = sb_bread(s, block_count_new - 1);\n\treiserfs_write_lock_nested(s, depth);\n\tif (!bh) {\n\t\tprintk(\"reiserfs_resize: can\\'t read last block\\n\");\n\t\treturn -EINVAL;\n\t}\n\tbforget(bh);\n\n\t/*\n\t * old disk layout detection; those partitions can be mounted, but\n\t * cannot be resized\n\t */\n\tif (SB_BUFFER_WITH_SB(s)->b_blocknr * SB_BUFFER_WITH_SB(s)->b_size\n\t    != REISERFS_DISK_OFFSET_IN_BYTES) {\n\t\tprintk\n\t\t    (\"reiserfs_resize: unable to resize a reiserfs without distributed bitmap (fs version < 3.5.12)\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t/* count used bits in last bitmap block */\n\tblock_r = SB_BLOCK_COUNT(s) -\n\t\t\t(reiserfs_bmap_count(s) - 1) * s->s_blocksize * 8;\n\n\t/* count bitmap blocks in new fs */\n\tbmap_nr_new = block_count_new / (s->s_blocksize * 8);\n\tblock_r_new = block_count_new - bmap_nr_new * s->s_blocksize * 8;\n\tif (block_r_new)\n\t\tbmap_nr_new++;\n\telse\n\t\tblock_r_new = s->s_blocksize * 8;\n\n\t/* save old values */\n\tblock_count = SB_BLOCK_COUNT(s);\n\tbmap_nr = reiserfs_bmap_count(s);\n\n\t/* resizing of reiserfs bitmaps (journal and real), if needed */\n\tif (bmap_nr_new > bmap_nr) {\n\t\t/* reallocate journal bitmaps */\n\t\tif (reiserfs_allocate_list_bitmaps(s, jbitmap, bmap_nr_new) < 0) {\n\t\t\tprintk\n\t\t\t    (\"reiserfs_resize: unable to allocate memory for journal bitmaps\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t/*\n\t\t * the new journal bitmaps are zero filled, now we copy i\n\t\t * the bitmap node pointers from the old journal bitmap\n\t\t * structs, and then transfer the new data structures\n\t\t * into the journal struct.\n\t\t *\n\t\t * using the copy_size var below allows this code to work for\n\t\t * both shrinking and expanding the FS.\n\t\t */\n\t\tcopy_size = bmap_nr_new < bmap_nr ? bmap_nr_new : bmap_nr;\n\t\tcopy_size =\n\t\t    copy_size * sizeof(struct reiserfs_list_bitmap_node *);\n\t\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\t\tstruct reiserfs_bitmap_node **node_tmp;\n\t\t\tjb = SB_JOURNAL(s)->j_list_bitmap + i;\n\t\t\tmemcpy(jbitmap[i].bitmaps, jb->bitmaps, copy_size);\n\n\t\t\t/*\n\t\t\t * just in case vfree schedules on us, copy the new\n\t\t\t * pointer into the journal struct before freeing the\n\t\t\t * old one\n\t\t\t */\n\t\t\tnode_tmp = jb->bitmaps;\n\t\t\tjb->bitmaps = jbitmap[i].bitmaps;\n\t\t\tvfree(node_tmp);\n\t\t}\n\n\t\t/*\n\t\t * allocate additional bitmap blocks, reallocate\n\t\t * array of bitmap block pointers\n\t\t */\n\t\tbitmap =\n\t\t    vzalloc(sizeof(struct reiserfs_bitmap_info) * bmap_nr_new);\n\t\tif (!bitmap) {\n\t\t\t/*\n\t\t\t * Journal bitmaps are still supersized, but the\n\t\t\t * memory isn't leaked, so I guess it's ok\n\t\t\t */\n\t\t\tprintk(\"reiserfs_resize: unable to allocate memory.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfor (i = 0; i < bmap_nr; i++)\n\t\t\tbitmap[i] = old_bitmap[i];\n\n\t\t/*\n\t\t * This doesn't go through the journal, but it doesn't have to.\n\t\t * The changes are still atomic: We're synced up when the\n\t\t * journal transaction begins, and the new bitmaps don't\n\t\t * matter if the transaction fails.\n\t\t */\n\t\tfor (i = bmap_nr; i < bmap_nr_new; i++) {\n\t\t\tint depth;\n\t\t\t/*\n\t\t\t * don't use read_bitmap_block since it will cache\n\t\t\t * the uninitialized bitmap\n\t\t\t */\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tbh = sb_bread(s, i * s->s_blocksize * 8);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\tif (!bh) {\n\t\t\t\tvfree(bitmap);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tmemset(bh->b_data, 0, sb_blocksize(sb));\n\t\t\treiserfs_set_le_bit(0, bh->b_data);\n\t\t\treiserfs_cache_bitmap_metadata(s, bh, bitmap + i);\n\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\t/* update bitmap_info stuff */\n\t\t\tbitmap[i].free_count = sb_blocksize(sb) * 8 - 1;\n\t\t\tbrelse(bh);\n\t\t}\n\t\t/* free old bitmap blocks array */\n\t\tSB_AP_BITMAP(s) = bitmap;\n\t\tvfree(old_bitmap);\n\t}\n\n\t/*\n\t * begin transaction, if there was an error, it's fine. Yes, we have\n\t * incorrect bitmaps now, but none of it is ever going to touch the\n\t * disk anyway.\n\t */\n\terr = journal_begin(&th, s, 10);\n\tif (err)\n\t\treturn err;\n\n\t/* Extend old last bitmap block - new blocks have been made available */\n\tinfo = SB_AP_BITMAP(s) + bmap_nr - 1;\n\tbh = reiserfs_read_bitmap_block(s, bmap_nr - 1);\n\tif (!bh) {\n\t\tint jerr = journal_end(&th);\n\t\tif (jerr)\n\t\t\treturn jerr;\n\t\treturn -EIO;\n\t}\n\n\treiserfs_prepare_for_journal(s, bh, 1);\n\tfor (i = block_r; i < s->s_blocksize * 8; i++)\n\t\treiserfs_clear_le_bit(i, bh->b_data);\n\tinfo->free_count += s->s_blocksize * 8 - block_r;\n\n\tjournal_mark_dirty(&th, bh);\n\tbrelse(bh);\n\n\t/* Correct new last bitmap block - It may not be full */\n\tinfo = SB_AP_BITMAP(s) + bmap_nr_new - 1;\n\tbh = reiserfs_read_bitmap_block(s, bmap_nr_new - 1);\n\tif (!bh) {\n\t\tint jerr = journal_end(&th);\n\t\tif (jerr)\n\t\t\treturn jerr;\n\t\treturn -EIO;\n\t}\n\n\treiserfs_prepare_for_journal(s, bh, 1);\n\tfor (i = block_r_new; i < s->s_blocksize * 8; i++)\n\t\treiserfs_set_le_bit(i, bh->b_data);\n\tjournal_mark_dirty(&th, bh);\n\tbrelse(bh);\n\n\tinfo->free_count -= s->s_blocksize * 8 - block_r_new;\n\t/* update super */\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\tfree_blocks = SB_FREE_BLOCKS(s);\n\tPUT_SB_FREE_BLOCKS(s,\n\t\t\t   free_blocks + (block_count_new - block_count -\n\t\t\t\t\t  (bmap_nr_new - bmap_nr)));\n\tPUT_SB_BLOCK_COUNT(s, block_count_new);\n\tPUT_SB_BMAP_NR(s, bmap_would_wrap(bmap_nr_new) ? : bmap_nr_new);\n\n\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\n\tSB_JOURNAL(s)->j_must_wait = 1;\n\treturn journal_end(&th);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "&th",
            "SB_BUFFER_WITH_SB(s)"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT_SB_BMAP_NR",
          "args": [
            "s",
            "bmap_would_wrap(bmap_nr_new) ? : bmap_nr_new"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bmap_would_wrap",
          "args": [
            "bmap_nr_new"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "bmap_would_wrap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1166-1169",
          "snippet": "static inline int bmap_would_wrap(unsigned bmap_nr)\n{\n\treturn bmap_nr > ((1LL << 16) - 1);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int bmap_would_wrap(unsigned bmap_nr)\n{\n\treturn bmap_nr > ((1LL << 16) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PUT_SB_BLOCK_COUNT",
          "args": [
            "s",
            "block_count_new"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT_SB_FREE_BLOCKS",
          "args": [
            "s",
            "free_blocks + (block_count_new - block_count -\n\t\t\t\t\t  (bmap_nr_new - bmap_nr))"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_FREE_BLOCKS",
          "args": [
            "s"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "s",
            "SB_BUFFER_WITH_SB(s)",
            "1"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_set_le_bit",
          "args": [
            "i",
            "bh->b_data"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_read_bitmap_block",
          "args": [
            "s",
            "bmap_nr_new - 1"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_read_bitmap_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1407-1444",
          "snippet": "struct buffer_head *reiserfs_read_bitmap_block(struct super_block *sb,\n                                               unsigned int bitmap)\n{\n\tb_blocknr_t block = (sb->s_blocksize << 3) * bitmap;\n\tstruct reiserfs_bitmap_info *info = SB_AP_BITMAP(sb) + bitmap;\n\tstruct buffer_head *bh;\n\n\t/*\n\t * Way old format filesystems had the bitmaps packed up front.\n\t * I doubt there are any of these left, but just in case...\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(sb)->s_properties)))\n\t\tblock = REISERFS_SB(sb)->s_sbh->b_blocknr + 1 + bitmap;\n\telse if (bitmap == 0)\n\t\tblock = (REISERFS_DISK_OFFSET_IN_BYTES >> sb->s_blocksize_bits) + 1;\n\n\tbh = sb_bread(sb, block);\n\tif (bh == NULL)\n\t\treiserfs_warning(sb, \"sh-2029: %s: bitmap block (#%u) \"\n\t\t                 \"reading failed\", __func__, block);\n\telse {\n\t\tif (buffer_locked(bh)) {\n\t\t\tint depth;\n\t\t\tPROC_INFO_INC(sb, scan_bitmap.wait);\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(atomic_read(&bh->b_count) == 0);\n\n\t\tif (info->free_count == UINT_MAX)\n\t\t\treiserfs_cache_bitmap_metadata(sb, bh, info);\n\t}\n\n\treturn bh;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstruct buffer_head *reiserfs_read_bitmap_block(struct super_block *sb,\n                                               unsigned int bitmap)\n{\n\tb_blocknr_t block = (sb->s_blocksize << 3) * bitmap;\n\tstruct reiserfs_bitmap_info *info = SB_AP_BITMAP(sb) + bitmap;\n\tstruct buffer_head *bh;\n\n\t/*\n\t * Way old format filesystems had the bitmaps packed up front.\n\t * I doubt there are any of these left, but just in case...\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(sb)->s_properties)))\n\t\tblock = REISERFS_SB(sb)->s_sbh->b_blocknr + 1 + bitmap;\n\telse if (bitmap == 0)\n\t\tblock = (REISERFS_DISK_OFFSET_IN_BYTES >> sb->s_blocksize_bits) + 1;\n\n\tbh = sb_bread(sb, block);\n\tif (bh == NULL)\n\t\treiserfs_warning(sb, \"sh-2029: %s: bitmap block (#%u) \"\n\t\t                 \"reading failed\", __func__, block);\n\telse {\n\t\tif (buffer_locked(bh)) {\n\t\t\tint depth;\n\t\t\tPROC_INFO_INC(sb, scan_bitmap.wait);\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(atomic_read(&bh->b_count) == 0);\n\n\t\tif (info->free_count == UINT_MAX)\n\t\t\treiserfs_cache_bitmap_metadata(sb, bh, info);\n\t}\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_AP_BITMAP",
          "args": [
            "s"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_clear_le_bit",
          "args": [
            "i",
            "bh->b_data"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_AP_BITMAP",
          "args": [
            "s"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "s",
            "10"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "old_bitmap"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_AP_BITMAP",
          "args": [
            "s"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_blocksize",
          "args": [
            "sb"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "s",
            "depth"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "s"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_cache_bitmap_metadata",
          "args": [
            "s",
            "bh",
            "bitmap + i"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_cache_bitmap_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1385-1405",
          "snippet": "void reiserfs_cache_bitmap_metadata(struct super_block *sb,\n                                    struct buffer_head *bh,\n                                    struct reiserfs_bitmap_info *info)\n{\n\tunsigned long *cur = (unsigned long *)(bh->b_data + bh->b_size);\n\n\t/* The first bit must ALWAYS be 1 */\n\tif (!reiserfs_test_le_bit(0, (unsigned long *)bh->b_data))\n\t\treiserfs_error(sb, \"reiserfs-2025\", \"bitmap block %lu is \"\n\t\t\t       \"corrupted: first bit must be 1\", bh->b_blocknr);\n\n\tinfo->free_count = 0;\n\n\twhile (--cur >= (unsigned long *)bh->b_data) {\n\t\t/* 0 and ~0 are special, we can optimize for them */\n\t\tif (*cur == 0)\n\t\t\tinfo->free_count += BITS_PER_LONG;\n\t\telse if (*cur != ~0L)\t/* A mix, investigate */\n\t\t\tinfo->free_count += BITS_PER_LONG - hweight_long(*cur);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_cache_bitmap_metadata(struct super_block *sb,\n                                    struct buffer_head *bh,\n                                    struct reiserfs_bitmap_info *info)\n{\n\tunsigned long *cur = (unsigned long *)(bh->b_data + bh->b_size);\n\n\t/* The first bit must ALWAYS be 1 */\n\tif (!reiserfs_test_le_bit(0, (unsigned long *)bh->b_data))\n\t\treiserfs_error(sb, \"reiserfs-2025\", \"bitmap block %lu is \"\n\t\t\t       \"corrupted: first bit must be 1\", bh->b_blocknr);\n\n\tinfo->free_count = 0;\n\n\twhile (--cur >= (unsigned long *)bh->b_data) {\n\t\t/* 0 and ~0 are special, we can optimize for them */\n\t\tif (*cur == 0)\n\t\t\tinfo->free_count += BITS_PER_LONG;\n\t\telse if (*cur != ~0L)\t/* A mix, investigate */\n\t\t\tinfo->free_count += BITS_PER_LONG - hweight_long(*cur);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_set_le_bit",
          "args": [
            "0",
            "bh->b_data"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "sb_blocksize(sb)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_blocksize",
          "args": [
            "sb"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "bitmap"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "i * s->s_blocksize * 8"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"reiserfs_resize: unable to allocate memory.\\n\""
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "291-295",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "sizeof(struct reiserfs_bitmap_info) * bmap_nr_new"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "node_tmp"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "jbitmap[i].bitmaps",
            "jb->bitmaps",
            "copy_size"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_allocate_list_bitmaps",
          "args": [
            "s",
            "jbitmap",
            "bmap_nr_new"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_allocate_list_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "279-304",
          "snippet": "int reiserfs_allocate_list_bitmaps(struct super_block *sb,\n\t\t\t\t   struct reiserfs_list_bitmap *jb_array,\n\t\t\t\t   unsigned int bmap_nr)\n{\n\tint i;\n\tint failed = 0;\n\tstruct reiserfs_list_bitmap *jb;\n\tint mem = bmap_nr * sizeof(struct reiserfs_bitmap_node *);\n\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tjb->bitmaps = vzalloc(mem);\n\t\tif (!jb->bitmaps) {\n\t\t\treiserfs_warning(sb, \"clm-2000\", \"unable to \"\n\t\t\t\t\t \"allocate bitmaps for journal lists\");\n\t\t\tfailed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (failed) {\n\t\tfree_list_bitmaps(sb, jb_array);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_allocate_list_bitmaps(struct super_block *sb,\n\t\t\t\t   struct reiserfs_list_bitmap *jb_array,\n\t\t\t\t   unsigned int bmap_nr)\n{\n\tint i;\n\tint failed = 0;\n\tstruct reiserfs_list_bitmap *jb;\n\tint mem = bmap_nr * sizeof(struct reiserfs_bitmap_node *);\n\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tjb->bitmaps = vzalloc(mem);\n\t\tif (!jb->bitmaps) {\n\t\t\treiserfs_warning(sb, \"clm-2000\", \"unable to \"\n\t\t\t\t\t \"allocate bitmaps for journal lists\");\n\t\t\tfailed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (failed) {\n\t\tfree_list_bitmaps(sb, jb_array);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_bmap_count",
          "args": [
            "s"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_bmap_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1161-1164",
          "snippet": "static inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "s"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "s"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "bh"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "block_count_new - 1"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "s"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "s"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_AP_BITMAP",
          "args": [
            "s"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint reiserfs_resize(struct super_block *s, unsigned long block_count_new)\n{\n\tint err = 0;\n\tstruct reiserfs_super_block *sb;\n\tstruct reiserfs_bitmap_info *bitmap;\n\tstruct reiserfs_bitmap_info *info;\n\tstruct reiserfs_bitmap_info *old_bitmap = SB_AP_BITMAP(s);\n\tstruct buffer_head *bh;\n\tstruct reiserfs_transaction_handle th;\n\tunsigned int bmap_nr_new, bmap_nr;\n\tunsigned int block_r_new, block_r;\n\n\tstruct reiserfs_list_bitmap *jb;\n\tstruct reiserfs_list_bitmap jbitmap[JOURNAL_NUM_BITMAPS];\n\n\tunsigned long int block_count, free_blocks;\n\tint i;\n\tint copy_size;\n\tint depth;\n\n\tsb = SB_DISK_SUPER_BLOCK(s);\n\n\tif (SB_BLOCK_COUNT(s) >= block_count_new) {\n\t\tprintk(\"can\\'t shrink filesystem on-line\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check the device size */\n\tdepth = reiserfs_write_unlock_nested(s);\n\tbh = sb_bread(s, block_count_new - 1);\n\treiserfs_write_lock_nested(s, depth);\n\tif (!bh) {\n\t\tprintk(\"reiserfs_resize: can\\'t read last block\\n\");\n\t\treturn -EINVAL;\n\t}\n\tbforget(bh);\n\n\t/*\n\t * old disk layout detection; those partitions can be mounted, but\n\t * cannot be resized\n\t */\n\tif (SB_BUFFER_WITH_SB(s)->b_blocknr * SB_BUFFER_WITH_SB(s)->b_size\n\t    != REISERFS_DISK_OFFSET_IN_BYTES) {\n\t\tprintk\n\t\t    (\"reiserfs_resize: unable to resize a reiserfs without distributed bitmap (fs version < 3.5.12)\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t/* count used bits in last bitmap block */\n\tblock_r = SB_BLOCK_COUNT(s) -\n\t\t\t(reiserfs_bmap_count(s) - 1) * s->s_blocksize * 8;\n\n\t/* count bitmap blocks in new fs */\n\tbmap_nr_new = block_count_new / (s->s_blocksize * 8);\n\tblock_r_new = block_count_new - bmap_nr_new * s->s_blocksize * 8;\n\tif (block_r_new)\n\t\tbmap_nr_new++;\n\telse\n\t\tblock_r_new = s->s_blocksize * 8;\n\n\t/* save old values */\n\tblock_count = SB_BLOCK_COUNT(s);\n\tbmap_nr = reiserfs_bmap_count(s);\n\n\t/* resizing of reiserfs bitmaps (journal and real), if needed */\n\tif (bmap_nr_new > bmap_nr) {\n\t\t/* reallocate journal bitmaps */\n\t\tif (reiserfs_allocate_list_bitmaps(s, jbitmap, bmap_nr_new) < 0) {\n\t\t\tprintk\n\t\t\t    (\"reiserfs_resize: unable to allocate memory for journal bitmaps\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t/*\n\t\t * the new journal bitmaps are zero filled, now we copy i\n\t\t * the bitmap node pointers from the old journal bitmap\n\t\t * structs, and then transfer the new data structures\n\t\t * into the journal struct.\n\t\t *\n\t\t * using the copy_size var below allows this code to work for\n\t\t * both shrinking and expanding the FS.\n\t\t */\n\t\tcopy_size = bmap_nr_new < bmap_nr ? bmap_nr_new : bmap_nr;\n\t\tcopy_size =\n\t\t    copy_size * sizeof(struct reiserfs_list_bitmap_node *);\n\t\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\t\tstruct reiserfs_bitmap_node **node_tmp;\n\t\t\tjb = SB_JOURNAL(s)->j_list_bitmap + i;\n\t\t\tmemcpy(jbitmap[i].bitmaps, jb->bitmaps, copy_size);\n\n\t\t\t/*\n\t\t\t * just in case vfree schedules on us, copy the new\n\t\t\t * pointer into the journal struct before freeing the\n\t\t\t * old one\n\t\t\t */\n\t\t\tnode_tmp = jb->bitmaps;\n\t\t\tjb->bitmaps = jbitmap[i].bitmaps;\n\t\t\tvfree(node_tmp);\n\t\t}\n\n\t\t/*\n\t\t * allocate additional bitmap blocks, reallocate\n\t\t * array of bitmap block pointers\n\t\t */\n\t\tbitmap =\n\t\t    vzalloc(sizeof(struct reiserfs_bitmap_info) * bmap_nr_new);\n\t\tif (!bitmap) {\n\t\t\t/*\n\t\t\t * Journal bitmaps are still supersized, but the\n\t\t\t * memory isn't leaked, so I guess it's ok\n\t\t\t */\n\t\t\tprintk(\"reiserfs_resize: unable to allocate memory.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfor (i = 0; i < bmap_nr; i++)\n\t\t\tbitmap[i] = old_bitmap[i];\n\n\t\t/*\n\t\t * This doesn't go through the journal, but it doesn't have to.\n\t\t * The changes are still atomic: We're synced up when the\n\t\t * journal transaction begins, and the new bitmaps don't\n\t\t * matter if the transaction fails.\n\t\t */\n\t\tfor (i = bmap_nr; i < bmap_nr_new; i++) {\n\t\t\tint depth;\n\t\t\t/*\n\t\t\t * don't use read_bitmap_block since it will cache\n\t\t\t * the uninitialized bitmap\n\t\t\t */\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tbh = sb_bread(s, i * s->s_blocksize * 8);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\tif (!bh) {\n\t\t\t\tvfree(bitmap);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tmemset(bh->b_data, 0, sb_blocksize(sb));\n\t\t\treiserfs_set_le_bit(0, bh->b_data);\n\t\t\treiserfs_cache_bitmap_metadata(s, bh, bitmap + i);\n\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\t/* update bitmap_info stuff */\n\t\t\tbitmap[i].free_count = sb_blocksize(sb) * 8 - 1;\n\t\t\tbrelse(bh);\n\t\t}\n\t\t/* free old bitmap blocks array */\n\t\tSB_AP_BITMAP(s) = bitmap;\n\t\tvfree(old_bitmap);\n\t}\n\n\t/*\n\t * begin transaction, if there was an error, it's fine. Yes, we have\n\t * incorrect bitmaps now, but none of it is ever going to touch the\n\t * disk anyway.\n\t */\n\terr = journal_begin(&th, s, 10);\n\tif (err)\n\t\treturn err;\n\n\t/* Extend old last bitmap block - new blocks have been made available */\n\tinfo = SB_AP_BITMAP(s) + bmap_nr - 1;\n\tbh = reiserfs_read_bitmap_block(s, bmap_nr - 1);\n\tif (!bh) {\n\t\tint jerr = journal_end(&th);\n\t\tif (jerr)\n\t\t\treturn jerr;\n\t\treturn -EIO;\n\t}\n\n\treiserfs_prepare_for_journal(s, bh, 1);\n\tfor (i = block_r; i < s->s_blocksize * 8; i++)\n\t\treiserfs_clear_le_bit(i, bh->b_data);\n\tinfo->free_count += s->s_blocksize * 8 - block_r;\n\n\tjournal_mark_dirty(&th, bh);\n\tbrelse(bh);\n\n\t/* Correct new last bitmap block - It may not be full */\n\tinfo = SB_AP_BITMAP(s) + bmap_nr_new - 1;\n\tbh = reiserfs_read_bitmap_block(s, bmap_nr_new - 1);\n\tif (!bh) {\n\t\tint jerr = journal_end(&th);\n\t\tif (jerr)\n\t\t\treturn jerr;\n\t\treturn -EIO;\n\t}\n\n\treiserfs_prepare_for_journal(s, bh, 1);\n\tfor (i = block_r_new; i < s->s_blocksize * 8; i++)\n\t\treiserfs_set_le_bit(i, bh->b_data);\n\tjournal_mark_dirty(&th, bh);\n\tbrelse(bh);\n\n\tinfo->free_count -= s->s_blocksize * 8 - block_r_new;\n\t/* update super */\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\tfree_blocks = SB_FREE_BLOCKS(s);\n\tPUT_SB_FREE_BLOCKS(s,\n\t\t\t   free_blocks + (block_count_new - block_count -\n\t\t\t\t\t  (bmap_nr_new - bmap_nr)));\n\tPUT_SB_BLOCK_COUNT(s, block_count_new);\n\tPUT_SB_BMAP_NR(s, bmap_would_wrap(bmap_nr_new) ? : bmap_nr_new);\n\n\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\n\tSB_JOURNAL(s)->j_must_wait = 1;\n\treturn journal_end(&th);\n}"
  }
]