[
  {
    "function_name": "fuse_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1312-1320",
    "snippet": "static void __exit fuse_exit(void)\n{\n\tprintk(KERN_DEBUG \"fuse exit\\n\");\n\n\tfuse_ctl_cleanup();\n\tfuse_sysfs_cleanup();\n\tfuse_fs_cleanup();\n\tfuse_dev_cleanup();\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_dev_cleanup",
          "args": [],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_dev_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2275-2279",
          "snippet": "void fuse_dev_cleanup(void)\n{\n\tmisc_deregister(&fuse_miscdevice);\n\tkmem_cache_destroy(fuse_req_cachep);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_req_cachep;",
            "static struct miscdevice fuse_miscdevice = {\n\t.minor = FUSE_MINOR,\n\t.name  = \"fuse\",\n\t.fops = &fuse_dev_operations,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\nstatic struct miscdevice fuse_miscdevice = {\n\t.minor = FUSE_MINOR,\n\t.name  = \"fuse\",\n\t.fops = &fuse_dev_operations,\n};\n\nvoid fuse_dev_cleanup(void)\n{\n\tmisc_deregister(&fuse_miscdevice);\n\tkmem_cache_destroy(fuse_req_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_fs_cleanup",
          "args": [],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_fs_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "1227-1238",
          "snippet": "static void fuse_fs_cleanup(void)\n{\n\tunregister_filesystem(&fuse_fs_type);\n\tunregister_fuseblk();\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(fuse_inode_cachep);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_inode_cachep;",
            "static struct file_system_type fuse_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fuse\",\n\t.fs_flags\t= FS_HAS_SUBTYPE,\n\t.mount\t\t= fuse_mount,\n\t.kill_sb\t= fuse_kill_sb_anon,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_inode_cachep;\nstatic struct file_system_type fuse_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fuse\",\n\t.fs_flags\t= FS_HAS_SUBTYPE,\n\t.mount\t\t= fuse_mount,\n\t.kill_sb\t= fuse_kill_sb_anon,\n};\n\nstatic void fuse_fs_cleanup(void)\n{\n\tunregister_filesystem(&fuse_fs_type);\n\tunregister_fuseblk();\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(fuse_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_sysfs_cleanup",
          "args": [],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_sysfs_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "1267-1271",
          "snippet": "static void fuse_sysfs_cleanup(void)\n{\n\tkobject_put(connections_kobj);\n\tkobject_put(fuse_kobj);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *fuse_kobj;",
            "static struct kobject *connections_kobj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct kobject *fuse_kobj;\nstatic struct kobject *connections_kobj;\n\nstatic void fuse_sysfs_cleanup(void)\n{\n\tkobject_put(connections_kobj);\n\tkobject_put(fuse_kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_ctl_cleanup",
          "args": [],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ctl_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "351-354",
          "snippet": "void __exit fuse_ctl_cleanup(void)\n{\n\tunregister_filesystem(&fuse_ctl_fs_type);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type fuse_ctl_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fusectl\",\n\t.mount\t\t= fuse_ctl_mount,\n\t.kill_sb\t= fuse_ctl_kill_sb,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct file_system_type fuse_ctl_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fusectl\",\n\t.mount\t\t= fuse_ctl_mount,\n\t.kill_sb\t= fuse_ctl_kill_sb,\n};\n\nvoid __exit fuse_ctl_cleanup(void)\n{\n\tunregister_filesystem(&fuse_ctl_fs_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"fuse exit\\n\""
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void __exit fuse_exit(void)\n{\n\tprintk(KERN_DEBUG \"fuse exit\\n\");\n\n\tfuse_ctl_cleanup();\n\tfuse_sysfs_cleanup();\n\tfuse_fs_cleanup();\n\tfuse_dev_cleanup();\n}"
  },
  {
    "function_name": "fuse_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1273-1310",
    "snippet": "static int __init fuse_init(void)\n{\n\tint res;\n\n\tprintk(KERN_INFO \"fuse init (API version %i.%i)\\n\",\n\t       FUSE_KERNEL_VERSION, FUSE_KERNEL_MINOR_VERSION);\n\n\tINIT_LIST_HEAD(&fuse_conn_list);\n\tres = fuse_fs_init();\n\tif (res)\n\t\tgoto err;\n\n\tres = fuse_dev_init();\n\tif (res)\n\t\tgoto err_fs_cleanup;\n\n\tres = fuse_sysfs_init();\n\tif (res)\n\t\tgoto err_dev_cleanup;\n\n\tres = fuse_ctl_init();\n\tif (res)\n\t\tgoto err_sysfs_cleanup;\n\n\tsanitize_global_limit(&max_user_bgreq);\n\tsanitize_global_limit(&max_user_congthresh);\n\n\treturn 0;\n\n err_sysfs_cleanup:\n\tfuse_sysfs_cleanup();\n err_dev_cleanup:\n\tfuse_dev_cleanup();\n err_fs_cleanup:\n\tfuse_fs_cleanup();\n err:\n\treturn res;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct list_head fuse_conn_list;",
      "unsigned max_user_bgreq;",
      "unsigned max_user_congthresh;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_fs_cleanup",
          "args": [],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_fs_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "1227-1238",
          "snippet": "static void fuse_fs_cleanup(void)\n{\n\tunregister_filesystem(&fuse_fs_type);\n\tunregister_fuseblk();\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(fuse_inode_cachep);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_inode_cachep;",
            "static struct file_system_type fuse_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fuse\",\n\t.fs_flags\t= FS_HAS_SUBTYPE,\n\t.mount\t\t= fuse_mount,\n\t.kill_sb\t= fuse_kill_sb_anon,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_inode_cachep;\nstatic struct file_system_type fuse_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fuse\",\n\t.fs_flags\t= FS_HAS_SUBTYPE,\n\t.mount\t\t= fuse_mount,\n\t.kill_sb\t= fuse_kill_sb_anon,\n};\n\nstatic void fuse_fs_cleanup(void)\n{\n\tunregister_filesystem(&fuse_fs_type);\n\tunregister_fuseblk();\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(fuse_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_dev_cleanup",
          "args": [],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_dev_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2275-2279",
          "snippet": "void fuse_dev_cleanup(void)\n{\n\tmisc_deregister(&fuse_miscdevice);\n\tkmem_cache_destroy(fuse_req_cachep);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_req_cachep;",
            "static struct miscdevice fuse_miscdevice = {\n\t.minor = FUSE_MINOR,\n\t.name  = \"fuse\",\n\t.fops = &fuse_dev_operations,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\nstatic struct miscdevice fuse_miscdevice = {\n\t.minor = FUSE_MINOR,\n\t.name  = \"fuse\",\n\t.fops = &fuse_dev_operations,\n};\n\nvoid fuse_dev_cleanup(void)\n{\n\tmisc_deregister(&fuse_miscdevice);\n\tkmem_cache_destroy(fuse_req_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_sysfs_cleanup",
          "args": [],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_sysfs_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "1267-1271",
          "snippet": "static void fuse_sysfs_cleanup(void)\n{\n\tkobject_put(connections_kobj);\n\tkobject_put(fuse_kobj);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *fuse_kobj;",
            "static struct kobject *connections_kobj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct kobject *fuse_kobj;\nstatic struct kobject *connections_kobj;\n\nstatic void fuse_sysfs_cleanup(void)\n{\n\tkobject_put(connections_kobj);\n\tkobject_put(fuse_kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanitize_global_limit",
          "args": [
            "&max_user_congthresh"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_global_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "791-799",
          "snippet": "static void sanitize_global_limit(unsigned *limit)\n{\n\tif (*limit == 0)\n\t\t*limit = ((totalram_pages << PAGE_SHIFT) >> 13) /\n\t\t\t sizeof(struct fuse_req);\n\n\tif (*limit >= 1 << 16)\n\t\t*limit = (1 << 16) - 1;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void sanitize_global_limit(unsigned *limit)\n{\n\tif (*limit == 0)\n\t\t*limit = ((totalram_pages << PAGE_SHIFT) >> 13) /\n\t\t\t sizeof(struct fuse_req);\n\n\tif (*limit >= 1 << 16)\n\t\t*limit = (1 << 16) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_ctl_init",
          "args": [],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ctl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "346-349",
          "snippet": "int __init fuse_ctl_init(void)\n{\n\treturn register_filesystem(&fuse_ctl_fs_type);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type fuse_ctl_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fusectl\",\n\t.mount\t\t= fuse_ctl_mount,\n\t.kill_sb\t= fuse_ctl_kill_sb,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct file_system_type fuse_ctl_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fusectl\",\n\t.mount\t\t= fuse_ctl_mount,\n\t.kill_sb\t= fuse_ctl_kill_sb,\n};\n\nint __init fuse_ctl_init(void)\n{\n\treturn register_filesystem(&fuse_ctl_fs_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_sysfs_init",
          "args": [],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_sysfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "1243-1265",
          "snippet": "static int fuse_sysfs_init(void)\n{\n\tint err;\n\n\tfuse_kobj = kobject_create_and_add(\"fuse\", fs_kobj);\n\tif (!fuse_kobj) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tconnections_kobj = kobject_create_and_add(\"connections\", fuse_kobj);\n\tif (!connections_kobj) {\n\t\terr = -ENOMEM;\n\t\tgoto out_fuse_unregister;\n\t}\n\n\treturn 0;\n\n out_fuse_unregister:\n\tkobject_put(fuse_kobj);\n out_err:\n\treturn err;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *fuse_kobj;",
            "static struct kobject *connections_kobj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct kobject *fuse_kobj;\nstatic struct kobject *connections_kobj;\n\nstatic int fuse_sysfs_init(void)\n{\n\tint err;\n\n\tfuse_kobj = kobject_create_and_add(\"fuse\", fs_kobj);\n\tif (!fuse_kobj) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tconnections_kobj = kobject_create_and_add(\"connections\", fuse_kobj);\n\tif (!connections_kobj) {\n\t\terr = -ENOMEM;\n\t\tgoto out_fuse_unregister;\n\t}\n\n\treturn 0;\n\n out_fuse_unregister:\n\tkobject_put(fuse_kobj);\n out_err:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_dev_init",
          "args": [],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_dev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2254-2273",
          "snippet": "int __init fuse_dev_init(void)\n{\n\tint err = -ENOMEM;\n\tfuse_req_cachep = kmem_cache_create(\"fuse_request\",\n\t\t\t\t\t    sizeof(struct fuse_req),\n\t\t\t\t\t    0, 0, NULL);\n\tif (!fuse_req_cachep)\n\t\tgoto out;\n\n\terr = misc_register(&fuse_miscdevice);\n\tif (err)\n\t\tgoto out_cache_clean;\n\n\treturn 0;\n\n out_cache_clean:\n\tkmem_cache_destroy(fuse_req_cachep);\n out:\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_req_cachep;",
            "static struct miscdevice fuse_miscdevice = {\n\t.minor = FUSE_MINOR,\n\t.name  = \"fuse\",\n\t.fops = &fuse_dev_operations,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\nstatic struct miscdevice fuse_miscdevice = {\n\t.minor = FUSE_MINOR,\n\t.name  = \"fuse\",\n\t.fops = &fuse_dev_operations,\n};\n\nint __init fuse_dev_init(void)\n{\n\tint err = -ENOMEM;\n\tfuse_req_cachep = kmem_cache_create(\"fuse_request\",\n\t\t\t\t\t    sizeof(struct fuse_req),\n\t\t\t\t\t    0, 0, NULL);\n\tif (!fuse_req_cachep)\n\t\tgoto out;\n\n\terr = misc_register(&fuse_miscdevice);\n\tif (err)\n\t\tgoto out_cache_clean;\n\n\treturn 0;\n\n out_cache_clean:\n\tkmem_cache_destroy(fuse_req_cachep);\n out:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_fs_init",
          "args": [],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_fs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "1197-1225",
          "snippet": "static int __init fuse_fs_init(void)\n{\n\tint err;\n\n\tfuse_inode_cachep = kmem_cache_create(\"fuse_inode\",\n\t\t\t\t\t      sizeof(struct fuse_inode),\n\t\t\t\t\t      0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t      fuse_inode_init_once);\n\terr = -ENOMEM;\n\tif (!fuse_inode_cachep)\n\t\tgoto out;\n\n\terr = register_fuseblk();\n\tif (err)\n\t\tgoto out2;\n\n\terr = register_filesystem(&fuse_fs_type);\n\tif (err)\n\t\tgoto out3;\n\n\treturn 0;\n\n out3:\n\tunregister_fuseblk();\n out2:\n\tkmem_cache_destroy(fuse_inode_cachep);\n out:\n\treturn err;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_inode_cachep;",
            "static struct file_system_type fuse_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fuse\",\n\t.fs_flags\t= FS_HAS_SUBTYPE,\n\t.mount\t\t= fuse_mount,\n\t.kill_sb\t= fuse_kill_sb_anon,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_inode_cachep;\nstatic struct file_system_type fuse_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fuse\",\n\t.fs_flags\t= FS_HAS_SUBTYPE,\n\t.mount\t\t= fuse_mount,\n\t.kill_sb\t= fuse_kill_sb_anon,\n};\n\nstatic int __init fuse_fs_init(void)\n{\n\tint err;\n\n\tfuse_inode_cachep = kmem_cache_create(\"fuse_inode\",\n\t\t\t\t\t      sizeof(struct fuse_inode),\n\t\t\t\t\t      0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t      fuse_inode_init_once);\n\terr = -ENOMEM;\n\tif (!fuse_inode_cachep)\n\t\tgoto out;\n\n\terr = register_fuseblk();\n\tif (err)\n\t\tgoto out2;\n\n\terr = register_filesystem(&fuse_fs_type);\n\tif (err)\n\t\tgoto out3;\n\n\treturn 0;\n\n out3:\n\tunregister_fuseblk();\n out2:\n\tkmem_cache_destroy(fuse_inode_cachep);\n out:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fuse_conn_list"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"fuse init (API version %i.%i)\\n\"",
            "FUSE_KERNEL_VERSION",
            "FUSE_KERNEL_MINOR_VERSION"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct list_head fuse_conn_list;\nunsigned max_user_bgreq;\nunsigned max_user_congthresh;\n\nstatic int __init fuse_init(void)\n{\n\tint res;\n\n\tprintk(KERN_INFO \"fuse init (API version %i.%i)\\n\",\n\t       FUSE_KERNEL_VERSION, FUSE_KERNEL_MINOR_VERSION);\n\n\tINIT_LIST_HEAD(&fuse_conn_list);\n\tres = fuse_fs_init();\n\tif (res)\n\t\tgoto err;\n\n\tres = fuse_dev_init();\n\tif (res)\n\t\tgoto err_fs_cleanup;\n\n\tres = fuse_sysfs_init();\n\tif (res)\n\t\tgoto err_dev_cleanup;\n\n\tres = fuse_ctl_init();\n\tif (res)\n\t\tgoto err_sysfs_cleanup;\n\n\tsanitize_global_limit(&max_user_bgreq);\n\tsanitize_global_limit(&max_user_congthresh);\n\n\treturn 0;\n\n err_sysfs_cleanup:\n\tfuse_sysfs_cleanup();\n err_dev_cleanup:\n\tfuse_dev_cleanup();\n err_fs_cleanup:\n\tfuse_fs_cleanup();\n err:\n\treturn res;\n}"
  },
  {
    "function_name": "fuse_sysfs_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1267-1271",
    "snippet": "static void fuse_sysfs_cleanup(void)\n{\n\tkobject_put(connections_kobj);\n\tkobject_put(fuse_kobj);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobject *fuse_kobj;",
      "static struct kobject *connections_kobj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "fuse_kobj"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "connections_kobj"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct kobject *fuse_kobj;\nstatic struct kobject *connections_kobj;\n\nstatic void fuse_sysfs_cleanup(void)\n{\n\tkobject_put(connections_kobj);\n\tkobject_put(fuse_kobj);\n}"
  },
  {
    "function_name": "fuse_sysfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1243-1265",
    "snippet": "static int fuse_sysfs_init(void)\n{\n\tint err;\n\n\tfuse_kobj = kobject_create_and_add(\"fuse\", fs_kobj);\n\tif (!fuse_kobj) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tconnections_kobj = kobject_create_and_add(\"connections\", fuse_kobj);\n\tif (!connections_kobj) {\n\t\terr = -ENOMEM;\n\t\tgoto out_fuse_unregister;\n\t}\n\n\treturn 0;\n\n out_fuse_unregister:\n\tkobject_put(fuse_kobj);\n out_err:\n\treturn err;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobject *fuse_kobj;",
      "static struct kobject *connections_kobj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "fuse_kobj"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"connections\"",
            "fuse_kobj"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"fuse\"",
            "fs_kobj"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct kobject *fuse_kobj;\nstatic struct kobject *connections_kobj;\n\nstatic int fuse_sysfs_init(void)\n{\n\tint err;\n\n\tfuse_kobj = kobject_create_and_add(\"fuse\", fs_kobj);\n\tif (!fuse_kobj) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tconnections_kobj = kobject_create_and_add(\"connections\", fuse_kobj);\n\tif (!connections_kobj) {\n\t\terr = -ENOMEM;\n\t\tgoto out_fuse_unregister;\n\t}\n\n\treturn 0;\n\n out_fuse_unregister:\n\tkobject_put(fuse_kobj);\n out_err:\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_fs_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1227-1238",
    "snippet": "static void fuse_fs_cleanup(void)\n{\n\tunregister_filesystem(&fuse_fs_type);\n\tunregister_fuseblk();\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(fuse_inode_cachep);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fuse_inode_cachep;",
      "static struct file_system_type fuse_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fuse\",\n\t.fs_flags\t= FS_HAS_SUBTYPE,\n\t.mount\t\t= fuse_mount,\n\t.kill_sb\t= fuse_kill_sb_anon,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "fuse_inode_cachep"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_fuseblk",
          "args": [],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_fuseblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "1185-1187",
          "snippet": "static inline void unregister_fuseblk(void)\n{\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void unregister_fuseblk(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&fuse_fs_type"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_inode_cachep;\nstatic struct file_system_type fuse_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fuse\",\n\t.fs_flags\t= FS_HAS_SUBTYPE,\n\t.mount\t\t= fuse_mount,\n\t.kill_sb\t= fuse_kill_sb_anon,\n};\n\nstatic void fuse_fs_cleanup(void)\n{\n\tunregister_filesystem(&fuse_fs_type);\n\tunregister_fuseblk();\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(fuse_inode_cachep);\n}"
  },
  {
    "function_name": "fuse_fs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1197-1225",
    "snippet": "static int __init fuse_fs_init(void)\n{\n\tint err;\n\n\tfuse_inode_cachep = kmem_cache_create(\"fuse_inode\",\n\t\t\t\t\t      sizeof(struct fuse_inode),\n\t\t\t\t\t      0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t      fuse_inode_init_once);\n\terr = -ENOMEM;\n\tif (!fuse_inode_cachep)\n\t\tgoto out;\n\n\terr = register_fuseblk();\n\tif (err)\n\t\tgoto out2;\n\n\terr = register_filesystem(&fuse_fs_type);\n\tif (err)\n\t\tgoto out3;\n\n\treturn 0;\n\n out3:\n\tunregister_fuseblk();\n out2:\n\tkmem_cache_destroy(fuse_inode_cachep);\n out:\n\treturn err;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fuse_inode_cachep;",
      "static struct file_system_type fuse_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fuse\",\n\t.fs_flags\t= FS_HAS_SUBTYPE,\n\t.mount\t\t= fuse_mount,\n\t.kill_sb\t= fuse_kill_sb_anon,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "fuse_inode_cachep"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_fuseblk",
          "args": [],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_fuseblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "1185-1187",
          "snippet": "static inline void unregister_fuseblk(void)\n{\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void unregister_fuseblk(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&fuse_fs_type"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"fuse_inode\"",
            "sizeof(struct fuse_inode)",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "fuse_inode_init_once"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_inode_cachep;\nstatic struct file_system_type fuse_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fuse\",\n\t.fs_flags\t= FS_HAS_SUBTYPE,\n\t.mount\t\t= fuse_mount,\n\t.kill_sb\t= fuse_kill_sb_anon,\n};\n\nstatic int __init fuse_fs_init(void)\n{\n\tint err;\n\n\tfuse_inode_cachep = kmem_cache_create(\"fuse_inode\",\n\t\t\t\t\t      sizeof(struct fuse_inode),\n\t\t\t\t\t      0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t      fuse_inode_init_once);\n\terr = -ENOMEM;\n\tif (!fuse_inode_cachep)\n\t\tgoto out;\n\n\terr = register_fuseblk();\n\tif (err)\n\t\tgoto out2;\n\n\terr = register_filesystem(&fuse_fs_type);\n\tif (err)\n\t\tgoto out3;\n\n\treturn 0;\n\n out3:\n\tunregister_fuseblk();\n out2:\n\tkmem_cache_destroy(fuse_inode_cachep);\n out:\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_inode_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1190-1195",
    "snippet": "static void fuse_inode_init_once(void *foo)\n{\n\tstruct inode *inode = foo;\n\n\tinode_init_once(inode);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "inode"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "1190-1195",
          "snippet": "static void fuse_inode_init_once(void *foo)\n{\n\tstruct inode *inode = foo;\n\n\tinode_init_once(inode);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_inode_init_once(void *foo)\n{\n\tstruct inode *inode = foo;\n\n\tinode_init_once(inode);\n}"
  },
  {
    "function_name": "unregister_fuseblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1185-1187",
    "snippet": "static inline void unregister_fuseblk(void)\n{\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void unregister_fuseblk(void)\n{\n}"
  },
  {
    "function_name": "register_fuseblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1180-1183",
    "snippet": "static inline int register_fuseblk(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline int register_fuseblk(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "unregister_fuseblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1175-1178",
    "snippet": "static inline void unregister_fuseblk(void)\n{\n\tunregister_filesystem(&fuseblk_fs_type);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&fuseblk_fs_type"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void unregister_fuseblk(void)\n{\n\tunregister_filesystem(&fuseblk_fs_type);\n}"
  },
  {
    "function_name": "register_fuseblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1170-1173",
    "snippet": "static inline int register_fuseblk(void)\n{\n\treturn register_filesystem(&fuseblk_fs_type);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&fuseblk_fs_type"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline int register_fuseblk(void)\n{\n\treturn register_filesystem(&fuseblk_fs_type);\n}"
  },
  {
    "function_name": "fuse_kill_sb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1148-1159",
    "snippet": "static void fuse_kill_sb_blk(struct super_block *sb)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n\tif (fc) {\n\t\tdown_write(&fc->killsb);\n\t\tfc->sb = NULL;\n\t\tup_write(&fc->killsb);\n\t}\n\n\tkill_block_super(sb);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_block_super",
          "args": [
            "sb"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_kill_block_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "629-638",
          "snippet": "static void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_sb_info_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstruct kmem_cache *ecryptfs_sb_info_cache;\n\nstatic void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&fc->killsb"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&fc->killsb"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn_super",
          "args": [
            "sb"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "618-621",
          "snippet": "static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_kill_sb_blk(struct super_block *sb)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n\tif (fc) {\n\t\tdown_write(&fc->killsb);\n\t\tfc->sb = NULL;\n\t\tup_write(&fc->killsb);\n\t}\n\n\tkill_block_super(sb);\n}"
  },
  {
    "function_name": "fuse_mount_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1141-1146",
    "snippet": "static struct dentry *fuse_mount_blk(struct file_system_type *fs_type,\n\t\t\t   int flags, const char *dev_name,\n\t\t\t   void *raw_data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, raw_data, fuse_fill_super);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "raw_data",
            "fuse_fill_super"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct dentry *fuse_mount_blk(struct file_system_type *fs_type,\n\t\t\t   int flags, const char *dev_name,\n\t\t\t   void *raw_data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, raw_data, fuse_fill_super);\n}"
  },
  {
    "function_name": "fuse_kill_sb_anon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1118-1129",
    "snippet": "static void fuse_kill_sb_anon(struct super_block *sb)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n\tif (fc) {\n\t\tdown_write(&fc->killsb);\n\t\tfc->sb = NULL;\n\t\tup_write(&fc->killsb);\n\t}\n\n\tkill_anon_super(sb);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_anon_super",
          "args": [
            "sb"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&fc->killsb"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&fc->killsb"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn_super",
          "args": [
            "sb"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "618-621",
          "snippet": "static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_kill_sb_anon(struct super_block *sb)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n\tif (fc) {\n\t\tdown_write(&fc->killsb);\n\t\tfc->sb = NULL;\n\t\tup_write(&fc->killsb);\n\t}\n\n\tkill_anon_super(sb);\n}"
  },
  {
    "function_name": "fuse_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "1111-1116",
    "snippet": "static struct dentry *fuse_mount(struct file_system_type *fs_type,\n\t\t       int flags, const char *dev_name,\n\t\t       void *raw_data)\n{\n\treturn mount_nodev(fs_type, flags, raw_data, fuse_fill_super);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_nodev",
          "args": [
            "fs_type",
            "flags",
            "raw_data",
            "fuse_fill_super"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct dentry *fuse_mount(struct file_system_type *fs_type,\n\t\t       int flags, const char *dev_name,\n\t\t       void *raw_data)\n{\n\treturn mount_nodev(fs_type, flags, raw_data, fuse_fill_super);\n}"
  },
  {
    "function_name": "fuse_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "978-1109",
    "snippet": "static int fuse_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct fuse_conn *fc;\n\tstruct inode *root;\n\tstruct fuse_mount_data d;\n\tstruct file *file;\n\tstruct dentry *root_dentry;\n\tstruct fuse_req *init_req;\n\tint err;\n\tint is_bdev = sb->s_bdev != NULL;\n\n\terr = -EINVAL;\n\tif (sb->s_flags & MS_MANDLOCK)\n\t\tgoto err;\n\n\tsb->s_flags &= ~(MS_NOSEC | MS_I_VERSION);\n\n\tif (!parse_fuse_opt(data, &d, is_bdev))\n\t\tgoto err;\n\n\tif (is_bdev) {\n#ifdef CONFIG_BLOCK\n\t\terr = -EINVAL;\n\t\tif (!sb_set_blocksize(sb, d.blksize))\n\t\t\tgoto err;\n#endif\n\t} else {\n\t\tsb->s_blocksize = PAGE_CACHE_SIZE;\n\t\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\t}\n\tsb->s_magic = FUSE_SUPER_MAGIC;\n\tsb->s_op = &fuse_super_operations;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_time_gran = 1;\n\tsb->s_export_op = &fuse_export_operations;\n\n\tfile = fget(d.fd);\n\terr = -EINVAL;\n\tif (!file)\n\t\tgoto err;\n\n\tif ((file->f_op != &fuse_dev_operations) ||\n\t    (file->f_cred->user_ns != &init_user_ns))\n\t\tgoto err_fput;\n\n\tfc = kmalloc(sizeof(*fc), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!fc)\n\t\tgoto err_fput;\n\n\tfuse_conn_init(fc);\n\n\tfc->dev = sb->s_dev;\n\tfc->sb = sb;\n\terr = fuse_bdi_init(fc, sb);\n\tif (err)\n\t\tgoto err_put_conn;\n\n\tsb->s_bdi = &fc->bdi;\n\n\t/* Handle umasking inside the fuse code */\n\tif (sb->s_flags & MS_POSIXACL)\n\t\tfc->dont_mask = 1;\n\tsb->s_flags |= MS_POSIXACL;\n\n\tfc->release = fuse_free_conn;\n\tfc->flags = d.flags;\n\tfc->user_id = d.user_id;\n\tfc->group_id = d.group_id;\n\tfc->max_read = max_t(unsigned, 4096, d.max_read);\n\n\t/* Used by get_root_inode() */\n\tsb->s_fs_info = fc;\n\n\terr = -ENOMEM;\n\troot = fuse_get_root_inode(sb, d.rootmode);\n\troot_dentry = d_make_root(root);\n\tif (!root_dentry)\n\t\tgoto err_put_conn;\n\t/* only now - we want root dentry with NULL ->d_op */\n\tsb->s_d_op = &fuse_dentry_operations;\n\n\tinit_req = fuse_request_alloc(0);\n\tif (!init_req)\n\t\tgoto err_put_root;\n\tinit_req->background = 1;\n\n\tif (is_bdev) {\n\t\tfc->destroy_req = fuse_request_alloc(0);\n\t\tif (!fc->destroy_req)\n\t\t\tgoto err_free_init_req;\n\t}\n\n\tmutex_lock(&fuse_mutex);\n\terr = -EINVAL;\n\tif (file->private_data)\n\t\tgoto err_unlock;\n\n\terr = fuse_ctl_add_conn(fc);\n\tif (err)\n\t\tgoto err_unlock;\n\n\tlist_add_tail(&fc->entry, &fuse_conn_list);\n\tsb->s_root = root_dentry;\n\tfc->connected = 1;\n\tfile->private_data = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\t/*\n\t * atomic_dec_and_test() in fput() provides the necessary\n\t * memory barrier for file->private_data to be visible on all\n\t * CPUs after this\n\t */\n\tfput(file);\n\n\tfuse_send_init(fc, init_req);\n\n\treturn 0;\n\n err_unlock:\n\tmutex_unlock(&fuse_mutex);\n err_free_init_req:\n\tfuse_request_free(init_req);\n err_put_root:\n\tdput(root_dentry);\n err_put_conn:\n\tfuse_bdi_destroy(fc);\n\tfuse_conn_put(fc);\n err_fput:\n\tfput(file);\n err:\n\treturn err;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [
      "#define FUSE_SUPER_MAGIC 0x65735546"
    ],
    "globals_used": [
      "struct list_head fuse_conn_list;",
      "static const struct export_operations fuse_export_operations = {\n\t.fh_to_dentry\t= fuse_fh_to_dentry,\n\t.fh_to_parent\t= fuse_fh_to_parent,\n\t.encode_fh\t= fuse_encode_fh,\n\t.get_parent\t= fuse_get_parent,\n};",
      "static const struct super_operations fuse_super_operations = {\n\t.alloc_inode    = fuse_alloc_inode,\n\t.destroy_inode  = fuse_destroy_inode,\n\t.evict_inode\t= fuse_evict_inode,\n\t.write_inode\t= fuse_write_inode,\n\t.drop_inode\t= generic_delete_inode,\n\t.remount_fs\t= fuse_remount_fs,\n\t.put_super\t= fuse_put_super,\n\t.umount_begin\t= fuse_umount_begin,\n\t.statfs\t\t= fuse_statfs,\n\t.show_options\t= fuse_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_conn_put",
          "args": [
            "fc"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "599-606",
          "snippet": "void fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_bdi_destroy",
          "args": [
            "fc"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "root_dentry"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_free",
          "args": [
            "init_req"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "93-100",
          "snippet": "void fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_req_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\n\nvoid fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fuse_mutex"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_send_init",
          "args": [
            "fc",
            "init_req"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_send_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "903-929",
          "snippet": "static void fuse_send_init(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_init_in *arg = &req->misc.init_in;\n\n\targ->major = FUSE_KERNEL_VERSION;\n\targ->minor = FUSE_KERNEL_MINOR_VERSION;\n\targ->max_readahead = fc->bdi.ra_pages * PAGE_CACHE_SIZE;\n\targ->flags |= FUSE_ASYNC_READ | FUSE_POSIX_LOCKS | FUSE_ATOMIC_O_TRUNC |\n\t\tFUSE_EXPORT_SUPPORT | FUSE_BIG_WRITES | FUSE_DONT_MASK |\n\t\tFUSE_SPLICE_WRITE | FUSE_SPLICE_MOVE | FUSE_SPLICE_READ |\n\t\tFUSE_FLOCK_LOCKS | FUSE_IOCTL_DIR | FUSE_AUTO_INVAL_DATA |\n\t\tFUSE_DO_READDIRPLUS | FUSE_READDIRPLUS_AUTO | FUSE_ASYNC_DIO |\n\t\tFUSE_WRITEBACK_CACHE | FUSE_NO_OPEN_SUPPORT;\n\treq->in.h.opcode = FUSE_INIT;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(*arg);\n\treq->in.args[0].value = arg;\n\treq->out.numargs = 1;\n\t/* Variable length argument used for backward compatibility\n\t   with interface version < 7.5.  Rest of init_out is zeroed\n\t   by do_get_request(), so a short reply is not a problem */\n\treq->out.argvar = 1;\n\treq->out.args[0].size = sizeof(struct fuse_init_out);\n\treq->out.args[0].value = &req->misc.init_out;\n\treq->end = process_init_reply;\n\tfuse_request_send_background(fc, req);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_send_init(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_init_in *arg = &req->misc.init_in;\n\n\targ->major = FUSE_KERNEL_VERSION;\n\targ->minor = FUSE_KERNEL_MINOR_VERSION;\n\targ->max_readahead = fc->bdi.ra_pages * PAGE_CACHE_SIZE;\n\targ->flags |= FUSE_ASYNC_READ | FUSE_POSIX_LOCKS | FUSE_ATOMIC_O_TRUNC |\n\t\tFUSE_EXPORT_SUPPORT | FUSE_BIG_WRITES | FUSE_DONT_MASK |\n\t\tFUSE_SPLICE_WRITE | FUSE_SPLICE_MOVE | FUSE_SPLICE_READ |\n\t\tFUSE_FLOCK_LOCKS | FUSE_IOCTL_DIR | FUSE_AUTO_INVAL_DATA |\n\t\tFUSE_DO_READDIRPLUS | FUSE_READDIRPLUS_AUTO | FUSE_ASYNC_DIO |\n\t\tFUSE_WRITEBACK_CACHE | FUSE_NO_OPEN_SUPPORT;\n\treq->in.h.opcode = FUSE_INIT;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(*arg);\n\treq->in.args[0].value = arg;\n\treq->out.numargs = 1;\n\t/* Variable length argument used for backward compatibility\n\t   with interface version < 7.5.  Rest of init_out is zeroed\n\t   by do_get_request(), so a short reply is not a problem */\n\treq->out.argvar = 1;\n\treq->out.args[0].size = sizeof(struct fuse_init_out);\n\treq->out.args[0].value = &req->misc.init_out;\n\treq->end = process_init_reply;\n\tfuse_request_send_background(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fuse_mutex"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_conn_get",
          "args": [
            "fc"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "609-613",
          "snippet": "struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)\n{\n\tatomic_inc(&fc->count);\n\treturn fc;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_conn *fuse_conn_get(struct fuse_conn *fc)\n{\n\tatomic_inc(&fc->count);\n\treturn fc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&fc->entry",
            "&fuse_conn_list"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_ctl_add_conn",
          "args": [
            "fc"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ctl_add_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "238-271",
          "snippet": "int fuse_ctl_add_conn(struct fuse_conn *fc)\n{\n\tstruct dentry *parent;\n\tchar name[32];\n\n\tif (!fuse_control_sb)\n\t\treturn 0;\n\n\tparent = fuse_control_sb->s_root;\n\tinc_nlink(parent->d_inode);\n\tsprintf(name, \"%u\", fc->dev);\n\tparent = fuse_ctl_add_dentry(parent, fc, name, S_IFDIR | 0500, 2,\n\t\t\t\t     &simple_dir_inode_operations,\n\t\t\t\t     &simple_dir_operations);\n\tif (!parent)\n\t\tgoto err;\n\n\tif (!fuse_ctl_add_dentry(parent, fc, \"waiting\", S_IFREG | 0400, 1,\n\t\t\t\t NULL, &fuse_ctl_waiting_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"abort\", S_IFREG | 0200, 1,\n\t\t\t\t NULL, &fuse_ctl_abort_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"max_background\", S_IFREG | 0600,\n\t\t\t\t 1, NULL, &fuse_conn_max_background_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"congestion_threshold\",\n\t\t\t\t S_IFREG | 0600, 1, NULL,\n\t\t\t\t &fuse_conn_congestion_threshold_ops))\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\tfuse_ctl_remove_conn(fc);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct super_block *fuse_control_sb;",
            "static const struct file_operations fuse_ctl_abort_ops = {\n\t.open = nonseekable_open,\n\t.write = fuse_conn_abort_write,\n\t.llseek = no_llseek,\n};",
            "static const struct file_operations fuse_ctl_waiting_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_waiting_read,\n\t.llseek = no_llseek,\n};",
            "static const struct file_operations fuse_conn_max_background_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_max_background_read,\n\t.write = fuse_conn_max_background_write,\n\t.llseek = no_llseek,\n};",
            "static const struct file_operations fuse_conn_congestion_threshold_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_congestion_threshold_read,\n\t.write = fuse_conn_congestion_threshold_write,\n\t.llseek = no_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct super_block *fuse_control_sb;\nstatic const struct file_operations fuse_ctl_abort_ops = {\n\t.open = nonseekable_open,\n\t.write = fuse_conn_abort_write,\n\t.llseek = no_llseek,\n};\nstatic const struct file_operations fuse_ctl_waiting_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_waiting_read,\n\t.llseek = no_llseek,\n};\nstatic const struct file_operations fuse_conn_max_background_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_max_background_read,\n\t.write = fuse_conn_max_background_write,\n\t.llseek = no_llseek,\n};\nstatic const struct file_operations fuse_conn_congestion_threshold_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_congestion_threshold_read,\n\t.write = fuse_conn_congestion_threshold_write,\n\t.llseek = no_llseek,\n};\n\nint fuse_ctl_add_conn(struct fuse_conn *fc)\n{\n\tstruct dentry *parent;\n\tchar name[32];\n\n\tif (!fuse_control_sb)\n\t\treturn 0;\n\n\tparent = fuse_control_sb->s_root;\n\tinc_nlink(parent->d_inode);\n\tsprintf(name, \"%u\", fc->dev);\n\tparent = fuse_ctl_add_dentry(parent, fc, name, S_IFDIR | 0500, 2,\n\t\t\t\t     &simple_dir_inode_operations,\n\t\t\t\t     &simple_dir_operations);\n\tif (!parent)\n\t\tgoto err;\n\n\tif (!fuse_ctl_add_dentry(parent, fc, \"waiting\", S_IFREG | 0400, 1,\n\t\t\t\t NULL, &fuse_ctl_waiting_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"abort\", S_IFREG | 0200, 1,\n\t\t\t\t NULL, &fuse_ctl_abort_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"max_background\", S_IFREG | 0600,\n\t\t\t\t 1, NULL, &fuse_conn_max_background_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"congestion_threshold\",\n\t\t\t\t S_IFREG | 0600, 1, NULL,\n\t\t\t\t &fuse_conn_congestion_threshold_ops))\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\tfuse_ctl_remove_conn(fc);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fuse_mutex"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_request_alloc",
          "args": [
            "0"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_alloc_nofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "88-91",
          "snippet": "struct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_root_inode",
          "args": [
            "sb",
            "d.rootmode"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_root_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "616-625",
          "snippet": "static struct inode *fuse_get_root_inode(struct super_block *sb, unsigned mode)\n{\n\tstruct fuse_attr attr;\n\tmemset(&attr, 0, sizeof(attr));\n\n\tattr.mode = mode;\n\tattr.ino = FUSE_ROOT_ID;\n\tattr.nlink = 1;\n\treturn fuse_iget(sb, 1, 0, &attr, 0, 0);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct inode *fuse_get_root_inode(struct super_block *sb, unsigned mode)\n{\n\tstruct fuse_attr attr;\n\tmemset(&attr, 0, sizeof(attr));\n\n\tattr.mode = mode;\n\tattr.ino = FUSE_ROOT_ID;\n\tattr.nlink = 1;\n\treturn fuse_iget(sb, 1, 0, &attr, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsigned",
            "4096",
            "d.max_read"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_bdi_init",
          "args": [
            "fc",
            "sb"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "936-976",
          "snippet": "static int fuse_bdi_init(struct fuse_conn *fc, struct super_block *sb)\n{\n\tint err;\n\n\tfc->bdi.name = \"fuse\";\n\tfc->bdi.ra_pages = (VM_MAX_READAHEAD * 1024) / PAGE_CACHE_SIZE;\n\t/* fuse does it's own writeback accounting */\n\tfc->bdi.capabilities = BDI_CAP_NO_ACCT_WB | BDI_CAP_STRICTLIMIT;\n\n\terr = bdi_init(&fc->bdi);\n\tif (err)\n\t\treturn err;\n\n\tfc->bdi_initialized = 1;\n\n\tif (sb->s_bdev) {\n\t\terr =  bdi_register(&fc->bdi, NULL, \"%u:%u-fuseblk\",\n\t\t\t\t    MAJOR(fc->dev), MINOR(fc->dev));\n\t} else {\n\t\terr = bdi_register_dev(&fc->bdi, fc->dev);\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * For a single fuse filesystem use max 1% of dirty +\n\t * writeback threshold.\n\t *\n\t * This gives about 1M of write buffer for memory maps on a\n\t * machine with 1G and 10% dirty_ratio, which should be more\n\t * than enough.\n\t *\n\t * Privileged users can raise it by writing to\n\t *\n\t *    /sys/class/bdi/<bdi>/max_ratio\n\t */\n\tbdi_set_max_ratio(&fc->bdi, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_bdi_init(struct fuse_conn *fc, struct super_block *sb)\n{\n\tint err;\n\n\tfc->bdi.name = \"fuse\";\n\tfc->bdi.ra_pages = (VM_MAX_READAHEAD * 1024) / PAGE_CACHE_SIZE;\n\t/* fuse does it's own writeback accounting */\n\tfc->bdi.capabilities = BDI_CAP_NO_ACCT_WB | BDI_CAP_STRICTLIMIT;\n\n\terr = bdi_init(&fc->bdi);\n\tif (err)\n\t\treturn err;\n\n\tfc->bdi_initialized = 1;\n\n\tif (sb->s_bdev) {\n\t\terr =  bdi_register(&fc->bdi, NULL, \"%u:%u-fuseblk\",\n\t\t\t\t    MAJOR(fc->dev), MINOR(fc->dev));\n\t} else {\n\t\terr = bdi_register_dev(&fc->bdi, fc->dev);\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * For a single fuse filesystem use max 1% of dirty +\n\t * writeback threshold.\n\t *\n\t * This gives about 1M of write buffer for memory maps on a\n\t * machine with 1G and 10% dirty_ratio, which should be more\n\t * than enough.\n\t *\n\t * Privileged users can raise it by writing to\n\t *\n\t *    /sys/class/bdi/<bdi>/max_ratio\n\t */\n\tbdi_set_max_ratio(&fc->bdi, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_conn_init",
          "args": [
            "fc"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "570-596",
          "snippet": "void fuse_conn_init(struct fuse_conn *fc)\n{\n\tmemset(fc, 0, sizeof(*fc));\n\tspin_lock_init(&fc->lock);\n\tinit_rwsem(&fc->killsb);\n\tatomic_set(&fc->count, 1);\n\tinit_waitqueue_head(&fc->waitq);\n\tinit_waitqueue_head(&fc->blocked_waitq);\n\tinit_waitqueue_head(&fc->reserved_req_waitq);\n\tINIT_LIST_HEAD(&fc->pending);\n\tINIT_LIST_HEAD(&fc->processing);\n\tINIT_LIST_HEAD(&fc->io);\n\tINIT_LIST_HEAD(&fc->interrupts);\n\tINIT_LIST_HEAD(&fc->bg_queue);\n\tINIT_LIST_HEAD(&fc->entry);\n\tfc->forget_list_tail = &fc->forget_list_head;\n\tatomic_set(&fc->num_waiting, 0);\n\tfc->max_background = FUSE_DEFAULT_MAX_BACKGROUND;\n\tfc->congestion_threshold = FUSE_DEFAULT_CONGESTION_THRESHOLD;\n\tfc->khctr = 0;\n\tfc->polled_files = RB_ROOT;\n\tfc->reqctr = 0;\n\tfc->blocked = 0;\n\tfc->initialized = 0;\n\tfc->attr_version = 1;\n\tget_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [
            "#define FUSE_DEFAULT_CONGESTION_THRESHOLD (FUSE_DEFAULT_MAX_BACKGROUND * 3 / 4)",
            "#define FUSE_DEFAULT_MAX_BACKGROUND 12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\n#define FUSE_DEFAULT_CONGESTION_THRESHOLD (FUSE_DEFAULT_MAX_BACKGROUND * 3 / 4)\n#define FUSE_DEFAULT_MAX_BACKGROUND 12\n\nvoid fuse_conn_init(struct fuse_conn *fc)\n{\n\tmemset(fc, 0, sizeof(*fc));\n\tspin_lock_init(&fc->lock);\n\tinit_rwsem(&fc->killsb);\n\tatomic_set(&fc->count, 1);\n\tinit_waitqueue_head(&fc->waitq);\n\tinit_waitqueue_head(&fc->blocked_waitq);\n\tinit_waitqueue_head(&fc->reserved_req_waitq);\n\tINIT_LIST_HEAD(&fc->pending);\n\tINIT_LIST_HEAD(&fc->processing);\n\tINIT_LIST_HEAD(&fc->io);\n\tINIT_LIST_HEAD(&fc->interrupts);\n\tINIT_LIST_HEAD(&fc->bg_queue);\n\tINIT_LIST_HEAD(&fc->entry);\n\tfc->forget_list_tail = &fc->forget_list_head;\n\tatomic_set(&fc->num_waiting, 0);\n\tfc->max_background = FUSE_DEFAULT_MAX_BACKGROUND;\n\tfc->congestion_threshold = FUSE_DEFAULT_CONGESTION_THRESHOLD;\n\tfc->khctr = 0;\n\tfc->polled_files = RB_ROOT;\n\tfc->reqctr = 0;\n\tfc->blocked = 0;\n\tfc->initialized = 0;\n\tfc->attr_version = 1;\n\tget_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*fc)",
            "GFP_KERNEL"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "d.fd"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "fget_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "656-659",
          "snippet": "struct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "d.blksize"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_fuse_opt",
          "args": [
            "data",
            "&d",
            "is_bdev"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "parse_fuse_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "469-550",
          "snippet": "static int parse_fuse_opt(char *opt, struct fuse_mount_data *d, int is_bdev)\n{\n\tchar *p;\n\tmemset(d, 0, sizeof(struct fuse_mount_data));\n\td->max_read = ~0;\n\td->blksize = FUSE_DEFAULT_BLKSIZE;\n\n\twhile ((p = strsep(&opt, \",\")) != NULL) {\n\t\tint token;\n\t\tint value;\n\t\tunsigned uv;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase OPT_FD:\n\t\t\tif (match_int(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\td->fd = value;\n\t\t\td->fd_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_ROOTMODE:\n\t\t\tif (match_octal(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\tif (!fuse_valid_type(value))\n\t\t\t\treturn 0;\n\t\t\td->rootmode = value;\n\t\t\td->rootmode_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_USER_ID:\n\t\t\tif (fuse_match_uint(&args[0], &uv))\n\t\t\t\treturn 0;\n\t\t\td->user_id = make_kuid(current_user_ns(), uv);\n\t\t\tif (!uid_valid(d->user_id))\n\t\t\t\treturn 0;\n\t\t\td->user_id_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_GROUP_ID:\n\t\t\tif (fuse_match_uint(&args[0], &uv))\n\t\t\t\treturn 0;\n\t\t\td->group_id = make_kgid(current_user_ns(), uv);\n\t\t\tif (!gid_valid(d->group_id))\n\t\t\t\treturn 0;\n\t\t\td->group_id_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_DEFAULT_PERMISSIONS:\n\t\t\td->flags |= FUSE_DEFAULT_PERMISSIONS;\n\t\t\tbreak;\n\n\t\tcase OPT_ALLOW_OTHER:\n\t\t\td->flags |= FUSE_ALLOW_OTHER;\n\t\t\tbreak;\n\n\t\tcase OPT_MAX_READ:\n\t\t\tif (match_int(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\td->max_read = value;\n\t\t\tbreak;\n\n\t\tcase OPT_BLKSIZE:\n\t\t\tif (!is_bdev || match_int(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\td->blksize = value;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!d->fd_present || !d->rootmode_present ||\n\t    !d->user_id_present || !d->group_id_present)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [
            "#define FUSE_DEFAULT_BLKSIZE 512"
          ],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{OPT_FD,\t\t\t\"fd=%u\"},\n\t{OPT_ROOTMODE,\t\t\t\"rootmode=%o\"},\n\t{OPT_USER_ID,\t\t\t\"user_id=%u\"},\n\t{OPT_GROUP_ID,\t\t\t\"group_id=%u\"},\n\t{OPT_DEFAULT_PERMISSIONS,\t\"default_permissions\"},\n\t{OPT_ALLOW_OTHER,\t\t\"allow_other\"},\n\t{OPT_MAX_READ,\t\t\t\"max_read=%u\"},\n\t{OPT_BLKSIZE,\t\t\t\"blksize=%u\"},\n\t{OPT_ERR,\t\t\tNULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\n#define FUSE_DEFAULT_BLKSIZE 512\n\nstatic const match_table_t tokens = {\n\t{OPT_FD,\t\t\t\"fd=%u\"},\n\t{OPT_ROOTMODE,\t\t\t\"rootmode=%o\"},\n\t{OPT_USER_ID,\t\t\t\"user_id=%u\"},\n\t{OPT_GROUP_ID,\t\t\t\"group_id=%u\"},\n\t{OPT_DEFAULT_PERMISSIONS,\t\"default_permissions\"},\n\t{OPT_ALLOW_OTHER,\t\t\"allow_other\"},\n\t{OPT_MAX_READ,\t\t\t\"max_read=%u\"},\n\t{OPT_BLKSIZE,\t\t\t\"blksize=%u\"},\n\t{OPT_ERR,\t\t\tNULL}\n};\n\nstatic int parse_fuse_opt(char *opt, struct fuse_mount_data *d, int is_bdev)\n{\n\tchar *p;\n\tmemset(d, 0, sizeof(struct fuse_mount_data));\n\td->max_read = ~0;\n\td->blksize = FUSE_DEFAULT_BLKSIZE;\n\n\twhile ((p = strsep(&opt, \",\")) != NULL) {\n\t\tint token;\n\t\tint value;\n\t\tunsigned uv;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase OPT_FD:\n\t\t\tif (match_int(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\td->fd = value;\n\t\t\td->fd_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_ROOTMODE:\n\t\t\tif (match_octal(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\tif (!fuse_valid_type(value))\n\t\t\t\treturn 0;\n\t\t\td->rootmode = value;\n\t\t\td->rootmode_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_USER_ID:\n\t\t\tif (fuse_match_uint(&args[0], &uv))\n\t\t\t\treturn 0;\n\t\t\td->user_id = make_kuid(current_user_ns(), uv);\n\t\t\tif (!uid_valid(d->user_id))\n\t\t\t\treturn 0;\n\t\t\td->user_id_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_GROUP_ID:\n\t\t\tif (fuse_match_uint(&args[0], &uv))\n\t\t\t\treturn 0;\n\t\t\td->group_id = make_kgid(current_user_ns(), uv);\n\t\t\tif (!gid_valid(d->group_id))\n\t\t\t\treturn 0;\n\t\t\td->group_id_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_DEFAULT_PERMISSIONS:\n\t\t\td->flags |= FUSE_DEFAULT_PERMISSIONS;\n\t\t\tbreak;\n\n\t\tcase OPT_ALLOW_OTHER:\n\t\t\td->flags |= FUSE_ALLOW_OTHER;\n\t\t\tbreak;\n\n\t\tcase OPT_MAX_READ:\n\t\t\tif (match_int(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\td->max_read = value;\n\t\t\tbreak;\n\n\t\tcase OPT_BLKSIZE:\n\t\t\tif (!is_bdev || match_int(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\td->blksize = value;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!d->fd_present || !d->rootmode_present ||\n\t    !d->user_id_present || !d->group_id_present)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\n#define FUSE_SUPER_MAGIC 0x65735546\n\nstruct list_head fuse_conn_list;\nstatic const struct export_operations fuse_export_operations = {\n\t.fh_to_dentry\t= fuse_fh_to_dentry,\n\t.fh_to_parent\t= fuse_fh_to_parent,\n\t.encode_fh\t= fuse_encode_fh,\n\t.get_parent\t= fuse_get_parent,\n};\nstatic const struct super_operations fuse_super_operations = {\n\t.alloc_inode    = fuse_alloc_inode,\n\t.destroy_inode  = fuse_destroy_inode,\n\t.evict_inode\t= fuse_evict_inode,\n\t.write_inode\t= fuse_write_inode,\n\t.drop_inode\t= generic_delete_inode,\n\t.remount_fs\t= fuse_remount_fs,\n\t.put_super\t= fuse_put_super,\n\t.umount_begin\t= fuse_umount_begin,\n\t.statfs\t\t= fuse_statfs,\n\t.show_options\t= fuse_show_options,\n};\n\nstatic int fuse_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct fuse_conn *fc;\n\tstruct inode *root;\n\tstruct fuse_mount_data d;\n\tstruct file *file;\n\tstruct dentry *root_dentry;\n\tstruct fuse_req *init_req;\n\tint err;\n\tint is_bdev = sb->s_bdev != NULL;\n\n\terr = -EINVAL;\n\tif (sb->s_flags & MS_MANDLOCK)\n\t\tgoto err;\n\n\tsb->s_flags &= ~(MS_NOSEC | MS_I_VERSION);\n\n\tif (!parse_fuse_opt(data, &d, is_bdev))\n\t\tgoto err;\n\n\tif (is_bdev) {\n#ifdef CONFIG_BLOCK\n\t\terr = -EINVAL;\n\t\tif (!sb_set_blocksize(sb, d.blksize))\n\t\t\tgoto err;\n#endif\n\t} else {\n\t\tsb->s_blocksize = PAGE_CACHE_SIZE;\n\t\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\t}\n\tsb->s_magic = FUSE_SUPER_MAGIC;\n\tsb->s_op = &fuse_super_operations;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_time_gran = 1;\n\tsb->s_export_op = &fuse_export_operations;\n\n\tfile = fget(d.fd);\n\terr = -EINVAL;\n\tif (!file)\n\t\tgoto err;\n\n\tif ((file->f_op != &fuse_dev_operations) ||\n\t    (file->f_cred->user_ns != &init_user_ns))\n\t\tgoto err_fput;\n\n\tfc = kmalloc(sizeof(*fc), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!fc)\n\t\tgoto err_fput;\n\n\tfuse_conn_init(fc);\n\n\tfc->dev = sb->s_dev;\n\tfc->sb = sb;\n\terr = fuse_bdi_init(fc, sb);\n\tif (err)\n\t\tgoto err_put_conn;\n\n\tsb->s_bdi = &fc->bdi;\n\n\t/* Handle umasking inside the fuse code */\n\tif (sb->s_flags & MS_POSIXACL)\n\t\tfc->dont_mask = 1;\n\tsb->s_flags |= MS_POSIXACL;\n\n\tfc->release = fuse_free_conn;\n\tfc->flags = d.flags;\n\tfc->user_id = d.user_id;\n\tfc->group_id = d.group_id;\n\tfc->max_read = max_t(unsigned, 4096, d.max_read);\n\n\t/* Used by get_root_inode() */\n\tsb->s_fs_info = fc;\n\n\terr = -ENOMEM;\n\troot = fuse_get_root_inode(sb, d.rootmode);\n\troot_dentry = d_make_root(root);\n\tif (!root_dentry)\n\t\tgoto err_put_conn;\n\t/* only now - we want root dentry with NULL ->d_op */\n\tsb->s_d_op = &fuse_dentry_operations;\n\n\tinit_req = fuse_request_alloc(0);\n\tif (!init_req)\n\t\tgoto err_put_root;\n\tinit_req->background = 1;\n\n\tif (is_bdev) {\n\t\tfc->destroy_req = fuse_request_alloc(0);\n\t\tif (!fc->destroy_req)\n\t\t\tgoto err_free_init_req;\n\t}\n\n\tmutex_lock(&fuse_mutex);\n\terr = -EINVAL;\n\tif (file->private_data)\n\t\tgoto err_unlock;\n\n\terr = fuse_ctl_add_conn(fc);\n\tif (err)\n\t\tgoto err_unlock;\n\n\tlist_add_tail(&fc->entry, &fuse_conn_list);\n\tsb->s_root = root_dentry;\n\tfc->connected = 1;\n\tfile->private_data = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\t/*\n\t * atomic_dec_and_test() in fput() provides the necessary\n\t * memory barrier for file->private_data to be visible on all\n\t * CPUs after this\n\t */\n\tfput(file);\n\n\tfuse_send_init(fc, init_req);\n\n\treturn 0;\n\n err_unlock:\n\tmutex_unlock(&fuse_mutex);\n err_free_init_req:\n\tfuse_request_free(init_req);\n err_put_root:\n\tdput(root_dentry);\n err_put_conn:\n\tfuse_bdi_destroy(fc);\n\tfuse_conn_put(fc);\n err_fput:\n\tfput(file);\n err:\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_bdi_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "936-976",
    "snippet": "static int fuse_bdi_init(struct fuse_conn *fc, struct super_block *sb)\n{\n\tint err;\n\n\tfc->bdi.name = \"fuse\";\n\tfc->bdi.ra_pages = (VM_MAX_READAHEAD * 1024) / PAGE_CACHE_SIZE;\n\t/* fuse does it's own writeback accounting */\n\tfc->bdi.capabilities = BDI_CAP_NO_ACCT_WB | BDI_CAP_STRICTLIMIT;\n\n\terr = bdi_init(&fc->bdi);\n\tif (err)\n\t\treturn err;\n\n\tfc->bdi_initialized = 1;\n\n\tif (sb->s_bdev) {\n\t\terr =  bdi_register(&fc->bdi, NULL, \"%u:%u-fuseblk\",\n\t\t\t\t    MAJOR(fc->dev), MINOR(fc->dev));\n\t} else {\n\t\terr = bdi_register_dev(&fc->bdi, fc->dev);\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * For a single fuse filesystem use max 1% of dirty +\n\t * writeback threshold.\n\t *\n\t * This gives about 1M of write buffer for memory maps on a\n\t * machine with 1G and 10% dirty_ratio, which should be more\n\t * than enough.\n\t *\n\t * Privileged users can raise it by writing to\n\t *\n\t *    /sys/class/bdi/<bdi>/max_ratio\n\t */\n\tbdi_set_max_ratio(&fc->bdi, 1);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdi_set_max_ratio",
          "args": [
            "&fc->bdi",
            "1"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_register_dev",
          "args": [
            "&fc->bdi",
            "fc->dev"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_register",
          "args": [
            "&fc->bdi",
            "NULL",
            "\"%u:%u-fuseblk\"",
            "MAJOR(fc->dev)",
            "MINOR(fc->dev)"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "fc->dev"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "fc->dev"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_init",
          "args": [
            "&fc->bdi"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_bdi_init(struct fuse_conn *fc, struct super_block *sb)\n{\n\tint err;\n\n\tfc->bdi.name = \"fuse\";\n\tfc->bdi.ra_pages = (VM_MAX_READAHEAD * 1024) / PAGE_CACHE_SIZE;\n\t/* fuse does it's own writeback accounting */\n\tfc->bdi.capabilities = BDI_CAP_NO_ACCT_WB | BDI_CAP_STRICTLIMIT;\n\n\terr = bdi_init(&fc->bdi);\n\tif (err)\n\t\treturn err;\n\n\tfc->bdi_initialized = 1;\n\n\tif (sb->s_bdev) {\n\t\terr =  bdi_register(&fc->bdi, NULL, \"%u:%u-fuseblk\",\n\t\t\t\t    MAJOR(fc->dev), MINOR(fc->dev));\n\t} else {\n\t\terr = bdi_register_dev(&fc->bdi, fc->dev);\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * For a single fuse filesystem use max 1% of dirty +\n\t * writeback threshold.\n\t *\n\t * This gives about 1M of write buffer for memory maps on a\n\t * machine with 1G and 10% dirty_ratio, which should be more\n\t * than enough.\n\t *\n\t * Privileged users can raise it by writing to\n\t *\n\t *    /sys/class/bdi/<bdi>/max_ratio\n\t */\n\tbdi_set_max_ratio(&fc->bdi, 1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_free_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "931-934",
    "snippet": "static void fuse_free_conn(struct fuse_conn *fc)\n{\n\tkfree_rcu(fc, rcu);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "fc",
            "rcu"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_free_conn(struct fuse_conn *fc)\n{\n\tkfree_rcu(fc, rcu);\n}"
  },
  {
    "function_name": "fuse_send_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "903-929",
    "snippet": "static void fuse_send_init(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_init_in *arg = &req->misc.init_in;\n\n\targ->major = FUSE_KERNEL_VERSION;\n\targ->minor = FUSE_KERNEL_MINOR_VERSION;\n\targ->max_readahead = fc->bdi.ra_pages * PAGE_CACHE_SIZE;\n\targ->flags |= FUSE_ASYNC_READ | FUSE_POSIX_LOCKS | FUSE_ATOMIC_O_TRUNC |\n\t\tFUSE_EXPORT_SUPPORT | FUSE_BIG_WRITES | FUSE_DONT_MASK |\n\t\tFUSE_SPLICE_WRITE | FUSE_SPLICE_MOVE | FUSE_SPLICE_READ |\n\t\tFUSE_FLOCK_LOCKS | FUSE_IOCTL_DIR | FUSE_AUTO_INVAL_DATA |\n\t\tFUSE_DO_READDIRPLUS | FUSE_READDIRPLUS_AUTO | FUSE_ASYNC_DIO |\n\t\tFUSE_WRITEBACK_CACHE | FUSE_NO_OPEN_SUPPORT;\n\treq->in.h.opcode = FUSE_INIT;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(*arg);\n\treq->in.args[0].value = arg;\n\treq->out.numargs = 1;\n\t/* Variable length argument used for backward compatibility\n\t   with interface version < 7.5.  Rest of init_out is zeroed\n\t   by do_get_request(), so a short reply is not a problem */\n\treq->out.argvar = 1;\n\treq->out.args[0].size = sizeof(struct fuse_init_out);\n\treq->out.args[0].value = &req->misc.init_out;\n\treq->end = process_init_reply;\n\tfuse_request_send_background(fc, req);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_request_send_background",
          "args": [
            "fc",
            "req"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_send_init(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_init_in *arg = &req->misc.init_in;\n\n\targ->major = FUSE_KERNEL_VERSION;\n\targ->minor = FUSE_KERNEL_MINOR_VERSION;\n\targ->max_readahead = fc->bdi.ra_pages * PAGE_CACHE_SIZE;\n\targ->flags |= FUSE_ASYNC_READ | FUSE_POSIX_LOCKS | FUSE_ATOMIC_O_TRUNC |\n\t\tFUSE_EXPORT_SUPPORT | FUSE_BIG_WRITES | FUSE_DONT_MASK |\n\t\tFUSE_SPLICE_WRITE | FUSE_SPLICE_MOVE | FUSE_SPLICE_READ |\n\t\tFUSE_FLOCK_LOCKS | FUSE_IOCTL_DIR | FUSE_AUTO_INVAL_DATA |\n\t\tFUSE_DO_READDIRPLUS | FUSE_READDIRPLUS_AUTO | FUSE_ASYNC_DIO |\n\t\tFUSE_WRITEBACK_CACHE | FUSE_NO_OPEN_SUPPORT;\n\treq->in.h.opcode = FUSE_INIT;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(*arg);\n\treq->in.args[0].value = arg;\n\treq->out.numargs = 1;\n\t/* Variable length argument used for backward compatibility\n\t   with interface version < 7.5.  Rest of init_out is zeroed\n\t   by do_get_request(), so a short reply is not a problem */\n\treq->out.argvar = 1;\n\treq->out.args[0].size = sizeof(struct fuse_init_out);\n\treq->out.args[0].value = &req->misc.init_out;\n\treq->end = process_init_reply;\n\tfuse_request_send_background(fc, req);\n}"
  },
  {
    "function_name": "process_init_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "839-901",
    "snippet": "static void process_init_reply(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_init_out *arg = &req->misc.init_out;\n\n\tif (req->out.h.error || arg->major != FUSE_KERNEL_VERSION)\n\t\tfc->conn_error = 1;\n\telse {\n\t\tunsigned long ra_pages;\n\n\t\tprocess_init_limits(fc, arg);\n\n\t\tif (arg->minor >= 6) {\n\t\t\tra_pages = arg->max_readahead / PAGE_CACHE_SIZE;\n\t\t\tif (arg->flags & FUSE_ASYNC_READ)\n\t\t\t\tfc->async_read = 1;\n\t\t\tif (!(arg->flags & FUSE_POSIX_LOCKS))\n\t\t\t\tfc->no_lock = 1;\n\t\t\tif (arg->minor >= 17) {\n\t\t\t\tif (!(arg->flags & FUSE_FLOCK_LOCKS))\n\t\t\t\t\tfc->no_flock = 1;\n\t\t\t} else {\n\t\t\t\tif (!(arg->flags & FUSE_POSIX_LOCKS))\n\t\t\t\t\tfc->no_flock = 1;\n\t\t\t}\n\t\t\tif (arg->flags & FUSE_ATOMIC_O_TRUNC)\n\t\t\t\tfc->atomic_o_trunc = 1;\n\t\t\tif (arg->minor >= 9) {\n\t\t\t\t/* LOOKUP has dependency on proto version */\n\t\t\t\tif (arg->flags & FUSE_EXPORT_SUPPORT)\n\t\t\t\t\tfc->export_support = 1;\n\t\t\t}\n\t\t\tif (arg->flags & FUSE_BIG_WRITES)\n\t\t\t\tfc->big_writes = 1;\n\t\t\tif (arg->flags & FUSE_DONT_MASK)\n\t\t\t\tfc->dont_mask = 1;\n\t\t\tif (arg->flags & FUSE_AUTO_INVAL_DATA)\n\t\t\t\tfc->auto_inval_data = 1;\n\t\t\tif (arg->flags & FUSE_DO_READDIRPLUS) {\n\t\t\t\tfc->do_readdirplus = 1;\n\t\t\t\tif (arg->flags & FUSE_READDIRPLUS_AUTO)\n\t\t\t\t\tfc->readdirplus_auto = 1;\n\t\t\t}\n\t\t\tif (arg->flags & FUSE_ASYNC_DIO)\n\t\t\t\tfc->async_dio = 1;\n\t\t\tif (arg->flags & FUSE_WRITEBACK_CACHE)\n\t\t\t\tfc->writeback_cache = 1;\n\t\t\tif (arg->time_gran && arg->time_gran <= 1000000000)\n\t\t\t\tfc->sb->s_time_gran = arg->time_gran;\n\t\t} else {\n\t\t\tra_pages = fc->max_read / PAGE_CACHE_SIZE;\n\t\t\tfc->no_lock = 1;\n\t\t\tfc->no_flock = 1;\n\t\t}\n\n\t\tfc->bdi.ra_pages = min(fc->bdi.ra_pages, ra_pages);\n\t\tfc->minor = arg->minor;\n\t\tfc->max_write = arg->minor < 5 ? 4096 : arg->max_write;\n\t\tfc->max_write = max_t(unsigned, 4096, fc->max_write);\n\t\tfc->conn_init = 1;\n\t}\n\tfuse_set_initialized(fc);\n\twake_up_all(&fc->blocked_waitq);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&fc->blocked_waitq"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_set_initialized",
          "args": [
            "fc"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_set_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "134-139",
          "snippet": "void fuse_set_initialized(struct fuse_conn *fc)\n{\n\t/* Make sure stores before this are seen on another CPU */\n\tsmp_wmb();\n\tfc->initialized = 1;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_set_initialized(struct fuse_conn *fc)\n{\n\t/* Make sure stores before this are seen on another CPU */\n\tsmp_wmb();\n\tfc->initialized = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsigned",
            "4096",
            "fc->max_write"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "fc->bdi.ra_pages",
            "ra_pages"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "minix_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "603-624",
          "snippet": "static int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);\n\nstatic int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_init_limits",
          "args": [
            "fc",
            "arg"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "process_init_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "814-837",
          "snippet": "static void process_init_limits(struct fuse_conn *fc, struct fuse_init_out *arg)\n{\n\tint cap_sys_admin = capable(CAP_SYS_ADMIN);\n\n\tif (arg->minor < 13)\n\t\treturn;\n\n\tsanitize_global_limit(&max_user_bgreq);\n\tsanitize_global_limit(&max_user_congthresh);\n\n\tif (arg->max_background) {\n\t\tfc->max_background = arg->max_background;\n\n\t\tif (!cap_sys_admin && fc->max_background > max_user_bgreq)\n\t\t\tfc->max_background = max_user_bgreq;\n\t}\n\tif (arg->congestion_threshold) {\n\t\tfc->congestion_threshold = arg->congestion_threshold;\n\n\t\tif (!cap_sys_admin &&\n\t\t    fc->congestion_threshold > max_user_congthresh)\n\t\t\tfc->congestion_threshold = max_user_congthresh;\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned max_user_bgreq;",
            "unsigned max_user_congthresh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nunsigned max_user_bgreq;\nunsigned max_user_congthresh;\n\nstatic void process_init_limits(struct fuse_conn *fc, struct fuse_init_out *arg)\n{\n\tint cap_sys_admin = capable(CAP_SYS_ADMIN);\n\n\tif (arg->minor < 13)\n\t\treturn;\n\n\tsanitize_global_limit(&max_user_bgreq);\n\tsanitize_global_limit(&max_user_congthresh);\n\n\tif (arg->max_background) {\n\t\tfc->max_background = arg->max_background;\n\n\t\tif (!cap_sys_admin && fc->max_background > max_user_bgreq)\n\t\t\tfc->max_background = max_user_bgreq;\n\t}\n\tif (arg->congestion_threshold) {\n\t\tfc->congestion_threshold = arg->congestion_threshold;\n\n\t\tif (!cap_sys_admin &&\n\t\t    fc->congestion_threshold > max_user_congthresh)\n\t\t\tfc->congestion_threshold = max_user_congthresh;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void process_init_reply(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_init_out *arg = &req->misc.init_out;\n\n\tif (req->out.h.error || arg->major != FUSE_KERNEL_VERSION)\n\t\tfc->conn_error = 1;\n\telse {\n\t\tunsigned long ra_pages;\n\n\t\tprocess_init_limits(fc, arg);\n\n\t\tif (arg->minor >= 6) {\n\t\t\tra_pages = arg->max_readahead / PAGE_CACHE_SIZE;\n\t\t\tif (arg->flags & FUSE_ASYNC_READ)\n\t\t\t\tfc->async_read = 1;\n\t\t\tif (!(arg->flags & FUSE_POSIX_LOCKS))\n\t\t\t\tfc->no_lock = 1;\n\t\t\tif (arg->minor >= 17) {\n\t\t\t\tif (!(arg->flags & FUSE_FLOCK_LOCKS))\n\t\t\t\t\tfc->no_flock = 1;\n\t\t\t} else {\n\t\t\t\tif (!(arg->flags & FUSE_POSIX_LOCKS))\n\t\t\t\t\tfc->no_flock = 1;\n\t\t\t}\n\t\t\tif (arg->flags & FUSE_ATOMIC_O_TRUNC)\n\t\t\t\tfc->atomic_o_trunc = 1;\n\t\t\tif (arg->minor >= 9) {\n\t\t\t\t/* LOOKUP has dependency on proto version */\n\t\t\t\tif (arg->flags & FUSE_EXPORT_SUPPORT)\n\t\t\t\t\tfc->export_support = 1;\n\t\t\t}\n\t\t\tif (arg->flags & FUSE_BIG_WRITES)\n\t\t\t\tfc->big_writes = 1;\n\t\t\tif (arg->flags & FUSE_DONT_MASK)\n\t\t\t\tfc->dont_mask = 1;\n\t\t\tif (arg->flags & FUSE_AUTO_INVAL_DATA)\n\t\t\t\tfc->auto_inval_data = 1;\n\t\t\tif (arg->flags & FUSE_DO_READDIRPLUS) {\n\t\t\t\tfc->do_readdirplus = 1;\n\t\t\t\tif (arg->flags & FUSE_READDIRPLUS_AUTO)\n\t\t\t\t\tfc->readdirplus_auto = 1;\n\t\t\t}\n\t\t\tif (arg->flags & FUSE_ASYNC_DIO)\n\t\t\t\tfc->async_dio = 1;\n\t\t\tif (arg->flags & FUSE_WRITEBACK_CACHE)\n\t\t\t\tfc->writeback_cache = 1;\n\t\t\tif (arg->time_gran && arg->time_gran <= 1000000000)\n\t\t\t\tfc->sb->s_time_gran = arg->time_gran;\n\t\t} else {\n\t\t\tra_pages = fc->max_read / PAGE_CACHE_SIZE;\n\t\t\tfc->no_lock = 1;\n\t\t\tfc->no_flock = 1;\n\t\t}\n\n\t\tfc->bdi.ra_pages = min(fc->bdi.ra_pages, ra_pages);\n\t\tfc->minor = arg->minor;\n\t\tfc->max_write = arg->minor < 5 ? 4096 : arg->max_write;\n\t\tfc->max_write = max_t(unsigned, 4096, fc->max_write);\n\t\tfc->conn_init = 1;\n\t}\n\tfuse_set_initialized(fc);\n\twake_up_all(&fc->blocked_waitq);\n}"
  },
  {
    "function_name": "process_init_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "814-837",
    "snippet": "static void process_init_limits(struct fuse_conn *fc, struct fuse_init_out *arg)\n{\n\tint cap_sys_admin = capable(CAP_SYS_ADMIN);\n\n\tif (arg->minor < 13)\n\t\treturn;\n\n\tsanitize_global_limit(&max_user_bgreq);\n\tsanitize_global_limit(&max_user_congthresh);\n\n\tif (arg->max_background) {\n\t\tfc->max_background = arg->max_background;\n\n\t\tif (!cap_sys_admin && fc->max_background > max_user_bgreq)\n\t\t\tfc->max_background = max_user_bgreq;\n\t}\n\tif (arg->congestion_threshold) {\n\t\tfc->congestion_threshold = arg->congestion_threshold;\n\n\t\tif (!cap_sys_admin &&\n\t\t    fc->congestion_threshold > max_user_congthresh)\n\t\t\tfc->congestion_threshold = max_user_congthresh;\n\t}\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned max_user_bgreq;",
      "unsigned max_user_congthresh;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sanitize_global_limit",
          "args": [
            "&max_user_congthresh"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_global_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "791-799",
          "snippet": "static void sanitize_global_limit(unsigned *limit)\n{\n\tif (*limit == 0)\n\t\t*limit = ((totalram_pages << PAGE_SHIFT) >> 13) /\n\t\t\t sizeof(struct fuse_req);\n\n\tif (*limit >= 1 << 16)\n\t\t*limit = (1 << 16) - 1;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void sanitize_global_limit(unsigned *limit)\n{\n\tif (*limit == 0)\n\t\t*limit = ((totalram_pages << PAGE_SHIFT) >> 13) /\n\t\t\t sizeof(struct fuse_req);\n\n\tif (*limit >= 1 << 16)\n\t\t*limit = (1 << 16) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nunsigned max_user_bgreq;\nunsigned max_user_congthresh;\n\nstatic void process_init_limits(struct fuse_conn *fc, struct fuse_init_out *arg)\n{\n\tint cap_sys_admin = capable(CAP_SYS_ADMIN);\n\n\tif (arg->minor < 13)\n\t\treturn;\n\n\tsanitize_global_limit(&max_user_bgreq);\n\tsanitize_global_limit(&max_user_congthresh);\n\n\tif (arg->max_background) {\n\t\tfc->max_background = arg->max_background;\n\n\t\tif (!cap_sys_admin && fc->max_background > max_user_bgreq)\n\t\t\tfc->max_background = max_user_bgreq;\n\t}\n\tif (arg->congestion_threshold) {\n\t\tfc->congestion_threshold = arg->congestion_threshold;\n\n\t\tif (!cap_sys_admin &&\n\t\t    fc->congestion_threshold > max_user_congthresh)\n\t\t\tfc->congestion_threshold = max_user_congthresh;\n\t}\n}"
  },
  {
    "function_name": "set_global_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "801-812",
    "snippet": "static int set_global_limit(const char *val, struct kernel_param *kp)\n{\n\tint rv;\n\n\trv = param_set_uint(val, kp);\n\tif (rv)\n\t\treturn rv;\n\n\tsanitize_global_limit((unsigned *)kp->arg);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int set_global_limit(const char *val, struct kernel_param *kp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sanitize_global_limit",
          "args": [
            "(unsigned *)kp->arg"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_global_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "791-799",
          "snippet": "static void sanitize_global_limit(unsigned *limit)\n{\n\tif (*limit == 0)\n\t\t*limit = ((totalram_pages << PAGE_SHIFT) >> 13) /\n\t\t\t sizeof(struct fuse_req);\n\n\tif (*limit >= 1 << 16)\n\t\t*limit = (1 << 16) - 1;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void sanitize_global_limit(unsigned *limit)\n{\n\tif (*limit == 0)\n\t\t*limit = ((totalram_pages << PAGE_SHIFT) >> 13) /\n\t\t\t sizeof(struct fuse_req);\n\n\tif (*limit >= 1 << 16)\n\t\t*limit = (1 << 16) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "param_set_uint",
          "args": [
            "val",
            "kp"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int set_global_limit(const char *val, struct kernel_param *kp);\n\nstatic int set_global_limit(const char *val, struct kernel_param *kp)\n{\n\tint rv;\n\n\trv = param_set_uint(val, kp);\n\tif (rv)\n\t\treturn rv;\n\n\tsanitize_global_limit((unsigned *)kp->arg);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sanitize_global_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "791-799",
    "snippet": "static void sanitize_global_limit(unsigned *limit)\n{\n\tif (*limit == 0)\n\t\t*limit = ((totalram_pages << PAGE_SHIFT) >> 13) /\n\t\t\t sizeof(struct fuse_req);\n\n\tif (*limit >= 1 << 16)\n\t\t*limit = (1 << 16) - 1;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void sanitize_global_limit(unsigned *limit)\n{\n\tif (*limit == 0)\n\t\t*limit = ((totalram_pages << PAGE_SHIFT) >> 13) /\n\t\t\t sizeof(struct fuse_req);\n\n\tif (*limit >= 1 << 16)\n\t\t*limit = (1 << 16) - 1;\n}"
  },
  {
    "function_name": "fuse_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "741-769",
    "snippet": "static struct dentry *fuse_get_parent(struct dentry *child)\n{\n\tstruct inode *child_inode = child->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(child_inode);\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\tstruct fuse_entry_out outarg;\n\tstruct qstr name;\n\tint err;\n\n\tif (!fc->export_support)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tname.len = 2;\n\tname.name = \"..\";\n\terr = fuse_lookup_name(child_inode->i_sb, get_node_id(child_inode),\n\t\t\t       &name, &outarg, &inode);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tparent = d_obtain_alias(inode);\n\tif (!IS_ERR(parent) && get_node_id(inode) != FUSE_ROOT_ID)\n\t\tfuse_invalidate_entry_cache(parent);\n\n\treturn parent;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_invalidate_entry_cache",
          "args": [
            "parent"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_entry_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "133-136",
          "snippet": "void fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "parent"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_lookup_name",
          "args": [
            "child_inode->i_sb",
            "get_node_id(child_inode)",
            "&name",
            "&outarg",
            "&inode"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lookup_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "285-333",
          "snippet": "int fuse_lookup_name(struct super_block *sb, u64 nodeid, struct qstr *name,\n\t\t     struct fuse_entry_out *outarg, struct inode **inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tu64 attr_version;\n\tint err;\n\n\t*inode = NULL;\n\terr = -ENAMETOOLONG;\n\tif (name->len > FUSE_NAME_MAX)\n\t\tgoto out;\n\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tfuse_lookup_init(fc, &args, nodeid, name, outarg);\n\terr = fuse_simple_request(fc, &args);\n\t/* Zero nodeid is same as -ENOENT, but with valid timeout */\n\tif (err || !outarg->nodeid)\n\t\tgoto out_put_forget;\n\n\terr = -EIO;\n\tif (!outarg->nodeid)\n\t\tgoto out_put_forget;\n\tif (!fuse_valid_type(outarg->attr.mode))\n\t\tgoto out_put_forget;\n\n\t*inode = fuse_iget(sb, outarg->nodeid, outarg->generation,\n\t\t\t   &outarg->attr, entry_attr_timeout(outarg),\n\t\t\t   attr_version);\n\terr = -ENOMEM;\n\tif (!*inode) {\n\t\tfuse_queue_forget(fc, forget, outarg->nodeid, 1);\n\t\tgoto out;\n\t}\n\terr = 0;\n\n out_put_forget:\n\tkfree(forget);\n out:\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_lookup_name(struct super_block *sb, u64 nodeid, struct qstr *name,\n\t\t     struct fuse_entry_out *outarg, struct inode **inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tu64 attr_version;\n\tint err;\n\n\t*inode = NULL;\n\terr = -ENAMETOOLONG;\n\tif (name->len > FUSE_NAME_MAX)\n\t\tgoto out;\n\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tfuse_lookup_init(fc, &args, nodeid, name, outarg);\n\terr = fuse_simple_request(fc, &args);\n\t/* Zero nodeid is same as -ENOENT, but with valid timeout */\n\tif (err || !outarg->nodeid)\n\t\tgoto out_put_forget;\n\n\terr = -EIO;\n\tif (!outarg->nodeid)\n\t\tgoto out_put_forget;\n\tif (!fuse_valid_type(outarg->attr.mode))\n\t\tgoto out_put_forget;\n\n\t*inode = fuse_iget(sb, outarg->nodeid, outarg->generation,\n\t\t\t   &outarg->attr, entry_attr_timeout(outarg),\n\t\t\t   attr_version);\n\terr = -ENOMEM;\n\tif (!*inode) {\n\t\tfuse_queue_forget(fc, forget, outarg->nodeid, 1);\n\t\tgoto out;\n\t}\n\terr = 0;\n\n out_put_forget:\n\tkfree(forget);\n out:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "child_inode"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct dentry *fuse_get_parent(struct dentry *child)\n{\n\tstruct inode *child_inode = child->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(child_inode);\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\tstruct fuse_entry_out outarg;\n\tstruct qstr name;\n\tint err;\n\n\tif (!fc->export_support)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tname.len = 2;\n\tname.name = \"..\";\n\terr = fuse_lookup_name(child_inode->i_sb, get_node_id(child_inode),\n\t\t\t       &name, &outarg, &inode);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tparent = d_obtain_alias(inode);\n\tif (!IS_ERR(parent) && get_node_id(inode) != FUSE_ROOT_ID)\n\t\tfuse_invalidate_entry_cache(parent);\n\n\treturn parent;\n}"
  },
  {
    "function_name": "fuse_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "727-739",
    "snippet": "static struct dentry *fuse_fh_to_parent(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct fuse_inode_handle parent;\n\n\tif (fh_type != 0x82 || fh_len < 6)\n\t\treturn NULL;\n\n\tparent.nodeid = (u64) fid->raw[3] << 32;\n\tparent.nodeid |= (u64) fid->raw[4];\n\tparent.generation = fid->raw[5];\n\treturn fuse_get_dentry(sb, &parent);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_get_dentry",
          "args": [
            "sb",
            "&parent"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "632-679",
          "snippet": "static struct dentry *fuse_get_dentry(struct super_block *sb,\n\t\t\t\t      struct fuse_inode_handle *handle)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tstruct inode *inode;\n\tstruct dentry *entry;\n\tint err = -ESTALE;\n\n\tif (handle->nodeid == 0)\n\t\tgoto out_err;\n\n\tinode = ilookup5(sb, handle->nodeid, fuse_inode_eq, &handle->nodeid);\n\tif (!inode) {\n\t\tstruct fuse_entry_out outarg;\n\t\tstruct qstr name;\n\n\t\tif (!fc->export_support)\n\t\t\tgoto out_err;\n\n\t\tname.len = 1;\n\t\tname.name = \".\";\n\t\terr = fuse_lookup_name(sb, handle->nodeid, &name, &outarg,\n\t\t\t\t       &inode);\n\t\tif (err && err != -ENOENT)\n\t\t\tgoto out_err;\n\t\tif (err || !inode) {\n\t\t\terr = -ESTALE;\n\t\t\tgoto out_err;\n\t\t}\n\t\terr = -EIO;\n\t\tif (get_node_id(inode) != handle->nodeid)\n\t\t\tgoto out_iput;\n\t}\n\terr = -ESTALE;\n\tif (inode->i_generation != handle->generation)\n\t\tgoto out_iput;\n\n\tentry = d_obtain_alias(inode);\n\tif (!IS_ERR(entry) && get_node_id(inode) != FUSE_ROOT_ID)\n\t\tfuse_invalidate_entry_cache(entry);\n\n\treturn entry;\n\n out_iput:\n\tiput(inode);\n out_err:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct dentry *fuse_get_dentry(struct super_block *sb,\n\t\t\t\t      struct fuse_inode_handle *handle)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tstruct inode *inode;\n\tstruct dentry *entry;\n\tint err = -ESTALE;\n\n\tif (handle->nodeid == 0)\n\t\tgoto out_err;\n\n\tinode = ilookup5(sb, handle->nodeid, fuse_inode_eq, &handle->nodeid);\n\tif (!inode) {\n\t\tstruct fuse_entry_out outarg;\n\t\tstruct qstr name;\n\n\t\tif (!fc->export_support)\n\t\t\tgoto out_err;\n\n\t\tname.len = 1;\n\t\tname.name = \".\";\n\t\terr = fuse_lookup_name(sb, handle->nodeid, &name, &outarg,\n\t\t\t\t       &inode);\n\t\tif (err && err != -ENOENT)\n\t\t\tgoto out_err;\n\t\tif (err || !inode) {\n\t\t\terr = -ESTALE;\n\t\t\tgoto out_err;\n\t\t}\n\t\terr = -EIO;\n\t\tif (get_node_id(inode) != handle->nodeid)\n\t\t\tgoto out_iput;\n\t}\n\terr = -ESTALE;\n\tif (inode->i_generation != handle->generation)\n\t\tgoto out_iput;\n\n\tentry = d_obtain_alias(inode);\n\tif (!IS_ERR(entry) && get_node_id(inode) != FUSE_ROOT_ID)\n\t\tfuse_invalidate_entry_cache(entry);\n\n\treturn entry;\n\n out_iput:\n\tiput(inode);\n out_err:\n\treturn ERR_PTR(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct dentry *fuse_fh_to_parent(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct fuse_inode_handle parent;\n\n\tif (fh_type != 0x82 || fh_len < 6)\n\t\treturn NULL;\n\n\tparent.nodeid = (u64) fid->raw[3] << 32;\n\tparent.nodeid |= (u64) fid->raw[4];\n\tparent.generation = fid->raw[5];\n\treturn fuse_get_dentry(sb, &parent);\n}"
  },
  {
    "function_name": "fuse_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "713-725",
    "snippet": "static struct dentry *fuse_fh_to_dentry(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct fuse_inode_handle handle;\n\n\tif ((fh_type != 0x81 && fh_type != 0x82) || fh_len < 3)\n\t\treturn NULL;\n\n\thandle.nodeid = (u64) fid->raw[0] << 32;\n\thandle.nodeid |= (u64) fid->raw[1];\n\thandle.generation = fid->raw[2];\n\treturn fuse_get_dentry(sb, &handle);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_get_dentry",
          "args": [
            "sb",
            "&handle"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "632-679",
          "snippet": "static struct dentry *fuse_get_dentry(struct super_block *sb,\n\t\t\t\t      struct fuse_inode_handle *handle)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tstruct inode *inode;\n\tstruct dentry *entry;\n\tint err = -ESTALE;\n\n\tif (handle->nodeid == 0)\n\t\tgoto out_err;\n\n\tinode = ilookup5(sb, handle->nodeid, fuse_inode_eq, &handle->nodeid);\n\tif (!inode) {\n\t\tstruct fuse_entry_out outarg;\n\t\tstruct qstr name;\n\n\t\tif (!fc->export_support)\n\t\t\tgoto out_err;\n\n\t\tname.len = 1;\n\t\tname.name = \".\";\n\t\terr = fuse_lookup_name(sb, handle->nodeid, &name, &outarg,\n\t\t\t\t       &inode);\n\t\tif (err && err != -ENOENT)\n\t\t\tgoto out_err;\n\t\tif (err || !inode) {\n\t\t\terr = -ESTALE;\n\t\t\tgoto out_err;\n\t\t}\n\t\terr = -EIO;\n\t\tif (get_node_id(inode) != handle->nodeid)\n\t\t\tgoto out_iput;\n\t}\n\terr = -ESTALE;\n\tif (inode->i_generation != handle->generation)\n\t\tgoto out_iput;\n\n\tentry = d_obtain_alias(inode);\n\tif (!IS_ERR(entry) && get_node_id(inode) != FUSE_ROOT_ID)\n\t\tfuse_invalidate_entry_cache(entry);\n\n\treturn entry;\n\n out_iput:\n\tiput(inode);\n out_err:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct dentry *fuse_get_dentry(struct super_block *sb,\n\t\t\t\t      struct fuse_inode_handle *handle)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tstruct inode *inode;\n\tstruct dentry *entry;\n\tint err = -ESTALE;\n\n\tif (handle->nodeid == 0)\n\t\tgoto out_err;\n\n\tinode = ilookup5(sb, handle->nodeid, fuse_inode_eq, &handle->nodeid);\n\tif (!inode) {\n\t\tstruct fuse_entry_out outarg;\n\t\tstruct qstr name;\n\n\t\tif (!fc->export_support)\n\t\t\tgoto out_err;\n\n\t\tname.len = 1;\n\t\tname.name = \".\";\n\t\terr = fuse_lookup_name(sb, handle->nodeid, &name, &outarg,\n\t\t\t\t       &inode);\n\t\tif (err && err != -ENOENT)\n\t\t\tgoto out_err;\n\t\tif (err || !inode) {\n\t\t\terr = -ESTALE;\n\t\t\tgoto out_err;\n\t\t}\n\t\terr = -EIO;\n\t\tif (get_node_id(inode) != handle->nodeid)\n\t\t\tgoto out_iput;\n\t}\n\terr = -ESTALE;\n\tif (inode->i_generation != handle->generation)\n\t\tgoto out_iput;\n\n\tentry = d_obtain_alias(inode);\n\tif (!IS_ERR(entry) && get_node_id(inode) != FUSE_ROOT_ID)\n\t\tfuse_invalidate_entry_cache(entry);\n\n\treturn entry;\n\n out_iput:\n\tiput(inode);\n out_err:\n\treturn ERR_PTR(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct dentry *fuse_fh_to_dentry(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct fuse_inode_handle handle;\n\n\tif ((fh_type != 0x81 && fh_type != 0x82) || fh_len < 3)\n\t\treturn NULL;\n\n\thandle.nodeid = (u64) fid->raw[0] << 32;\n\thandle.nodeid |= (u64) fid->raw[1];\n\thandle.generation = fid->raw[2];\n\treturn fuse_get_dentry(sb, &handle);\n}"
  },
  {
    "function_name": "fuse_encode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "681-711",
    "snippet": "static int fuse_encode_fh(struct inode *inode, u32 *fh, int *max_len,\n\t\t\t   struct inode *parent)\n{\n\tint len = parent ? 6 : 3;\n\tu64 nodeid;\n\tu32 generation;\n\n\tif (*max_len < len) {\n\t\t*max_len = len;\n\t\treturn  FILEID_INVALID;\n\t}\n\n\tnodeid = get_fuse_inode(inode)->nodeid;\n\tgeneration = inode->i_generation;\n\n\tfh[0] = (u32)(nodeid >> 32);\n\tfh[1] = (u32)(nodeid & 0xffffffff);\n\tfh[2] = generation;\n\n\tif (parent) {\n\t\tnodeid = get_fuse_inode(parent)->nodeid;\n\t\tgeneration = parent->i_generation;\n\n\t\tfh[3] = (u32)(nodeid >> 32);\n\t\tfh[4] = (u32)(nodeid & 0xffffffff);\n\t\tfh[5] = generation;\n\t}\n\n\t*max_len = len;\n\treturn parent ? 0x82 : 0x81;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "nodeid & 0xffffffff"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "nodeid >> 32"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "parent"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "nodeid & 0xffffffff"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "nodeid >> 32"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_encode_fh(struct inode *inode, u32 *fh, int *max_len,\n\t\t\t   struct inode *parent)\n{\n\tint len = parent ? 6 : 3;\n\tu64 nodeid;\n\tu32 generation;\n\n\tif (*max_len < len) {\n\t\t*max_len = len;\n\t\treturn  FILEID_INVALID;\n\t}\n\n\tnodeid = get_fuse_inode(inode)->nodeid;\n\tgeneration = inode->i_generation;\n\n\tfh[0] = (u32)(nodeid >> 32);\n\tfh[1] = (u32)(nodeid & 0xffffffff);\n\tfh[2] = generation;\n\n\tif (parent) {\n\t\tnodeid = get_fuse_inode(parent)->nodeid;\n\t\tgeneration = parent->i_generation;\n\n\t\tfh[3] = (u32)(nodeid >> 32);\n\t\tfh[4] = (u32)(nodeid & 0xffffffff);\n\t\tfh[5] = generation;\n\t}\n\n\t*max_len = len;\n\treturn parent ? 0x82 : 0x81;\n}"
  },
  {
    "function_name": "fuse_get_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "632-679",
    "snippet": "static struct dentry *fuse_get_dentry(struct super_block *sb,\n\t\t\t\t      struct fuse_inode_handle *handle)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tstruct inode *inode;\n\tstruct dentry *entry;\n\tint err = -ESTALE;\n\n\tif (handle->nodeid == 0)\n\t\tgoto out_err;\n\n\tinode = ilookup5(sb, handle->nodeid, fuse_inode_eq, &handle->nodeid);\n\tif (!inode) {\n\t\tstruct fuse_entry_out outarg;\n\t\tstruct qstr name;\n\n\t\tif (!fc->export_support)\n\t\t\tgoto out_err;\n\n\t\tname.len = 1;\n\t\tname.name = \".\";\n\t\terr = fuse_lookup_name(sb, handle->nodeid, &name, &outarg,\n\t\t\t\t       &inode);\n\t\tif (err && err != -ENOENT)\n\t\t\tgoto out_err;\n\t\tif (err || !inode) {\n\t\t\terr = -ESTALE;\n\t\t\tgoto out_err;\n\t\t}\n\t\terr = -EIO;\n\t\tif (get_node_id(inode) != handle->nodeid)\n\t\t\tgoto out_iput;\n\t}\n\terr = -ESTALE;\n\tif (inode->i_generation != handle->generation)\n\t\tgoto out_iput;\n\n\tentry = d_obtain_alias(inode);\n\tif (!IS_ERR(entry) && get_node_id(inode) != FUSE_ROOT_ID)\n\t\tfuse_invalidate_entry_cache(entry);\n\n\treturn entry;\n\n out_iput:\n\tiput(inode);\n out_err:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_entry_cache",
          "args": [
            "entry"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_entry_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "133-136",
          "snippet": "void fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "entry"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lookup_name",
          "args": [
            "sb",
            "handle->nodeid",
            "&name",
            "&outarg",
            "&inode"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lookup_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "285-333",
          "snippet": "int fuse_lookup_name(struct super_block *sb, u64 nodeid, struct qstr *name,\n\t\t     struct fuse_entry_out *outarg, struct inode **inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tu64 attr_version;\n\tint err;\n\n\t*inode = NULL;\n\terr = -ENAMETOOLONG;\n\tif (name->len > FUSE_NAME_MAX)\n\t\tgoto out;\n\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tfuse_lookup_init(fc, &args, nodeid, name, outarg);\n\terr = fuse_simple_request(fc, &args);\n\t/* Zero nodeid is same as -ENOENT, but with valid timeout */\n\tif (err || !outarg->nodeid)\n\t\tgoto out_put_forget;\n\n\terr = -EIO;\n\tif (!outarg->nodeid)\n\t\tgoto out_put_forget;\n\tif (!fuse_valid_type(outarg->attr.mode))\n\t\tgoto out_put_forget;\n\n\t*inode = fuse_iget(sb, outarg->nodeid, outarg->generation,\n\t\t\t   &outarg->attr, entry_attr_timeout(outarg),\n\t\t\t   attr_version);\n\terr = -ENOMEM;\n\tif (!*inode) {\n\t\tfuse_queue_forget(fc, forget, outarg->nodeid, 1);\n\t\tgoto out;\n\t}\n\terr = 0;\n\n out_put_forget:\n\tkfree(forget);\n out:\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_lookup_name(struct super_block *sb, u64 nodeid, struct qstr *name,\n\t\t     struct fuse_entry_out *outarg, struct inode **inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tu64 attr_version;\n\tint err;\n\n\t*inode = NULL;\n\terr = -ENAMETOOLONG;\n\tif (name->len > FUSE_NAME_MAX)\n\t\tgoto out;\n\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tfuse_lookup_init(fc, &args, nodeid, name, outarg);\n\terr = fuse_simple_request(fc, &args);\n\t/* Zero nodeid is same as -ENOENT, but with valid timeout */\n\tif (err || !outarg->nodeid)\n\t\tgoto out_put_forget;\n\n\terr = -EIO;\n\tif (!outarg->nodeid)\n\t\tgoto out_put_forget;\n\tif (!fuse_valid_type(outarg->attr.mode))\n\t\tgoto out_put_forget;\n\n\t*inode = fuse_iget(sb, outarg->nodeid, outarg->generation,\n\t\t\t   &outarg->attr, entry_attr_timeout(outarg),\n\t\t\t   attr_version);\n\terr = -ENOMEM;\n\tif (!*inode) {\n\t\tfuse_queue_forget(fc, forget, outarg->nodeid, 1);\n\t\tgoto out;\n\t}\n\terr = 0;\n\n out_put_forget:\n\tkfree(forget);\n out:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilookup5",
          "args": [
            "sb",
            "handle->nodeid",
            "fuse_inode_eq",
            "&handle->nodeid"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1239-1247",
          "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn_super",
          "args": [
            "sb"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "618-621",
          "snippet": "static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct dentry *fuse_get_dentry(struct super_block *sb,\n\t\t\t\t      struct fuse_inode_handle *handle)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tstruct inode *inode;\n\tstruct dentry *entry;\n\tint err = -ESTALE;\n\n\tif (handle->nodeid == 0)\n\t\tgoto out_err;\n\n\tinode = ilookup5(sb, handle->nodeid, fuse_inode_eq, &handle->nodeid);\n\tif (!inode) {\n\t\tstruct fuse_entry_out outarg;\n\t\tstruct qstr name;\n\n\t\tif (!fc->export_support)\n\t\t\tgoto out_err;\n\n\t\tname.len = 1;\n\t\tname.name = \".\";\n\t\terr = fuse_lookup_name(sb, handle->nodeid, &name, &outarg,\n\t\t\t\t       &inode);\n\t\tif (err && err != -ENOENT)\n\t\t\tgoto out_err;\n\t\tif (err || !inode) {\n\t\t\terr = -ESTALE;\n\t\t\tgoto out_err;\n\t\t}\n\t\terr = -EIO;\n\t\tif (get_node_id(inode) != handle->nodeid)\n\t\t\tgoto out_iput;\n\t}\n\terr = -ESTALE;\n\tif (inode->i_generation != handle->generation)\n\t\tgoto out_iput;\n\n\tentry = d_obtain_alias(inode);\n\tif (!IS_ERR(entry) && get_node_id(inode) != FUSE_ROOT_ID)\n\t\tfuse_invalidate_entry_cache(entry);\n\n\treturn entry;\n\n out_iput:\n\tiput(inode);\n out_err:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "fuse_get_root_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "616-625",
    "snippet": "static struct inode *fuse_get_root_inode(struct super_block *sb, unsigned mode)\n{\n\tstruct fuse_attr attr;\n\tmemset(&attr, 0, sizeof(attr));\n\n\tattr.mode = mode;\n\tattr.ino = FUSE_ROOT_ID;\n\tattr.nlink = 1;\n\treturn fuse_iget(sb, 1, 0, &attr, 0, 0);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_iget",
          "args": [
            "sb",
            "1",
            "0",
            "&attr",
            "0",
            "0"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "293-327",
          "snippet": "struct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n retry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {\n\t\t/* Inode has changed type, any I/O on the old should fail */\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fc->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fc->lock);\n\tfuse_change_attributes(inode, attr, attr_valid, attr_version);\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n retry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {\n\t\t/* Inode has changed type, any I/O on the old should fail */\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fc->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fc->lock);\n\tfuse_change_attributes(inode, attr, attr_valid, attr_version);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&attr",
            "0",
            "sizeof(attr)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct inode *fuse_get_root_inode(struct super_block *sb, unsigned mode)\n{\n\tstruct fuse_attr attr;\n\tmemset(&attr, 0, sizeof(attr));\n\n\tattr.mode = mode;\n\tattr.ino = FUSE_ROOT_ID;\n\tattr.nlink = 1;\n\treturn fuse_iget(sb, 1, 0, &attr, 0, 0);\n}"
  },
  {
    "function_name": "fuse_conn_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "609-613",
    "snippet": "struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)\n{\n\tatomic_inc(&fc->count);\n\treturn fc;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fc->count"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_conn *fuse_conn_get(struct fuse_conn *fc)\n{\n\tatomic_inc(&fc->count);\n\treturn fc;\n}"
  },
  {
    "function_name": "fuse_conn_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "599-606",
    "snippet": "void fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fc->release",
          "args": [
            "fc"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_request_free",
          "args": [
            "fc->destroy_req"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "93-100",
          "snippet": "void fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_req_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\n\nvoid fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&fc->count"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}"
  },
  {
    "function_name": "fuse_conn_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "570-596",
    "snippet": "void fuse_conn_init(struct fuse_conn *fc)\n{\n\tmemset(fc, 0, sizeof(*fc));\n\tspin_lock_init(&fc->lock);\n\tinit_rwsem(&fc->killsb);\n\tatomic_set(&fc->count, 1);\n\tinit_waitqueue_head(&fc->waitq);\n\tinit_waitqueue_head(&fc->blocked_waitq);\n\tinit_waitqueue_head(&fc->reserved_req_waitq);\n\tINIT_LIST_HEAD(&fc->pending);\n\tINIT_LIST_HEAD(&fc->processing);\n\tINIT_LIST_HEAD(&fc->io);\n\tINIT_LIST_HEAD(&fc->interrupts);\n\tINIT_LIST_HEAD(&fc->bg_queue);\n\tINIT_LIST_HEAD(&fc->entry);\n\tfc->forget_list_tail = &fc->forget_list_head;\n\tatomic_set(&fc->num_waiting, 0);\n\tfc->max_background = FUSE_DEFAULT_MAX_BACKGROUND;\n\tfc->congestion_threshold = FUSE_DEFAULT_CONGESTION_THRESHOLD;\n\tfc->khctr = 0;\n\tfc->polled_files = RB_ROOT;\n\tfc->reqctr = 0;\n\tfc->blocked = 0;\n\tfc->initialized = 0;\n\tfc->attr_version = 1;\n\tget_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [
      "#define FUSE_DEFAULT_CONGESTION_THRESHOLD (FUSE_DEFAULT_MAX_BACKGROUND * 3 / 4)",
      "#define FUSE_DEFAULT_MAX_BACKGROUND 12"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&fc->scramble_key",
            "sizeof(fc->scramble_key)"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fc->num_waiting",
            "0"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fc->entry"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fc->bg_queue"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fc->interrupts"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fc->io"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fc->processing"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fc->pending"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fc->reserved_req_waitq"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fc->blocked_waitq"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fc->waitq"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fc->count",
            "1"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&fc->killsb"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fc->lock"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fc",
            "0",
            "sizeof(*fc)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\n#define FUSE_DEFAULT_CONGESTION_THRESHOLD (FUSE_DEFAULT_MAX_BACKGROUND * 3 / 4)\n#define FUSE_DEFAULT_MAX_BACKGROUND 12\n\nvoid fuse_conn_init(struct fuse_conn *fc)\n{\n\tmemset(fc, 0, sizeof(*fc));\n\tspin_lock_init(&fc->lock);\n\tinit_rwsem(&fc->killsb);\n\tatomic_set(&fc->count, 1);\n\tinit_waitqueue_head(&fc->waitq);\n\tinit_waitqueue_head(&fc->blocked_waitq);\n\tinit_waitqueue_head(&fc->reserved_req_waitq);\n\tINIT_LIST_HEAD(&fc->pending);\n\tINIT_LIST_HEAD(&fc->processing);\n\tINIT_LIST_HEAD(&fc->io);\n\tINIT_LIST_HEAD(&fc->interrupts);\n\tINIT_LIST_HEAD(&fc->bg_queue);\n\tINIT_LIST_HEAD(&fc->entry);\n\tfc->forget_list_tail = &fc->forget_list_head;\n\tatomic_set(&fc->num_waiting, 0);\n\tfc->max_background = FUSE_DEFAULT_MAX_BACKGROUND;\n\tfc->congestion_threshold = FUSE_DEFAULT_CONGESTION_THRESHOLD;\n\tfc->khctr = 0;\n\tfc->polled_files = RB_ROOT;\n\tfc->reqctr = 0;\n\tfc->blocked = 0;\n\tfc->initialized = 0;\n\tfc->attr_version = 1;\n\tget_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));\n}"
  },
  {
    "function_name": "fuse_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "552-568",
    "snippet": "static int fuse_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n\tseq_printf(m, \",user_id=%u\", from_kuid_munged(&init_user_ns, fc->user_id));\n\tseq_printf(m, \",group_id=%u\", from_kgid_munged(&init_user_ns, fc->group_id));\n\tif (fc->flags & FUSE_DEFAULT_PERMISSIONS)\n\t\tseq_puts(m, \",default_permissions\");\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\tseq_puts(m, \",allow_other\");\n\tif (fc->max_read != ~0)\n\t\tseq_printf(m, \",max_read=%u\", fc->max_read);\n\tif (sb->s_bdev && sb->s_blocksize != FUSE_DEFAULT_BLKSIZE)\n\t\tseq_printf(m, \",blksize=%lu\", sb->s_blocksize);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [
      "#define FUSE_DEFAULT_BLKSIZE 512"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",blksize=%lu\"",
            "sb->s_blocksize"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\",allow_other\""
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "fc->group_id"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "fc->user_id"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn_super",
          "args": [
            "sb"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "618-621",
          "snippet": "static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\n#define FUSE_DEFAULT_BLKSIZE 512\n\nstatic int fuse_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n\tseq_printf(m, \",user_id=%u\", from_kuid_munged(&init_user_ns, fc->user_id));\n\tseq_printf(m, \",group_id=%u\", from_kgid_munged(&init_user_ns, fc->group_id));\n\tif (fc->flags & FUSE_DEFAULT_PERMISSIONS)\n\t\tseq_puts(m, \",default_permissions\");\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\tseq_puts(m, \",allow_other\");\n\tif (fc->max_read != ~0)\n\t\tseq_printf(m, \",max_read=%u\", fc->max_read);\n\tif (sb->s_bdev && sb->s_blocksize != FUSE_DEFAULT_BLKSIZE)\n\t\tseq_printf(m, \",blksize=%lu\", sb->s_blocksize);\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_fuse_opt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "469-550",
    "snippet": "static int parse_fuse_opt(char *opt, struct fuse_mount_data *d, int is_bdev)\n{\n\tchar *p;\n\tmemset(d, 0, sizeof(struct fuse_mount_data));\n\td->max_read = ~0;\n\td->blksize = FUSE_DEFAULT_BLKSIZE;\n\n\twhile ((p = strsep(&opt, \",\")) != NULL) {\n\t\tint token;\n\t\tint value;\n\t\tunsigned uv;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase OPT_FD:\n\t\t\tif (match_int(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\td->fd = value;\n\t\t\td->fd_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_ROOTMODE:\n\t\t\tif (match_octal(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\tif (!fuse_valid_type(value))\n\t\t\t\treturn 0;\n\t\t\td->rootmode = value;\n\t\t\td->rootmode_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_USER_ID:\n\t\t\tif (fuse_match_uint(&args[0], &uv))\n\t\t\t\treturn 0;\n\t\t\td->user_id = make_kuid(current_user_ns(), uv);\n\t\t\tif (!uid_valid(d->user_id))\n\t\t\t\treturn 0;\n\t\t\td->user_id_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_GROUP_ID:\n\t\t\tif (fuse_match_uint(&args[0], &uv))\n\t\t\t\treturn 0;\n\t\t\td->group_id = make_kgid(current_user_ns(), uv);\n\t\t\tif (!gid_valid(d->group_id))\n\t\t\t\treturn 0;\n\t\t\td->group_id_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_DEFAULT_PERMISSIONS:\n\t\t\td->flags |= FUSE_DEFAULT_PERMISSIONS;\n\t\t\tbreak;\n\n\t\tcase OPT_ALLOW_OTHER:\n\t\t\td->flags |= FUSE_ALLOW_OTHER;\n\t\t\tbreak;\n\n\t\tcase OPT_MAX_READ:\n\t\t\tif (match_int(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\td->max_read = value;\n\t\t\tbreak;\n\n\t\tcase OPT_BLKSIZE:\n\t\t\tif (!is_bdev || match_int(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\td->blksize = value;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!d->fd_present || !d->rootmode_present ||\n\t    !d->user_id_present || !d->group_id_present)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [
      "#define FUSE_DEFAULT_BLKSIZE 512"
    ],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{OPT_FD,\t\t\t\"fd=%u\"},\n\t{OPT_ROOTMODE,\t\t\t\"rootmode=%o\"},\n\t{OPT_USER_ID,\t\t\t\"user_id=%u\"},\n\t{OPT_GROUP_ID,\t\t\t\"group_id=%u\"},\n\t{OPT_DEFAULT_PERMISSIONS,\t\"default_permissions\"},\n\t{OPT_ALLOW_OTHER,\t\t\"allow_other\"},\n\t{OPT_MAX_READ,\t\t\t\"max_read=%u\"},\n\t{OPT_BLKSIZE,\t\t\t\"blksize=%u\"},\n\t{OPT_ERR,\t\t\tNULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&value"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&value"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "d->group_id"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "uv"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_match_uint",
          "args": [
            "&args[0]",
            "&uv"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_match_uint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "458-467",
          "snippet": "static int fuse_match_uint(substring_t *s, unsigned int *res)\n{\n\tint err = -ENOMEM;\n\tchar *buf = match_strdup(s);\n\tif (buf) {\n\t\terr = kstrtouint(buf, 10, res);\n\t\tkfree(buf);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_match_uint(substring_t *s, unsigned int *res)\n{\n\tint err = -ENOMEM;\n\tchar *buf = match_strdup(s);\n\tif (buf) {\n\t\terr = kstrtouint(buf, 10, res);\n\t\tkfree(buf);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "d->user_id"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "uv"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_valid_type",
          "args": [
            "value"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_valid_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "279-283",
          "snippet": "int fuse_valid_type(int m)\n{\n\treturn S_ISREG(m) || S_ISDIR(m) || S_ISLNK(m) || S_ISCHR(m) ||\n\t\tS_ISBLK(m) || S_ISFIFO(m) || S_ISSOCK(m);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_valid_type(int m)\n{\n\treturn S_ISREG(m) || S_ISDIR(m) || S_ISLNK(m) || S_ISCHR(m) ||\n\t\tS_ISBLK(m) || S_ISFIFO(m) || S_ISSOCK(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&value"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&value"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&opt",
            "\",\""
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "d",
            "0",
            "sizeof(struct fuse_mount_data)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\n#define FUSE_DEFAULT_BLKSIZE 512\n\nstatic const match_table_t tokens = {\n\t{OPT_FD,\t\t\t\"fd=%u\"},\n\t{OPT_ROOTMODE,\t\t\t\"rootmode=%o\"},\n\t{OPT_USER_ID,\t\t\t\"user_id=%u\"},\n\t{OPT_GROUP_ID,\t\t\t\"group_id=%u\"},\n\t{OPT_DEFAULT_PERMISSIONS,\t\"default_permissions\"},\n\t{OPT_ALLOW_OTHER,\t\t\"allow_other\"},\n\t{OPT_MAX_READ,\t\t\t\"max_read=%u\"},\n\t{OPT_BLKSIZE,\t\t\t\"blksize=%u\"},\n\t{OPT_ERR,\t\t\tNULL}\n};\n\nstatic int parse_fuse_opt(char *opt, struct fuse_mount_data *d, int is_bdev)\n{\n\tchar *p;\n\tmemset(d, 0, sizeof(struct fuse_mount_data));\n\td->max_read = ~0;\n\td->blksize = FUSE_DEFAULT_BLKSIZE;\n\n\twhile ((p = strsep(&opt, \",\")) != NULL) {\n\t\tint token;\n\t\tint value;\n\t\tunsigned uv;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase OPT_FD:\n\t\t\tif (match_int(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\td->fd = value;\n\t\t\td->fd_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_ROOTMODE:\n\t\t\tif (match_octal(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\tif (!fuse_valid_type(value))\n\t\t\t\treturn 0;\n\t\t\td->rootmode = value;\n\t\t\td->rootmode_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_USER_ID:\n\t\t\tif (fuse_match_uint(&args[0], &uv))\n\t\t\t\treturn 0;\n\t\t\td->user_id = make_kuid(current_user_ns(), uv);\n\t\t\tif (!uid_valid(d->user_id))\n\t\t\t\treturn 0;\n\t\t\td->user_id_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_GROUP_ID:\n\t\t\tif (fuse_match_uint(&args[0], &uv))\n\t\t\t\treturn 0;\n\t\t\td->group_id = make_kgid(current_user_ns(), uv);\n\t\t\tif (!gid_valid(d->group_id))\n\t\t\t\treturn 0;\n\t\t\td->group_id_present = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_DEFAULT_PERMISSIONS:\n\t\t\td->flags |= FUSE_DEFAULT_PERMISSIONS;\n\t\t\tbreak;\n\n\t\tcase OPT_ALLOW_OTHER:\n\t\t\td->flags |= FUSE_ALLOW_OTHER;\n\t\t\tbreak;\n\n\t\tcase OPT_MAX_READ:\n\t\t\tif (match_int(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\td->max_read = value;\n\t\t\tbreak;\n\n\t\tcase OPT_BLKSIZE:\n\t\t\tif (!is_bdev || match_int(&args[0], &value))\n\t\t\t\treturn 0;\n\t\t\td->blksize = value;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!d->fd_present || !d->rootmode_present ||\n\t    !d->user_id_present || !d->group_id_present)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "fuse_match_uint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "458-467",
    "snippet": "static int fuse_match_uint(substring_t *s, unsigned int *res)\n{\n\tint err = -ENOMEM;\n\tchar *buf = match_strdup(s);\n\tif (buf) {\n\t\terr = kstrtouint(buf, 10, res);\n\t\tkfree(buf);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "buf",
            "10",
            "res"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "s"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_match_uint(substring_t *s, unsigned int *res)\n{\n\tint err = -ENOMEM;\n\tchar *buf = match_strdup(s);\n\tif (buf) {\n\t\terr = kstrtouint(buf, 10, res);\n\t\tkfree(buf);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "408-432",
    "snippet": "static int fuse_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tFUSE_ARGS(args);\n\tstruct fuse_statfs_out outarg;\n\tint err;\n\n\tif (!fuse_allow_current_process(fc)) {\n\t\tbuf->f_type = FUSE_SUPER_MAGIC;\n\t\treturn 0;\n\t}\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs.in.numargs = 0;\n\targs.in.h.opcode = FUSE_STATFS;\n\targs.in.h.nodeid = get_node_id(dentry->d_inode);\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err)\n\t\tconvert_fuse_statfs(buf, &outarg.st);\n\treturn err;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [
      "#define FUSE_SUPER_MAGIC 0x65735546"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "convert_fuse_statfs",
          "args": [
            "buf",
            "&outarg.st"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "convert_fuse_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "394-406",
          "snippet": "static void convert_fuse_statfs(struct kstatfs *stbuf, struct fuse_kstatfs *attr)\n{\n\tstbuf->f_type    = FUSE_SUPER_MAGIC;\n\tstbuf->f_bsize   = attr->bsize;\n\tstbuf->f_frsize  = attr->frsize;\n\tstbuf->f_blocks  = attr->blocks;\n\tstbuf->f_bfree   = attr->bfree;\n\tstbuf->f_bavail  = attr->bavail;\n\tstbuf->f_files   = attr->files;\n\tstbuf->f_ffree   = attr->ffree;\n\tstbuf->f_namelen = attr->namelen;\n\t/* fsid is left zero */\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [
            "#define FUSE_SUPER_MAGIC 0x65735546"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\n#define FUSE_SUPER_MAGIC 0x65735546\n\nstatic void convert_fuse_statfs(struct kstatfs *stbuf, struct fuse_kstatfs *attr)\n{\n\tstbuf->f_type    = FUSE_SUPER_MAGIC;\n\tstbuf->f_bsize   = attr->bsize;\n\tstbuf->f_frsize  = attr->frsize;\n\tstbuf->f_blocks  = attr->blocks;\n\tstbuf->f_bfree   = attr->bfree;\n\tstbuf->f_bavail  = attr->bavail;\n\tstbuf->f_files   = attr->files;\n\tstbuf->f_ffree   = attr->ffree;\n\tstbuf->f_namelen = attr->namelen;\n\t/* fsid is left zero */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "dentry->d_inode"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&outarg",
            "0",
            "sizeof(outarg)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_allow_current_process",
          "args": [
            "fc"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_allow_current_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1013-1030",
          "snippet": "int fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn_super",
          "args": [
            "sb"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "618-621",
          "snippet": "static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\n#define FUSE_SUPER_MAGIC 0x65735546\n\nstatic int fuse_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tFUSE_ARGS(args);\n\tstruct fuse_statfs_out outarg;\n\tint err;\n\n\tif (!fuse_allow_current_process(fc)) {\n\t\tbuf->f_type = FUSE_SUPER_MAGIC;\n\t\treturn 0;\n\t}\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs.in.numargs = 0;\n\targs.in.h.opcode = FUSE_STATFS;\n\targs.in.h.nodeid = get_node_id(dentry->d_inode);\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err)\n\t\tconvert_fuse_statfs(buf, &outarg.st);\n\treturn err;\n}"
  },
  {
    "function_name": "convert_fuse_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "394-406",
    "snippet": "static void convert_fuse_statfs(struct kstatfs *stbuf, struct fuse_kstatfs *attr)\n{\n\tstbuf->f_type    = FUSE_SUPER_MAGIC;\n\tstbuf->f_bsize   = attr->bsize;\n\tstbuf->f_frsize  = attr->frsize;\n\tstbuf->f_blocks  = attr->blocks;\n\tstbuf->f_bfree   = attr->bfree;\n\tstbuf->f_bavail  = attr->bavail;\n\tstbuf->f_files   = attr->files;\n\tstbuf->f_ffree   = attr->ffree;\n\tstbuf->f_namelen = attr->namelen;\n\t/* fsid is left zero */\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [
      "#define FUSE_SUPER_MAGIC 0x65735546"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\n#define FUSE_SUPER_MAGIC 0x65735546\n\nstatic void convert_fuse_statfs(struct kstatfs *stbuf, struct fuse_kstatfs *attr)\n{\n\tstbuf->f_type    = FUSE_SUPER_MAGIC;\n\tstbuf->f_bsize   = attr->bsize;\n\tstbuf->f_frsize  = attr->frsize;\n\tstbuf->f_blocks  = attr->blocks;\n\tstbuf->f_bfree   = attr->bfree;\n\tstbuf->f_bavail  = attr->bavail;\n\tstbuf->f_files   = attr->files;\n\tstbuf->f_ffree   = attr->ffree;\n\tstbuf->f_namelen = attr->namelen;\n\t/* fsid is left zero */\n}"
  },
  {
    "function_name": "fuse_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "378-392",
    "snippet": "static void fuse_put_super(struct super_block *sb)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n\tfuse_send_destroy(fc);\n\n\tfuse_abort_conn(fc);\n\tmutex_lock(&fuse_mutex);\n\tlist_del(&fc->entry);\n\tfuse_ctl_remove_conn(fc);\n\tmutex_unlock(&fuse_mutex);\n\tfuse_bdi_destroy(fc);\n\n\tfuse_conn_put(fc);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_conn_put",
          "args": [
            "fc"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "599-606",
          "snippet": "void fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_bdi_destroy",
          "args": [
            "fc"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fuse_mutex"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_ctl_remove_conn",
          "args": [
            "fc"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ctl_remove_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "277-291",
          "snippet": "void fuse_ctl_remove_conn(struct fuse_conn *fc)\n{\n\tint i;\n\n\tif (!fuse_control_sb)\n\t\treturn;\n\n\tfor (i = fc->ctl_ndents - 1; i >= 0; i--) {\n\t\tstruct dentry *dentry = fc->ctl_dentry[i];\n\t\tdentry->d_inode->i_private = NULL;\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\tdrop_nlink(fuse_control_sb->s_root->d_inode);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct super_block *fuse_control_sb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct super_block *fuse_control_sb;\n\nvoid fuse_ctl_remove_conn(struct fuse_conn *fc)\n{\n\tint i;\n\n\tif (!fuse_control_sb)\n\t\treturn;\n\n\tfor (i = fc->ctl_ndents - 1; i >= 0; i--) {\n\t\tstruct dentry *dentry = fc->ctl_dentry[i];\n\t\tdentry->d_inode->i_private = NULL;\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\tdrop_nlink(fuse_control_sb->s_root->d_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&fc->entry"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fuse_mutex"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_abort_conn",
          "args": [
            "fc"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_abort_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2185-2200",
          "snippet": "void fuse_abort_conn(struct fuse_conn *fc)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_io_requests(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->waitq);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_abort_conn(struct fuse_conn *fc)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_io_requests(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->waitq);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_send_destroy",
          "args": [
            "fc"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_send_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "359-370",
          "snippet": "static void fuse_send_destroy(struct fuse_conn *fc)\n{\n\tstruct fuse_req *req = fc->destroy_req;\n\tif (req && fc->conn_init) {\n\t\tfc->destroy_req = NULL;\n\t\treq->in.h.opcode = FUSE_DESTROY;\n\t\treq->force = 1;\n\t\treq->background = 0;\n\t\tfuse_request_send(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_send_destroy(struct fuse_conn *fc)\n{\n\tstruct fuse_req *req = fc->destroy_req;\n\tif (req && fc->conn_init) {\n\t\tfc->destroy_req = NULL;\n\t\treq->in.h.opcode = FUSE_DESTROY;\n\t\treq->force = 1;\n\t\treq->background = 0;\n\t\tfuse_request_send(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn_super",
          "args": [
            "sb"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "618-621",
          "snippet": "static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_put_super(struct super_block *sb)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n\tfuse_send_destroy(fc);\n\n\tfuse_abort_conn(fc);\n\tmutex_lock(&fuse_mutex);\n\tlist_del(&fc->entry);\n\tfuse_ctl_remove_conn(fc);\n\tmutex_unlock(&fuse_mutex);\n\tfuse_bdi_destroy(fc);\n\n\tfuse_conn_put(fc);\n}"
  },
  {
    "function_name": "fuse_bdi_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "372-376",
    "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&fc->bdi"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
  },
  {
    "function_name": "fuse_send_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "359-370",
    "snippet": "static void fuse_send_destroy(struct fuse_conn *fc)\n{\n\tstruct fuse_req *req = fc->destroy_req;\n\tif (req && fc->conn_init) {\n\t\tfc->destroy_req = NULL;\n\t\treq->in.h.opcode = FUSE_DESTROY;\n\t\treq->force = 1;\n\t\treq->background = 0;\n\t\tfuse_request_send(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_send",
          "args": [
            "fc",
            "req"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_send_destroy(struct fuse_conn *fc)\n{\n\tstruct fuse_req *req = fc->destroy_req;\n\tif (req && fc->conn_init) {\n\t\tfc->destroy_req = NULL;\n\t\treq->in.h.opcode = FUSE_DESTROY;\n\t\treq->force = 1;\n\t\treq->background = 0;\n\t\tfuse_request_send(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}"
  },
  {
    "function_name": "fuse_umount_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "354-357",
    "snippet": "static void fuse_umount_begin(struct super_block *sb)\n{\n\tfuse_abort_conn(get_fuse_conn_super(sb));\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_abort_conn",
          "args": [
            "get_fuse_conn_super(sb)"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_abort_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2185-2200",
          "snippet": "void fuse_abort_conn(struct fuse_conn *fc)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_io_requests(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->waitq);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_abort_conn(struct fuse_conn *fc)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_io_requests(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->waitq);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn_super",
          "args": [
            "sb"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "618-621",
          "snippet": "static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_umount_begin(struct super_block *sb)\n{\n\tfuse_abort_conn(get_fuse_conn_super(sb));\n}"
  },
  {
    "function_name": "fuse_reverse_inval_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "329-352",
    "snippet": "int fuse_reverse_inval_inode(struct super_block *sb, u64 nodeid,\n\t\t\t     loff_t offset, loff_t len)\n{\n\tstruct inode *inode;\n\tpgoff_t pg_start;\n\tpgoff_t pg_end;\n\n\tinode = ilookup5(sb, nodeid, fuse_inode_eq, &nodeid);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tfuse_invalidate_attr(inode);\n\tif (offset >= 0) {\n\t\tpg_start = offset >> PAGE_CACHE_SHIFT;\n\t\tif (len <= 0)\n\t\t\tpg_end = -1;\n\t\telse\n\t\t\tpg_end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t      pg_start, pg_end);\n\t}\n\tiput(inode);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "inode->i_mapping",
            "pg_start",
            "pg_end"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "inode"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilookup5",
          "args": [
            "sb",
            "nodeid",
            "fuse_inode_eq",
            "&nodeid"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1239-1247",
          "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_reverse_inval_inode(struct super_block *sb, u64 nodeid,\n\t\t\t     loff_t offset, loff_t len)\n{\n\tstruct inode *inode;\n\tpgoff_t pg_start;\n\tpgoff_t pg_end;\n\n\tinode = ilookup5(sb, nodeid, fuse_inode_eq, &nodeid);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tfuse_invalidate_attr(inode);\n\tif (offset >= 0) {\n\t\tpg_start = offset >> PAGE_CACHE_SHIFT;\n\t\tif (len <= 0)\n\t\t\tpg_end = -1;\n\t\telse\n\t\t\tpg_end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t      pg_start, pg_end);\n\t}\n\tiput(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "293-327",
    "snippet": "struct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n retry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {\n\t\t/* Inode has changed type, any I/O on the old should fail */\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fc->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fc->lock);\n\tfuse_change_attributes(inode, attr, attr_valid, attr_version);\n\n\treturn inode;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_change_attributes",
          "args": [
            "inode",
            "attr",
            "attr_valid",
            "attr_version"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_change_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "199-251",
          "snippet": "void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,\n\t\t\t    u64 attr_valid, u64 attr_version)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tstruct timespec old_mtime;\n\n\tspin_lock(&fc->lock);\n\tif ((attr_version != 0 && fi->attr_version > attr_version) ||\n\t    test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn;\n\t}\n\n\told_mtime = inode->i_mtime;\n\tfuse_change_attributes_common(inode, attr, attr_valid);\n\n\toldsize = inode->i_size;\n\t/*\n\t * In case of writeback_cache enabled, the cached writes beyond EOF\n\t * extend local i_size without keeping userspace server in sync. So,\n\t * attr->size coming from server can be stale. We cannot trust it.\n\t */\n\tif (!is_wb || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, attr->size);\n\tspin_unlock(&fc->lock);\n\n\tif (!is_wb && S_ISREG(inode->i_mode)) {\n\t\tbool inval = false;\n\n\t\tif (oldsize != attr->size) {\n\t\t\ttruncate_pagecache(inode, attr->size);\n\t\t\tinval = true;\n\t\t} else if (fc->auto_inval_data) {\n\t\t\tstruct timespec new_mtime = {\n\t\t\t\t.tv_sec = attr->mtime,\n\t\t\t\t.tv_nsec = attr->mtimensec,\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Auto inval mode also checks and invalidates if mtime\n\t\t\t * has changed.\n\t\t\t */\n\t\t\tif (!timespec_equal(&old_mtime, &new_mtime))\n\t\t\t\tinval = true;\n\t\t}\n\n\t\tif (inval)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,\n\t\t\t    u64 attr_valid, u64 attr_version)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tstruct timespec old_mtime;\n\n\tspin_lock(&fc->lock);\n\tif ((attr_version != 0 && fi->attr_version > attr_version) ||\n\t    test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn;\n\t}\n\n\told_mtime = inode->i_mtime;\n\tfuse_change_attributes_common(inode, attr, attr_valid);\n\n\toldsize = inode->i_size;\n\t/*\n\t * In case of writeback_cache enabled, the cached writes beyond EOF\n\t * extend local i_size without keeping userspace server in sync. So,\n\t * attr->size coming from server can be stale. We cannot trust it.\n\t */\n\tif (!is_wb || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, attr->size);\n\tspin_unlock(&fc->lock);\n\n\tif (!is_wb && S_ISREG(inode->i_mode)) {\n\t\tbool inval = false;\n\n\t\tif (oldsize != attr->size) {\n\t\t\ttruncate_pagecache(inode, attr->size);\n\t\t\tinval = true;\n\t\t} else if (fc->auto_inval_data) {\n\t\t\tstruct timespec new_mtime = {\n\t\t\t\t.tv_sec = attr->mtime,\n\t\t\t\t.tv_nsec = attr->mtimensec,\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Auto inval mode also checks and invalidates if mtime\n\t\t\t * has changed.\n\t\t\t */\n\t\t\tif (!timespec_equal(&old_mtime, &new_mtime))\n\t\t\t\tinval = true;\n\t\t}\n\n\t\tif (inval)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_init_inode",
          "args": [
            "inode",
            "attr"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "253-275",
          "snippet": "static void fuse_init_inode(struct inode *inode, struct fuse_attr *attr)\n{\n\tinode->i_mode = attr->mode & S_IFMT;\n\tinode->i_size = attr->size;\n\tinode->i_mtime.tv_sec  = attr->mtime;\n\tinode->i_mtime.tv_nsec = attr->mtimensec;\n\tinode->i_ctime.tv_sec  = attr->ctime;\n\tinode->i_ctime.tv_nsec = attr->ctimensec;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfuse_init_common(inode);\n\t\tfuse_init_file_inode(inode);\n\t} else if (S_ISDIR(inode->i_mode))\n\t\tfuse_init_dir(inode);\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfuse_init_symlink(inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tfuse_init_common(inode);\n\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t   new_decode_dev(attr->rdev));\n\t} else\n\t\tBUG();\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_init_inode(struct inode *inode, struct fuse_attr *attr)\n{\n\tinode->i_mode = attr->mode & S_IFMT;\n\tinode->i_size = attr->size;\n\tinode->i_mtime.tv_sec  = attr->mtime;\n\tinode->i_mtime.tv_nsec = attr->mtimensec;\n\tinode->i_ctime.tv_sec  = attr->ctime;\n\tinode->i_ctime.tv_nsec = attr->ctimensec;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfuse_init_common(inode);\n\t\tfuse_init_file_inode(inode);\n\t} else if (S_ISDIR(inode->i_mode))\n\t\tfuse_init_dir(inode);\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfuse_init_symlink(inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tfuse_init_common(inode);\n\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t   new_decode_dev(attr->rdev));\n\t} else\n\t\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "attr->mode"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "nodeid",
            "fuse_inode_eq",
            "fuse_inode_set",
            "&nodeid"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn_super",
          "args": [
            "sb"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "618-621",
          "snippet": "static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n retry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {\n\t\t/* Inode has changed type, any I/O on the old should fail */\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fc->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fc->lock);\n\tfuse_change_attributes(inode, attr, attr_valid, attr_version);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "fuse_inode_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "286-291",
    "snippet": "static int fuse_inode_set(struct inode *inode, void *_nodeidp)\n{\n\tu64 nodeid = *(u64 *) _nodeidp;\n\tget_fuse_inode(inode)->nodeid = nodeid;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_inode_set(struct inode *inode, void *_nodeidp)\n{\n\tu64 nodeid = *(u64 *) _nodeidp;\n\tget_fuse_inode(inode)->nodeid = nodeid;\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_inode_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "277-284",
    "snippet": "int fuse_inode_eq(struct inode *inode, void *_nodeidp)\n{\n\tu64 nodeid = *(u64 *) _nodeidp;\n\tif (get_node_id(inode) == nodeid)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_inode_eq(struct inode *inode, void *_nodeidp)\n{\n\tu64 nodeid = *(u64 *) _nodeidp;\n\tif (get_node_id(inode) == nodeid)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "fuse_init_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "253-275",
    "snippet": "static void fuse_init_inode(struct inode *inode, struct fuse_attr *attr)\n{\n\tinode->i_mode = attr->mode & S_IFMT;\n\tinode->i_size = attr->size;\n\tinode->i_mtime.tv_sec  = attr->mtime;\n\tinode->i_mtime.tv_nsec = attr->mtimensec;\n\tinode->i_ctime.tv_sec  = attr->ctime;\n\tinode->i_ctime.tv_nsec = attr->ctimensec;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfuse_init_common(inode);\n\t\tfuse_init_file_inode(inode);\n\t} else if (S_ISDIR(inode->i_mode))\n\t\tfuse_init_dir(inode);\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfuse_init_symlink(inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tfuse_init_common(inode);\n\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t   new_decode_dev(attr->rdev));\n\t} else\n\t\tBUG();\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "new_decode_dev(attr->rdev)"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "attr->rdev"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_init_common",
          "args": [
            "inode"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1938-1941",
          "snippet": "void fuse_init_common(struct inode *inode)\n{\n\tinode->i_op = &fuse_common_inode_operations;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations fuse_common_inode_operations = {\n\t.setattr\t= fuse_setattr,\n\t.permission\t= fuse_permission,\n\t.getattr\t= fuse_getattr,\n\t.setxattr\t= fuse_setxattr,\n\t.getxattr\t= fuse_getxattr,\n\t.listxattr\t= fuse_listxattr,\n\t.removexattr\t= fuse_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct inode_operations fuse_common_inode_operations = {\n\t.setattr\t= fuse_setattr,\n\t.permission\t= fuse_permission,\n\t.getattr\t= fuse_getattr,\n\t.setxattr\t= fuse_setxattr,\n\t.getxattr\t= fuse_getxattr,\n\t.listxattr\t= fuse_listxattr,\n\t.removexattr\t= fuse_removexattr,\n};\n\nvoid fuse_init_common(struct inode *inode)\n{\n\tinode->i_op = &fuse_common_inode_operations;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "inode->i_mode"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "inode->i_mode"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_init_symlink",
          "args": [
            "inode"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1949-1952",
          "snippet": "void fuse_init_symlink(struct inode *inode)\n{\n\tinode->i_op = &fuse_symlink_inode_operations;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations fuse_symlink_inode_operations = {\n\t.setattr\t= fuse_setattr,\n\t.follow_link\t= fuse_follow_link,\n\t.put_link\t= fuse_put_link,\n\t.readlink\t= generic_readlink,\n\t.getattr\t= fuse_getattr,\n\t.setxattr\t= fuse_setxattr,\n\t.getxattr\t= fuse_getxattr,\n\t.listxattr\t= fuse_listxattr,\n\t.removexattr\t= fuse_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct inode_operations fuse_symlink_inode_operations = {\n\t.setattr\t= fuse_setattr,\n\t.follow_link\t= fuse_follow_link,\n\t.put_link\t= fuse_put_link,\n\t.readlink\t= generic_readlink,\n\t.getattr\t= fuse_getattr,\n\t.setxattr\t= fuse_setxattr,\n\t.getxattr\t= fuse_getxattr,\n\t.listxattr\t= fuse_listxattr,\n\t.removexattr\t= fuse_removexattr,\n};\n\nvoid fuse_init_symlink(struct inode *inode)\n{\n\tinode->i_op = &fuse_symlink_inode_operations;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_init_dir",
          "args": [
            "inode"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1943-1947",
          "snippet": "void fuse_init_dir(struct inode *inode)\n{\n\tinode->i_op = &fuse_dir_inode_operations;\n\tinode->i_fop = &fuse_dir_operations;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations fuse_dir_inode_operations = {\n\t.lookup\t\t= fuse_lookup,\n\t.mkdir\t\t= fuse_mkdir,\n\t.symlink\t= fuse_symlink,\n\t.unlink\t\t= fuse_unlink,\n\t.rmdir\t\t= fuse_rmdir,\n\t.rename2\t= fuse_rename2,\n\t.link\t\t= fuse_link,\n\t.setattr\t= fuse_setattr,\n\t.create\t\t= fuse_create,\n\t.atomic_open\t= fuse_atomic_open,\n\t.mknod\t\t= fuse_mknod,\n\t.permission\t= fuse_permission,\n\t.getattr\t= fuse_getattr,\n\t.setxattr\t= fuse_setxattr,\n\t.getxattr\t= fuse_getxattr,\n\t.listxattr\t= fuse_listxattr,\n\t.removexattr\t= fuse_removexattr,\n};",
            "static const struct file_operations fuse_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= fuse_readdir,\n\t.open\t\t= fuse_dir_open,\n\t.release\t= fuse_dir_release,\n\t.fsync\t\t= fuse_dir_fsync,\n\t.unlocked_ioctl\t= fuse_dir_ioctl,\n\t.compat_ioctl\t= fuse_dir_compat_ioctl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct inode_operations fuse_dir_inode_operations = {\n\t.lookup\t\t= fuse_lookup,\n\t.mkdir\t\t= fuse_mkdir,\n\t.symlink\t= fuse_symlink,\n\t.unlink\t\t= fuse_unlink,\n\t.rmdir\t\t= fuse_rmdir,\n\t.rename2\t= fuse_rename2,\n\t.link\t\t= fuse_link,\n\t.setattr\t= fuse_setattr,\n\t.create\t\t= fuse_create,\n\t.atomic_open\t= fuse_atomic_open,\n\t.mknod\t\t= fuse_mknod,\n\t.permission\t= fuse_permission,\n\t.getattr\t= fuse_getattr,\n\t.setxattr\t= fuse_setxattr,\n\t.getxattr\t= fuse_getxattr,\n\t.listxattr\t= fuse_listxattr,\n\t.removexattr\t= fuse_removexattr,\n};\nstatic const struct file_operations fuse_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= fuse_readdir,\n\t.open\t\t= fuse_dir_open,\n\t.release\t= fuse_dir_release,\n\t.fsync\t\t= fuse_dir_fsync,\n\t.unlocked_ioctl\t= fuse_dir_ioctl,\n\t.compat_ioctl\t= fuse_dir_compat_ioctl,\n};\n\nvoid fuse_init_dir(struct inode *inode)\n{\n\tinode->i_op = &fuse_dir_inode_operations;\n\tinode->i_fop = &fuse_dir_operations;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_init_file_inode",
          "args": [
            "inode"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_init_inode(struct inode *inode, struct fuse_attr *attr)\n{\n\tinode->i_mode = attr->mode & S_IFMT;\n\tinode->i_size = attr->size;\n\tinode->i_mtime.tv_sec  = attr->mtime;\n\tinode->i_mtime.tv_nsec = attr->mtimensec;\n\tinode->i_ctime.tv_sec  = attr->ctime;\n\tinode->i_ctime.tv_nsec = attr->ctimensec;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfuse_init_common(inode);\n\t\tfuse_init_file_inode(inode);\n\t} else if (S_ISDIR(inode->i_mode))\n\t\tfuse_init_dir(inode);\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfuse_init_symlink(inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tfuse_init_common(inode);\n\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t   new_decode_dev(attr->rdev));\n\t} else\n\t\tBUG();\n}"
  },
  {
    "function_name": "fuse_change_attributes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "199-251",
    "snippet": "void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,\n\t\t\t    u64 attr_valid, u64 attr_version)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tstruct timespec old_mtime;\n\n\tspin_lock(&fc->lock);\n\tif ((attr_version != 0 && fi->attr_version > attr_version) ||\n\t    test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn;\n\t}\n\n\told_mtime = inode->i_mtime;\n\tfuse_change_attributes_common(inode, attr, attr_valid);\n\n\toldsize = inode->i_size;\n\t/*\n\t * In case of writeback_cache enabled, the cached writes beyond EOF\n\t * extend local i_size without keeping userspace server in sync. So,\n\t * attr->size coming from server can be stale. We cannot trust it.\n\t */\n\tif (!is_wb || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, attr->size);\n\tspin_unlock(&fc->lock);\n\n\tif (!is_wb && S_ISREG(inode->i_mode)) {\n\t\tbool inval = false;\n\n\t\tif (oldsize != attr->size) {\n\t\t\ttruncate_pagecache(inode, attr->size);\n\t\t\tinval = true;\n\t\t} else if (fc->auto_inval_data) {\n\t\t\tstruct timespec new_mtime = {\n\t\t\t\t.tv_sec = attr->mtime,\n\t\t\t\t.tv_nsec = attr->mtimensec,\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Auto inval mode also checks and invalidates if mtime\n\t\t\t * has changed.\n\t\t\t */\n\t\t\tif (!timespec_equal(&old_mtime, &new_mtime))\n\t\t\t\tinval = true;\n\t\t}\n\n\t\tif (inval)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_inode_pages2",
          "args": [
            "inode->i_mapping"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_equal",
          "args": [
            "&old_mtime",
            "&new_mtime"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "attr->size"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "attr->size"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_change_attributes_common",
          "args": [
            "inode",
            "attr",
            "attr_valid"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_change_attributes_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "157-197",
          "snippet": "void fuse_change_attributes_common(struct inode *inode, struct fuse_attr *attr,\n\t\t\t\t   u64 attr_valid)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tfi->attr_version = ++fc->attr_version;\n\tfi->i_time = attr_valid;\n\n\tinode->i_ino     = fuse_squash_ino(attr->ino);\n\tinode->i_mode    = (inode->i_mode & S_IFMT) | (attr->mode & 07777);\n\tset_nlink(inode, attr->nlink);\n\tinode->i_uid     = make_kuid(&init_user_ns, attr->uid);\n\tinode->i_gid     = make_kgid(&init_user_ns, attr->gid);\n\tinode->i_blocks  = attr->blocks;\n\tinode->i_atime.tv_sec   = attr->atime;\n\tinode->i_atime.tv_nsec  = attr->atimensec;\n\t/* mtime from server may be stale due to local buffered write */\n\tif (!fc->writeback_cache || !S_ISREG(inode->i_mode)) {\n\t\tinode->i_mtime.tv_sec   = attr->mtime;\n\t\tinode->i_mtime.tv_nsec  = attr->mtimensec;\n\t\tinode->i_ctime.tv_sec   = attr->ctime;\n\t\tinode->i_ctime.tv_nsec  = attr->ctimensec;\n\t}\n\n\tif (attr->blksize != 0)\n\t\tinode->i_blkbits = ilog2(attr->blksize);\n\telse\n\t\tinode->i_blkbits = inode->i_sb->s_blocksize_bits;\n\n\t/*\n\t * Don't set the sticky bit in i_mode, unless we want the VFS\n\t * to check permissions.  This prevents failures due to the\n\t * check in may_delete().\n\t */\n\tfi->orig_i_mode = inode->i_mode;\n\tif (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))\n\t\tinode->i_mode &= ~S_ISVTX;\n\n\tfi->orig_ino = attr->ino;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_change_attributes_common(struct inode *inode, struct fuse_attr *attr,\n\t\t\t\t   u64 attr_valid)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tfi->attr_version = ++fc->attr_version;\n\tfi->i_time = attr_valid;\n\n\tinode->i_ino     = fuse_squash_ino(attr->ino);\n\tinode->i_mode    = (inode->i_mode & S_IFMT) | (attr->mode & 07777);\n\tset_nlink(inode, attr->nlink);\n\tinode->i_uid     = make_kuid(&init_user_ns, attr->uid);\n\tinode->i_gid     = make_kgid(&init_user_ns, attr->gid);\n\tinode->i_blocks  = attr->blocks;\n\tinode->i_atime.tv_sec   = attr->atime;\n\tinode->i_atime.tv_nsec  = attr->atimensec;\n\t/* mtime from server may be stale due to local buffered write */\n\tif (!fc->writeback_cache || !S_ISREG(inode->i_mode)) {\n\t\tinode->i_mtime.tv_sec   = attr->mtime;\n\t\tinode->i_mtime.tv_nsec  = attr->mtimensec;\n\t\tinode->i_ctime.tv_sec   = attr->ctime;\n\t\tinode->i_ctime.tv_nsec  = attr->ctimensec;\n\t}\n\n\tif (attr->blksize != 0)\n\t\tinode->i_blkbits = ilog2(attr->blksize);\n\telse\n\t\tinode->i_blkbits = inode->i_sb->s_blocksize_bits;\n\n\t/*\n\t * Don't set the sticky bit in i_mode, unless we want the VFS\n\t * to check permissions.  This prevents failures due to the\n\t * check in may_delete().\n\t */\n\tfi->orig_i_mode = inode->i_mode;\n\tif (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))\n\t\tinode->i_mode &= ~S_ISVTX;\n\n\tfi->orig_ino = attr->ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FUSE_I_SIZE_UNSTABLE",
            "&fi->state"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,\n\t\t\t    u64 attr_valid, u64 attr_version)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tstruct timespec old_mtime;\n\n\tspin_lock(&fc->lock);\n\tif ((attr_version != 0 && fi->attr_version > attr_version) ||\n\t    test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn;\n\t}\n\n\told_mtime = inode->i_mtime;\n\tfuse_change_attributes_common(inode, attr, attr_valid);\n\n\toldsize = inode->i_size;\n\t/*\n\t * In case of writeback_cache enabled, the cached writes beyond EOF\n\t * extend local i_size without keeping userspace server in sync. So,\n\t * attr->size coming from server can be stale. We cannot trust it.\n\t */\n\tif (!is_wb || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, attr->size);\n\tspin_unlock(&fc->lock);\n\n\tif (!is_wb && S_ISREG(inode->i_mode)) {\n\t\tbool inval = false;\n\n\t\tif (oldsize != attr->size) {\n\t\t\ttruncate_pagecache(inode, attr->size);\n\t\t\tinval = true;\n\t\t} else if (fc->auto_inval_data) {\n\t\t\tstruct timespec new_mtime = {\n\t\t\t\t.tv_sec = attr->mtime,\n\t\t\t\t.tv_nsec = attr->mtimensec,\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Auto inval mode also checks and invalidates if mtime\n\t\t\t * has changed.\n\t\t\t */\n\t\t\tif (!timespec_equal(&old_mtime, &new_mtime))\n\t\t\t\tinval = true;\n\t\t}\n\n\t\tif (inval)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n}"
  },
  {
    "function_name": "fuse_change_attributes_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "157-197",
    "snippet": "void fuse_change_attributes_common(struct inode *inode, struct fuse_attr *attr,\n\t\t\t\t   u64 attr_valid)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tfi->attr_version = ++fc->attr_version;\n\tfi->i_time = attr_valid;\n\n\tinode->i_ino     = fuse_squash_ino(attr->ino);\n\tinode->i_mode    = (inode->i_mode & S_IFMT) | (attr->mode & 07777);\n\tset_nlink(inode, attr->nlink);\n\tinode->i_uid     = make_kuid(&init_user_ns, attr->uid);\n\tinode->i_gid     = make_kgid(&init_user_ns, attr->gid);\n\tinode->i_blocks  = attr->blocks;\n\tinode->i_atime.tv_sec   = attr->atime;\n\tinode->i_atime.tv_nsec  = attr->atimensec;\n\t/* mtime from server may be stale due to local buffered write */\n\tif (!fc->writeback_cache || !S_ISREG(inode->i_mode)) {\n\t\tinode->i_mtime.tv_sec   = attr->mtime;\n\t\tinode->i_mtime.tv_nsec  = attr->mtimensec;\n\t\tinode->i_ctime.tv_sec   = attr->ctime;\n\t\tinode->i_ctime.tv_nsec  = attr->ctimensec;\n\t}\n\n\tif (attr->blksize != 0)\n\t\tinode->i_blkbits = ilog2(attr->blksize);\n\telse\n\t\tinode->i_blkbits = inode->i_sb->s_blocksize_bits;\n\n\t/*\n\t * Don't set the sticky bit in i_mode, unless we want the VFS\n\t * to check permissions.  This prevents failures due to the\n\t * check in may_delete().\n\t */\n\tfi->orig_i_mode = inode->i_mode;\n\tif (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))\n\t\tinode->i_mode &= ~S_ISVTX;\n\n\tfi->orig_ino = attr->ino;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "attr->blksize"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "attr->gid"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "attr->uid"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "attr->nlink"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_squash_ino",
          "args": [
            "attr->ino"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_squash_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "149-155",
          "snippet": "static ino_t fuse_squash_ino(u64 ino64)\n{\n\tino_t ino = (ino_t) ino64;\n\tif (sizeof(ino_t) < sizeof(u64))\n\t\tino ^= ino64 >> (sizeof(u64) - sizeof(ino_t)) * 8;\n\treturn ino;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ino_t fuse_squash_ino(u64 ino64)\n{\n\tino_t ino = (ino_t) ino64;\n\tif (sizeof(ino_t) < sizeof(u64))\n\t\tino ^= ino64 >> (sizeof(u64) - sizeof(ino_t)) * 8;\n\treturn ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_change_attributes_common(struct inode *inode, struct fuse_attr *attr,\n\t\t\t\t   u64 attr_valid)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tfi->attr_version = ++fc->attr_version;\n\tfi->i_time = attr_valid;\n\n\tinode->i_ino     = fuse_squash_ino(attr->ino);\n\tinode->i_mode    = (inode->i_mode & S_IFMT) | (attr->mode & 07777);\n\tset_nlink(inode, attr->nlink);\n\tinode->i_uid     = make_kuid(&init_user_ns, attr->uid);\n\tinode->i_gid     = make_kgid(&init_user_ns, attr->gid);\n\tinode->i_blocks  = attr->blocks;\n\tinode->i_atime.tv_sec   = attr->atime;\n\tinode->i_atime.tv_nsec  = attr->atimensec;\n\t/* mtime from server may be stale due to local buffered write */\n\tif (!fc->writeback_cache || !S_ISREG(inode->i_mode)) {\n\t\tinode->i_mtime.tv_sec   = attr->mtime;\n\t\tinode->i_mtime.tv_nsec  = attr->mtimensec;\n\t\tinode->i_ctime.tv_sec   = attr->ctime;\n\t\tinode->i_ctime.tv_nsec  = attr->ctimensec;\n\t}\n\n\tif (attr->blksize != 0)\n\t\tinode->i_blkbits = ilog2(attr->blksize);\n\telse\n\t\tinode->i_blkbits = inode->i_sb->s_blocksize_bits;\n\n\t/*\n\t * Don't set the sticky bit in i_mode, unless we want the VFS\n\t * to check permissions.  This prevents failures due to the\n\t * check in may_delete().\n\t */\n\tfi->orig_i_mode = inode->i_mode;\n\tif (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))\n\t\tinode->i_mode &= ~S_ISVTX;\n\n\tfi->orig_ino = attr->ino;\n}"
  },
  {
    "function_name": "fuse_squash_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "149-155",
    "snippet": "static ino_t fuse_squash_ino(u64 ino64)\n{\n\tino_t ino = (ino_t) ino64;\n\tif (sizeof(ino_t) < sizeof(u64))\n\t\tino ^= ino64 >> (sizeof(u64) - sizeof(ino_t)) * 8;\n\treturn ino;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ino_t fuse_squash_ino(u64 ino64)\n{\n\tino_t ino = (ino_t) ino64;\n\tif (sizeof(ino_t) < sizeof(u64))\n\t\tino ^= ino64 >> (sizeof(u64) - sizeof(ino_t)) * 8;\n\treturn ino;\n}"
  },
  {
    "function_name": "fuse_remount_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "136-143",
    "snippet": "static int fuse_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tif (*flags & MS_MANDLOCK)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tif (*flags & MS_MANDLOCK)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "124-134",
    "snippet": "static void fuse_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (inode->i_sb->s_flags & MS_ACTIVE) {\n\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\t\tfuse_queue_forget(fc, fi->forget, fi->nodeid, fi->nlookup);\n\t\tfi->forget = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_queue_forget",
          "args": [
            "fc",
            "fi->forget",
            "fi->nodeid",
            "fi->nlookup"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_queue_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "337-353",
          "snippet": "void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup)\n{\n\tforget->forget_one.nodeid = nodeid;\n\tforget->forget_one.nlookup = nlookup;\n\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->forget_list_tail->next = forget;\n\t\tfc->forget_list_tail = forget;\n\t\twake_up(&fc->waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t} else {\n\t\tkfree(forget);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup)\n{\n\tforget->forget_one.nodeid = nodeid;\n\tforget->forget_one.nlookup = nlookup;\n\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->forget_list_tail->next = forget;\n\t\tfc->forget_list_tail = forget;\n\t\twake_up(&fc->waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t} else {\n\t\tkfree(forget);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (inode->i_sb->s_flags & MS_ACTIVE) {\n\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\t\tfuse_queue_forget(fc, fi->forget, fi->nodeid, fi->nlookup);\n\t\tfi->forget = NULL;\n\t}\n}"
  },
  {
    "function_name": "fuse_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "115-122",
    "snippet": "static void fuse_destroy_inode(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tBUG_ON(!list_empty(&fi->write_files));\n\tBUG_ON(!list_empty(&fi->queued_writes));\n\tkfree(fi->forget);\n\tcall_rcu(&inode->i_rcu, fuse_i_callback);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "fuse_i_callback"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fi->forget"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&fi->queued_writes)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fi->queued_writes"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&fi->write_files)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_destroy_inode(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tBUG_ON(!list_empty(&fi->write_files));\n\tBUG_ON(!list_empty(&fi->queued_writes));\n\tkfree(fi->forget);\n\tcall_rcu(&inode->i_rcu, fuse_i_callback);\n}"
  },
  {
    "function_name": "fuse_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "109-113",
    "snippet": "static void fuse_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(fuse_inode_cachep, inode);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fuse_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "fuse_inode_cachep",
            "inode"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_inode_cachep;\n\nstatic void fuse_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(fuse_inode_cachep, inode);\n}"
  },
  {
    "function_name": "fuse_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "79-107",
    "snippet": "static struct inode *fuse_alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\n\tinode = kmem_cache_alloc(fuse_inode_cachep, GFP_KERNEL);\n\tif (!inode)\n\t\treturn NULL;\n\n\tfi = get_fuse_inode(inode);\n\tfi->i_time = 0;\n\tfi->nodeid = 0;\n\tfi->nlookup = 0;\n\tfi->attr_version = 0;\n\tfi->writectr = 0;\n\tfi->orig_ino = 0;\n\tfi->state = 0;\n\tINIT_LIST_HEAD(&fi->write_files);\n\tINIT_LIST_HEAD(&fi->queued_writes);\n\tINIT_LIST_HEAD(&fi->writepages);\n\tinit_waitqueue_head(&fi->page_waitq);\n\tfi->forget = fuse_alloc_forget();\n\tif (!fi->forget) {\n\t\tkmem_cache_free(fuse_inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fuse_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "fuse_inode_cachep",
            "inode"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_alloc_forget",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_alloc_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "74-77",
          "snippet": "struct fuse_forget_link *fuse_alloc_forget(void)\n{\n\treturn kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_forget_link *fuse_alloc_forget(void)\n{\n\treturn kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fi->page_waitq"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fi->writepages"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fi->queued_writes"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fi->write_files"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "fuse_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_inode_cachep;\n\nstatic struct inode *fuse_alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\n\tinode = kmem_cache_alloc(fuse_inode_cachep, GFP_KERNEL);\n\tif (!inode)\n\t\treturn NULL;\n\n\tfi = get_fuse_inode(inode);\n\tfi->i_time = 0;\n\tfi->nodeid = 0;\n\tfi->nlookup = 0;\n\tfi->attr_version = 0;\n\tfi->writectr = 0;\n\tfi->orig_ino = 0;\n\tfi->state = 0;\n\tINIT_LIST_HEAD(&fi->write_files);\n\tINIT_LIST_HEAD(&fi->queued_writes);\n\tINIT_LIST_HEAD(&fi->writepages);\n\tinit_waitqueue_head(&fi->page_waitq);\n\tfi->forget = fuse_alloc_forget();\n\tif (!fi->forget) {\n\t\tkmem_cache_free(fuse_inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "fuse_alloc_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
    "lines": "74-77",
    "snippet": "struct fuse_forget_link *fuse_alloc_forget(void)\n{\n\treturn kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct fuse_forget_link)",
            "GFP_KERNEL"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_forget_link *fuse_alloc_forget(void)\n{\n\treturn kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);\n}"
  }
]