[
  {
    "function_name": "kernfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
    "lines": "244-249",
    "snippet": "void __init kernfs_init(void)\n{\n\tkernfs_node_cache = kmem_cache_create(\"kernfs_node_cache\",\n\t\t\t\t\t      sizeof(struct kernfs_node),\n\t\t\t\t\t      0, SLAB_PANIC, NULL);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kernfs_node_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"kernfs_node_cache\"",
            "sizeof(struct kernfs_node)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *kernfs_node_cache;\n\nvoid __init kernfs_init(void)\n{\n\tkernfs_node_cache = kmem_cache_create(\"kernfs_node_cache\",\n\t\t\t\t\t      sizeof(struct kernfs_node),\n\t\t\t\t\t      0, SLAB_PANIC, NULL);\n}"
  },
  {
    "function_name": "kernfs_pin_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
    "lines": "226-242",
    "snippet": "struct super_block *kernfs_pin_sb(struct kernfs_root *root, const void *ns)\n{\n\tstruct kernfs_super_info *info;\n\tstruct super_block *sb = NULL;\n\n\tmutex_lock(&kernfs_mutex);\n\tlist_for_each_entry(info, &root->supers, node) {\n\t\tif (info->ns == ns) {\n\t\t\tsb = info->sb;\n\t\t\tif (!atomic_inc_not_zero(&info->sb->s_active))\n\t\t\t\tsb = ERR_PTR(-EINVAL);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&kernfs_mutex);\n\treturn sb;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&info->sb->s_active"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "info",
            "&root->supers",
            "node"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct super_block *kernfs_pin_sb(struct kernfs_root *root, const void *ns)\n{\n\tstruct kernfs_super_info *info;\n\tstruct super_block *sb = NULL;\n\n\tmutex_lock(&kernfs_mutex);\n\tlist_for_each_entry(info, &root->supers, node) {\n\t\tif (info->ns == ns) {\n\t\t\tsb = info->sb;\n\t\t\tif (!atomic_inc_not_zero(&info->sb->s_active))\n\t\t\t\tsb = ERR_PTR(-EINVAL);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&kernfs_mutex);\n\treturn sb;\n}"
  },
  {
    "function_name": "kernfs_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
    "lines": "196-212",
    "snippet": "void kernfs_kill_sb(struct super_block *sb)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\tstruct kernfs_node *root_kn = sb->s_root->d_fsdata;\n\n\tmutex_lock(&kernfs_mutex);\n\tlist_del(&info->node);\n\tmutex_unlock(&kernfs_mutex);\n\n\t/*\n\t * Remove the superblock from fs_supers/s_instances\n\t * so we can't find it, before freeing kernfs_super_info.\n\t */\n\tkill_anon_super(sb);\n\tkfree(info);\n\tkernfs_put(root_kn);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "root_kn"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_anon_super",
          "args": [
            "sb"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&info->node"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_info",
          "args": [
            "sb"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid kernfs_kill_sb(struct super_block *sb)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\tstruct kernfs_node *root_kn = sb->s_root->d_fsdata;\n\n\tmutex_lock(&kernfs_mutex);\n\tlist_del(&info->node);\n\tmutex_unlock(&kernfs_mutex);\n\n\t/*\n\t * Remove the superblock from fs_supers/s_instances\n\t * so we can't find it, before freeing kernfs_super_info.\n\t */\n\tkill_anon_super(sb);\n\tkfree(info);\n\tkernfs_put(root_kn);\n}"
  },
  {
    "function_name": "kernfs_mount_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
    "lines": "146-186",
    "snippet": "struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,\n\t\t\t\tstruct kernfs_root *root, unsigned long magic,\n\t\t\t\tbool *new_sb_created, const void *ns)\n{\n\tstruct super_block *sb;\n\tstruct kernfs_super_info *info;\n\tint error;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo->root = root;\n\tinfo->ns = ns;\n\n\tsb = sget(fs_type, kernfs_test_super, kernfs_set_super, flags, info);\n\tif (IS_ERR(sb) || sb->s_fs_info != info)\n\t\tkfree(info);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (new_sb_created)\n\t\t*new_sb_created = !sb->s_root;\n\n\tif (!sb->s_root) {\n\t\tstruct kernfs_super_info *info = kernfs_info(sb);\n\n\t\terror = kernfs_fill_super(sb, magic);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t\tsb->s_flags |= MS_ACTIVE;\n\n\t\tmutex_lock(&kernfs_mutex);\n\t\tlist_add(&info->node, &root->supers);\n\t\tmutex_unlock(&kernfs_mutex);\n\t}\n\n\treturn dget(sb->s_root);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "sb->s_root"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&info->node",
            "&root->supers"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_fill_super",
          "args": [
            "sb",
            "magic"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
          "lines": "65-98",
          "snippet": "static int kernfs_fill_super(struct super_block *sb, unsigned long magic)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\tstruct inode *inode;\n\tstruct dentry *root;\n\n\tinfo->sb = sb;\n\tsb->s_blocksize = PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\tsb->s_magic = magic;\n\tsb->s_op = &kernfs_sops;\n\tsb->s_time_gran = 1;\n\n\t/* get root inode, initialize and unlock it */\n\tmutex_lock(&kernfs_mutex);\n\tinode = kernfs_get_inode(sb, info->root->kn);\n\tmutex_unlock(&kernfs_mutex);\n\tif (!inode) {\n\t\tpr_debug(\"kernfs: could not get root inode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* instantiate and link root dentry */\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tpr_debug(\"%s: could not get root dentry!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tkernfs_get(info->root->kn);\n\troot->d_fsdata = info->root->kn;\n\tsb->s_root = root;\n\tsb->s_d_op = &kernfs_dops;\n\treturn 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct super_operations kernfs_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= kernfs_evict_inode,\n\n\t.remount_fs\t= kernfs_sop_remount_fs,\n\t.show_options\t= kernfs_sop_show_options,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nconst struct super_operations kernfs_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= kernfs_evict_inode,\n\n\t.remount_fs\t= kernfs_sop_remount_fs,\n\t.show_options\t= kernfs_sop_show_options,\n};\n\nstatic int kernfs_fill_super(struct super_block *sb, unsigned long magic)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\tstruct inode *inode;\n\tstruct dentry *root;\n\n\tinfo->sb = sb;\n\tsb->s_blocksize = PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\tsb->s_magic = magic;\n\tsb->s_op = &kernfs_sops;\n\tsb->s_time_gran = 1;\n\n\t/* get root inode, initialize and unlock it */\n\tmutex_lock(&kernfs_mutex);\n\tinode = kernfs_get_inode(sb, info->root->kn);\n\tmutex_unlock(&kernfs_mutex);\n\tif (!inode) {\n\t\tpr_debug(\"kernfs: could not get root inode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* instantiate and link root dentry */\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tpr_debug(\"%s: could not get root dentry!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tkernfs_get(info->root->kn);\n\troot->d_fsdata = info->root->kn;\n\tsb->s_root = root;\n\tsb->s_d_op = &kernfs_dops;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_info",
          "args": [
            "sb"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "sb"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sb"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sb"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "kernfs_test_super",
            "kernfs_set_super",
            "flags",
            "info"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*info)",
            "GFP_KERNEL"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,\n\t\t\t\tstruct kernfs_root *root, unsigned long magic,\n\t\t\t\tbool *new_sb_created, const void *ns)\n{\n\tstruct super_block *sb;\n\tstruct kernfs_super_info *info;\n\tint error;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo->root = root;\n\tinfo->ns = ns;\n\n\tsb = sget(fs_type, kernfs_test_super, kernfs_set_super, flags, info);\n\tif (IS_ERR(sb) || sb->s_fs_info != info)\n\t\tkfree(info);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (new_sb_created)\n\t\t*new_sb_created = !sb->s_root;\n\n\tif (!sb->s_root) {\n\t\tstruct kernfs_super_info *info = kernfs_info(sb);\n\n\t\terror = kernfs_fill_super(sb, magic);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t\tsb->s_flags |= MS_ACTIVE;\n\n\t\tmutex_lock(&kernfs_mutex);\n\t\tlist_add(&info->node, &root->supers);\n\t\tmutex_unlock(&kernfs_mutex);\n\t}\n\n\treturn dget(sb->s_root);\n}"
  },
  {
    "function_name": "kernfs_super_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
    "lines": "123-128",
    "snippet": "const void *kernfs_super_ns(struct super_block *sb)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\n\treturn info->ns;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_info",
          "args": [
            "sb"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nconst void *kernfs_super_ns(struct super_block *sb)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\n\treturn info->ns;\n}"
  },
  {
    "function_name": "kernfs_set_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
    "lines": "108-115",
    "snippet": "static int kernfs_set_super(struct super_block *sb, void *data)\n{\n\tint error;\n\terror = set_anon_super(sb, data);\n\tif (!error)\n\t\tsb->s_fs_info = data;\n\treturn error;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_anon_super",
          "args": [
            "sb",
            "data"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int kernfs_set_super(struct super_block *sb, void *data)\n{\n\tint error;\n\terror = set_anon_super(sb, data);\n\tif (!error)\n\t\tsb->s_fs_info = data;\n\treturn error;\n}"
  },
  {
    "function_name": "kernfs_test_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
    "lines": "100-106",
    "snippet": "static int kernfs_test_super(struct super_block *sb, void *data)\n{\n\tstruct kernfs_super_info *sb_info = kernfs_info(sb);\n\tstruct kernfs_super_info *info = data;\n\n\treturn sb_info->root == info->root && sb_info->ns == info->ns;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_info",
          "args": [
            "sb"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int kernfs_test_super(struct super_block *sb, void *data)\n{\n\tstruct kernfs_super_info *sb_info = kernfs_info(sb);\n\tstruct kernfs_super_info *info = data;\n\n\treturn sb_info->root == info->root && sb_info->ns == info->ns;\n}"
  },
  {
    "function_name": "kernfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
    "lines": "65-98",
    "snippet": "static int kernfs_fill_super(struct super_block *sb, unsigned long magic)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\tstruct inode *inode;\n\tstruct dentry *root;\n\n\tinfo->sb = sb;\n\tsb->s_blocksize = PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\tsb->s_magic = magic;\n\tsb->s_op = &kernfs_sops;\n\tsb->s_time_gran = 1;\n\n\t/* get root inode, initialize and unlock it */\n\tmutex_lock(&kernfs_mutex);\n\tinode = kernfs_get_inode(sb, info->root->kn);\n\tmutex_unlock(&kernfs_mutex);\n\tif (!inode) {\n\t\tpr_debug(\"kernfs: could not get root inode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* instantiate and link root dentry */\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tpr_debug(\"%s: could not get root dentry!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tkernfs_get(info->root->kn);\n\troot->d_fsdata = info->root->kn;\n\tsb->s_root = root;\n\tsb->s_d_op = &kernfs_dops;\n\treturn 0;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct super_operations kernfs_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= kernfs_evict_inode,\n\n\t.remount_fs\t= kernfs_sop_remount_fs,\n\t.show_options\t= kernfs_sop_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "info->root->kn"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: could not get root dentry!\\n\"",
            "__func__"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"kernfs: could not get root inode\\n\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_inode",
          "args": [
            "sb",
            "info->root->kn"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "329-338",
          "snippet": "struct inode *kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, kn->ino);\n\tif (inode && (inode->i_state & I_NEW))\n\t\tkernfs_init_inode(kn, inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstruct inode *kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, kn->ino);\n\tif (inode && (inode->i_state & I_NEW))\n\t\tkernfs_init_inode(kn, inode);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_info",
          "args": [
            "sb"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nconst struct super_operations kernfs_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= kernfs_evict_inode,\n\n\t.remount_fs\t= kernfs_sop_remount_fs,\n\t.show_options\t= kernfs_sop_show_options,\n};\n\nstatic int kernfs_fill_super(struct super_block *sb, unsigned long magic)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\tstruct inode *inode;\n\tstruct dentry *root;\n\n\tinfo->sb = sb;\n\tsb->s_blocksize = PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\tsb->s_magic = magic;\n\tsb->s_op = &kernfs_sops;\n\tsb->s_time_gran = 1;\n\n\t/* get root inode, initialize and unlock it */\n\tmutex_lock(&kernfs_mutex);\n\tinode = kernfs_get_inode(sb, info->root->kn);\n\tmutex_unlock(&kernfs_mutex);\n\tif (!inode) {\n\t\tpr_debug(\"kernfs: could not get root inode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* instantiate and link root dentry */\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tpr_debug(\"%s: could not get root dentry!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tkernfs_get(info->root->kn);\n\troot->d_fsdata = info->root->kn;\n\tsb->s_root = root;\n\tsb->s_d_op = &kernfs_dops;\n\treturn 0;\n}"
  },
  {
    "function_name": "kernfs_root_from_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
    "lines": "58-63",
    "snippet": "struct kernfs_root *kernfs_root_from_sb(struct super_block *sb)\n{\n\tif (sb->s_op == &kernfs_sops)\n\t\treturn kernfs_info(sb)->root;\n\treturn NULL;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct super_operations kernfs_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= kernfs_evict_inode,\n\n\t.remount_fs\t= kernfs_sop_remount_fs,\n\t.show_options\t= kernfs_sop_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_info",
          "args": [
            "sb"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nconst struct super_operations kernfs_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= kernfs_evict_inode,\n\n\t.remount_fs\t= kernfs_sop_remount_fs,\n\t.show_options\t= kernfs_sop_show_options,\n};\n\nstruct kernfs_root *kernfs_root_from_sb(struct super_block *sb)\n{\n\tif (sb->s_op == &kernfs_sops)\n\t\treturn kernfs_info(sb)->root;\n\treturn NULL;\n}"
  },
  {
    "function_name": "kernfs_sop_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
    "lines": "32-40",
    "snippet": "static int kernfs_sop_show_options(struct seq_file *sf, struct dentry *dentry)\n{\n\tstruct kernfs_root *root = kernfs_root(dentry->d_fsdata);\n\tstruct kernfs_syscall_ops *scops = root->syscall_ops;\n\n\tif (scops && scops->show_options)\n\t\treturn scops->show_options(sf, root);\n\treturn 0;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scops->show_options",
          "args": [
            "sf",
            "root"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_root",
          "args": [
            "dentry->d_fsdata"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_root_from_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
          "lines": "58-63",
          "snippet": "struct kernfs_root *kernfs_root_from_sb(struct super_block *sb)\n{\n\tif (sb->s_op == &kernfs_sops)\n\t\treturn kernfs_info(sb)->root;\n\treturn NULL;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct super_operations kernfs_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= kernfs_evict_inode,\n\n\t.remount_fs\t= kernfs_sop_remount_fs,\n\t.show_options\t= kernfs_sop_show_options,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nconst struct super_operations kernfs_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= kernfs_evict_inode,\n\n\t.remount_fs\t= kernfs_sop_remount_fs,\n\t.show_options\t= kernfs_sop_show_options,\n};\n\nstruct kernfs_root *kernfs_root_from_sb(struct super_block *sb)\n{\n\tif (sb->s_op == &kernfs_sops)\n\t\treturn kernfs_info(sb)->root;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int kernfs_sop_show_options(struct seq_file *sf, struct dentry *dentry)\n{\n\tstruct kernfs_root *root = kernfs_root(dentry->d_fsdata);\n\tstruct kernfs_syscall_ops *scops = root->syscall_ops;\n\n\tif (scops && scops->show_options)\n\t\treturn scops->show_options(sf, root);\n\treturn 0;\n}"
  },
  {
    "function_name": "kernfs_sop_remount_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
    "lines": "22-30",
    "snippet": "static int kernfs_sop_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct kernfs_root *root = kernfs_info(sb)->root;\n\tstruct kernfs_syscall_ops *scops = root->syscall_ops;\n\n\tif (scops && scops->remount_fs)\n\t\treturn scops->remount_fs(root, flags, data);\n\treturn 0;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scops->remount_fs",
          "args": [
            "root",
            "flags",
            "data"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_info",
          "args": [
            "sb"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int kernfs_sop_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct kernfs_root *root = kernfs_info(sb)->root;\n\tstruct kernfs_syscall_ops *scops = root->syscall_ops;\n\n\tif (scops && scops->remount_fs)\n\t\treturn scops->remount_fs(root, flags, data);\n\treturn 0;\n}"
  }
]