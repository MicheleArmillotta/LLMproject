[
  {
    "function_name": "init_ramfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
    "lines": "258-265",
    "snippet": "int __init init_ramfs_fs(void)\n{\n\tstatic unsigned long once;\n\n\tif (test_and_set_bit(0, &once))\n\t\treturn 0;\n\treturn register_filesystem(&ramfs_fs_type);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ramfs_fs_type = {\n\t.name\t\t= \"ramfs\",\n\t.mount\t\t= ramfs_mount,\n\t.kill_sb\t= ramfs_kill_sb,\n\t.fs_flags\t= FS_USERNS_MOUNT,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&ramfs_fs_type"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "0",
            "&once"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct file_system_type ramfs_fs_type = {\n\t.name\t\t= \"ramfs\",\n\t.mount\t\t= ramfs_mount,\n\t.kill_sb\t= ramfs_kill_sb,\n\t.fs_flags\t= FS_USERNS_MOUNT,\n};\n\nint __init init_ramfs_fs(void)\n{\n\tstatic unsigned long once;\n\n\tif (test_and_set_bit(0, &once))\n\t\treturn 0;\n\treturn register_filesystem(&ramfs_fs_type);\n}"
  },
  {
    "function_name": "ramfs_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
    "lines": "245-249",
    "snippet": "static void ramfs_kill_sb(struct super_block *sb)\n{\n\tkfree(sb->s_fs_info);\n\tkill_litter_super(sb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_litter_super",
          "args": [
            "sb"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sb->s_fs_info"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void ramfs_kill_sb(struct super_block *sb)\n{\n\tkfree(sb->s_fs_info);\n\tkill_litter_super(sb);\n}"
  },
  {
    "function_name": "ramfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
    "lines": "239-243",
    "snippet": "struct dentry *ramfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_nodev(fs_type, flags, data, ramfs_fill_super);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_nodev",
          "args": [
            "fs_type",
            "flags",
            "data",
            "ramfs_fill_super"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstruct dentry *ramfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_nodev(fs_type, flags, data, ramfs_fill_super);\n}"
  },
  {
    "function_name": "ramfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
    "lines": "207-237",
    "snippet": "int ramfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct ramfs_fs_info *fsi;\n\tstruct inode *inode;\n\tint err;\n\n\tsave_mount_options(sb, data);\n\n\tfsi = kzalloc(sizeof(struct ramfs_fs_info), GFP_KERNEL);\n\tsb->s_fs_info = fsi;\n\tif (!fsi)\n\t\treturn -ENOMEM;\n\n\terr = ramfs_parse_options(data, &fsi->mount_opts);\n\tif (err)\n\t\treturn err;\n\n\tsb->s_maxbytes\t\t= MAX_LFS_FILESIZE;\n\tsb->s_blocksize\t\t= PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits\t= PAGE_CACHE_SHIFT;\n\tsb->s_magic\t\t= RAMFS_MAGIC;\n\tsb->s_op\t\t= &ramfs_ops;\n\tsb->s_time_gran\t\t= 1;\n\n\tinode = ramfs_get_inode(sb, NULL, S_IFDIR | fsi->mount_opts.mode, 0);\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations ramfs_ops;",
      "static const struct super_operations ramfs_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.show_options\t= generic_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ramfs_get_inode",
          "args": [
            "sb",
            "NULL",
            "S_IFDIR | fsi->mount_opts.mode",
            "0"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "ramfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
          "lines": "53-86",
          "snippet": "struct inode *ramfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tinode->i_mapping->a_ops = &ramfs_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);\n\t\tmapping_set_unevictable(inode->i_mapping);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &ramfs_file_inode_operations;\n\t\t\tinode->i_fop = &ramfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &ramfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations ramfs_dir_inode_operations;",
            "static const struct address_space_operations ramfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n\t.set_page_dirty\t= __set_page_dirty_no_writeback,\n};",
            "static const struct inode_operations ramfs_dir_inode_operations = {\n\t.create\t\t= ramfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= ramfs_symlink,\n\t.mkdir\t\t= ramfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= ramfs_mknod,\n\t.rename\t\t= simple_rename,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations ramfs_dir_inode_operations;\nstatic const struct address_space_operations ramfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n\t.set_page_dirty\t= __set_page_dirty_no_writeback,\n};\nstatic const struct inode_operations ramfs_dir_inode_operations = {\n\t.create\t\t= ramfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= ramfs_symlink,\n\t.mkdir\t\t= ramfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= ramfs_mknod,\n\t.rename\t\t= simple_rename,\n};\n\nstruct inode *ramfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tinode->i_mapping->a_ops = &ramfs_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);\n\t\tmapping_set_unevictable(inode->i_mapping);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &ramfs_file_inode_operations;\n\t\t\tinode->i_fop = &ramfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &ramfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ramfs_parse_options",
          "args": [
            "data",
            "&fsi->mount_opts"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "ramfs_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
          "lines": "175-205",
          "snippet": "static int ramfs_parse_options(char *data, struct ramfs_mount_opts *opts)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint token;\n\tchar *p;\n\n\topts->mode = RAMFS_DEFAULT_MODE;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\t/*\n\t\t * We might like to report bad mount options here;\n\t\t * but traditionally ramfs has ignored all mount options,\n\t\t * and as it is used as a !CONFIG_SHMEM simple substitute\n\t\t * for tmpfs, better continue to ignore other mount options.\n\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RAMFS_DEFAULT_MODE\t0755"
          ],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define RAMFS_DEFAULT_MODE\t0755\n\nstatic const match_table_t tokens = {\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ramfs_parse_options(char *data, struct ramfs_mount_opts *opts)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint token;\n\tchar *p;\n\n\topts->mode = RAMFS_DEFAULT_MODE;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\t/*\n\t\t * We might like to report bad mount options here;\n\t\t * but traditionally ramfs has ignored all mount options,\n\t\t * and as it is used as a !CONFIG_SHMEM simple substitute\n\t\t * for tmpfs, better continue to ignore other mount options.\n\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ramfs_fs_info)",
            "GFP_KERNEL"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_mount_options",
          "args": [
            "sb",
            "data"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "save_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1189-1193",
          "snippet": "void save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic const struct super_operations ramfs_ops;\nstatic const struct super_operations ramfs_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.show_options\t= generic_show_options,\n};\n\nint ramfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct ramfs_fs_info *fsi;\n\tstruct inode *inode;\n\tint err;\n\n\tsave_mount_options(sb, data);\n\n\tfsi = kzalloc(sizeof(struct ramfs_fs_info), GFP_KERNEL);\n\tsb->s_fs_info = fsi;\n\tif (!fsi)\n\t\treturn -ENOMEM;\n\n\terr = ramfs_parse_options(data, &fsi->mount_opts);\n\tif (err)\n\t\treturn err;\n\n\tsb->s_maxbytes\t\t= MAX_LFS_FILESIZE;\n\tsb->s_blocksize\t\t= PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits\t= PAGE_CACHE_SHIFT;\n\tsb->s_magic\t\t= RAMFS_MAGIC;\n\tsb->s_op\t\t= &ramfs_ops;\n\tsb->s_time_gran\t\t= 1;\n\n\tinode = ramfs_get_inode(sb, NULL, S_IFDIR | fsi->mount_opts.mode, 0);\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ramfs_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
    "lines": "175-205",
    "snippet": "static int ramfs_parse_options(char *data, struct ramfs_mount_opts *opts)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint token;\n\tchar *p;\n\n\topts->mode = RAMFS_DEFAULT_MODE;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\t/*\n\t\t * We might like to report bad mount options here;\n\t\t * but traditionally ramfs has ignored all mount options,\n\t\t * and as it is used as a !CONFIG_SHMEM simple substitute\n\t\t * for tmpfs, better continue to ignore other mount options.\n\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define RAMFS_DEFAULT_MODE\t0755"
    ],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&data",
            "\",\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define RAMFS_DEFAULT_MODE\t0755\n\nstatic const match_table_t tokens = {\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ramfs_parse_options(char *data, struct ramfs_mount_opts *opts)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint token;\n\tchar *p;\n\n\topts->mode = RAMFS_DEFAULT_MODE;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\t/*\n\t\t * We might like to report bad mount options here;\n\t\t * but traditionally ramfs has ignored all mount options,\n\t\t * and as it is used as a !CONFIG_SHMEM simple substitute\n\t\t * for tmpfs, better continue to ignore other mount options.\n\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ramfs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
    "lines": "120-137",
    "snippet": "static int ramfs_symlink(struct inode * dir, struct dentry *dentry, const char * symname)\n{\n\tstruct inode *inode;\n\tint error = -ENOSPC;\n\n\tinode = ramfs_get_inode(dir->i_sb, dir, S_IFLNK|S_IRWXUGO, 0);\n\tif (inode) {\n\t\tint l = strlen(symname)+1;\n\t\terror = page_symlink(inode, symname, l);\n\t\tif (!error) {\n\t\t\td_instantiate(dentry, inode);\n\t\t\tdget(dentry);\n\t\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t\t} else\n\t\t\tiput(inode);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_symlink",
          "args": [
            "inode",
            "symname",
            "l"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "page_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4532-4536",
          "snippet": "int page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ramfs_get_inode",
          "args": [
            "dir->i_sb",
            "dir",
            "S_IFLNK|S_IRWXUGO",
            "0"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "ramfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
          "lines": "53-86",
          "snippet": "struct inode *ramfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tinode->i_mapping->a_ops = &ramfs_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);\n\t\tmapping_set_unevictable(inode->i_mapping);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &ramfs_file_inode_operations;\n\t\t\tinode->i_fop = &ramfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &ramfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations ramfs_dir_inode_operations;",
            "static const struct address_space_operations ramfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n\t.set_page_dirty\t= __set_page_dirty_no_writeback,\n};",
            "static const struct inode_operations ramfs_dir_inode_operations = {\n\t.create\t\t= ramfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= ramfs_symlink,\n\t.mkdir\t\t= ramfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= ramfs_mknod,\n\t.rename\t\t= simple_rename,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations ramfs_dir_inode_operations;\nstatic const struct address_space_operations ramfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n\t.set_page_dirty\t= __set_page_dirty_no_writeback,\n};\nstatic const struct inode_operations ramfs_dir_inode_operations = {\n\t.create\t\t= ramfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= ramfs_symlink,\n\t.mkdir\t\t= ramfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= ramfs_mknod,\n\t.rename\t\t= simple_rename,\n};\n\nstruct inode *ramfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tinode->i_mapping->a_ops = &ramfs_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);\n\t\tmapping_set_unevictable(inode->i_mapping);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &ramfs_file_inode_operations;\n\t\t\tinode->i_fop = &ramfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &ramfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ramfs_symlink(struct inode * dir, struct dentry *dentry, const char * symname)\n{\n\tstruct inode *inode;\n\tint error = -ENOSPC;\n\n\tinode = ramfs_get_inode(dir->i_sb, dir, S_IFLNK|S_IRWXUGO, 0);\n\tif (inode) {\n\t\tint l = strlen(symname)+1;\n\t\terror = page_symlink(inode, symname, l);\n\t\tif (!error) {\n\t\t\td_instantiate(dentry, inode);\n\t\t\tdget(dentry);\n\t\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t\t} else\n\t\t\tiput(inode);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "ramfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
    "lines": "115-118",
    "snippet": "static int ramfs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)\n{\n\treturn ramfs_mknod(dir, dentry, mode | S_IFREG, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ramfs_mknod",
          "args": [
            "dir",
            "dentry",
            "mode | S_IFREG",
            "0"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ramfs_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
          "lines": "92-105",
          "snippet": "static int\nramfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = ramfs_get_inode(dir->i_sb, dir, mode, dev);\n\tint error = -ENOSPC;\n\n\tif (inode) {\n\t\td_instantiate(dentry, inode);\n\t\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\t\terror = 0;\n\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int\nramfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = ramfs_get_inode(dir->i_sb, dir, mode, dev);\n\tint error = -ENOSPC;\n\n\tif (inode) {\n\t\td_instantiate(dentry, inode);\n\t\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\t\terror = 0;\n\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ramfs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)\n{\n\treturn ramfs_mknod(dir, dentry, mode | S_IFREG, 0);\n}"
  },
  {
    "function_name": "ramfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
    "lines": "107-113",
    "snippet": "static int ramfs_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)\n{\n\tint retval = ramfs_mknod(dir, dentry, mode | S_IFDIR, 0);\n\tif (!retval)\n\t\tinc_nlink(dir);\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ramfs_mknod",
          "args": [
            "dir",
            "dentry",
            "mode | S_IFDIR",
            "0"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "ramfs_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
          "lines": "92-105",
          "snippet": "static int\nramfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = ramfs_get_inode(dir->i_sb, dir, mode, dev);\n\tint error = -ENOSPC;\n\n\tif (inode) {\n\t\td_instantiate(dentry, inode);\n\t\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\t\terror = 0;\n\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int\nramfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = ramfs_get_inode(dir->i_sb, dir, mode, dev);\n\tint error = -ENOSPC;\n\n\tif (inode) {\n\t\td_instantiate(dentry, inode);\n\t\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\t\terror = 0;\n\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ramfs_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)\n{\n\tint retval = ramfs_mknod(dir, dentry, mode | S_IFDIR, 0);\n\tif (!retval)\n\t\tinc_nlink(dir);\n\treturn retval;\n}"
  },
  {
    "function_name": "ramfs_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
    "lines": "92-105",
    "snippet": "static int\nramfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = ramfs_get_inode(dir->i_sb, dir, mode, dev);\n\tint error = -ENOSPC;\n\n\tif (inode) {\n\t\td_instantiate(dentry, inode);\n\t\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\t\terror = 0;\n\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ramfs_get_inode",
          "args": [
            "dir->i_sb",
            "dir",
            "mode",
            "dev"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "ramfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
          "lines": "53-86",
          "snippet": "struct inode *ramfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tinode->i_mapping->a_ops = &ramfs_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);\n\t\tmapping_set_unevictable(inode->i_mapping);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &ramfs_file_inode_operations;\n\t\t\tinode->i_fop = &ramfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &ramfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations ramfs_dir_inode_operations;",
            "static const struct address_space_operations ramfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n\t.set_page_dirty\t= __set_page_dirty_no_writeback,\n};",
            "static const struct inode_operations ramfs_dir_inode_operations = {\n\t.create\t\t= ramfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= ramfs_symlink,\n\t.mkdir\t\t= ramfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= ramfs_mknod,\n\t.rename\t\t= simple_rename,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations ramfs_dir_inode_operations;\nstatic const struct address_space_operations ramfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n\t.set_page_dirty\t= __set_page_dirty_no_writeback,\n};\nstatic const struct inode_operations ramfs_dir_inode_operations = {\n\t.create\t\t= ramfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= ramfs_symlink,\n\t.mkdir\t\t= ramfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= ramfs_mknod,\n\t.rename\t\t= simple_rename,\n};\n\nstruct inode *ramfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tinode->i_mapping->a_ops = &ramfs_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);\n\t\tmapping_set_unevictable(inode->i_mapping);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &ramfs_file_inode_operations;\n\t\t\tinode->i_fop = &ramfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &ramfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int\nramfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = ramfs_get_inode(dir->i_sb, dir, mode, dev);\n\tint error = -ENOSPC;\n\n\tif (inode) {\n\t\td_instantiate(dentry, inode);\n\t\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\t\terror = 0;\n\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "ramfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/inode.c",
    "lines": "53-86",
    "snippet": "struct inode *ramfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tinode->i_mapping->a_ops = &ramfs_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);\n\t\tmapping_set_unevictable(inode->i_mapping);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &ramfs_file_inode_operations;\n\t\t\tinode->i_fop = &ramfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &ramfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations ramfs_dir_inode_operations;",
      "static const struct address_space_operations ramfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n\t.set_page_dirty\t= __set_page_dirty_no_writeback,\n};",
      "static const struct inode_operations ramfs_dir_inode_operations = {\n\t.create\t\t= ramfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= ramfs_symlink,\n\t.mkdir\t\t= ramfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= ramfs_mknod,\n\t.rename\t\t= simple_rename,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "mode",
            "dev"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_unevictable",
          "args": [
            "inode->i_mapping"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "inode->i_mapping",
            "GFP_HIGHUSER"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations ramfs_dir_inode_operations;\nstatic const struct address_space_operations ramfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n\t.set_page_dirty\t= __set_page_dirty_no_writeback,\n};\nstatic const struct inode_operations ramfs_dir_inode_operations = {\n\t.create\t\t= ramfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= ramfs_symlink,\n\t.mkdir\t\t= ramfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= ramfs_mknod,\n\t.rename\t\t= simple_rename,\n};\n\nstruct inode *ramfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tinode->i_mapping->a_ops = &ramfs_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);\n\t\tmapping_set_unevictable(inode->i_mapping);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &ramfs_file_inode_operations;\n\t\t\tinode->i_fop = &ramfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &ramfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}"
  }
]