[
  {
    "function_name": "xfs_do_force_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
    "lines": "802-854",
    "snippet": "void\nxfs_do_force_shutdown(\n\txfs_mount_t\t*mp,\n\tint\t\tflags,\n\tchar\t\t*fname,\n\tint\t\tlnnum)\n{\n\tint\t\tlogerror;\n\n\tlogerror = flags & SHUTDOWN_LOG_IO_ERROR;\n\n\tif (!(flags & SHUTDOWN_FORCE_UMOUNT)) {\n\t\txfs_notice(mp,\n\t\"%s(0x%x) called from line %d of file %s.  Return address = 0x%p\",\n\t\t\t__func__, flags, lnnum, fname, __return_address);\n\t}\n\t/*\n\t * No need to duplicate efforts.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp) && !logerror)\n\t\treturn;\n\n\t/*\n\t * This flags XFS_MOUNT_FS_SHUTDOWN, makes sure that we don't\n\t * queue up anybody new on the log reservations, and wakes up\n\t * everybody who's sleeping on log reservations to tell them\n\t * the bad news.\n\t */\n\tif (xfs_log_force_umount(mp, logerror))\n\t\treturn;\n\n\tif (flags & SHUTDOWN_CORRUPT_INCORE) {\n\t\txfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_CORRUPT,\n    \"Corruption of in-memory data detected.  Shutting down filesystem\");\n\t\tif (XFS_ERRLEVEL_HIGH <= xfs_error_level)\n\t\t\txfs_stack_trace();\n\t} else if (!(flags & SHUTDOWN_FORCE_UMOUNT)) {\n\t\tif (logerror) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_LOGERROR,\n\t\t\"Log I/O Error Detected.  Shutting down filesystem\");\n\t\t} else if (flags & SHUTDOWN_DEVICE_REQ) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_IOERROR,\n\t\t\"All device paths lost.  Shutting down filesystem\");\n\t\t} else if (!(flags & SHUTDOWN_REMOTE_REQ)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_IOERROR,\n\t\t\"I/O Error Detected. Shutting down filesystem\");\n\t\t}\n\t}\n\tif (!(flags & SHUTDOWN_FORCE_UMOUNT)) {\n\t\txfs_alert(mp,\n\t\"Please umount the filesystem and rectify the problem(s)\");\n\t}\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"Please umount the filesystem and rectify the problem(s)\""
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_fsblock_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iomap.c",
          "lines": "95-110",
          "snippet": "STATIC int\nxfs_alert_fsblock_zero(\n\txfs_inode_t\t*ip,\n\txfs_bmbt_irec_t\t*imap)\n{\n\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\"blkcnt: %llx extent-state: %x\",\n\t\t(unsigned long long)ip->i_ino,\n\t\t(unsigned long long)imap->br_startblock,\n\t\t(unsigned long long)imap->br_startoff,\n\t\t(unsigned long long)imap->br_blockcount,\n\t\timap->br_state);\n\treturn -EFSCORRUPTED;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_alert_fsblock_zero(\n\txfs_inode_t\t*ip,\n\txfs_bmbt_irec_t\t*imap)\n{\n\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\"blkcnt: %llx extent-state: %x\",\n\t\t(unsigned long long)ip->i_ino,\n\t\t(unsigned long long)imap->br_startblock,\n\t\t(unsigned long long)imap->br_startoff,\n\t\t(unsigned long long)imap->br_blockcount,\n\t\timap->br_state);\n\treturn -EFSCORRUPTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alert_tag",
          "args": [
            "mp",
            "XFS_PTAG_SHUTDOWN_IOERROR",
            "\"I/O Error Detected. Shutting down filesystem\""
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_stack_trace",
          "args": [],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_force_umount",
          "args": [
            "mp",
            "logerror"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"%s(0x%x) called from line %d of file %s.  Return address = 0x%p\"",
            "__func__",
            "flags",
            "lnnum",
            "fname",
            "__return_address"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_do_force_shutdown(\n\txfs_mount_t\t*mp,\n\tint\t\tflags,\n\tchar\t\t*fname,\n\tint\t\tlnnum)\n{\n\tint\t\tlogerror;\n\n\tlogerror = flags & SHUTDOWN_LOG_IO_ERROR;\n\n\tif (!(flags & SHUTDOWN_FORCE_UMOUNT)) {\n\t\txfs_notice(mp,\n\t\"%s(0x%x) called from line %d of file %s.  Return address = 0x%p\",\n\t\t\t__func__, flags, lnnum, fname, __return_address);\n\t}\n\t/*\n\t * No need to duplicate efforts.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp) && !logerror)\n\t\treturn;\n\n\t/*\n\t * This flags XFS_MOUNT_FS_SHUTDOWN, makes sure that we don't\n\t * queue up anybody new on the log reservations, and wakes up\n\t * everybody who's sleeping on log reservations to tell them\n\t * the bad news.\n\t */\n\tif (xfs_log_force_umount(mp, logerror))\n\t\treturn;\n\n\tif (flags & SHUTDOWN_CORRUPT_INCORE) {\n\t\txfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_CORRUPT,\n    \"Corruption of in-memory data detected.  Shutting down filesystem\");\n\t\tif (XFS_ERRLEVEL_HIGH <= xfs_error_level)\n\t\t\txfs_stack_trace();\n\t} else if (!(flags & SHUTDOWN_FORCE_UMOUNT)) {\n\t\tif (logerror) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_LOGERROR,\n\t\t\"Log I/O Error Detected.  Shutting down filesystem\");\n\t\t} else if (flags & SHUTDOWN_DEVICE_REQ) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_IOERROR,\n\t\t\"All device paths lost.  Shutting down filesystem\");\n\t\t} else if (!(flags & SHUTDOWN_REMOTE_REQ)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_IOERROR,\n\t\t\"I/O Error Detected. Shutting down filesystem\");\n\t\t}\n\t}\n\tif (!(flags & SHUTDOWN_FORCE_UMOUNT)) {\n\t\txfs_alert(mp,\n\t\"Please umount the filesystem and rectify the problem(s)\");\n\t}\n}"
  },
  {
    "function_name": "xfs_fs_goingdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
    "lines": "766-794",
    "snippet": "int\nxfs_fs_goingdown(\n\txfs_mount_t\t*mp,\n\t__uint32_t\tinflags)\n{\n\tswitch (inflags) {\n\tcase XFS_FSOP_GOING_FLAGS_DEFAULT: {\n\t\tstruct super_block *sb = freeze_bdev(mp->m_super->s_bdev);\n\n\t\tif (sb && !IS_ERR(sb)) {\n\t\t\txfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\n\t\t\tthaw_bdev(sb->s_bdev, sb);\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase XFS_FSOP_GOING_FLAGS_LOGFLUSH:\n\t\txfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\n\t\tbreak;\n\tcase XFS_FSOP_GOING_FLAGS_NOLOGFLUSH:\n\t\txfs_force_shutdown(mp,\n\t\t\t\tSHUTDOWN_FORCE_UMOUNT | SHUTDOWN_LOG_IO_ERROR);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "SHUTDOWN_FORCE_UMOUNT | SHUTDOWN_LOG_IO_ERROR"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "SHUTDOWN_FORCE_UMOUNT"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thaw_bdev",
          "args": [
            "sb->s_bdev",
            "sb"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "255-282",
          "snippet": "int thaw_bdev(struct block_device *bdev, struct super_block *sb)\n{\n\tint error = -EINVAL;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (!bdev->bd_fsfreeze_count)\n\t\tgoto out;\n\n\terror = 0;\n\tif (--bdev->bd_fsfreeze_count > 0)\n\t\tgoto out;\n\n\tif (!sb)\n\t\tgoto out;\n\n\tif (sb->s_op->thaw_super)\n\t\terror = sb->s_op->thaw_super(sb);\n\telse\n\t\terror = thaw_super(sb);\n\tif (error) {\n\t\tbdev->bd_fsfreeze_count++;\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn error;\n\t}\nout:\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint thaw_bdev(struct block_device *bdev, struct super_block *sb)\n{\n\tint error = -EINVAL;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (!bdev->bd_fsfreeze_count)\n\t\tgoto out;\n\n\terror = 0;\n\tif (--bdev->bd_fsfreeze_count > 0)\n\t\tgoto out;\n\n\tif (!sb)\n\t\tgoto out;\n\n\tif (sb->s_op->thaw_super)\n\t\terror = sb->s_op->thaw_super(sb);\n\telse\n\t\terror = thaw_super(sb);\n\tif (error) {\n\t\tbdev->bd_fsfreeze_count++;\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn error;\n\t}\nout:\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "SHUTDOWN_FORCE_UMOUNT"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sb"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeze_bdev",
          "args": [
            "mp->m_super->s_bdev"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "freeze_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "209-245",
          "snippet": "struct super_block *freeze_bdev(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\tint error = 0;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (++bdev->bd_fsfreeze_count > 1) {\n\t\t/*\n\t\t * We don't even need to grab a reference - the first call\n\t\t * to freeze_bdev grab an active reference and only the last\n\t\t * thaw_bdev drops it.\n\t\t */\n\t\tsb = get_super(bdev);\n\t\tdrop_super(sb);\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn sb;\n\t}\n\n\tsb = get_active_super(bdev);\n\tif (!sb)\n\t\tgoto out;\n\tif (sb->s_op->freeze_super)\n\t\terror = sb->s_op->freeze_super(sb);\n\telse\n\t\terror = freeze_super(sb);\n\tif (error) {\n\t\tdeactivate_super(sb);\n\t\tbdev->bd_fsfreeze_count--;\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn ERR_PTR(error);\n\t}\n\tdeactivate_super(sb);\n out:\n\tsync_blockdev(bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn sb;\t/* thaw_bdev releases s->s_umount */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct super_block *freeze_bdev(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\tint error = 0;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (++bdev->bd_fsfreeze_count > 1) {\n\t\t/*\n\t\t * We don't even need to grab a reference - the first call\n\t\t * to freeze_bdev grab an active reference and only the last\n\t\t * thaw_bdev drops it.\n\t\t */\n\t\tsb = get_super(bdev);\n\t\tdrop_super(sb);\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn sb;\n\t}\n\n\tsb = get_active_super(bdev);\n\tif (!sb)\n\t\tgoto out;\n\tif (sb->s_op->freeze_super)\n\t\terror = sb->s_op->freeze_super(sb);\n\telse\n\t\terror = freeze_super(sb);\n\tif (error) {\n\t\tdeactivate_super(sb);\n\t\tbdev->bd_fsfreeze_count--;\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn ERR_PTR(error);\n\t}\n\tdeactivate_super(sb);\n out:\n\tsync_blockdev(bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn sb;\t/* thaw_bdev releases s->s_umount */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_fs_goingdown(\n\txfs_mount_t\t*mp,\n\t__uint32_t\tinflags)\n{\n\tswitch (inflags) {\n\tcase XFS_FSOP_GOING_FLAGS_DEFAULT: {\n\t\tstruct super_block *sb = freeze_bdev(mp->m_super->s_bdev);\n\n\t\tif (sb && !IS_ERR(sb)) {\n\t\t\txfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\n\t\t\tthaw_bdev(sb->s_bdev, sb);\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase XFS_FSOP_GOING_FLAGS_LOGFLUSH:\n\t\txfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\n\t\tbreak;\n\tcase XFS_FSOP_GOING_FLAGS_NOLOGFLUSH:\n\t\txfs_force_shutdown(mp,\n\t\t\t\tSHUTDOWN_FORCE_UMOUNT | SHUTDOWN_LOG_IO_ERROR);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_reserve_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
    "lines": "665-764",
    "snippet": "int\nxfs_reserve_blocks(\n\txfs_mount_t             *mp,\n\t__uint64_t              *inval,\n\txfs_fsop_resblks_t      *outval)\n{\n\t__int64_t\t\tlcounter, delta, fdblks_delta;\n\t__uint64_t\t\trequest;\n\n\t/* If inval is null, report current values and return */\n\tif (inval == (__uint64_t *)NULL) {\n\t\tif (!outval)\n\t\t\treturn -EINVAL;\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t\treturn 0;\n\t}\n\n\trequest = *inval;\n\n\t/*\n\t * With per-cpu counters, this becomes an interesting\n\t * problem. we needto work out if we are freeing or allocation\n\t * blocks first, then we can do the modification as necessary.\n\t *\n\t * We do this under the m_sb_lock so that if we are near\n\t * ENOSPC, we will hold out any changes while we work out\n\t * what to do. This means that the amount of free space can\n\t * change while we do this, so we need to retry if we end up\n\t * trying to reserve more space than is available.\n\t *\n\t * We also use the xfs_mod_incore_sb() interface so that we\n\t * don't have to care about whether per cpu counter are\n\t * enabled, disabled or even compiled in....\n\t */\nretry:\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, 0);\n\n\t/*\n\t * If our previous reservation was larger than the current value,\n\t * then move any unused blocks back to the free pool.\n\t */\n\tfdblks_delta = 0;\n\tif (mp->m_resblks > request) {\n\t\tlcounter = mp->m_resblks_avail - request;\n\t\tif (lcounter  > 0) {\t\t/* release unused blocks */\n\t\t\tfdblks_delta = lcounter;\n\t\t\tmp->m_resblks_avail -= lcounter;\n\t\t}\n\t\tmp->m_resblks = request;\n\t} else {\n\t\t__int64_t\tfree;\n\n\t\tfree =  mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tif (!free)\n\t\t\tgoto out; /* ENOSPC and fdblks_delta = 0 */\n\n\t\tdelta = request - mp->m_resblks;\n\t\tlcounter = free - delta;\n\t\tif (lcounter < 0) {\n\t\t\t/* We can't satisfy the request, just get what we can */\n\t\t\tmp->m_resblks += free;\n\t\t\tmp->m_resblks_avail += free;\n\t\t\tfdblks_delta = -free;\n\t\t} else {\n\t\t\tfdblks_delta = -delta;\n\t\t\tmp->m_resblks = request;\n\t\t\tmp->m_resblks_avail += delta;\n\t\t}\n\t}\nout:\n\tif (outval) {\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (fdblks_delta) {\n\t\t/*\n\t\t * If we are putting blocks back here, m_resblks_avail is\n\t\t * already at its max so this will put it in the free pool.\n\t\t *\n\t\t * If we need space, we'll either succeed in getting it\n\t\t * from the free block count or we'll get an enospc. If\n\t\t * we get a ENOSPC, it means things changed while we were\n\t\t * calculating fdblks_delta and so we should try again to\n\t\t * see if there is anything left to reserve.\n\t\t *\n\t\t * Don't set the reserved flag here - we don't want to reserve\n\t\t * the extra reserve blocks from the reserve.....\n\t\t */\n\t\tint error;\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t fdblks_delta, 0);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto retry;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_modify_counters",
          "args": [
            "mp",
            "XFS_SBS_FDBLOCKS",
            "fdblks_delta",
            "0"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_modify_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1846-1977",
          "snippet": "int\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ALLOC_SET_ASIDE",
          "args": [
            "mp"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icsb_sync_counters_locked",
          "args": [
            "mp",
            "0"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_sync_counters_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1744-1759",
          "snippet": "void\nxfs_icsb_sync_counters_locked(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\txfs_icsb_cnts_t\tcnt;\n\n\txfs_icsb_count(mp, &cnt, flags);\n\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_ICOUNT))\n\t\tmp->m_sb.sb_icount = cnt.icsb_icount;\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_IFREE))\n\t\tmp->m_sb.sb_ifree = cnt.icsb_ifree;\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_FDBLOCKS))\n\t\tmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_sync_counters_locked(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\txfs_icsb_cnts_t\tcnt;\n\n\txfs_icsb_count(mp, &cnt, flags);\n\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_ICOUNT))\n\t\tmp->m_sb.sb_icount = cnt.icsb_icount;\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_IFREE))\n\t\tmp->m_sb.sb_ifree = cnt.icsb_ifree;\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_FDBLOCKS))\n\t\tmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_reserve_blocks(\n\txfs_mount_t             *mp,\n\t__uint64_t              *inval,\n\txfs_fsop_resblks_t      *outval)\n{\n\t__int64_t\t\tlcounter, delta, fdblks_delta;\n\t__uint64_t\t\trequest;\n\n\t/* If inval is null, report current values and return */\n\tif (inval == (__uint64_t *)NULL) {\n\t\tif (!outval)\n\t\t\treturn -EINVAL;\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t\treturn 0;\n\t}\n\n\trequest = *inval;\n\n\t/*\n\t * With per-cpu counters, this becomes an interesting\n\t * problem. we needto work out if we are freeing or allocation\n\t * blocks first, then we can do the modification as necessary.\n\t *\n\t * We do this under the m_sb_lock so that if we are near\n\t * ENOSPC, we will hold out any changes while we work out\n\t * what to do. This means that the amount of free space can\n\t * change while we do this, so we need to retry if we end up\n\t * trying to reserve more space than is available.\n\t *\n\t * We also use the xfs_mod_incore_sb() interface so that we\n\t * don't have to care about whether per cpu counter are\n\t * enabled, disabled or even compiled in....\n\t */\nretry:\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, 0);\n\n\t/*\n\t * If our previous reservation was larger than the current value,\n\t * then move any unused blocks back to the free pool.\n\t */\n\tfdblks_delta = 0;\n\tif (mp->m_resblks > request) {\n\t\tlcounter = mp->m_resblks_avail - request;\n\t\tif (lcounter  > 0) {\t\t/* release unused blocks */\n\t\t\tfdblks_delta = lcounter;\n\t\t\tmp->m_resblks_avail -= lcounter;\n\t\t}\n\t\tmp->m_resblks = request;\n\t} else {\n\t\t__int64_t\tfree;\n\n\t\tfree =  mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tif (!free)\n\t\t\tgoto out; /* ENOSPC and fdblks_delta = 0 */\n\n\t\tdelta = request - mp->m_resblks;\n\t\tlcounter = free - delta;\n\t\tif (lcounter < 0) {\n\t\t\t/* We can't satisfy the request, just get what we can */\n\t\t\tmp->m_resblks += free;\n\t\t\tmp->m_resblks_avail += free;\n\t\t\tfdblks_delta = -free;\n\t\t} else {\n\t\t\tfdblks_delta = -delta;\n\t\t\tmp->m_resblks = request;\n\t\t\tmp->m_resblks_avail += delta;\n\t\t}\n\t}\nout:\n\tif (outval) {\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (fdblks_delta) {\n\t\t/*\n\t\t * If we are putting blocks back here, m_resblks_avail is\n\t\t * already at its max so this will put it in the free pool.\n\t\t *\n\t\t * If we need space, we'll either succeed in getting it\n\t\t * from the free block count or we'll get an enospc. If\n\t\t * we get a ENOSPC, it means things changed while we were\n\t\t * calculating fdblks_delta and so we should try again to\n\t\t * see if there is anything left to reserve.\n\t\t *\n\t\t * Don't set the reserved flag here - we don't want to reserve\n\t\t * the extra reserve blocks from the reserve.....\n\t\t */\n\t\tint error;\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t fdblks_delta, 0);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto retry;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_fs_counts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
    "lines": "635-648",
    "snippet": "int\nxfs_fs_counts(\n\txfs_mount_t\t\t*mp,\n\txfs_fsop_counts_t\t*cnt)\n{\n\txfs_icsb_sync_counters(mp, XFS_ICSB_LAZY_COUNT);\n\tspin_lock(&mp->m_sb_lock);\n\tcnt->freedata = mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\tcnt->freertx = mp->m_sb.sb_frextents;\n\tcnt->freeino = mp->m_sb.sb_ifree;\n\tcnt->allocino = mp->m_sb.sb_icount;\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ALLOC_SET_ASIDE",
          "args": [
            "mp"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_sync_counters",
          "args": [
            "mp",
            "XFS_ICSB_LAZY_COUNT"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_sync_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1764-1772",
          "snippet": "void\nxfs_icsb_sync_counters(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, flags);\n\tspin_unlock(&mp->m_sb_lock);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_sync_counters(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, flags);\n\tspin_unlock(&mp->m_sb_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_fs_counts(\n\txfs_mount_t\t\t*mp,\n\txfs_fsop_counts_t\t*cnt)\n{\n\txfs_icsb_sync_counters(mp, XFS_ICSB_LAZY_COUNT);\n\tspin_lock(&mp->m_sb_lock);\n\tcnt->freedata = mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\tcnt->freertx = mp->m_sb.sb_frextents;\n\tcnt->freeino = mp->m_sb.sb_ifree;\n\tcnt->allocino = mp->m_sb.sb_icount;\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_growfs_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
    "lines": "615-629",
    "snippet": "int\nxfs_growfs_log(\n\txfs_mount_t\t\t*mp,\n\txfs_growfs_log_t\t*in)\n{\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!mutex_trylock(&mp->m_growlock))\n\t\treturn -EWOULDBLOCK;\n\terror = xfs_growfs_log_private(mp, in);\n\tmutex_unlock(&mp->m_growlock);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mp->m_growlock"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_growfs_log_private",
          "args": [
            "mp",
            "in"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_growfs_log_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "564-584",
          "snippet": "static int\nxfs_growfs_log_private(\n\txfs_mount_t\t\t*mp,\t/* mount point for filesystem */\n\txfs_growfs_log_t\t*in)\t/* growfs log input struct */\n{\n\txfs_extlen_t\t\tnb;\n\n\tnb = in->newblocks;\n\tif (nb < XFS_MIN_LOG_BLOCKS || nb < XFS_B_TO_FSB(mp, XFS_MIN_LOG_BYTES))\n\t\treturn -EINVAL;\n\tif (nb == mp->m_sb.sb_logblocks &&\n\t    in->isint == (mp->m_sb.sb_logstart != 0))\n\t\treturn -EINVAL;\n\t/*\n\t * Moving the log is hard, need new interfaces to sync\n\t * the log first, hold off all activity while moving it.\n\t * Can have shorter or longer log in the same space,\n\t * or transform internal to external log or vice versa.\n\t */\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_growfs_log_private(\n\txfs_mount_t\t\t*mp,\t/* mount point for filesystem */\n\txfs_growfs_log_t\t*in)\t/* growfs log input struct */\n{\n\txfs_extlen_t\t\tnb;\n\n\tnb = in->newblocks;\n\tif (nb < XFS_MIN_LOG_BLOCKS || nb < XFS_B_TO_FSB(mp, XFS_MIN_LOG_BYTES))\n\t\treturn -EINVAL;\n\tif (nb == mp->m_sb.sb_logblocks &&\n\t    in->isint == (mp->m_sb.sb_logstart != 0))\n\t\treturn -EINVAL;\n\t/*\n\t * Moving the log is hard, need new interfaces to sync\n\t * the log first, hold off all activity while moving it.\n\t * Can have shorter or longer log in the same space,\n\t * or transform internal to external log or vice versa.\n\t */\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&mp->m_growlock"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_growfs_log(\n\txfs_mount_t\t\t*mp,\n\txfs_growfs_log_t\t*in)\n{\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!mutex_trylock(&mp->m_growlock))\n\t\treturn -EWOULDBLOCK;\n\terror = xfs_growfs_log_private(mp, in);\n\tmutex_unlock(&mp->m_growlock);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_growfs_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
    "lines": "593-613",
    "snippet": "int\nxfs_growfs_data(\n\txfs_mount_t\t\t*mp,\n\txfs_growfs_data_t\t*in)\n{\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!mutex_trylock(&mp->m_growlock))\n\t\treturn -EWOULDBLOCK;\n\terror = xfs_growfs_data_private(mp, in);\n\t/*\n\t * Increment the generation unconditionally, the error could be from\n\t * updating the secondary superblocks, in which case the new size\n\t * is live already.\n\t */\n\tmp->m_generation++;\n\tmutex_unlock(&mp->m_growlock);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mp->m_growlock"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_growfs_data_private",
          "args": [
            "mp",
            "in"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_growfs_data_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "141-562",
          "snippet": "static int\nxfs_growfs_data_private(\n\txfs_mount_t\t\t*mp,\t\t/* mount point for filesystem */\n\txfs_growfs_data_t\t*in)\t\t/* growfs data input struct */\n{\n\txfs_agf_t\t\t*agf;\n\tstruct xfs_agfl\t\t*agfl;\n\txfs_agi_t\t\t*agi;\n\txfs_agnumber_t\t\tagno;\n\txfs_extlen_t\t\tagsize;\n\txfs_extlen_t\t\ttmpsize;\n\txfs_alloc_rec_t\t\t*arec;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\tbucket;\n\tint\t\t\tdpct;\n\tint\t\t\terror, saved_error = 0;\n\txfs_agnumber_t\t\tnagcount;\n\txfs_agnumber_t\t\tnagimax = 0;\n\txfs_rfsblock_t\t\tnb, nb_mod;\n\txfs_rfsblock_t\t\tnew;\n\txfs_rfsblock_t\t\tnfree;\n\txfs_agnumber_t\t\toagcount;\n\tint\t\t\tpct;\n\txfs_trans_t\t\t*tp;\n\n\tnb = in->newblocks;\n\tpct = in->imaxpct;\n\tif (nb < mp->m_sb.sb_dblocks || pct < 0 || pct > 100)\n\t\treturn -EINVAL;\n\tif ((error = xfs_sb_validate_fsb_count(&mp->m_sb, nb)))\n\t\treturn error;\n\tdpct = pct - mp->m_sb.sb_imax_pct;\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp,\n\t\t\t\tXFS_FSB_TO_BB(mp, nb) - XFS_FSS_TO_BB(mp, 1),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\txfs_buf_relse(bp);\n\n\tnew = nb;\t/* use new as a temporary here */\n\tnb_mod = do_div(new, mp->m_sb.sb_agblocks);\n\tnagcount = new + (nb_mod != 0);\n\tif (nb_mod && nb_mod < XFS_MIN_AG_BLOCKS) {\n\t\tnagcount--;\n\t\tnb = (xfs_rfsblock_t)nagcount * mp->m_sb.sb_agblocks;\n\t\tif (nb < mp->m_sb.sb_dblocks)\n\t\t\treturn -EINVAL;\n\t}\n\tnew = nb - mp->m_sb.sb_dblocks;\n\toagcount = mp->m_sb.sb_agcount;\n\n\t/* allocate the new per-ag structures */\n\tif (nagcount > oagcount) {\n\t\terror = xfs_initialize_perag(mp, nagcount, &nagimax);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFS);\n\ttp->t_flags |= XFS_TRANS_RESERVE;\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growdata,\n\t\t\t\t  XFS_GROWFS_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Write new AG headers to disk. Non-transactional, but written\n\t * synchronously so they are completed prior to the growfs transaction\n\t * being logged.\n\t */\n\tnfree = 0;\n\tfor (agno = nagcount - 1; agno >= oagcount; agno--, new -= agsize) {\n\t\t__be32\t*agfl_bno;\n\n\t\t/*\n\t\t * AG freespace header block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGF_DADDR(mp)),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0,\n\t\t\t\t&xfs_agf_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tagf = XFS_BUF_TO_AGF(bp);\n\t\tagf->agf_magicnum = cpu_to_be32(XFS_AGF_MAGIC);\n\t\tagf->agf_versionnum = cpu_to_be32(XFS_AGF_VERSION);\n\t\tagf->agf_seqno = cpu_to_be32(agno);\n\t\tif (agno == nagcount - 1)\n\t\t\tagsize =\n\t\t\t\tnb -\n\t\t\t\t(agno * (xfs_rfsblock_t)mp->m_sb.sb_agblocks);\n\t\telse\n\t\t\tagsize = mp->m_sb.sb_agblocks;\n\t\tagf->agf_length = cpu_to_be32(agsize);\n\t\tagf->agf_roots[XFS_BTNUM_BNOi] = cpu_to_be32(XFS_BNO_BLOCK(mp));\n\t\tagf->agf_roots[XFS_BTNUM_CNTi] = cpu_to_be32(XFS_CNT_BLOCK(mp));\n\t\tagf->agf_levels[XFS_BTNUM_BNOi] = cpu_to_be32(1);\n\t\tagf->agf_levels[XFS_BTNUM_CNTi] = cpu_to_be32(1);\n\t\tagf->agf_flfirst = 0;\n\t\tagf->agf_fllast = cpu_to_be32(XFS_AGFL_SIZE(mp) - 1);\n\t\tagf->agf_flcount = 0;\n\t\ttmpsize = agsize - XFS_PREALLOC_BLOCKS(mp);\n\t\tagf->agf_freeblks = cpu_to_be32(tmpsize);\n\t\tagf->agf_longest = cpu_to_be32(tmpsize);\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\tuuid_copy(&agf->agf_uuid, &mp->m_sb.sb_uuid);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * AG freelist header block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp)),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0,\n\t\t\t\t&xfs_agfl_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tagfl = XFS_BUF_TO_AGFL(bp);\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tagfl->agfl_magicnum = cpu_to_be32(XFS_AGFL_MAGIC);\n\t\t\tagfl->agfl_seqno = cpu_to_be32(agno);\n\t\t\tuuid_copy(&agfl->agfl_uuid, &mp->m_sb.sb_uuid);\n\t\t}\n\n\t\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, bp);\n\t\tfor (bucket = 0; bucket < XFS_AGFL_SIZE(mp); bucket++)\n\t\t\tagfl_bno[bucket] = cpu_to_be32(NULLAGBLOCK);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * AG inode header block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0,\n\t\t\t\t&xfs_agi_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tagi = XFS_BUF_TO_AGI(bp);\n\t\tagi->agi_magicnum = cpu_to_be32(XFS_AGI_MAGIC);\n\t\tagi->agi_versionnum = cpu_to_be32(XFS_AGI_VERSION);\n\t\tagi->agi_seqno = cpu_to_be32(agno);\n\t\tagi->agi_length = cpu_to_be32(agsize);\n\t\tagi->agi_count = 0;\n\t\tagi->agi_root = cpu_to_be32(XFS_IBT_BLOCK(mp));\n\t\tagi->agi_level = cpu_to_be32(1);\n\t\tagi->agi_freecount = 0;\n\t\tagi->agi_newino = cpu_to_be32(NULLAGINO);\n\t\tagi->agi_dirino = cpu_to_be32(NULLAGINO);\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\tuuid_copy(&agi->agi_uuid, &mp->m_sb.sb_uuid);\n\t\tif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\n\t\t\tagi->agi_free_root = cpu_to_be32(XFS_FIBT_BLOCK(mp));\n\t\t\tagi->agi_free_level = cpu_to_be32(1);\n\t\t}\n\t\tfor (bucket = 0; bucket < XFS_AGI_UNLINKED_BUCKETS; bucket++)\n\t\t\tagi->agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * BNO btree root block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_BNO_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_allocbt_buf_ops);\n\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTB_CRC_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, XFS_BTREE_CRC_BLOCKS);\n\t\telse\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTB_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, 0);\n\n\t\tarec = XFS_ALLOC_REC_ADDR(mp, XFS_BUF_TO_BLOCK(bp), 1);\n\t\tarec->ar_startblock = cpu_to_be32(XFS_PREALLOC_BLOCKS(mp));\n\t\tarec->ar_blockcount = cpu_to_be32(\n\t\t\tagsize - be32_to_cpu(arec->ar_startblock));\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * CNT btree root block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_CNT_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_allocbt_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTC_CRC_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, XFS_BTREE_CRC_BLOCKS);\n\t\telse\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTC_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, 0);\n\n\t\tarec = XFS_ALLOC_REC_ADDR(mp, XFS_BUF_TO_BLOCK(bp), 1);\n\t\tarec->ar_startblock = cpu_to_be32(XFS_PREALLOC_BLOCKS(mp));\n\t\tarec->ar_blockcount = cpu_to_be32(\n\t\t\tagsize - be32_to_cpu(arec->ar_startblock));\n\t\tnfree += be32_to_cpu(arec->ar_blockcount);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * INO btree root block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_IBT_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_inobt_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\txfs_btree_init_block(mp, bp, XFS_IBT_CRC_MAGIC, 0, 0,\n\t\t\t\t\t\tagno, XFS_BTREE_CRC_BLOCKS);\n\t\telse\n\t\t\txfs_btree_init_block(mp, bp, XFS_IBT_MAGIC, 0, 0,\n\t\t\t\t\t\tagno, 0);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * FINO btree root block\n\t\t */\n\t\tif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\n\t\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_FIBT_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_inobt_buf_ops);\n\t\t\tif (!bp) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto error0;\n\t\t\t}\n\n\t\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\t\txfs_btree_init_block(mp, bp, XFS_FIBT_CRC_MAGIC,\n\t\t\t\t\t\t     0, 0, agno,\n\t\t\t\t\t\t     XFS_BTREE_CRC_BLOCKS);\n\t\t\telse\n\t\t\t\txfs_btree_init_block(mp, bp, XFS_FIBT_MAGIC, 0,\n\t\t\t\t\t\t     0, agno, 0);\n\n\t\t\terror = xfs_bwrite(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n\n\t}\n\txfs_trans_agblocks_delta(tp, nfree);\n\t/*\n\t * There are new blocks in the old last a.g.\n\t */\n\tif (new) {\n\t\t/*\n\t\t * Change the agi length.\n\t\t */\n\t\terror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\t\tASSERT(bp);\n\t\tagi = XFS_BUF_TO_AGI(bp);\n\t\tbe32_add_cpu(&agi->agi_length, new);\n\t\tASSERT(nagcount == oagcount ||\n\t\t       be32_to_cpu(agi->agi_length) == mp->m_sb.sb_agblocks);\n\t\txfs_ialloc_log_agi(tp, bp, XFS_AGI_LENGTH);\n\t\t/*\n\t\t * Change agf length.\n\t\t */\n\t\terror = xfs_alloc_read_agf(mp, tp, agno, 0, &bp);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\t\tASSERT(bp);\n\t\tagf = XFS_BUF_TO_AGF(bp);\n\t\tbe32_add_cpu(&agf->agf_length, new);\n\t\tASSERT(be32_to_cpu(agf->agf_length) ==\n\t\t       be32_to_cpu(agi->agi_length));\n\n\t\txfs_alloc_log_agf(tp, bp, XFS_AGF_LENGTH);\n\t\t/*\n\t\t * Free the new space.\n\t\t */\n\t\terror = xfs_free_extent(tp, XFS_AGB_TO_FSB(mp, agno,\n\t\t\tbe32_to_cpu(agf->agf_length) - new), new);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\t}\n\n\t/*\n\t * Update changed superblock fields transactionally. These are not\n\t * seen by the rest of the world until the transaction commit applies\n\t * them atomically to the superblock.\n\t */\n\tif (nagcount > oagcount)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_AGCOUNT, nagcount - oagcount);\n\tif (nb > mp->m_sb.sb_dblocks)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_DBLOCKS,\n\t\t\t\t nb - mp->m_sb.sb_dblocks);\n\tif (nfree)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, nfree);\n\tif (dpct)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IMAXPCT, dpct);\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/* New allocation groups fully initialized, so update mount struct */\n\tif (nagimax)\n\t\tmp->m_maxagi = nagimax;\n\tif (mp->m_sb.sb_imax_pct) {\n\t\t__uint64_t icount = mp->m_sb.sb_dblocks * mp->m_sb.sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\tmp->m_maxicount = icount << mp->m_sb.sb_inopblog;\n\t} else\n\t\tmp->m_maxicount = 0;\n\txfs_set_low_space_thresholds(mp);\n\n\t/* update secondary superblocks. */\n\tfor (agno = 1; agno < nagcount; agno++) {\n\t\terror = 0;\n\t\t/*\n\t\t * new secondary superblocks need to be zeroed, not read from\n\t\t * disk as the contents of the new area we are growing into is\n\t\t * completely unknown.\n\t\t */\n\t\tif (agno < oagcount) {\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t  XFS_AGB_TO_DADDR(mp, agno, XFS_SB_BLOCK(mp)),\n\t\t\t\t  XFS_FSS_TO_BB(mp, 1), 0, &bp,\n\t\t\t\t  &xfs_sb_buf_ops);\n\t\t} else {\n\t\t\tbp = xfs_trans_get_buf(NULL, mp->m_ddev_targp,\n\t\t\t\t  XFS_AGB_TO_DADDR(mp, agno, XFS_SB_BLOCK(mp)),\n\t\t\t\t  XFS_FSS_TO_BB(mp, 1), 0);\n\t\t\tif (bp) {\n\t\t\t\tbp->b_ops = &xfs_sb_buf_ops;\n\t\t\t\txfs_buf_zero(bp, 0, BBTOB(bp->b_length));\n\t\t\t} else\n\t\t\t\terror = -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * If we get an error reading or writing alternate superblocks,\n\t\t * continue.  xfs_repair chooses the \"best\" superblock based\n\t\t * on most matches; if we break early, we'll leave more\n\t\t * superblocks un-updated than updated, and xfs_repair may\n\t\t * pick them over the properly-updated primary.\n\t\t */\n\t\tif (error) {\n\t\t\txfs_warn(mp,\n\t\t\"error %d reading secondary superblock for ag %d\",\n\t\t\t\terror, agno);\n\t\t\tsaved_error = error;\n\t\t\tcontinue;\n\t\t}\n\t\txfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error) {\n\t\t\txfs_warn(mp,\n\t\t\"write error %d updating secondary superblock for ag %d\",\n\t\t\t\terror, agno);\n\t\t\tsaved_error = error;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn saved_error ? saved_error : error;\n\n error0:\n\txfs_trans_cancel(tp, XFS_TRANS_ABORT);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_growfs_data_private(\n\txfs_mount_t\t\t*mp,\t\t/* mount point for filesystem */\n\txfs_growfs_data_t\t*in)\t\t/* growfs data input struct */\n{\n\txfs_agf_t\t\t*agf;\n\tstruct xfs_agfl\t\t*agfl;\n\txfs_agi_t\t\t*agi;\n\txfs_agnumber_t\t\tagno;\n\txfs_extlen_t\t\tagsize;\n\txfs_extlen_t\t\ttmpsize;\n\txfs_alloc_rec_t\t\t*arec;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\tbucket;\n\tint\t\t\tdpct;\n\tint\t\t\terror, saved_error = 0;\n\txfs_agnumber_t\t\tnagcount;\n\txfs_agnumber_t\t\tnagimax = 0;\n\txfs_rfsblock_t\t\tnb, nb_mod;\n\txfs_rfsblock_t\t\tnew;\n\txfs_rfsblock_t\t\tnfree;\n\txfs_agnumber_t\t\toagcount;\n\tint\t\t\tpct;\n\txfs_trans_t\t\t*tp;\n\n\tnb = in->newblocks;\n\tpct = in->imaxpct;\n\tif (nb < mp->m_sb.sb_dblocks || pct < 0 || pct > 100)\n\t\treturn -EINVAL;\n\tif ((error = xfs_sb_validate_fsb_count(&mp->m_sb, nb)))\n\t\treturn error;\n\tdpct = pct - mp->m_sb.sb_imax_pct;\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp,\n\t\t\t\tXFS_FSB_TO_BB(mp, nb) - XFS_FSS_TO_BB(mp, 1),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\txfs_buf_relse(bp);\n\n\tnew = nb;\t/* use new as a temporary here */\n\tnb_mod = do_div(new, mp->m_sb.sb_agblocks);\n\tnagcount = new + (nb_mod != 0);\n\tif (nb_mod && nb_mod < XFS_MIN_AG_BLOCKS) {\n\t\tnagcount--;\n\t\tnb = (xfs_rfsblock_t)nagcount * mp->m_sb.sb_agblocks;\n\t\tif (nb < mp->m_sb.sb_dblocks)\n\t\t\treturn -EINVAL;\n\t}\n\tnew = nb - mp->m_sb.sb_dblocks;\n\toagcount = mp->m_sb.sb_agcount;\n\n\t/* allocate the new per-ag structures */\n\tif (nagcount > oagcount) {\n\t\terror = xfs_initialize_perag(mp, nagcount, &nagimax);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFS);\n\ttp->t_flags |= XFS_TRANS_RESERVE;\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growdata,\n\t\t\t\t  XFS_GROWFS_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Write new AG headers to disk. Non-transactional, but written\n\t * synchronously so they are completed prior to the growfs transaction\n\t * being logged.\n\t */\n\tnfree = 0;\n\tfor (agno = nagcount - 1; agno >= oagcount; agno--, new -= agsize) {\n\t\t__be32\t*agfl_bno;\n\n\t\t/*\n\t\t * AG freespace header block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGF_DADDR(mp)),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0,\n\t\t\t\t&xfs_agf_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tagf = XFS_BUF_TO_AGF(bp);\n\t\tagf->agf_magicnum = cpu_to_be32(XFS_AGF_MAGIC);\n\t\tagf->agf_versionnum = cpu_to_be32(XFS_AGF_VERSION);\n\t\tagf->agf_seqno = cpu_to_be32(agno);\n\t\tif (agno == nagcount - 1)\n\t\t\tagsize =\n\t\t\t\tnb -\n\t\t\t\t(agno * (xfs_rfsblock_t)mp->m_sb.sb_agblocks);\n\t\telse\n\t\t\tagsize = mp->m_sb.sb_agblocks;\n\t\tagf->agf_length = cpu_to_be32(agsize);\n\t\tagf->agf_roots[XFS_BTNUM_BNOi] = cpu_to_be32(XFS_BNO_BLOCK(mp));\n\t\tagf->agf_roots[XFS_BTNUM_CNTi] = cpu_to_be32(XFS_CNT_BLOCK(mp));\n\t\tagf->agf_levels[XFS_BTNUM_BNOi] = cpu_to_be32(1);\n\t\tagf->agf_levels[XFS_BTNUM_CNTi] = cpu_to_be32(1);\n\t\tagf->agf_flfirst = 0;\n\t\tagf->agf_fllast = cpu_to_be32(XFS_AGFL_SIZE(mp) - 1);\n\t\tagf->agf_flcount = 0;\n\t\ttmpsize = agsize - XFS_PREALLOC_BLOCKS(mp);\n\t\tagf->agf_freeblks = cpu_to_be32(tmpsize);\n\t\tagf->agf_longest = cpu_to_be32(tmpsize);\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\tuuid_copy(&agf->agf_uuid, &mp->m_sb.sb_uuid);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * AG freelist header block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp)),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0,\n\t\t\t\t&xfs_agfl_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tagfl = XFS_BUF_TO_AGFL(bp);\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tagfl->agfl_magicnum = cpu_to_be32(XFS_AGFL_MAGIC);\n\t\t\tagfl->agfl_seqno = cpu_to_be32(agno);\n\t\t\tuuid_copy(&agfl->agfl_uuid, &mp->m_sb.sb_uuid);\n\t\t}\n\n\t\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, bp);\n\t\tfor (bucket = 0; bucket < XFS_AGFL_SIZE(mp); bucket++)\n\t\t\tagfl_bno[bucket] = cpu_to_be32(NULLAGBLOCK);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * AG inode header block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0,\n\t\t\t\t&xfs_agi_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tagi = XFS_BUF_TO_AGI(bp);\n\t\tagi->agi_magicnum = cpu_to_be32(XFS_AGI_MAGIC);\n\t\tagi->agi_versionnum = cpu_to_be32(XFS_AGI_VERSION);\n\t\tagi->agi_seqno = cpu_to_be32(agno);\n\t\tagi->agi_length = cpu_to_be32(agsize);\n\t\tagi->agi_count = 0;\n\t\tagi->agi_root = cpu_to_be32(XFS_IBT_BLOCK(mp));\n\t\tagi->agi_level = cpu_to_be32(1);\n\t\tagi->agi_freecount = 0;\n\t\tagi->agi_newino = cpu_to_be32(NULLAGINO);\n\t\tagi->agi_dirino = cpu_to_be32(NULLAGINO);\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\tuuid_copy(&agi->agi_uuid, &mp->m_sb.sb_uuid);\n\t\tif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\n\t\t\tagi->agi_free_root = cpu_to_be32(XFS_FIBT_BLOCK(mp));\n\t\t\tagi->agi_free_level = cpu_to_be32(1);\n\t\t}\n\t\tfor (bucket = 0; bucket < XFS_AGI_UNLINKED_BUCKETS; bucket++)\n\t\t\tagi->agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * BNO btree root block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_BNO_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_allocbt_buf_ops);\n\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTB_CRC_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, XFS_BTREE_CRC_BLOCKS);\n\t\telse\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTB_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, 0);\n\n\t\tarec = XFS_ALLOC_REC_ADDR(mp, XFS_BUF_TO_BLOCK(bp), 1);\n\t\tarec->ar_startblock = cpu_to_be32(XFS_PREALLOC_BLOCKS(mp));\n\t\tarec->ar_blockcount = cpu_to_be32(\n\t\t\tagsize - be32_to_cpu(arec->ar_startblock));\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * CNT btree root block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_CNT_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_allocbt_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTC_CRC_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, XFS_BTREE_CRC_BLOCKS);\n\t\telse\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTC_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, 0);\n\n\t\tarec = XFS_ALLOC_REC_ADDR(mp, XFS_BUF_TO_BLOCK(bp), 1);\n\t\tarec->ar_startblock = cpu_to_be32(XFS_PREALLOC_BLOCKS(mp));\n\t\tarec->ar_blockcount = cpu_to_be32(\n\t\t\tagsize - be32_to_cpu(arec->ar_startblock));\n\t\tnfree += be32_to_cpu(arec->ar_blockcount);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * INO btree root block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_IBT_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_inobt_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\txfs_btree_init_block(mp, bp, XFS_IBT_CRC_MAGIC, 0, 0,\n\t\t\t\t\t\tagno, XFS_BTREE_CRC_BLOCKS);\n\t\telse\n\t\t\txfs_btree_init_block(mp, bp, XFS_IBT_MAGIC, 0, 0,\n\t\t\t\t\t\tagno, 0);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * FINO btree root block\n\t\t */\n\t\tif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\n\t\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_FIBT_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_inobt_buf_ops);\n\t\t\tif (!bp) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto error0;\n\t\t\t}\n\n\t\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\t\txfs_btree_init_block(mp, bp, XFS_FIBT_CRC_MAGIC,\n\t\t\t\t\t\t     0, 0, agno,\n\t\t\t\t\t\t     XFS_BTREE_CRC_BLOCKS);\n\t\t\telse\n\t\t\t\txfs_btree_init_block(mp, bp, XFS_FIBT_MAGIC, 0,\n\t\t\t\t\t\t     0, agno, 0);\n\n\t\t\terror = xfs_bwrite(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n\n\t}\n\txfs_trans_agblocks_delta(tp, nfree);\n\t/*\n\t * There are new blocks in the old last a.g.\n\t */\n\tif (new) {\n\t\t/*\n\t\t * Change the agi length.\n\t\t */\n\t\terror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\t\tASSERT(bp);\n\t\tagi = XFS_BUF_TO_AGI(bp);\n\t\tbe32_add_cpu(&agi->agi_length, new);\n\t\tASSERT(nagcount == oagcount ||\n\t\t       be32_to_cpu(agi->agi_length) == mp->m_sb.sb_agblocks);\n\t\txfs_ialloc_log_agi(tp, bp, XFS_AGI_LENGTH);\n\t\t/*\n\t\t * Change agf length.\n\t\t */\n\t\terror = xfs_alloc_read_agf(mp, tp, agno, 0, &bp);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\t\tASSERT(bp);\n\t\tagf = XFS_BUF_TO_AGF(bp);\n\t\tbe32_add_cpu(&agf->agf_length, new);\n\t\tASSERT(be32_to_cpu(agf->agf_length) ==\n\t\t       be32_to_cpu(agi->agi_length));\n\n\t\txfs_alloc_log_agf(tp, bp, XFS_AGF_LENGTH);\n\t\t/*\n\t\t * Free the new space.\n\t\t */\n\t\terror = xfs_free_extent(tp, XFS_AGB_TO_FSB(mp, agno,\n\t\t\tbe32_to_cpu(agf->agf_length) - new), new);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\t}\n\n\t/*\n\t * Update changed superblock fields transactionally. These are not\n\t * seen by the rest of the world until the transaction commit applies\n\t * them atomically to the superblock.\n\t */\n\tif (nagcount > oagcount)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_AGCOUNT, nagcount - oagcount);\n\tif (nb > mp->m_sb.sb_dblocks)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_DBLOCKS,\n\t\t\t\t nb - mp->m_sb.sb_dblocks);\n\tif (nfree)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, nfree);\n\tif (dpct)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IMAXPCT, dpct);\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/* New allocation groups fully initialized, so update mount struct */\n\tif (nagimax)\n\t\tmp->m_maxagi = nagimax;\n\tif (mp->m_sb.sb_imax_pct) {\n\t\t__uint64_t icount = mp->m_sb.sb_dblocks * mp->m_sb.sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\tmp->m_maxicount = icount << mp->m_sb.sb_inopblog;\n\t} else\n\t\tmp->m_maxicount = 0;\n\txfs_set_low_space_thresholds(mp);\n\n\t/* update secondary superblocks. */\n\tfor (agno = 1; agno < nagcount; agno++) {\n\t\terror = 0;\n\t\t/*\n\t\t * new secondary superblocks need to be zeroed, not read from\n\t\t * disk as the contents of the new area we are growing into is\n\t\t * completely unknown.\n\t\t */\n\t\tif (agno < oagcount) {\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t  XFS_AGB_TO_DADDR(mp, agno, XFS_SB_BLOCK(mp)),\n\t\t\t\t  XFS_FSS_TO_BB(mp, 1), 0, &bp,\n\t\t\t\t  &xfs_sb_buf_ops);\n\t\t} else {\n\t\t\tbp = xfs_trans_get_buf(NULL, mp->m_ddev_targp,\n\t\t\t\t  XFS_AGB_TO_DADDR(mp, agno, XFS_SB_BLOCK(mp)),\n\t\t\t\t  XFS_FSS_TO_BB(mp, 1), 0);\n\t\t\tif (bp) {\n\t\t\t\tbp->b_ops = &xfs_sb_buf_ops;\n\t\t\t\txfs_buf_zero(bp, 0, BBTOB(bp->b_length));\n\t\t\t} else\n\t\t\t\terror = -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * If we get an error reading or writing alternate superblocks,\n\t\t * continue.  xfs_repair chooses the \"best\" superblock based\n\t\t * on most matches; if we break early, we'll leave more\n\t\t * superblocks un-updated than updated, and xfs_repair may\n\t\t * pick them over the properly-updated primary.\n\t\t */\n\t\tif (error) {\n\t\t\txfs_warn(mp,\n\t\t\"error %d reading secondary superblock for ag %d\",\n\t\t\t\terror, agno);\n\t\t\tsaved_error = error;\n\t\t\tcontinue;\n\t\t}\n\t\txfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error) {\n\t\t\txfs_warn(mp,\n\t\t\"write error %d updating secondary superblock for ag %d\",\n\t\t\t\terror, agno);\n\t\t\tsaved_error = error;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn saved_error ? saved_error : error;\n\n error0:\n\txfs_trans_cancel(tp, XFS_TRANS_ABORT);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&mp->m_growlock"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_growfs_data(\n\txfs_mount_t\t\t*mp,\n\txfs_growfs_data_t\t*in)\n{\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!mutex_trylock(&mp->m_growlock))\n\t\treturn -EWOULDBLOCK;\n\terror = xfs_growfs_data_private(mp, in);\n\t/*\n\t * Increment the generation unconditionally, the error could be from\n\t * updating the secondary superblocks, in which case the new size\n\t * is live already.\n\t */\n\tmp->m_generation++;\n\tmutex_unlock(&mp->m_growlock);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_growfs_log_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
    "lines": "564-584",
    "snippet": "static int\nxfs_growfs_log_private(\n\txfs_mount_t\t\t*mp,\t/* mount point for filesystem */\n\txfs_growfs_log_t\t*in)\t/* growfs log input struct */\n{\n\txfs_extlen_t\t\tnb;\n\n\tnb = in->newblocks;\n\tif (nb < XFS_MIN_LOG_BLOCKS || nb < XFS_B_TO_FSB(mp, XFS_MIN_LOG_BYTES))\n\t\treturn -EINVAL;\n\tif (nb == mp->m_sb.sb_logblocks &&\n\t    in->isint == (mp->m_sb.sb_logstart != 0))\n\t\treturn -EINVAL;\n\t/*\n\t * Moving the log is hard, need new interfaces to sync\n\t * the log first, hold off all activity while moving it.\n\t * Can have shorter or longer log in the same space,\n\t * or transform internal to external log or vice versa.\n\t */\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "XFS_MIN_LOG_BYTES"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_growfs_log_private(\n\txfs_mount_t\t\t*mp,\t/* mount point for filesystem */\n\txfs_growfs_log_t\t*in)\t/* growfs log input struct */\n{\n\txfs_extlen_t\t\tnb;\n\n\tnb = in->newblocks;\n\tif (nb < XFS_MIN_LOG_BLOCKS || nb < XFS_B_TO_FSB(mp, XFS_MIN_LOG_BYTES))\n\t\treturn -EINVAL;\n\tif (nb == mp->m_sb.sb_logblocks &&\n\t    in->isint == (mp->m_sb.sb_logstart != 0))\n\t\treturn -EINVAL;\n\t/*\n\t * Moving the log is hard, need new interfaces to sync\n\t * the log first, hold off all activity while moving it.\n\t * Can have shorter or longer log in the same space,\n\t * or transform internal to external log or vice versa.\n\t */\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "xfs_growfs_data_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
    "lines": "141-562",
    "snippet": "static int\nxfs_growfs_data_private(\n\txfs_mount_t\t\t*mp,\t\t/* mount point for filesystem */\n\txfs_growfs_data_t\t*in)\t\t/* growfs data input struct */\n{\n\txfs_agf_t\t\t*agf;\n\tstruct xfs_agfl\t\t*agfl;\n\txfs_agi_t\t\t*agi;\n\txfs_agnumber_t\t\tagno;\n\txfs_extlen_t\t\tagsize;\n\txfs_extlen_t\t\ttmpsize;\n\txfs_alloc_rec_t\t\t*arec;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\tbucket;\n\tint\t\t\tdpct;\n\tint\t\t\terror, saved_error = 0;\n\txfs_agnumber_t\t\tnagcount;\n\txfs_agnumber_t\t\tnagimax = 0;\n\txfs_rfsblock_t\t\tnb, nb_mod;\n\txfs_rfsblock_t\t\tnew;\n\txfs_rfsblock_t\t\tnfree;\n\txfs_agnumber_t\t\toagcount;\n\tint\t\t\tpct;\n\txfs_trans_t\t\t*tp;\n\n\tnb = in->newblocks;\n\tpct = in->imaxpct;\n\tif (nb < mp->m_sb.sb_dblocks || pct < 0 || pct > 100)\n\t\treturn -EINVAL;\n\tif ((error = xfs_sb_validate_fsb_count(&mp->m_sb, nb)))\n\t\treturn error;\n\tdpct = pct - mp->m_sb.sb_imax_pct;\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp,\n\t\t\t\tXFS_FSB_TO_BB(mp, nb) - XFS_FSS_TO_BB(mp, 1),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\txfs_buf_relse(bp);\n\n\tnew = nb;\t/* use new as a temporary here */\n\tnb_mod = do_div(new, mp->m_sb.sb_agblocks);\n\tnagcount = new + (nb_mod != 0);\n\tif (nb_mod && nb_mod < XFS_MIN_AG_BLOCKS) {\n\t\tnagcount--;\n\t\tnb = (xfs_rfsblock_t)nagcount * mp->m_sb.sb_agblocks;\n\t\tif (nb < mp->m_sb.sb_dblocks)\n\t\t\treturn -EINVAL;\n\t}\n\tnew = nb - mp->m_sb.sb_dblocks;\n\toagcount = mp->m_sb.sb_agcount;\n\n\t/* allocate the new per-ag structures */\n\tif (nagcount > oagcount) {\n\t\terror = xfs_initialize_perag(mp, nagcount, &nagimax);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFS);\n\ttp->t_flags |= XFS_TRANS_RESERVE;\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growdata,\n\t\t\t\t  XFS_GROWFS_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Write new AG headers to disk. Non-transactional, but written\n\t * synchronously so they are completed prior to the growfs transaction\n\t * being logged.\n\t */\n\tnfree = 0;\n\tfor (agno = nagcount - 1; agno >= oagcount; agno--, new -= agsize) {\n\t\t__be32\t*agfl_bno;\n\n\t\t/*\n\t\t * AG freespace header block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGF_DADDR(mp)),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0,\n\t\t\t\t&xfs_agf_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tagf = XFS_BUF_TO_AGF(bp);\n\t\tagf->agf_magicnum = cpu_to_be32(XFS_AGF_MAGIC);\n\t\tagf->agf_versionnum = cpu_to_be32(XFS_AGF_VERSION);\n\t\tagf->agf_seqno = cpu_to_be32(agno);\n\t\tif (agno == nagcount - 1)\n\t\t\tagsize =\n\t\t\t\tnb -\n\t\t\t\t(agno * (xfs_rfsblock_t)mp->m_sb.sb_agblocks);\n\t\telse\n\t\t\tagsize = mp->m_sb.sb_agblocks;\n\t\tagf->agf_length = cpu_to_be32(agsize);\n\t\tagf->agf_roots[XFS_BTNUM_BNOi] = cpu_to_be32(XFS_BNO_BLOCK(mp));\n\t\tagf->agf_roots[XFS_BTNUM_CNTi] = cpu_to_be32(XFS_CNT_BLOCK(mp));\n\t\tagf->agf_levels[XFS_BTNUM_BNOi] = cpu_to_be32(1);\n\t\tagf->agf_levels[XFS_BTNUM_CNTi] = cpu_to_be32(1);\n\t\tagf->agf_flfirst = 0;\n\t\tagf->agf_fllast = cpu_to_be32(XFS_AGFL_SIZE(mp) - 1);\n\t\tagf->agf_flcount = 0;\n\t\ttmpsize = agsize - XFS_PREALLOC_BLOCKS(mp);\n\t\tagf->agf_freeblks = cpu_to_be32(tmpsize);\n\t\tagf->agf_longest = cpu_to_be32(tmpsize);\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\tuuid_copy(&agf->agf_uuid, &mp->m_sb.sb_uuid);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * AG freelist header block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp)),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0,\n\t\t\t\t&xfs_agfl_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tagfl = XFS_BUF_TO_AGFL(bp);\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tagfl->agfl_magicnum = cpu_to_be32(XFS_AGFL_MAGIC);\n\t\t\tagfl->agfl_seqno = cpu_to_be32(agno);\n\t\t\tuuid_copy(&agfl->agfl_uuid, &mp->m_sb.sb_uuid);\n\t\t}\n\n\t\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, bp);\n\t\tfor (bucket = 0; bucket < XFS_AGFL_SIZE(mp); bucket++)\n\t\t\tagfl_bno[bucket] = cpu_to_be32(NULLAGBLOCK);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * AG inode header block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0,\n\t\t\t\t&xfs_agi_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tagi = XFS_BUF_TO_AGI(bp);\n\t\tagi->agi_magicnum = cpu_to_be32(XFS_AGI_MAGIC);\n\t\tagi->agi_versionnum = cpu_to_be32(XFS_AGI_VERSION);\n\t\tagi->agi_seqno = cpu_to_be32(agno);\n\t\tagi->agi_length = cpu_to_be32(agsize);\n\t\tagi->agi_count = 0;\n\t\tagi->agi_root = cpu_to_be32(XFS_IBT_BLOCK(mp));\n\t\tagi->agi_level = cpu_to_be32(1);\n\t\tagi->agi_freecount = 0;\n\t\tagi->agi_newino = cpu_to_be32(NULLAGINO);\n\t\tagi->agi_dirino = cpu_to_be32(NULLAGINO);\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\tuuid_copy(&agi->agi_uuid, &mp->m_sb.sb_uuid);\n\t\tif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\n\t\t\tagi->agi_free_root = cpu_to_be32(XFS_FIBT_BLOCK(mp));\n\t\t\tagi->agi_free_level = cpu_to_be32(1);\n\t\t}\n\t\tfor (bucket = 0; bucket < XFS_AGI_UNLINKED_BUCKETS; bucket++)\n\t\t\tagi->agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * BNO btree root block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_BNO_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_allocbt_buf_ops);\n\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTB_CRC_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, XFS_BTREE_CRC_BLOCKS);\n\t\telse\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTB_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, 0);\n\n\t\tarec = XFS_ALLOC_REC_ADDR(mp, XFS_BUF_TO_BLOCK(bp), 1);\n\t\tarec->ar_startblock = cpu_to_be32(XFS_PREALLOC_BLOCKS(mp));\n\t\tarec->ar_blockcount = cpu_to_be32(\n\t\t\tagsize - be32_to_cpu(arec->ar_startblock));\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * CNT btree root block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_CNT_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_allocbt_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTC_CRC_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, XFS_BTREE_CRC_BLOCKS);\n\t\telse\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTC_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, 0);\n\n\t\tarec = XFS_ALLOC_REC_ADDR(mp, XFS_BUF_TO_BLOCK(bp), 1);\n\t\tarec->ar_startblock = cpu_to_be32(XFS_PREALLOC_BLOCKS(mp));\n\t\tarec->ar_blockcount = cpu_to_be32(\n\t\t\tagsize - be32_to_cpu(arec->ar_startblock));\n\t\tnfree += be32_to_cpu(arec->ar_blockcount);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * INO btree root block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_IBT_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_inobt_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\txfs_btree_init_block(mp, bp, XFS_IBT_CRC_MAGIC, 0, 0,\n\t\t\t\t\t\tagno, XFS_BTREE_CRC_BLOCKS);\n\t\telse\n\t\t\txfs_btree_init_block(mp, bp, XFS_IBT_MAGIC, 0, 0,\n\t\t\t\t\t\tagno, 0);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * FINO btree root block\n\t\t */\n\t\tif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\n\t\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_FIBT_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_inobt_buf_ops);\n\t\t\tif (!bp) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto error0;\n\t\t\t}\n\n\t\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\t\txfs_btree_init_block(mp, bp, XFS_FIBT_CRC_MAGIC,\n\t\t\t\t\t\t     0, 0, agno,\n\t\t\t\t\t\t     XFS_BTREE_CRC_BLOCKS);\n\t\t\telse\n\t\t\t\txfs_btree_init_block(mp, bp, XFS_FIBT_MAGIC, 0,\n\t\t\t\t\t\t     0, agno, 0);\n\n\t\t\terror = xfs_bwrite(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n\n\t}\n\txfs_trans_agblocks_delta(tp, nfree);\n\t/*\n\t * There are new blocks in the old last a.g.\n\t */\n\tif (new) {\n\t\t/*\n\t\t * Change the agi length.\n\t\t */\n\t\terror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\t\tASSERT(bp);\n\t\tagi = XFS_BUF_TO_AGI(bp);\n\t\tbe32_add_cpu(&agi->agi_length, new);\n\t\tASSERT(nagcount == oagcount ||\n\t\t       be32_to_cpu(agi->agi_length) == mp->m_sb.sb_agblocks);\n\t\txfs_ialloc_log_agi(tp, bp, XFS_AGI_LENGTH);\n\t\t/*\n\t\t * Change agf length.\n\t\t */\n\t\terror = xfs_alloc_read_agf(mp, tp, agno, 0, &bp);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\t\tASSERT(bp);\n\t\tagf = XFS_BUF_TO_AGF(bp);\n\t\tbe32_add_cpu(&agf->agf_length, new);\n\t\tASSERT(be32_to_cpu(agf->agf_length) ==\n\t\t       be32_to_cpu(agi->agi_length));\n\n\t\txfs_alloc_log_agf(tp, bp, XFS_AGF_LENGTH);\n\t\t/*\n\t\t * Free the new space.\n\t\t */\n\t\terror = xfs_free_extent(tp, XFS_AGB_TO_FSB(mp, agno,\n\t\t\tbe32_to_cpu(agf->agf_length) - new), new);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\t}\n\n\t/*\n\t * Update changed superblock fields transactionally. These are not\n\t * seen by the rest of the world until the transaction commit applies\n\t * them atomically to the superblock.\n\t */\n\tif (nagcount > oagcount)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_AGCOUNT, nagcount - oagcount);\n\tif (nb > mp->m_sb.sb_dblocks)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_DBLOCKS,\n\t\t\t\t nb - mp->m_sb.sb_dblocks);\n\tif (nfree)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, nfree);\n\tif (dpct)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IMAXPCT, dpct);\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/* New allocation groups fully initialized, so update mount struct */\n\tif (nagimax)\n\t\tmp->m_maxagi = nagimax;\n\tif (mp->m_sb.sb_imax_pct) {\n\t\t__uint64_t icount = mp->m_sb.sb_dblocks * mp->m_sb.sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\tmp->m_maxicount = icount << mp->m_sb.sb_inopblog;\n\t} else\n\t\tmp->m_maxicount = 0;\n\txfs_set_low_space_thresholds(mp);\n\n\t/* update secondary superblocks. */\n\tfor (agno = 1; agno < nagcount; agno++) {\n\t\terror = 0;\n\t\t/*\n\t\t * new secondary superblocks need to be zeroed, not read from\n\t\t * disk as the contents of the new area we are growing into is\n\t\t * completely unknown.\n\t\t */\n\t\tif (agno < oagcount) {\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t  XFS_AGB_TO_DADDR(mp, agno, XFS_SB_BLOCK(mp)),\n\t\t\t\t  XFS_FSS_TO_BB(mp, 1), 0, &bp,\n\t\t\t\t  &xfs_sb_buf_ops);\n\t\t} else {\n\t\t\tbp = xfs_trans_get_buf(NULL, mp->m_ddev_targp,\n\t\t\t\t  XFS_AGB_TO_DADDR(mp, agno, XFS_SB_BLOCK(mp)),\n\t\t\t\t  XFS_FSS_TO_BB(mp, 1), 0);\n\t\t\tif (bp) {\n\t\t\t\tbp->b_ops = &xfs_sb_buf_ops;\n\t\t\t\txfs_buf_zero(bp, 0, BBTOB(bp->b_length));\n\t\t\t} else\n\t\t\t\terror = -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * If we get an error reading or writing alternate superblocks,\n\t\t * continue.  xfs_repair chooses the \"best\" superblock based\n\t\t * on most matches; if we break early, we'll leave more\n\t\t * superblocks un-updated than updated, and xfs_repair may\n\t\t * pick them over the properly-updated primary.\n\t\t */\n\t\tif (error) {\n\t\t\txfs_warn(mp,\n\t\t\"error %d reading secondary superblock for ag %d\",\n\t\t\t\terror, agno);\n\t\t\tsaved_error = error;\n\t\t\tcontinue;\n\t\t}\n\t\txfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error) {\n\t\t\txfs_warn(mp,\n\t\t\"write error %d updating secondary superblock for ag %d\",\n\t\t\t\terror, agno);\n\t\t\tsaved_error = error;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn saved_error ? saved_error : error;\n\n error0:\n\txfs_trans_cancel(tp, XFS_TRANS_ABORT);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "XFS_TRANS_ABORT"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"write error %d updating secondary superblock for ag %d\"",
            "error",
            "agno"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bwrite",
          "args": [
            "bp"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1077-1095",
          "snippet": "int\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_to_disk",
          "args": [
            "XFS_BUF_TO_SBP(bp)",
            "&mp->m_sb"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "460-530",
          "snippet": "void\nxfs_sb_to_disk(\n\tstruct xfs_dsb\t*to,\n\tstruct xfs_sb\t*from)\n{\n\txfs_sb_quota_to_disk(to, from);\n\n\tto->sb_magicnum = cpu_to_be32(from->sb_magicnum);\n\tto->sb_blocksize = cpu_to_be32(from->sb_blocksize);\n\tto->sb_dblocks = cpu_to_be64(from->sb_dblocks);\n\tto->sb_rblocks = cpu_to_be64(from->sb_rblocks);\n\tto->sb_rextents = cpu_to_be64(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = cpu_to_be64(from->sb_logstart);\n\tto->sb_rootino = cpu_to_be64(from->sb_rootino);\n\tto->sb_rbmino = cpu_to_be64(from->sb_rbmino);\n\tto->sb_rsumino = cpu_to_be64(from->sb_rsumino);\n\tto->sb_rextsize = cpu_to_be32(from->sb_rextsize);\n\tto->sb_agblocks = cpu_to_be32(from->sb_agblocks);\n\tto->sb_agcount = cpu_to_be32(from->sb_agcount);\n\tto->sb_rbmblocks = cpu_to_be32(from->sb_rbmblocks);\n\tto->sb_logblocks = cpu_to_be32(from->sb_logblocks);\n\tto->sb_versionnum = cpu_to_be16(from->sb_versionnum);\n\tto->sb_sectsize = cpu_to_be16(from->sb_sectsize);\n\tto->sb_inodesize = cpu_to_be16(from->sb_inodesize);\n\tto->sb_inopblock = cpu_to_be16(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = cpu_to_be64(from->sb_icount);\n\tto->sb_ifree = cpu_to_be64(from->sb_ifree);\n\tto->sb_fdblocks = cpu_to_be64(from->sb_fdblocks);\n\tto->sb_frextents = cpu_to_be64(from->sb_frextents);\n\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = cpu_to_be32(from->sb_inoalignmt);\n\tto->sb_unit = cpu_to_be32(from->sb_unit);\n\tto->sb_width = cpu_to_be32(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = cpu_to_be16(from->sb_logsectsize);\n\tto->sb_logsunit = cpu_to_be32(from->sb_logsunit);\n\n\t/*\n\t * We need to ensure that bad_features2 always matches features2.\n\t * Hence we enforce that here rather than having to remember to do it\n\t * everywhere else that updates features2.\n\t */\n\tfrom->sb_bad_features2 = from->sb_features2;\n\tto->sb_features2 = cpu_to_be32(from->sb_features2);\n\tto->sb_bad_features2 = cpu_to_be32(from->sb_bad_features2);\n\n\tif (xfs_sb_version_hascrc(from)) {\n\t\tto->sb_features_compat = cpu_to_be32(from->sb_features_compat);\n\t\tto->sb_features_ro_compat =\n\t\t\t\tcpu_to_be32(from->sb_features_ro_compat);\n\t\tto->sb_features_incompat =\n\t\t\t\tcpu_to_be32(from->sb_features_incompat);\n\t\tto->sb_features_log_incompat =\n\t\t\t\tcpu_to_be32(from->sb_features_log_incompat);\n\t\tto->sb_pad = 0;\n\t\tto->sb_lsn = cpu_to_be64(from->sb_lsn);\n\t}\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_sb_to_disk(\n\tstruct xfs_dsb\t*to,\n\tstruct xfs_sb\t*from)\n{\n\txfs_sb_quota_to_disk(to, from);\n\n\tto->sb_magicnum = cpu_to_be32(from->sb_magicnum);\n\tto->sb_blocksize = cpu_to_be32(from->sb_blocksize);\n\tto->sb_dblocks = cpu_to_be64(from->sb_dblocks);\n\tto->sb_rblocks = cpu_to_be64(from->sb_rblocks);\n\tto->sb_rextents = cpu_to_be64(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = cpu_to_be64(from->sb_logstart);\n\tto->sb_rootino = cpu_to_be64(from->sb_rootino);\n\tto->sb_rbmino = cpu_to_be64(from->sb_rbmino);\n\tto->sb_rsumino = cpu_to_be64(from->sb_rsumino);\n\tto->sb_rextsize = cpu_to_be32(from->sb_rextsize);\n\tto->sb_agblocks = cpu_to_be32(from->sb_agblocks);\n\tto->sb_agcount = cpu_to_be32(from->sb_agcount);\n\tto->sb_rbmblocks = cpu_to_be32(from->sb_rbmblocks);\n\tto->sb_logblocks = cpu_to_be32(from->sb_logblocks);\n\tto->sb_versionnum = cpu_to_be16(from->sb_versionnum);\n\tto->sb_sectsize = cpu_to_be16(from->sb_sectsize);\n\tto->sb_inodesize = cpu_to_be16(from->sb_inodesize);\n\tto->sb_inopblock = cpu_to_be16(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = cpu_to_be64(from->sb_icount);\n\tto->sb_ifree = cpu_to_be64(from->sb_ifree);\n\tto->sb_fdblocks = cpu_to_be64(from->sb_fdblocks);\n\tto->sb_frextents = cpu_to_be64(from->sb_frextents);\n\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = cpu_to_be32(from->sb_inoalignmt);\n\tto->sb_unit = cpu_to_be32(from->sb_unit);\n\tto->sb_width = cpu_to_be32(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = cpu_to_be16(from->sb_logsectsize);\n\tto->sb_logsunit = cpu_to_be32(from->sb_logsunit);\n\n\t/*\n\t * We need to ensure that bad_features2 always matches features2.\n\t * Hence we enforce that here rather than having to remember to do it\n\t * everywhere else that updates features2.\n\t */\n\tfrom->sb_bad_features2 = from->sb_features2;\n\tto->sb_features2 = cpu_to_be32(from->sb_features2);\n\tto->sb_bad_features2 = cpu_to_be32(from->sb_bad_features2);\n\n\tif (xfs_sb_version_hascrc(from)) {\n\t\tto->sb_features_compat = cpu_to_be32(from->sb_features_compat);\n\t\tto->sb_features_ro_compat =\n\t\t\t\tcpu_to_be32(from->sb_features_ro_compat);\n\t\tto->sb_features_incompat =\n\t\t\t\tcpu_to_be32(from->sb_features_incompat);\n\t\tto->sb_features_log_incompat =\n\t\t\t\tcpu_to_be32(from->sb_features_log_incompat);\n\t\tto->sb_pad = 0;\n\t\tto->sb_lsn = cpu_to_be64(from->sb_lsn);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_SBP",
          "args": [
            "bp"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"error %d reading secondary superblock for ag %d\"",
            "error",
            "agno"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_zero",
          "args": [
            "bp",
            "0",
            "BBTOB(bp->b_length)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_length"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_buf",
          "args": [
            "NULL",
            "mp->m_ddev_targp",
            "XFS_AGB_TO_DADDR(mp, agno, XFS_SB_BLOCK(mp))",
            "XFS_FSS_TO_BB(mp, 1)",
            "0"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "166-176",
          "snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSS_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "agno",
            "XFS_SB_BLOCK(mp)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_SB_BLOCK",
          "args": [
            "mp"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "NULL",
            "mp->m_ddev_targp",
            "XFS_AGB_TO_DADDR(mp, agno, XFS_SB_BLOCK(mp))",
            "XFS_FSS_TO_BB(mp, 1)",
            "0",
            "&bp",
            "&xfs_sb_buf_ops"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSS_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "agno",
            "XFS_SB_BLOCK(mp)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_SB_BLOCK",
          "args": [
            "mp"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_set_low_space_thresholds",
          "args": [
            "mp"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_low_space_thresholds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "497-509",
          "snippet": "void\nxfs_set_low_space_thresholds(\n\tstruct xfs_mount\t*mp)\n{\n\tint i;\n\n\tfor (i = 0; i < XFS_LOWSP_MAX; i++) {\n\t\t__uint64_t space = mp->m_sb.sb_dblocks;\n\n\t\tdo_div(space, 100);\n\t\tmp->m_low_space[i] = space * (i + 1);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_set_low_space_thresholds(\n\tstruct xfs_mount\t*mp)\n{\n\tint i;\n\n\tfor (i = 0; i < XFS_LOWSP_MAX; i++) {\n\t\t__uint64_t space = mp->m_sb.sb_dblocks;\n\n\t\tdo_div(space, 100);\n\t\tmp->m_low_space[i] = space * (i + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "icount",
            "100"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_sb",
          "args": [
            "tp",
            "XFS_TRANS_SB_IMAXPCT",
            "dpct"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "297-395",
          "snippet": "void\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_free_extent",
          "args": [
            "tp",
            "XFS_AGB_TO_FSB(mp, agno,\n\t\t\tbe32_to_cpu(agf->agf_length) - new)",
            "new"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2587-2633",
          "snippet": "int\t\t\t\t/* error */\nxfs_free_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_fsblock_t\tbno,\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t/* length of extent */\n{\n\txfs_alloc_arg_t\targs;\n\tint\t\terror;\n\n\tASSERT(len != 0);\n\tmemset(&args, 0, sizeof(xfs_alloc_arg_t));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * validate that the block number is legal - the enables us to detect\n\t * and handle a silent filesystem corruption rather than crashing.\n\t */\n\targs.agno = XFS_FSB_TO_AGNO(args.mp, bno);\n\tif (args.agno >= args.mp->m_sb.sb_agcount)\n\t\treturn -EFSCORRUPTED;\n\n\targs.agbno = XFS_FSB_TO_AGBNO(args.mp, bno);\n\tif (args.agbno >= args.mp->m_sb.sb_agblocks)\n\t\treturn -EFSCORRUPTED;\n\n\targs.pag = xfs_perag_get(args.mp, args.agno);\n\tASSERT(args.pag);\n\n\terror = xfs_alloc_fix_freelist(&args, XFS_ALLOC_FLAG_FREEING);\n\tif (error)\n\t\tgoto error0;\n\n\t/* validate the extent size is legal now we have the agf locked */\n\tif (args.agbno + len >\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args.agbp)->agf_length)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\n\terror = xfs_free_ag_extent(tp, args.agbp, args.agno, args.agbno, len, 0);\n\tif (!error)\n\t\txfs_extent_busy_insert(tp, args.agno, args.agbno, len, 0);\nerror0:\n\txfs_perag_put(args.pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_free_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_fsblock_t\tbno,\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t/* length of extent */\n{\n\txfs_alloc_arg_t\targs;\n\tint\t\terror;\n\n\tASSERT(len != 0);\n\tmemset(&args, 0, sizeof(xfs_alloc_arg_t));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * validate that the block number is legal - the enables us to detect\n\t * and handle a silent filesystem corruption rather than crashing.\n\t */\n\targs.agno = XFS_FSB_TO_AGNO(args.mp, bno);\n\tif (args.agno >= args.mp->m_sb.sb_agcount)\n\t\treturn -EFSCORRUPTED;\n\n\targs.agbno = XFS_FSB_TO_AGBNO(args.mp, bno);\n\tif (args.agbno >= args.mp->m_sb.sb_agblocks)\n\t\treturn -EFSCORRUPTED;\n\n\targs.pag = xfs_perag_get(args.mp, args.agno);\n\tASSERT(args.pag);\n\n\terror = xfs_alloc_fix_freelist(&args, XFS_ALLOC_FLAG_FREEING);\n\tif (error)\n\t\tgoto error0;\n\n\t/* validate the extent size is legal now we have the agf locked */\n\tif (args.agbno + len >\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args.agbp)->agf_length)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\n\terror = xfs_free_ag_extent(tp, args.agbp, args.agno, args.agbno, len, 0);\n\tif (!error)\n\t\txfs_extent_busy_insert(tp, args.agno, args.agbno, len, 0);\nerror0:\n\txfs_perag_put(args.pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_FSB",
          "args": [
            "mp",
            "agno",
            "be32_to_cpu(agf->agf_length) - new"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_length"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_log_agf",
          "args": [
            "tp",
            "bp",
            "XFS_AGF_LENGTH"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_log_agf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2079-2110",
          "snippet": "void\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be32_to_cpu(agf->agf_length) ==\n\t\t       be32_to_cpu(agi->agi_length)"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_length"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_length"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agf->agf_length",
            "new"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "bp"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_read_agf",
          "args": [
            "mp",
            "tp",
            "agno",
            "0",
            "&bp"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_read_agf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2310-2364",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_ALLOC_FLAG_... */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tstruct xfs_agf\t\t*agf;\t\t/* ag freelist header */\n\tstruct xfs_perag\t*pag;\t\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_read_agf(mp, tp, agno,\n\t\t\t(flags & XFS_ALLOC_FLAG_TRYLOCK) ? XBF_TRYLOCK : 0,\n\t\t\tbpp);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\tASSERT(!(*bpp)->b_error);\n\n\tagf = XFS_BUF_TO_AGF(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagf_init) {\n\t\tpag->pagf_freeblks = be32_to_cpu(agf->agf_freeblks);\n\t\tpag->pagf_btreeblks = be32_to_cpu(agf->agf_btreeblks);\n\t\tpag->pagf_flcount = be32_to_cpu(agf->agf_flcount);\n\t\tpag->pagf_longest = be32_to_cpu(agf->agf_longest);\n\t\tpag->pagf_levels[XFS_BTNUM_BNOi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]);\n\t\tpag->pagf_levels[XFS_BTNUM_CNTi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]);\n\t\tspin_lock_init(&pag->pagb_lock);\n\t\tpag->pagb_count = 0;\n\t\tpag->pagb_tree = RB_ROOT;\n\t\tpag->pagf_init = 1;\n\t}\n#ifdef DEBUG\n\telse if (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tASSERT(pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks));\n\t\tASSERT(pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks));\n\t\tASSERT(pag->pagf_flcount == be32_to_cpu(agf->agf_flcount));\n\t\tASSERT(pag->pagf_longest == be32_to_cpu(agf->agf_longest));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_BNOi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_CNTi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]));\n\t}\n#endif\n\txfs_perag_put(pag);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_alloc_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_ALLOC_FLAG_... */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tstruct xfs_agf\t\t*agf;\t\t/* ag freelist header */\n\tstruct xfs_perag\t*pag;\t\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_read_agf(mp, tp, agno,\n\t\t\t(flags & XFS_ALLOC_FLAG_TRYLOCK) ? XBF_TRYLOCK : 0,\n\t\t\tbpp);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\tASSERT(!(*bpp)->b_error);\n\n\tagf = XFS_BUF_TO_AGF(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagf_init) {\n\t\tpag->pagf_freeblks = be32_to_cpu(agf->agf_freeblks);\n\t\tpag->pagf_btreeblks = be32_to_cpu(agf->agf_btreeblks);\n\t\tpag->pagf_flcount = be32_to_cpu(agf->agf_flcount);\n\t\tpag->pagf_longest = be32_to_cpu(agf->agf_longest);\n\t\tpag->pagf_levels[XFS_BTNUM_BNOi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]);\n\t\tpag->pagf_levels[XFS_BTNUM_CNTi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]);\n\t\tspin_lock_init(&pag->pagb_lock);\n\t\tpag->pagb_count = 0;\n\t\tpag->pagb_tree = RB_ROOT;\n\t\tpag->pagf_init = 1;\n\t}\n#ifdef DEBUG\n\telse if (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tASSERT(pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks));\n\t\tASSERT(pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks));\n\t\tASSERT(pag->pagf_flcount == be32_to_cpu(agf->agf_flcount));\n\t\tASSERT(pag->pagf_longest == be32_to_cpu(agf->agf_longest));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_BNOi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_CNTi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]));\n\t}\n#endif\n\txfs_perag_put(pag);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_log_agi",
          "args": [
            "tp",
            "bp",
            "XFS_AGI_LENGTH"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_log_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1971-2026",
          "snippet": "void\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nagcount == oagcount ||\n\t\t       be32_to_cpu(agi->agi_length) == mp->m_sb.sb_agblocks"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_length"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agi->agi_length",
            "new"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "bp"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_read_agi",
          "args": [
            "mp",
            "tp",
            "agno",
            "&bp"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_read_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2144-2177",
          "snippet": "int\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_agblocks_delta",
          "args": [
            "tp",
            "nfree"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_init_block",
          "args": [
            "mp",
            "bp",
            "XFS_FIBT_MAGIC",
            "0",
            "0",
            "agno",
            "0"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_init_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1022-1034",
          "snippet": "void\nxfs_btree_init_block(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\t__u32\t\tmagic,\n\t__u16\t\tlevel,\n\t__u16\t\tnumrecs,\n\t__u64\t\towner,\n\tunsigned int\tflags)\n{\n\txfs_btree_init_block_int(mp, XFS_BUF_TO_BLOCK(bp), bp->b_bn,\n\t\t\t\t magic, level, numrecs, owner, flags);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_init_block(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\t__u32\t\tmagic,\n\t__u16\t\tlevel,\n\t__u16\t\tnumrecs,\n\t__u64\t\towner,\n\tunsigned int\tflags)\n{\n\txfs_btree_init_block_int(mp, XFS_BUF_TO_BLOCK(bp), bp->b_bn,\n\t\t\t\t magic, level, numrecs, owner, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_growfs_get_hdr_buf",
          "args": [
            "mp",
            "XFS_AGB_TO_DADDR(mp, agno, XFS_FIBT_BLOCK(mp))",
            "BTOBB(mp->m_sb.sb_blocksize)",
            "0",
            "&xfs_inobt_buf_ops"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_growfs_get_hdr_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "119-139",
          "snippet": "static struct xfs_buf *\nxfs_growfs_get_hdr_buf(\n\tstruct xfs_mount\t*mp,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\tbp = xfs_buf_get_uncached(mp->m_ddev_targp, numblks, flags);\n\tif (!bp)\n\t\treturn NULL;\n\n\txfs_buf_zero(bp, 0, BBTOB(bp->b_length));\n\tbp->b_bn = blkno;\n\tbp->b_maps[0].bm_bn = blkno;\n\tbp->b_ops = ops;\n\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct xfs_buf *\nxfs_growfs_get_hdr_buf(\n\tstruct xfs_mount\t*mp,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\tbp = xfs_buf_get_uncached(mp->m_ddev_targp, numblks, flags);\n\tif (!bp)\n\t\treturn NULL;\n\n\txfs_buf_zero(bp, 0, BBTOB(bp->b_length));\n\tbp->b_bn = blkno;\n\tbp->b_maps[0].bm_bn = blkno;\n\tbp->b_ops = ops;\n\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "mp->m_sb.sb_blocksize"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "agno",
            "XFS_FIBT_BLOCK(mp)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FIBT_BLOCK",
          "args": [
            "mp"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasfinobt",
          "args": [
            "&mp->m_sb"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasfinobt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "565-569",
          "snippet": "static inline int xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "mp->m_sb.sb_blocksize"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "agno",
            "XFS_IBT_BLOCK(mp)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IBT_BLOCK",
          "args": [
            "mp"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "arec->ar_blockcount"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "agsize - be32_to_cpu(arec->ar_startblock)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "arec->ar_startblock"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_PREALLOC_BLOCKS(mp)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_PREALLOC_BLOCKS",
          "args": [
            "mp"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ALLOC_REC_ADDR",
          "args": [
            "mp",
            "XFS_BUF_TO_BLOCK(bp)",
            "1"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "mp->m_sb.sb_blocksize"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "agno",
            "XFS_CNT_BLOCK(mp)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_CNT_BLOCK",
          "args": [
            "mp"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "agsize - be32_to_cpu(arec->ar_startblock)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "arec->ar_startblock"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_PREALLOC_BLOCKS(mp)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_PREALLOC_BLOCKS",
          "args": [
            "mp"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ALLOC_REC_ADDR",
          "args": [
            "mp",
            "XFS_BUF_TO_BLOCK(bp)",
            "1"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "mp->m_sb.sb_blocksize"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "agno",
            "XFS_BNO_BLOCK(mp)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BNO_BLOCK",
          "args": [
            "mp"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGINO"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_FIBT_BLOCK(mp)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FIBT_BLOCK",
          "args": [
            "mp"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&agi->agi_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGINO"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGINO"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_IBT_BLOCK(mp)"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IBT_BLOCK",
          "args": [
            "mp"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "agsize"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "agno"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_AGI_VERSION"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_AGI_MAGIC"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "bp"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSS_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AG_DADDR",
          "args": [
            "mp",
            "agno",
            "XFS_AGI_DADDR(mp)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGI_DADDR",
          "args": [
            "mp"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGFL_SIZE",
          "args": [
            "mp"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGFL_BNO",
          "args": [
            "mp",
            "bp"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "agno"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_AGFL_MAGIC"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGFL",
          "args": [
            "bp"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSS_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AG_DADDR",
          "args": [
            "mp",
            "agno",
            "XFS_AGFL_DADDR(mp)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGFL_DADDR",
          "args": [
            "mp"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tmpsize"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tmpsize"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_PREALLOC_BLOCKS",
          "args": [
            "mp"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_AGFL_SIZE(mp) - 1"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGFL_SIZE",
          "args": [
            "mp"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_CNT_BLOCK(mp)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_CNT_BLOCK",
          "args": [
            "mp"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_BNO_BLOCK(mp)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BNO_BLOCK",
          "args": [
            "mp"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "agsize"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "agno"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_AGF_VERSION"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_AGF_MAGIC"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "bp"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSS_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AG_DADDR",
          "args": [
            "mp",
            "agno",
            "XFS_AGF_DADDR(mp)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGF_DADDR",
          "args": [
            "mp"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_growdata",
            "XFS_GROWFS_SPACE_RES(mp)",
            "0"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_GROWFS_SPACE_RES",
          "args": [
            "mp"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_GROWFS"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_initialize_perag",
          "args": [
            "mp",
            "nagcount",
            "&nagimax"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_initialize_perag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "181-263",
          "snippet": "int\nxfs_initialize_perag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagcount,\n\txfs_agnumber_t\t*maxagi)\n{\n\txfs_agnumber_t\tindex;\n\txfs_agnumber_t\tfirst_initialised = 0;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\txfs_ino_t\tino;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\tint\t\terror = -ENOMEM;\n\n\t/*\n\t * Walk the current per-ag tree so we don't try to initialise AGs\n\t * that already exist (growfs case). Allocate and insert all the\n\t * AGs we don't find ready for initialisation.\n\t */\n\tfor (index = 0; index < agcount; index++) {\n\t\tpag = xfs_perag_get(mp, index);\n\t\tif (pag) {\n\t\t\txfs_perag_put(pag);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first_initialised)\n\t\t\tfirst_initialised = index;\n\n\t\tpag = kmem_zalloc(sizeof(*pag), KM_MAYFAIL);\n\t\tif (!pag)\n\t\t\tgoto out_unwind;\n\t\tpag->pag_agno = index;\n\t\tpag->pag_mount = mp;\n\t\tspin_lock_init(&pag->pag_ici_lock);\n\t\tmutex_init(&pag->pag_ici_reclaim_lock);\n\t\tINIT_RADIX_TREE(&pag->pag_ici_root, GFP_ATOMIC);\n\t\tspin_lock_init(&pag->pag_buf_lock);\n\t\tpag->pag_buf_tree = RB_ROOT;\n\n\t\tif (radix_tree_preload(GFP_NOFS))\n\t\t\tgoto out_unwind;\n\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tif (radix_tree_insert(&mp->m_perag_tree, index, pag)) {\n\t\t\tBUG();\n\t\t\tspin_unlock(&mp->m_perag_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\terror = -EEXIST;\n\t\t\tgoto out_unwind;\n\t\t}\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tradix_tree_preload_end();\n\t}\n\n\t/*\n\t * If we mount with the inode64 option, or no inode overflows\n\t * the legacy 32-bit address space clear the inode32 option.\n\t */\n\tagino = XFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\n\tino = XFS_AGINO_TO_INO(mp, agcount - 1, agino);\n\n\tif ((mp->m_flags & XFS_MOUNT_SMALL_INUMS) && ino > XFS_MAXINUMBER_32)\n\t\tmp->m_flags |= XFS_MOUNT_32BITINODES;\n\telse\n\t\tmp->m_flags &= ~XFS_MOUNT_32BITINODES;\n\n\tif (mp->m_flags & XFS_MOUNT_32BITINODES)\n\t\tindex = xfs_set_inode32(mp, agcount);\n\telse\n\t\tindex = xfs_set_inode64(mp, agcount);\n\n\tif (maxagi)\n\t\t*maxagi = index;\n\treturn 0;\n\nout_unwind:\n\tkmem_free(pag);\n\tfor (; index > first_initialised; index--) {\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, index);\n\t\tkmem_free(pag);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_initialize_perag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagcount,\n\txfs_agnumber_t\t*maxagi)\n{\n\txfs_agnumber_t\tindex;\n\txfs_agnumber_t\tfirst_initialised = 0;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\txfs_ino_t\tino;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\tint\t\terror = -ENOMEM;\n\n\t/*\n\t * Walk the current per-ag tree so we don't try to initialise AGs\n\t * that already exist (growfs case). Allocate and insert all the\n\t * AGs we don't find ready for initialisation.\n\t */\n\tfor (index = 0; index < agcount; index++) {\n\t\tpag = xfs_perag_get(mp, index);\n\t\tif (pag) {\n\t\t\txfs_perag_put(pag);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first_initialised)\n\t\t\tfirst_initialised = index;\n\n\t\tpag = kmem_zalloc(sizeof(*pag), KM_MAYFAIL);\n\t\tif (!pag)\n\t\t\tgoto out_unwind;\n\t\tpag->pag_agno = index;\n\t\tpag->pag_mount = mp;\n\t\tspin_lock_init(&pag->pag_ici_lock);\n\t\tmutex_init(&pag->pag_ici_reclaim_lock);\n\t\tINIT_RADIX_TREE(&pag->pag_ici_root, GFP_ATOMIC);\n\t\tspin_lock_init(&pag->pag_buf_lock);\n\t\tpag->pag_buf_tree = RB_ROOT;\n\n\t\tif (radix_tree_preload(GFP_NOFS))\n\t\t\tgoto out_unwind;\n\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tif (radix_tree_insert(&mp->m_perag_tree, index, pag)) {\n\t\t\tBUG();\n\t\t\tspin_unlock(&mp->m_perag_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\terror = -EEXIST;\n\t\t\tgoto out_unwind;\n\t\t}\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tradix_tree_preload_end();\n\t}\n\n\t/*\n\t * If we mount with the inode64 option, or no inode overflows\n\t * the legacy 32-bit address space clear the inode32 option.\n\t */\n\tagino = XFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\n\tino = XFS_AGINO_TO_INO(mp, agcount - 1, agino);\n\n\tif ((mp->m_flags & XFS_MOUNT_SMALL_INUMS) && ino > XFS_MAXINUMBER_32)\n\t\tmp->m_flags |= XFS_MOUNT_32BITINODES;\n\telse\n\t\tmp->m_flags &= ~XFS_MOUNT_32BITINODES;\n\n\tif (mp->m_flags & XFS_MOUNT_32BITINODES)\n\t\tindex = xfs_set_inode32(mp, agcount);\n\telse\n\t\tindex = xfs_set_inode64(mp, agcount);\n\n\tif (maxagi)\n\t\t*maxagi = index;\n\treturn 0;\n\nout_unwind:\n\tkmem_free(pag);\n\tfor (; index > first_initialised; index--) {\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, index);\n\t\tkmem_free(pag);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "new",
            "mp->m_sb.sb_agblocks"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_read_uncached",
          "args": [
            "mp->m_ddev_targp",
            "XFS_FSB_TO_BB(mp, nb) - XFS_FSS_TO_BB(mp, 1)",
            "XFS_FSS_TO_BB(mp, 1)",
            "0",
            "&bp",
            "NULL"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_read_uncached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "689-722",
          "snippet": "int\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSS_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSS_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "nb"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_validate_fsb_count",
          "args": [
            "&mp->m_sb",
            "nb"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_validate_fsb_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "167-179",
          "snippet": "int\nxfs_sb_validate_fsb_count(\n\txfs_sb_t\t*sbp,\n\t__uint64_t\tnblocks)\n{\n\tASSERT(PAGE_SHIFT >= sbp->sb_blocklog);\n\tASSERT(sbp->sb_blocklog >= BBSHIFT);\n\n\t/* Limited by ULONG_MAX of page cache index */\n\tif (nblocks >> (PAGE_CACHE_SHIFT - sbp->sb_blocklog) > ULONG_MAX)\n\t\treturn -EFBIG;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sb_validate_fsb_count(\n\txfs_sb_t\t*sbp,\n\t__uint64_t\tnblocks)\n{\n\tASSERT(PAGE_SHIFT >= sbp->sb_blocklog);\n\tASSERT(sbp->sb_blocklog >= BBSHIFT);\n\n\t/* Limited by ULONG_MAX of page cache index */\n\tif (nblocks >> (PAGE_CACHE_SHIFT - sbp->sb_blocklog) > ULONG_MAX)\n\t\treturn -EFBIG;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_growfs_data_private(\n\txfs_mount_t\t\t*mp,\t\t/* mount point for filesystem */\n\txfs_growfs_data_t\t*in)\t\t/* growfs data input struct */\n{\n\txfs_agf_t\t\t*agf;\n\tstruct xfs_agfl\t\t*agfl;\n\txfs_agi_t\t\t*agi;\n\txfs_agnumber_t\t\tagno;\n\txfs_extlen_t\t\tagsize;\n\txfs_extlen_t\t\ttmpsize;\n\txfs_alloc_rec_t\t\t*arec;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\tbucket;\n\tint\t\t\tdpct;\n\tint\t\t\terror, saved_error = 0;\n\txfs_agnumber_t\t\tnagcount;\n\txfs_agnumber_t\t\tnagimax = 0;\n\txfs_rfsblock_t\t\tnb, nb_mod;\n\txfs_rfsblock_t\t\tnew;\n\txfs_rfsblock_t\t\tnfree;\n\txfs_agnumber_t\t\toagcount;\n\tint\t\t\tpct;\n\txfs_trans_t\t\t*tp;\n\n\tnb = in->newblocks;\n\tpct = in->imaxpct;\n\tif (nb < mp->m_sb.sb_dblocks || pct < 0 || pct > 100)\n\t\treturn -EINVAL;\n\tif ((error = xfs_sb_validate_fsb_count(&mp->m_sb, nb)))\n\t\treturn error;\n\tdpct = pct - mp->m_sb.sb_imax_pct;\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp,\n\t\t\t\tXFS_FSB_TO_BB(mp, nb) - XFS_FSS_TO_BB(mp, 1),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\txfs_buf_relse(bp);\n\n\tnew = nb;\t/* use new as a temporary here */\n\tnb_mod = do_div(new, mp->m_sb.sb_agblocks);\n\tnagcount = new + (nb_mod != 0);\n\tif (nb_mod && nb_mod < XFS_MIN_AG_BLOCKS) {\n\t\tnagcount--;\n\t\tnb = (xfs_rfsblock_t)nagcount * mp->m_sb.sb_agblocks;\n\t\tif (nb < mp->m_sb.sb_dblocks)\n\t\t\treturn -EINVAL;\n\t}\n\tnew = nb - mp->m_sb.sb_dblocks;\n\toagcount = mp->m_sb.sb_agcount;\n\n\t/* allocate the new per-ag structures */\n\tif (nagcount > oagcount) {\n\t\terror = xfs_initialize_perag(mp, nagcount, &nagimax);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFS);\n\ttp->t_flags |= XFS_TRANS_RESERVE;\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growdata,\n\t\t\t\t  XFS_GROWFS_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Write new AG headers to disk. Non-transactional, but written\n\t * synchronously so they are completed prior to the growfs transaction\n\t * being logged.\n\t */\n\tnfree = 0;\n\tfor (agno = nagcount - 1; agno >= oagcount; agno--, new -= agsize) {\n\t\t__be32\t*agfl_bno;\n\n\t\t/*\n\t\t * AG freespace header block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGF_DADDR(mp)),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0,\n\t\t\t\t&xfs_agf_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tagf = XFS_BUF_TO_AGF(bp);\n\t\tagf->agf_magicnum = cpu_to_be32(XFS_AGF_MAGIC);\n\t\tagf->agf_versionnum = cpu_to_be32(XFS_AGF_VERSION);\n\t\tagf->agf_seqno = cpu_to_be32(agno);\n\t\tif (agno == nagcount - 1)\n\t\t\tagsize =\n\t\t\t\tnb -\n\t\t\t\t(agno * (xfs_rfsblock_t)mp->m_sb.sb_agblocks);\n\t\telse\n\t\t\tagsize = mp->m_sb.sb_agblocks;\n\t\tagf->agf_length = cpu_to_be32(agsize);\n\t\tagf->agf_roots[XFS_BTNUM_BNOi] = cpu_to_be32(XFS_BNO_BLOCK(mp));\n\t\tagf->agf_roots[XFS_BTNUM_CNTi] = cpu_to_be32(XFS_CNT_BLOCK(mp));\n\t\tagf->agf_levels[XFS_BTNUM_BNOi] = cpu_to_be32(1);\n\t\tagf->agf_levels[XFS_BTNUM_CNTi] = cpu_to_be32(1);\n\t\tagf->agf_flfirst = 0;\n\t\tagf->agf_fllast = cpu_to_be32(XFS_AGFL_SIZE(mp) - 1);\n\t\tagf->agf_flcount = 0;\n\t\ttmpsize = agsize - XFS_PREALLOC_BLOCKS(mp);\n\t\tagf->agf_freeblks = cpu_to_be32(tmpsize);\n\t\tagf->agf_longest = cpu_to_be32(tmpsize);\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\tuuid_copy(&agf->agf_uuid, &mp->m_sb.sb_uuid);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * AG freelist header block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp)),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0,\n\t\t\t\t&xfs_agfl_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tagfl = XFS_BUF_TO_AGFL(bp);\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tagfl->agfl_magicnum = cpu_to_be32(XFS_AGFL_MAGIC);\n\t\t\tagfl->agfl_seqno = cpu_to_be32(agno);\n\t\t\tuuid_copy(&agfl->agfl_uuid, &mp->m_sb.sb_uuid);\n\t\t}\n\n\t\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, bp);\n\t\tfor (bucket = 0; bucket < XFS_AGFL_SIZE(mp); bucket++)\n\t\t\tagfl_bno[bucket] = cpu_to_be32(NULLAGBLOCK);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * AG inode header block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0,\n\t\t\t\t&xfs_agi_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tagi = XFS_BUF_TO_AGI(bp);\n\t\tagi->agi_magicnum = cpu_to_be32(XFS_AGI_MAGIC);\n\t\tagi->agi_versionnum = cpu_to_be32(XFS_AGI_VERSION);\n\t\tagi->agi_seqno = cpu_to_be32(agno);\n\t\tagi->agi_length = cpu_to_be32(agsize);\n\t\tagi->agi_count = 0;\n\t\tagi->agi_root = cpu_to_be32(XFS_IBT_BLOCK(mp));\n\t\tagi->agi_level = cpu_to_be32(1);\n\t\tagi->agi_freecount = 0;\n\t\tagi->agi_newino = cpu_to_be32(NULLAGINO);\n\t\tagi->agi_dirino = cpu_to_be32(NULLAGINO);\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\tuuid_copy(&agi->agi_uuid, &mp->m_sb.sb_uuid);\n\t\tif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\n\t\t\tagi->agi_free_root = cpu_to_be32(XFS_FIBT_BLOCK(mp));\n\t\t\tagi->agi_free_level = cpu_to_be32(1);\n\t\t}\n\t\tfor (bucket = 0; bucket < XFS_AGI_UNLINKED_BUCKETS; bucket++)\n\t\t\tagi->agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * BNO btree root block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_BNO_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_allocbt_buf_ops);\n\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTB_CRC_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, XFS_BTREE_CRC_BLOCKS);\n\t\telse\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTB_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, 0);\n\n\t\tarec = XFS_ALLOC_REC_ADDR(mp, XFS_BUF_TO_BLOCK(bp), 1);\n\t\tarec->ar_startblock = cpu_to_be32(XFS_PREALLOC_BLOCKS(mp));\n\t\tarec->ar_blockcount = cpu_to_be32(\n\t\t\tagsize - be32_to_cpu(arec->ar_startblock));\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * CNT btree root block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_CNT_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_allocbt_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTC_CRC_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, XFS_BTREE_CRC_BLOCKS);\n\t\telse\n\t\t\txfs_btree_init_block(mp, bp, XFS_ABTC_MAGIC, 0, 1,\n\t\t\t\t\t\tagno, 0);\n\n\t\tarec = XFS_ALLOC_REC_ADDR(mp, XFS_BUF_TO_BLOCK(bp), 1);\n\t\tarec->ar_startblock = cpu_to_be32(XFS_PREALLOC_BLOCKS(mp));\n\t\tarec->ar_blockcount = cpu_to_be32(\n\t\t\tagsize - be32_to_cpu(arec->ar_startblock));\n\t\tnfree += be32_to_cpu(arec->ar_blockcount);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * INO btree root block\n\t\t */\n\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_IBT_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_inobt_buf_ops);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\txfs_btree_init_block(mp, bp, XFS_IBT_CRC_MAGIC, 0, 0,\n\t\t\t\t\t\tagno, XFS_BTREE_CRC_BLOCKS);\n\t\telse\n\t\t\txfs_btree_init_block(mp, bp, XFS_IBT_MAGIC, 0, 0,\n\t\t\t\t\t\tagno, 0);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/*\n\t\t * FINO btree root block\n\t\t */\n\t\tif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\n\t\t\tbp = xfs_growfs_get_hdr_buf(mp,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, agno, XFS_FIBT_BLOCK(mp)),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize), 0,\n\t\t\t\t&xfs_inobt_buf_ops);\n\t\t\tif (!bp) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto error0;\n\t\t\t}\n\n\t\t\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\t\txfs_btree_init_block(mp, bp, XFS_FIBT_CRC_MAGIC,\n\t\t\t\t\t\t     0, 0, agno,\n\t\t\t\t\t\t     XFS_BTREE_CRC_BLOCKS);\n\t\t\telse\n\t\t\t\txfs_btree_init_block(mp, bp, XFS_FIBT_MAGIC, 0,\n\t\t\t\t\t\t     0, agno, 0);\n\n\t\t\terror = xfs_bwrite(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n\n\t}\n\txfs_trans_agblocks_delta(tp, nfree);\n\t/*\n\t * There are new blocks in the old last a.g.\n\t */\n\tif (new) {\n\t\t/*\n\t\t * Change the agi length.\n\t\t */\n\t\terror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\t\tASSERT(bp);\n\t\tagi = XFS_BUF_TO_AGI(bp);\n\t\tbe32_add_cpu(&agi->agi_length, new);\n\t\tASSERT(nagcount == oagcount ||\n\t\t       be32_to_cpu(agi->agi_length) == mp->m_sb.sb_agblocks);\n\t\txfs_ialloc_log_agi(tp, bp, XFS_AGI_LENGTH);\n\t\t/*\n\t\t * Change agf length.\n\t\t */\n\t\terror = xfs_alloc_read_agf(mp, tp, agno, 0, &bp);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\t\tASSERT(bp);\n\t\tagf = XFS_BUF_TO_AGF(bp);\n\t\tbe32_add_cpu(&agf->agf_length, new);\n\t\tASSERT(be32_to_cpu(agf->agf_length) ==\n\t\t       be32_to_cpu(agi->agi_length));\n\n\t\txfs_alloc_log_agf(tp, bp, XFS_AGF_LENGTH);\n\t\t/*\n\t\t * Free the new space.\n\t\t */\n\t\terror = xfs_free_extent(tp, XFS_AGB_TO_FSB(mp, agno,\n\t\t\tbe32_to_cpu(agf->agf_length) - new), new);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\t}\n\n\t/*\n\t * Update changed superblock fields transactionally. These are not\n\t * seen by the rest of the world until the transaction commit applies\n\t * them atomically to the superblock.\n\t */\n\tif (nagcount > oagcount)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_AGCOUNT, nagcount - oagcount);\n\tif (nb > mp->m_sb.sb_dblocks)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_DBLOCKS,\n\t\t\t\t nb - mp->m_sb.sb_dblocks);\n\tif (nfree)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, nfree);\n\tif (dpct)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IMAXPCT, dpct);\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/* New allocation groups fully initialized, so update mount struct */\n\tif (nagimax)\n\t\tmp->m_maxagi = nagimax;\n\tif (mp->m_sb.sb_imax_pct) {\n\t\t__uint64_t icount = mp->m_sb.sb_dblocks * mp->m_sb.sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\tmp->m_maxicount = icount << mp->m_sb.sb_inopblog;\n\t} else\n\t\tmp->m_maxicount = 0;\n\txfs_set_low_space_thresholds(mp);\n\n\t/* update secondary superblocks. */\n\tfor (agno = 1; agno < nagcount; agno++) {\n\t\terror = 0;\n\t\t/*\n\t\t * new secondary superblocks need to be zeroed, not read from\n\t\t * disk as the contents of the new area we are growing into is\n\t\t * completely unknown.\n\t\t */\n\t\tif (agno < oagcount) {\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t  XFS_AGB_TO_DADDR(mp, agno, XFS_SB_BLOCK(mp)),\n\t\t\t\t  XFS_FSS_TO_BB(mp, 1), 0, &bp,\n\t\t\t\t  &xfs_sb_buf_ops);\n\t\t} else {\n\t\t\tbp = xfs_trans_get_buf(NULL, mp->m_ddev_targp,\n\t\t\t\t  XFS_AGB_TO_DADDR(mp, agno, XFS_SB_BLOCK(mp)),\n\t\t\t\t  XFS_FSS_TO_BB(mp, 1), 0);\n\t\t\tif (bp) {\n\t\t\t\tbp->b_ops = &xfs_sb_buf_ops;\n\t\t\t\txfs_buf_zero(bp, 0, BBTOB(bp->b_length));\n\t\t\t} else\n\t\t\t\terror = -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * If we get an error reading or writing alternate superblocks,\n\t\t * continue.  xfs_repair chooses the \"best\" superblock based\n\t\t * on most matches; if we break early, we'll leave more\n\t\t * superblocks un-updated than updated, and xfs_repair may\n\t\t * pick them over the properly-updated primary.\n\t\t */\n\t\tif (error) {\n\t\t\txfs_warn(mp,\n\t\t\"error %d reading secondary superblock for ag %d\",\n\t\t\t\terror, agno);\n\t\t\tsaved_error = error;\n\t\t\tcontinue;\n\t\t}\n\t\txfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error) {\n\t\t\txfs_warn(mp,\n\t\t\"write error %d updating secondary superblock for ag %d\",\n\t\t\t\terror, agno);\n\t\t\tsaved_error = error;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn saved_error ? saved_error : error;\n\n error0:\n\txfs_trans_cancel(tp, XFS_TRANS_ABORT);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_growfs_get_hdr_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
    "lines": "119-139",
    "snippet": "static struct xfs_buf *\nxfs_growfs_get_hdr_buf(\n\tstruct xfs_mount\t*mp,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\tbp = xfs_buf_get_uncached(mp->m_ddev_targp, numblks, flags);\n\tif (!bp)\n\t\treturn NULL;\n\n\txfs_buf_zero(bp, 0, BBTOB(bp->b_length));\n\tbp->b_bn = blkno;\n\tbp->b_maps[0].bm_bn = blkno;\n\tbp->b_ops = ops;\n\n\treturn bp;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_zero",
          "args": [
            "bp",
            "0",
            "BBTOB(bp->b_length)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_length"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_get_uncached",
          "args": [
            "mp->m_ddev_targp",
            "numblks",
            "flags"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_get_uncached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "801-847",
          "snippet": "xfs_buf_t *\nxfs_buf_get_uncached(\n\tstruct xfs_buftarg\t*target,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags)\n{\n\tunsigned long\t\tpage_count;\n\tint\t\t\terror, i;\n\tstruct xfs_buf\t\t*bp;\n\tDEFINE_SINGLE_BUF_MAP(map, XFS_BUF_DADDR_NULL, numblks);\n\n\tbp = _xfs_buf_alloc(target, &map, 1, 0);\n\tif (unlikely(bp == NULL))\n\t\tgoto fail;\n\n\tpage_count = PAGE_ALIGN(numblks << BBSHIFT) >> PAGE_SHIFT;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (error)\n\t\tgoto fail_free_buf;\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tbp->b_pages[i] = alloc_page(xb_to_gfp(flags));\n\t\tif (!bp->b_pages[i])\n\t\t\tgoto fail_free_mem;\n\t}\n\tbp->b_flags |= _XBF_PAGES;\n\n\terror = _xfs_buf_map_pages(bp, 0);\n\tif (unlikely(error)) {\n\t\txfs_warn(target->bt_mount,\n\t\t\t\"%s: failed to map pages\", __func__);\n\t\tgoto fail_free_mem;\n\t}\n\n\ttrace_xfs_buf_get_uncached(bp, _RET_IP_);\n\treturn bp;\n\n fail_free_mem:\n\twhile (--i >= 0)\n\t\t__free_page(bp->b_pages[i]);\n\t_xfs_buf_free_pages(bp);\n fail_free_buf:\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n fail:\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nxfs_buf_t *\nxfs_buf_get_uncached(\n\tstruct xfs_buftarg\t*target,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags)\n{\n\tunsigned long\t\tpage_count;\n\tint\t\t\terror, i;\n\tstruct xfs_buf\t\t*bp;\n\tDEFINE_SINGLE_BUF_MAP(map, XFS_BUF_DADDR_NULL, numblks);\n\n\tbp = _xfs_buf_alloc(target, &map, 1, 0);\n\tif (unlikely(bp == NULL))\n\t\tgoto fail;\n\n\tpage_count = PAGE_ALIGN(numblks << BBSHIFT) >> PAGE_SHIFT;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (error)\n\t\tgoto fail_free_buf;\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tbp->b_pages[i] = alloc_page(xb_to_gfp(flags));\n\t\tif (!bp->b_pages[i])\n\t\t\tgoto fail_free_mem;\n\t}\n\tbp->b_flags |= _XBF_PAGES;\n\n\terror = _xfs_buf_map_pages(bp, 0);\n\tif (unlikely(error)) {\n\t\txfs_warn(target->bt_mount,\n\t\t\t\"%s: failed to map pages\", __func__);\n\t\tgoto fail_free_mem;\n\t}\n\n\ttrace_xfs_buf_get_uncached(bp, _RET_IP_);\n\treturn bp;\n\n fail_free_mem:\n\twhile (--i >= 0)\n\t\t__free_page(bp->b_pages[i]);\n\t_xfs_buf_free_pages(bp);\n fail_free_buf:\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n fail:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct xfs_buf *\nxfs_growfs_get_hdr_buf(\n\tstruct xfs_mount\t*mp,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\tbp = xfs_buf_get_uncached(mp->m_ddev_targp, numblks, flags);\n\tif (!bp)\n\t\treturn NULL;\n\n\txfs_buf_zero(bp, 0, BBTOB(bp->b_length));\n\tbp->b_bn = blkno;\n\tbp->b_maps[0].bm_bn = blkno;\n\tbp->b_ops = ops;\n\n\treturn bp;\n}"
  },
  {
    "function_name": "xfs_fs_geometry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
    "lines": "48-117",
    "snippet": "int\nxfs_fs_geometry(\n\txfs_mount_t\t\t*mp,\n\txfs_fsop_geom_t\t\t*geo,\n\tint\t\t\tnew_version)\n{\n\n\tmemset(geo, 0, sizeof(*geo));\n\n\tgeo->blocksize = mp->m_sb.sb_blocksize;\n\tgeo->rtextsize = mp->m_sb.sb_rextsize;\n\tgeo->agblocks = mp->m_sb.sb_agblocks;\n\tgeo->agcount = mp->m_sb.sb_agcount;\n\tgeo->logblocks = mp->m_sb.sb_logblocks;\n\tgeo->sectsize = mp->m_sb.sb_sectsize;\n\tgeo->inodesize = mp->m_sb.sb_inodesize;\n\tgeo->imaxpct = mp->m_sb.sb_imax_pct;\n\tgeo->datablocks = mp->m_sb.sb_dblocks;\n\tgeo->rtblocks = mp->m_sb.sb_rblocks;\n\tgeo->rtextents = mp->m_sb.sb_rextents;\n\tgeo->logstart = mp->m_sb.sb_logstart;\n\tASSERT(sizeof(geo->uuid)==sizeof(mp->m_sb.sb_uuid));\n\tmemcpy(geo->uuid, &mp->m_sb.sb_uuid, sizeof(mp->m_sb.sb_uuid));\n\tif (new_version >= 2) {\n\t\tgeo->sunit = mp->m_sb.sb_unit;\n\t\tgeo->swidth = mp->m_sb.sb_width;\n\t}\n\tif (new_version >= 3) {\n\t\tgeo->version = XFS_FSOP_GEOM_VERSION;\n\t\tgeo->flags = XFS_FSOP_GEOM_FLAGS_NLINK |\n\t\t\t     XFS_FSOP_GEOM_FLAGS_DIRV2 |\n\t\t\t(xfs_sb_version_hasattr(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR : 0) |\n\t\t\t(xfs_sb_version_hasquota(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_QUOTA : 0) |\n\t\t\t(xfs_sb_version_hasalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_IALIGN : 0) |\n\t\t\t(xfs_sb_version_hasdalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DALIGN : 0) |\n\t\t\t(xfs_sb_version_hasextflgbit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_EXTFLG : 0) |\n\t\t\t(xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_SECTOR : 0) |\n\t\t\t(xfs_sb_version_hasasciici(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DIRV2CI : 0) |\n\t\t\t(xfs_sb_version_haslazysbcount(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LAZYSB : 0) |\n\t\t\t(xfs_sb_version_hasattr2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR2 : 0) |\n\t\t\t(xfs_sb_version_hasprojid32bit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_PROJID32 : 0) |\n\t\t\t(xfs_sb_version_hascrc(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_V5SB : 0) |\n\t\t\t(xfs_sb_version_hasftype(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FTYPE : 0) |\n\t\t\t(xfs_sb_version_hasfinobt(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FINOBT : 0);\n\t\tgeo->logsectsize = xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tmp->m_sb.sb_logsectsize : BBSIZE;\n\t\tgeo->rtsectsize = mp->m_sb.sb_blocksize;\n\t\tgeo->dirblocksize = mp->m_dir_geo->blksize;\n\t}\n\tif (new_version >= 4) {\n\t\tgeo->flags |=\n\t\t\t(xfs_sb_version_haslogv2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LOGV2 : 0);\n\t\tgeo->logsunit = mp->m_sb.sb_logsunit;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&mp->m_sb"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hassector",
          "args": [
            "&mp->m_sb"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hassector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "422-425",
          "snippet": "static inline bool xfs_sb_version_hassector(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_SECTORBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_SECTORBIT\t0x0800"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_SECTORBIT\t0x0800\n\nstatic inline bool xfs_sb_version_hassector(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_SECTORBIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasfinobt",
          "args": [
            "&mp->m_sb"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasfinobt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "565-569",
          "snippet": "static inline int xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasftype",
          "args": [
            "&mp->m_sb"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasftype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "557-563",
          "snippet": "static inline int xfs_sb_version_hasftype(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&\n\t\txfs_sb_has_incompat_feature(sbp, XFS_SB_FEAT_INCOMPAT_FTYPE)) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t (sbp->sb_features2 & XFS_SB_VERSION2_FTYPE));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_FEAT_INCOMPAT_FTYPE\t(1 << 0)\t/* filetype in dirent */",
            "#define XFS_SB_VERSION2_FTYPE\t\t0x00000200\t/* inode type in dir */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_FEAT_INCOMPAT_FTYPE\t(1 << 0)\t/* filetype in dirent */\n#define XFS_SB_VERSION2_FTYPE\t\t0x00000200\t/* inode type in dir */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hasftype(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&\n\t\txfs_sb_has_incompat_feature(sbp, XFS_SB_FEAT_INCOMPAT_FTYPE)) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t (sbp->sb_features2 & XFS_SB_VERSION2_FTYPE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasprojid32bit",
          "args": [
            "&mp->m_sb"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasprojid32bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "468-473",
          "snippet": "static inline bool xfs_sb_version_hasprojid32bit(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_PROJID32BIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_PROJID32BIT\t0x00000080\t/* 32 bit project id */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_PROJID32BIT\t0x00000080\t/* 32 bit project id */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasprojid32bit(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_PROJID32BIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasattr2",
          "args": [
            "&mp->m_sb"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasattr2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "448-453",
          "snippet": "static inline bool xfs_sb_version_hasattr2(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_ATTR2BIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasattr2(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_ATTR2BIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslazysbcount",
          "args": [
            "&mp->m_sb"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslazysbcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "441-446",
          "snippet": "static inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasasciici",
          "args": [
            "&mp->m_sb"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasasciici",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "427-430",
          "snippet": "static inline bool xfs_sb_version_hasasciici(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_BORGBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_BORGBIT\t\t0x4000\t/* ASCII only case-insens. */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_BORGBIT\t\t0x4000\t/* ASCII only case-insens. */\n\nstatic inline bool xfs_sb_version_hasasciici(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_BORGBIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasextflgbit",
          "args": [
            "&mp->m_sb"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasextflgbit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "416-420",
          "snippet": "static inline bool xfs_sb_version_hasextflgbit(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_EXTFLGBIT\t0x1000",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_EXTFLGBIT\t0x1000\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasextflgbit(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasdalign",
          "args": [
            "&mp->m_sb"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasdalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "405-408",
          "snippet": "static inline bool xfs_sb_version_hasdalign(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_DALIGNBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_DALIGNBIT\t0x0100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_DALIGNBIT\t0x0100\n\nstatic inline bool xfs_sb_version_hasdalign(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_DALIGNBIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasalign",
          "args": [
            "&mp->m_sb"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "399-403",
          "snippet": "static inline bool xfs_sb_version_hasalign(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t\t(sbp->sb_versionnum & XFS_SB_VERSION_ALIGNBIT));\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_ALIGNBIT\t\t0x0080",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_ALIGNBIT\t\t0x0080\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasalign(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t\t(sbp->sb_versionnum & XFS_SB_VERSION_ALIGNBIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasquota",
          "args": [
            "&mp->m_sb"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasquota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "389-392",
          "snippet": "static inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040\n\nstatic inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "geo->uuid",
            "&mp->m_sb.sb_uuid",
            "sizeof(mp->m_sb.sb_uuid)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "sizeof(geo->uuid)==sizeof(mp->m_sb.sb_uuid)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "geo",
            "0",
            "sizeof(*geo)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_fs_geometry(\n\txfs_mount_t\t\t*mp,\n\txfs_fsop_geom_t\t\t*geo,\n\tint\t\t\tnew_version)\n{\n\n\tmemset(geo, 0, sizeof(*geo));\n\n\tgeo->blocksize = mp->m_sb.sb_blocksize;\n\tgeo->rtextsize = mp->m_sb.sb_rextsize;\n\tgeo->agblocks = mp->m_sb.sb_agblocks;\n\tgeo->agcount = mp->m_sb.sb_agcount;\n\tgeo->logblocks = mp->m_sb.sb_logblocks;\n\tgeo->sectsize = mp->m_sb.sb_sectsize;\n\tgeo->inodesize = mp->m_sb.sb_inodesize;\n\tgeo->imaxpct = mp->m_sb.sb_imax_pct;\n\tgeo->datablocks = mp->m_sb.sb_dblocks;\n\tgeo->rtblocks = mp->m_sb.sb_rblocks;\n\tgeo->rtextents = mp->m_sb.sb_rextents;\n\tgeo->logstart = mp->m_sb.sb_logstart;\n\tASSERT(sizeof(geo->uuid)==sizeof(mp->m_sb.sb_uuid));\n\tmemcpy(geo->uuid, &mp->m_sb.sb_uuid, sizeof(mp->m_sb.sb_uuid));\n\tif (new_version >= 2) {\n\t\tgeo->sunit = mp->m_sb.sb_unit;\n\t\tgeo->swidth = mp->m_sb.sb_width;\n\t}\n\tif (new_version >= 3) {\n\t\tgeo->version = XFS_FSOP_GEOM_VERSION;\n\t\tgeo->flags = XFS_FSOP_GEOM_FLAGS_NLINK |\n\t\t\t     XFS_FSOP_GEOM_FLAGS_DIRV2 |\n\t\t\t(xfs_sb_version_hasattr(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR : 0) |\n\t\t\t(xfs_sb_version_hasquota(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_QUOTA : 0) |\n\t\t\t(xfs_sb_version_hasalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_IALIGN : 0) |\n\t\t\t(xfs_sb_version_hasdalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DALIGN : 0) |\n\t\t\t(xfs_sb_version_hasextflgbit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_EXTFLG : 0) |\n\t\t\t(xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_SECTOR : 0) |\n\t\t\t(xfs_sb_version_hasasciici(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DIRV2CI : 0) |\n\t\t\t(xfs_sb_version_haslazysbcount(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LAZYSB : 0) |\n\t\t\t(xfs_sb_version_hasattr2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR2 : 0) |\n\t\t\t(xfs_sb_version_hasprojid32bit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_PROJID32 : 0) |\n\t\t\t(xfs_sb_version_hascrc(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_V5SB : 0) |\n\t\t\t(xfs_sb_version_hasftype(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FTYPE : 0) |\n\t\t\t(xfs_sb_version_hasfinobt(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FINOBT : 0);\n\t\tgeo->logsectsize = xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tmp->m_sb.sb_logsectsize : BBSIZE;\n\t\tgeo->rtsectsize = mp->m_sb.sb_blocksize;\n\t\tgeo->dirblocksize = mp->m_dir_geo->blksize;\n\t}\n\tif (new_version >= 4) {\n\t\tgeo->flags |=\n\t\t\t(xfs_sb_version_haslogv2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LOGV2 : 0);\n\t\tgeo->logsunit = mp->m_sb.sb_logsunit;\n\t}\n\treturn 0;\n}"
  }
]