[
  {
    "function_name": "sysfs_remove_bin_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "492-496",
    "snippet": "void sysfs_remove_bin_file(struct kobject *kobj,\n\t\t\t   const struct bin_attribute *attr)\n{\n\tkernfs_remove_by_name(kobj->sd, attr->attr.name);\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_remove_by_name",
          "args": [
            "kobj->sd",
            "attr->attr.name"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nvoid sysfs_remove_bin_file(struct kobject *kobj,\n\t\t\t   const struct bin_attribute *attr)\n{\n\tkernfs_remove_by_name(kobj->sd, attr->attr.name);\n}"
  },
  {
    "function_name": "sysfs_create_bin_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "478-484",
    "snippet": "int sysfs_create_bin_file(struct kobject *kobj,\n\t\t\t  const struct bin_attribute *attr)\n{\n\tBUG_ON(!kobj || !kobj->sd || !attr);\n\n\treturn sysfs_add_file(kobj->sd, &attr->attr, true);\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_add_file",
          "args": [
            "kobj->sd",
            "&attr->attr",
            "true"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_add_file_to_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
          "lines": "349-369",
          "snippet": "int sysfs_add_file_to_group(struct kobject *kobj,\n\t\tconst struct attribute *attr, const char *group)\n{\n\tstruct kernfs_node *parent;\n\tint error;\n\n\tif (group) {\n\t\tparent = kernfs_find_and_get(kobj->sd, group);\n\t} else {\n\t\tparent = kobj->sd;\n\t\tkernfs_get(parent);\n\t}\n\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\terror = sysfs_add_file(parent, attr, false);\n\tkernfs_put(parent);\n\n\treturn error;\n}",
          "includes": [
            "#include \"../kernfs/kernfs-internal.h\"",
            "#include \"sysfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nint sysfs_add_file_to_group(struct kobject *kobj,\n\t\tconst struct attribute *attr, const char *group)\n{\n\tstruct kernfs_node *parent;\n\tint error;\n\n\tif (group) {\n\t\tparent = kernfs_find_and_get(kobj->sd, group);\n\t} else {\n\t\tparent = kobj->sd;\n\t\tkernfs_get(parent);\n\t}\n\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\terror = sysfs_add_file(parent, attr, false);\n\tkernfs_put(parent);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!kobj || !kobj->sd || !attr"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nint sysfs_create_bin_file(struct kobject *kobj,\n\t\t\t  const struct bin_attribute *attr)\n{\n\tBUG_ON(!kobj || !kobj->sd || !attr);\n\n\treturn sysfs_add_file(kobj->sd, &attr->attr, true);\n}"
  },
  {
    "function_name": "sysfs_remove_file_from_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "454-470",
    "snippet": "void sysfs_remove_file_from_group(struct kobject *kobj,\n\t\tconst struct attribute *attr, const char *group)\n{\n\tstruct kernfs_node *parent;\n\n\tif (group) {\n\t\tparent = kernfs_find_and_get(kobj->sd, group);\n\t} else {\n\t\tparent = kobj->sd;\n\t\tkernfs_get(parent);\n\t}\n\n\tif (parent) {\n\t\tkernfs_remove_by_name(parent, attr->name);\n\t\tkernfs_put(parent);\n\t}\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "parent"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_remove_by_name",
          "args": [
            "parent",
            "attr->name"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "parent"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get",
          "args": [
            "kobj->sd",
            "group"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nvoid sysfs_remove_file_from_group(struct kobject *kobj,\n\t\tconst struct attribute *attr, const char *group)\n{\n\tstruct kernfs_node *parent;\n\n\tif (group) {\n\t\tparent = kernfs_find_and_get(kobj->sd, group);\n\t} else {\n\t\tparent = kobj->sd;\n\t\tkernfs_get(parent);\n\t}\n\n\tif (parent) {\n\t\tkernfs_remove_by_name(parent, attr->name);\n\t\tkernfs_put(parent);\n\t}\n}"
  },
  {
    "function_name": "sysfs_remove_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "440-445",
    "snippet": "void sysfs_remove_files(struct kobject *kobj, const struct attribute **ptr)\n{\n\tint i;\n\tfor (i = 0; ptr[i]; i++)\n\t\tsysfs_remove_file(kobj, ptr[i]);\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_remove_file",
          "args": [
            "kobj",
            "ptr[i]"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_remove_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
          "lines": "440-445",
          "snippet": "void sysfs_remove_files(struct kobject *kobj, const struct attribute **ptr)\n{\n\tint i;\n\tfor (i = 0; ptr[i]; i++)\n\t\tsysfs_remove_file(kobj, ptr[i]);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nvoid sysfs_remove_files(struct kobject *kobj, const struct attribute **ptr)\n{\n\tint i;\n\tfor (i = 0; ptr[i]; i++)\n\t\tsysfs_remove_file(kobj, ptr[i]);\n}"
  },
  {
    "function_name": "sysfs_remove_file_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "424-438",
    "snippet": "bool sysfs_remove_file_self(struct kobject *kobj, const struct attribute *attr)\n{\n\tstruct kernfs_node *parent = kobj->sd;\n\tstruct kernfs_node *kn;\n\tbool ret;\n\n\tkn = kernfs_find_and_get(parent, attr->name);\n\tif (WARN_ON_ONCE(!kn))\n\t\treturn false;\n\n\tret = kernfs_remove_self(kn);\n\n\tkernfs_put(kn);\n\treturn ret;\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_remove_self",
          "args": [
            "kn"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_remove_self",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1144-1193",
          "snippet": "bool kernfs_remove_self(struct kernfs_node *kn)\n{\n\tbool ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_break_active_protection(kn);\n\n\t/*\n\t * SUICIDAL is used to arbitrate among competing invocations.  Only\n\t * the first one will actually perform removal.  When the removal\n\t * is complete, SUICIDED is set and the active ref is restored\n\t * while holding kernfs_mutex.  The ones which lost arbitration\n\t * waits for SUICDED && drained which can happen only after the\n\t * enclosing kernfs operation which executed the winning instance\n\t * of kernfs_remove_self() finished.\n\t */\n\tif (!(kn->flags & KERNFS_SUICIDAL)) {\n\t\tkn->flags |= KERNFS_SUICIDAL;\n\t\t__kernfs_remove(kn);\n\t\tkn->flags |= KERNFS_SUICIDED;\n\t\tret = true;\n\t} else {\n\t\twait_queue_head_t *waitq = &kernfs_root(kn)->deactivate_waitq;\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (true) {\n\t\t\tprepare_to_wait(waitq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\t\tif ((kn->flags & KERNFS_SUICIDED) &&\n\t\t\t    atomic_read(&kn->active) == KN_DEACTIVATED_BIAS)\n\t\t\t\tbreak;\n\n\t\t\tmutex_unlock(&kernfs_mutex);\n\t\t\tschedule();\n\t\t\tmutex_lock(&kernfs_mutex);\n\t\t}\n\t\tfinish_wait(waitq, &wait);\n\t\tWARN_ON_ONCE(!RB_EMPTY_NODE(&kn->rb));\n\t\tret = false;\n\t}\n\n\t/*\n\t * This must be done while holding kernfs_mutex; otherwise, waiting\n\t * for SUICIDED && deactivated could finish prematurely.\n\t */\n\tkernfs_unbreak_active_protection(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nbool kernfs_remove_self(struct kernfs_node *kn)\n{\n\tbool ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_break_active_protection(kn);\n\n\t/*\n\t * SUICIDAL is used to arbitrate among competing invocations.  Only\n\t * the first one will actually perform removal.  When the removal\n\t * is complete, SUICIDED is set and the active ref is restored\n\t * while holding kernfs_mutex.  The ones which lost arbitration\n\t * waits for SUICDED && drained which can happen only after the\n\t * enclosing kernfs operation which executed the winning instance\n\t * of kernfs_remove_self() finished.\n\t */\n\tif (!(kn->flags & KERNFS_SUICIDAL)) {\n\t\tkn->flags |= KERNFS_SUICIDAL;\n\t\t__kernfs_remove(kn);\n\t\tkn->flags |= KERNFS_SUICIDED;\n\t\tret = true;\n\t} else {\n\t\twait_queue_head_t *waitq = &kernfs_root(kn)->deactivate_waitq;\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (true) {\n\t\t\tprepare_to_wait(waitq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\t\tif ((kn->flags & KERNFS_SUICIDED) &&\n\t\t\t    atomic_read(&kn->active) == KN_DEACTIVATED_BIAS)\n\t\t\t\tbreak;\n\n\t\t\tmutex_unlock(&kernfs_mutex);\n\t\t\tschedule();\n\t\t\tmutex_lock(&kernfs_mutex);\n\t\t}\n\t\tfinish_wait(waitq, &wait);\n\t\tWARN_ON_ONCE(!RB_EMPTY_NODE(&kn->rb));\n\t\tret = false;\n\t}\n\n\t/*\n\t * This must be done while holding kernfs_mutex; otherwise, waiting\n\t * for SUICIDED && deactivated could finish prematurely.\n\t */\n\tkernfs_unbreak_active_protection(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!kn"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get",
          "args": [
            "parent",
            "attr->name"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nbool sysfs_remove_file_self(struct kobject *kobj, const struct attribute *attr)\n{\n\tstruct kernfs_node *parent = kobj->sd;\n\tstruct kernfs_node *kn;\n\tbool ret;\n\n\tkn = kernfs_find_and_get(parent, attr->name);\n\tif (WARN_ON_ONCE(!kn))\n\t\treturn false;\n\n\tret = kernfs_remove_self(kn);\n\n\tkernfs_put(kn);\n\treturn ret;\n}"
  },
  {
    "function_name": "sysfs_remove_file_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "408-414",
    "snippet": "void sysfs_remove_file_ns(struct kobject *kobj, const struct attribute *attr,\n\t\t\t  const void *ns)\n{\n\tstruct kernfs_node *parent = kobj->sd;\n\n\tkernfs_remove_by_name_ns(parent, attr->name, ns);\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_remove_by_name_ns",
          "args": [
            "parent",
            "attr->name",
            "ns"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_remove_by_name_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1204-1227",
          "snippet": "int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,\n\t\t\t     const void *ns)\n{\n\tstruct kernfs_node *kn;\n\n\tif (!parent) {\n\t\tWARN(1, KERN_WARNING \"kernfs: can not remove '%s', no directory\\n\",\n\t\t\tname);\n\t\treturn -ENOENT;\n\t}\n\n\tmutex_lock(&kernfs_mutex);\n\n\tkn = kernfs_find_ns(parent, name, ns);\n\tif (kn)\n\t\t__kernfs_remove(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\n\tif (kn)\n\t\treturn 0;\n\telse\n\t\treturn -ENOENT;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nint kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,\n\t\t\t     const void *ns)\n{\n\tstruct kernfs_node *kn;\n\n\tif (!parent) {\n\t\tWARN(1, KERN_WARNING \"kernfs: can not remove '%s', no directory\\n\",\n\t\t\tname);\n\t\treturn -ENOENT;\n\t}\n\n\tmutex_lock(&kernfs_mutex);\n\n\tkn = kernfs_find_ns(parent, name, ns);\n\tif (kn)\n\t\t__kernfs_remove(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\n\tif (kn)\n\t\treturn 0;\n\telse\n\t\treturn -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nvoid sysfs_remove_file_ns(struct kobject *kobj, const struct attribute *attr,\n\t\t\t  const void *ns)\n{\n\tstruct kernfs_node *parent = kobj->sd;\n\n\tkernfs_remove_by_name_ns(parent, attr->name, ns);\n}"
  },
  {
    "function_name": "sysfs_chmod_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "379-397",
    "snippet": "int sysfs_chmod_file(struct kobject *kobj, const struct attribute *attr,\n\t\t     umode_t mode)\n{\n\tstruct kernfs_node *kn;\n\tstruct iattr newattrs;\n\tint rc;\n\n\tkn = kernfs_find_and_get(kobj->sd, attr->name);\n\tif (!kn)\n\t\treturn -ENOENT;\n\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (kn->mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE;\n\n\trc = kernfs_setattr(kn, &newattrs);\n\n\tkernfs_put(kn);\n\treturn rc;\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_setattr",
          "args": [
            "kn",
            "&newattrs"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "102-110",
          "snippet": "int kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr)\n{\n\tint ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tret = __kernfs_setattr(kn, iattr);\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nint kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr)\n{\n\tint ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tret = __kernfs_setattr(kn, iattr);\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get",
          "args": [
            "kobj->sd",
            "attr->name"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nint sysfs_chmod_file(struct kobject *kobj, const struct attribute *attr,\n\t\t     umode_t mode)\n{\n\tstruct kernfs_node *kn;\n\tstruct iattr newattrs;\n\tint rc;\n\n\tkn = kernfs_find_and_get(kobj->sd, attr->name);\n\tif (!kn)\n\t\treturn -ENOENT;\n\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (kn->mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE;\n\n\trc = kernfs_setattr(kn, &newattrs);\n\n\tkernfs_put(kn);\n\treturn rc;\n}"
  },
  {
    "function_name": "sysfs_add_file_to_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "349-369",
    "snippet": "int sysfs_add_file_to_group(struct kobject *kobj,\n\t\tconst struct attribute *attr, const char *group)\n{\n\tstruct kernfs_node *parent;\n\tint error;\n\n\tif (group) {\n\t\tparent = kernfs_find_and_get(kobj->sd, group);\n\t} else {\n\t\tparent = kobj->sd;\n\t\tkernfs_get(parent);\n\t}\n\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\terror = sysfs_add_file(parent, attr, false);\n\tkernfs_put(parent);\n\n\treturn error;\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "parent"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_add_file",
          "args": [
            "parent",
            "attr",
            "false"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_add_file_to_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
          "lines": "349-369",
          "snippet": "int sysfs_add_file_to_group(struct kobject *kobj,\n\t\tconst struct attribute *attr, const char *group)\n{\n\tstruct kernfs_node *parent;\n\tint error;\n\n\tif (group) {\n\t\tparent = kernfs_find_and_get(kobj->sd, group);\n\t} else {\n\t\tparent = kobj->sd;\n\t\tkernfs_get(parent);\n\t}\n\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\terror = sysfs_add_file(parent, attr, false);\n\tkernfs_put(parent);\n\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "parent"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get",
          "args": [
            "kobj->sd",
            "group"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nint sysfs_add_file_to_group(struct kobject *kobj,\n\t\tconst struct attribute *attr, const char *group)\n{\n\tstruct kernfs_node *parent;\n\tint error;\n\n\tif (group) {\n\t\tparent = kernfs_find_and_get(kobj->sd, group);\n\t} else {\n\t\tparent = kobj->sd;\n\t\tkernfs_get(parent);\n\t}\n\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\terror = sysfs_add_file(parent, attr, false);\n\tkernfs_put(parent);\n\n\treturn error;\n}"
  },
  {
    "function_name": "sysfs_create_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "329-340",
    "snippet": "int sysfs_create_files(struct kobject *kobj, const struct attribute **ptr)\n{\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; ptr[i] && !err; i++)\n\t\terr = sysfs_create_file(kobj, ptr[i]);\n\tif (err)\n\t\twhile (--i >= 0)\n\t\t\tsysfs_remove_file(kobj, ptr[i]);\n\treturn err;\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_remove_file",
          "args": [
            "kobj",
            "ptr[i]"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_remove_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
          "lines": "440-445",
          "snippet": "void sysfs_remove_files(struct kobject *kobj, const struct attribute **ptr)\n{\n\tint i;\n\tfor (i = 0; ptr[i]; i++)\n\t\tsysfs_remove_file(kobj, ptr[i]);\n}",
          "includes": [
            "#include \"../kernfs/kernfs-internal.h\"",
            "#include \"sysfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nvoid sysfs_remove_files(struct kobject *kobj, const struct attribute **ptr)\n{\n\tint i;\n\tfor (i = 0; ptr[i]; i++)\n\t\tsysfs_remove_file(kobj, ptr[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_create_file",
          "args": [
            "kobj",
            "ptr[i]"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_create_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
          "lines": "329-340",
          "snippet": "int sysfs_create_files(struct kobject *kobj, const struct attribute **ptr)\n{\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; ptr[i] && !err; i++)\n\t\terr = sysfs_create_file(kobj, ptr[i]);\n\tif (err)\n\t\twhile (--i >= 0)\n\t\t\tsysfs_remove_file(kobj, ptr[i]);\n\treturn err;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nint sysfs_create_files(struct kobject *kobj, const struct attribute **ptr)\n{\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; ptr[i] && !err; i++)\n\t\terr = sysfs_create_file(kobj, ptr[i]);\n\tif (err)\n\t\twhile (--i >= 0)\n\t\t\tsysfs_remove_file(kobj, ptr[i]);\n\treturn err;\n}"
  },
  {
    "function_name": "sysfs_create_file_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "319-326",
    "snippet": "int sysfs_create_file_ns(struct kobject *kobj, const struct attribute *attr,\n\t\t\t const void *ns)\n{\n\tBUG_ON(!kobj || !kobj->sd || !attr);\n\n\treturn sysfs_add_file_mode_ns(kobj->sd, attr, false, attr->mode, ns);\n\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_add_file_mode_ns",
          "args": [
            "kobj->sd",
            "attr",
            "false",
            "attr->mode",
            "ns"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_add_file_mode_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
          "lines": "238-305",
          "snippet": "int sysfs_add_file_mode_ns(struct kernfs_node *parent,\n\t\t\t   const struct attribute *attr, bool is_bin,\n\t\t\t   umode_t mode, const void *ns)\n{\n\tstruct lock_class_key *key = NULL;\n\tconst struct kernfs_ops *ops;\n\tstruct kernfs_node *kn;\n\tloff_t size;\n\n\tif (!is_bin) {\n\t\tstruct kobject *kobj = parent->priv;\n\t\tconst struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;\n\n\t\t/* every kobject with an attribute needs a ktype assigned */\n\t\tif (WARN(!sysfs_ops, KERN_ERR\n\t\t\t \"missing sysfs attribute operations for kobject: %s\\n\",\n\t\t\t kobject_name(kobj)))\n\t\t\treturn -EINVAL;\n\n\t\tif (sysfs_ops->show && sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_rw;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_rw;\n\t\t} else if (sysfs_ops->show) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_ro;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_ro;\n\t\t} else if (sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_wo;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_wo;\n\t\t} else\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = PAGE_SIZE;\n\t} else {\n\t\tstruct bin_attribute *battr = (void *)attr;\n\n\t\tif (battr->mmap)\n\t\t\tops = &sysfs_bin_kfops_mmap;\n\t\telse if (battr->read && battr->write)\n\t\t\tops = &sysfs_bin_kfops_rw;\n\t\telse if (battr->read)\n\t\t\tops = &sysfs_bin_kfops_ro;\n\t\telse if (battr->write)\n\t\t\tops = &sysfs_bin_kfops_wo;\n\t\telse\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = battr->size;\n\t}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!attr->ignore_lockdep)\n\t\tkey = attr->key ?: (struct lock_class_key *)&attr->skey;\n#endif\n\tkn = __kernfs_create_file(parent, attr->name, mode & 0777, size, ops,\n\t\t\t\t  (void *)attr, ns, key);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, attr->name);\n\t\treturn PTR_ERR(kn);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"../kernfs/kernfs-internal.h\"",
            "#include \"sysfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kernfs_ops sysfs_file_kfops_empty = {\n};",
            "static const struct kernfs_ops sysfs_file_kfops_ro = {\n\t.seq_show\t= sysfs_kf_seq_show,\n};",
            "static const struct kernfs_ops sysfs_file_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n};",
            "static const struct kernfs_ops sysfs_file_kfops_rw = {\n\t.seq_show\t= sysfs_kf_seq_show,\n\t.write\t\t= sysfs_kf_write,\n};",
            "static const struct kernfs_ops sysfs_prealloc_kfops_ro = {\n\t.read\t\t= sysfs_kf_read,\n\t.prealloc\t= true,\n};",
            "static const struct kernfs_ops sysfs_prealloc_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};",
            "static const struct kernfs_ops sysfs_prealloc_kfops_rw = {\n\t.read\t\t= sysfs_kf_read,\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};",
            "static const struct kernfs_ops sysfs_bin_kfops_ro = {\n\t.read\t\t= sysfs_kf_bin_read,\n};",
            "static const struct kernfs_ops sysfs_bin_kfops_wo = {\n\t.write\t\t= sysfs_kf_bin_write,\n};",
            "static const struct kernfs_ops sysfs_bin_kfops_rw = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n};",
            "static const struct kernfs_ops sysfs_bin_kfops_mmap = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n\t.mmap\t\t= sysfs_kf_bin_mmap,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic const struct kernfs_ops sysfs_file_kfops_empty = {\n};\nstatic const struct kernfs_ops sysfs_file_kfops_ro = {\n\t.seq_show\t= sysfs_kf_seq_show,\n};\nstatic const struct kernfs_ops sysfs_file_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n};\nstatic const struct kernfs_ops sysfs_file_kfops_rw = {\n\t.seq_show\t= sysfs_kf_seq_show,\n\t.write\t\t= sysfs_kf_write,\n};\nstatic const struct kernfs_ops sysfs_prealloc_kfops_ro = {\n\t.read\t\t= sysfs_kf_read,\n\t.prealloc\t= true,\n};\nstatic const struct kernfs_ops sysfs_prealloc_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};\nstatic const struct kernfs_ops sysfs_prealloc_kfops_rw = {\n\t.read\t\t= sysfs_kf_read,\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_ro = {\n\t.read\t\t= sysfs_kf_bin_read,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_wo = {\n\t.write\t\t= sysfs_kf_bin_write,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_rw = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_mmap = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n\t.mmap\t\t= sysfs_kf_bin_mmap,\n};\n\nint sysfs_add_file_mode_ns(struct kernfs_node *parent,\n\t\t\t   const struct attribute *attr, bool is_bin,\n\t\t\t   umode_t mode, const void *ns)\n{\n\tstruct lock_class_key *key = NULL;\n\tconst struct kernfs_ops *ops;\n\tstruct kernfs_node *kn;\n\tloff_t size;\n\n\tif (!is_bin) {\n\t\tstruct kobject *kobj = parent->priv;\n\t\tconst struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;\n\n\t\t/* every kobject with an attribute needs a ktype assigned */\n\t\tif (WARN(!sysfs_ops, KERN_ERR\n\t\t\t \"missing sysfs attribute operations for kobject: %s\\n\",\n\t\t\t kobject_name(kobj)))\n\t\t\treturn -EINVAL;\n\n\t\tif (sysfs_ops->show && sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_rw;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_rw;\n\t\t} else if (sysfs_ops->show) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_ro;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_ro;\n\t\t} else if (sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_wo;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_wo;\n\t\t} else\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = PAGE_SIZE;\n\t} else {\n\t\tstruct bin_attribute *battr = (void *)attr;\n\n\t\tif (battr->mmap)\n\t\t\tops = &sysfs_bin_kfops_mmap;\n\t\telse if (battr->read && battr->write)\n\t\t\tops = &sysfs_bin_kfops_rw;\n\t\telse if (battr->read)\n\t\t\tops = &sysfs_bin_kfops_ro;\n\t\telse if (battr->write)\n\t\t\tops = &sysfs_bin_kfops_wo;\n\t\telse\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = battr->size;\n\t}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!attr->ignore_lockdep)\n\t\tkey = attr->key ?: (struct lock_class_key *)&attr->skey;\n#endif\n\tkn = __kernfs_create_file(parent, attr->name, mode & 0777, size, ops,\n\t\t\t\t  (void *)attr, ns, key);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, attr->name);\n\t\treturn PTR_ERR(kn);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!kobj || !kobj->sd || !attr"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nint sysfs_create_file_ns(struct kobject *kobj, const struct attribute *attr,\n\t\t\t const void *ns)\n{\n\tBUG_ON(!kobj || !kobj->sd || !attr);\n\n\treturn sysfs_add_file_mode_ns(kobj->sd, attr, false, attr->mode, ns);\n\n}"
  },
  {
    "function_name": "sysfs_add_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "307-311",
    "snippet": "int sysfs_add_file(struct kernfs_node *parent, const struct attribute *attr,\n\t\t   bool is_bin)\n{\n\treturn sysfs_add_file_mode_ns(parent, attr, is_bin, attr->mode, NULL);\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_add_file_mode_ns",
          "args": [
            "parent",
            "attr",
            "is_bin",
            "attr->mode",
            "NULL"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_add_file_mode_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
          "lines": "238-305",
          "snippet": "int sysfs_add_file_mode_ns(struct kernfs_node *parent,\n\t\t\t   const struct attribute *attr, bool is_bin,\n\t\t\t   umode_t mode, const void *ns)\n{\n\tstruct lock_class_key *key = NULL;\n\tconst struct kernfs_ops *ops;\n\tstruct kernfs_node *kn;\n\tloff_t size;\n\n\tif (!is_bin) {\n\t\tstruct kobject *kobj = parent->priv;\n\t\tconst struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;\n\n\t\t/* every kobject with an attribute needs a ktype assigned */\n\t\tif (WARN(!sysfs_ops, KERN_ERR\n\t\t\t \"missing sysfs attribute operations for kobject: %s\\n\",\n\t\t\t kobject_name(kobj)))\n\t\t\treturn -EINVAL;\n\n\t\tif (sysfs_ops->show && sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_rw;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_rw;\n\t\t} else if (sysfs_ops->show) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_ro;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_ro;\n\t\t} else if (sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_wo;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_wo;\n\t\t} else\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = PAGE_SIZE;\n\t} else {\n\t\tstruct bin_attribute *battr = (void *)attr;\n\n\t\tif (battr->mmap)\n\t\t\tops = &sysfs_bin_kfops_mmap;\n\t\telse if (battr->read && battr->write)\n\t\t\tops = &sysfs_bin_kfops_rw;\n\t\telse if (battr->read)\n\t\t\tops = &sysfs_bin_kfops_ro;\n\t\telse if (battr->write)\n\t\t\tops = &sysfs_bin_kfops_wo;\n\t\telse\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = battr->size;\n\t}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!attr->ignore_lockdep)\n\t\tkey = attr->key ?: (struct lock_class_key *)&attr->skey;\n#endif\n\tkn = __kernfs_create_file(parent, attr->name, mode & 0777, size, ops,\n\t\t\t\t  (void *)attr, ns, key);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, attr->name);\n\t\treturn PTR_ERR(kn);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"../kernfs/kernfs-internal.h\"",
            "#include \"sysfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kernfs_ops sysfs_file_kfops_empty = {\n};",
            "static const struct kernfs_ops sysfs_file_kfops_ro = {\n\t.seq_show\t= sysfs_kf_seq_show,\n};",
            "static const struct kernfs_ops sysfs_file_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n};",
            "static const struct kernfs_ops sysfs_file_kfops_rw = {\n\t.seq_show\t= sysfs_kf_seq_show,\n\t.write\t\t= sysfs_kf_write,\n};",
            "static const struct kernfs_ops sysfs_prealloc_kfops_ro = {\n\t.read\t\t= sysfs_kf_read,\n\t.prealloc\t= true,\n};",
            "static const struct kernfs_ops sysfs_prealloc_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};",
            "static const struct kernfs_ops sysfs_prealloc_kfops_rw = {\n\t.read\t\t= sysfs_kf_read,\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};",
            "static const struct kernfs_ops sysfs_bin_kfops_ro = {\n\t.read\t\t= sysfs_kf_bin_read,\n};",
            "static const struct kernfs_ops sysfs_bin_kfops_wo = {\n\t.write\t\t= sysfs_kf_bin_write,\n};",
            "static const struct kernfs_ops sysfs_bin_kfops_rw = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n};",
            "static const struct kernfs_ops sysfs_bin_kfops_mmap = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n\t.mmap\t\t= sysfs_kf_bin_mmap,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic const struct kernfs_ops sysfs_file_kfops_empty = {\n};\nstatic const struct kernfs_ops sysfs_file_kfops_ro = {\n\t.seq_show\t= sysfs_kf_seq_show,\n};\nstatic const struct kernfs_ops sysfs_file_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n};\nstatic const struct kernfs_ops sysfs_file_kfops_rw = {\n\t.seq_show\t= sysfs_kf_seq_show,\n\t.write\t\t= sysfs_kf_write,\n};\nstatic const struct kernfs_ops sysfs_prealloc_kfops_ro = {\n\t.read\t\t= sysfs_kf_read,\n\t.prealloc\t= true,\n};\nstatic const struct kernfs_ops sysfs_prealloc_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};\nstatic const struct kernfs_ops sysfs_prealloc_kfops_rw = {\n\t.read\t\t= sysfs_kf_read,\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_ro = {\n\t.read\t\t= sysfs_kf_bin_read,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_wo = {\n\t.write\t\t= sysfs_kf_bin_write,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_rw = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_mmap = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n\t.mmap\t\t= sysfs_kf_bin_mmap,\n};\n\nint sysfs_add_file_mode_ns(struct kernfs_node *parent,\n\t\t\t   const struct attribute *attr, bool is_bin,\n\t\t\t   umode_t mode, const void *ns)\n{\n\tstruct lock_class_key *key = NULL;\n\tconst struct kernfs_ops *ops;\n\tstruct kernfs_node *kn;\n\tloff_t size;\n\n\tif (!is_bin) {\n\t\tstruct kobject *kobj = parent->priv;\n\t\tconst struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;\n\n\t\t/* every kobject with an attribute needs a ktype assigned */\n\t\tif (WARN(!sysfs_ops, KERN_ERR\n\t\t\t \"missing sysfs attribute operations for kobject: %s\\n\",\n\t\t\t kobject_name(kobj)))\n\t\t\treturn -EINVAL;\n\n\t\tif (sysfs_ops->show && sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_rw;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_rw;\n\t\t} else if (sysfs_ops->show) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_ro;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_ro;\n\t\t} else if (sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_wo;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_wo;\n\t\t} else\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = PAGE_SIZE;\n\t} else {\n\t\tstruct bin_attribute *battr = (void *)attr;\n\n\t\tif (battr->mmap)\n\t\t\tops = &sysfs_bin_kfops_mmap;\n\t\telse if (battr->read && battr->write)\n\t\t\tops = &sysfs_bin_kfops_rw;\n\t\telse if (battr->read)\n\t\t\tops = &sysfs_bin_kfops_ro;\n\t\telse if (battr->write)\n\t\t\tops = &sysfs_bin_kfops_wo;\n\t\telse\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = battr->size;\n\t}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!attr->ignore_lockdep)\n\t\tkey = attr->key ?: (struct lock_class_key *)&attr->skey;\n#endif\n\tkn = __kernfs_create_file(parent, attr->name, mode & 0777, size, ops,\n\t\t\t\t  (void *)attr, ns, key);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, attr->name);\n\t\treturn PTR_ERR(kn);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nint sysfs_add_file(struct kernfs_node *parent, const struct attribute *attr,\n\t\t   bool is_bin)\n{\n\treturn sysfs_add_file_mode_ns(parent, attr, is_bin, attr->mode, NULL);\n}"
  },
  {
    "function_name": "sysfs_add_file_mode_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "238-305",
    "snippet": "int sysfs_add_file_mode_ns(struct kernfs_node *parent,\n\t\t\t   const struct attribute *attr, bool is_bin,\n\t\t\t   umode_t mode, const void *ns)\n{\n\tstruct lock_class_key *key = NULL;\n\tconst struct kernfs_ops *ops;\n\tstruct kernfs_node *kn;\n\tloff_t size;\n\n\tif (!is_bin) {\n\t\tstruct kobject *kobj = parent->priv;\n\t\tconst struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;\n\n\t\t/* every kobject with an attribute needs a ktype assigned */\n\t\tif (WARN(!sysfs_ops, KERN_ERR\n\t\t\t \"missing sysfs attribute operations for kobject: %s\\n\",\n\t\t\t kobject_name(kobj)))\n\t\t\treturn -EINVAL;\n\n\t\tif (sysfs_ops->show && sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_rw;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_rw;\n\t\t} else if (sysfs_ops->show) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_ro;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_ro;\n\t\t} else if (sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_wo;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_wo;\n\t\t} else\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = PAGE_SIZE;\n\t} else {\n\t\tstruct bin_attribute *battr = (void *)attr;\n\n\t\tif (battr->mmap)\n\t\t\tops = &sysfs_bin_kfops_mmap;\n\t\telse if (battr->read && battr->write)\n\t\t\tops = &sysfs_bin_kfops_rw;\n\t\telse if (battr->read)\n\t\t\tops = &sysfs_bin_kfops_ro;\n\t\telse if (battr->write)\n\t\t\tops = &sysfs_bin_kfops_wo;\n\t\telse\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = battr->size;\n\t}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!attr->ignore_lockdep)\n\t\tkey = attr->key ?: (struct lock_class_key *)&attr->skey;\n#endif\n\tkn = __kernfs_create_file(parent, attr->name, mode & 0777, size, ops,\n\t\t\t\t  (void *)attr, ns, key);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, attr->name);\n\t\treturn PTR_ERR(kn);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct kernfs_ops sysfs_file_kfops_empty = {\n};",
      "static const struct kernfs_ops sysfs_file_kfops_ro = {\n\t.seq_show\t= sysfs_kf_seq_show,\n};",
      "static const struct kernfs_ops sysfs_file_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n};",
      "static const struct kernfs_ops sysfs_file_kfops_rw = {\n\t.seq_show\t= sysfs_kf_seq_show,\n\t.write\t\t= sysfs_kf_write,\n};",
      "static const struct kernfs_ops sysfs_prealloc_kfops_ro = {\n\t.read\t\t= sysfs_kf_read,\n\t.prealloc\t= true,\n};",
      "static const struct kernfs_ops sysfs_prealloc_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};",
      "static const struct kernfs_ops sysfs_prealloc_kfops_rw = {\n\t.read\t\t= sysfs_kf_read,\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};",
      "static const struct kernfs_ops sysfs_bin_kfops_ro = {\n\t.read\t\t= sysfs_kf_bin_read,\n};",
      "static const struct kernfs_ops sysfs_bin_kfops_wo = {\n\t.write\t\t= sysfs_kf_bin_write,\n};",
      "static const struct kernfs_ops sysfs_bin_kfops_rw = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n};",
      "static const struct kernfs_ops sysfs_bin_kfops_mmap = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n\t.mmap\t\t= sysfs_kf_bin_mmap,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kn"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_warn_dup",
          "args": [
            "parent",
            "attr->name"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_warn_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/dir.c",
          "lines": "22-34",
          "snippet": "void sysfs_warn_dup(struct kernfs_node *parent, const char *name)\n{\n\tchar *buf, *path = NULL;\n\n\tbuf = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (buf)\n\t\tpath = kernfs_path(parent, buf, PATH_MAX);\n\n\tWARN(1, KERN_WARNING \"sysfs: cannot create duplicate filename '%s/%s'\\n\",\n\t     path, name);\n\n\tkfree(buf);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/slab.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nvoid sysfs_warn_dup(struct kernfs_node *parent, const char *name)\n{\n\tchar *buf, *path = NULL;\n\n\tbuf = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (buf)\n\t\tpath = kernfs_path(parent, buf, PATH_MAX);\n\n\tWARN(1, KERN_WARNING \"sysfs: cannot create duplicate filename '%s/%s'\\n\",\n\t     path, name);\n\n\tkfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kn"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kn"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernfs_create_file",
          "args": [
            "parent",
            "attr->name",
            "mode & 0777",
            "size",
            "ops",
            "(void *)attr",
            "ns",
            "key"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "__kernfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "909-954",
          "snippet": "struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,\n\t\t\t\t\t const char *name,\n\t\t\t\t\t umode_t mode, loff_t size,\n\t\t\t\t\t const struct kernfs_ops *ops,\n\t\t\t\t\t void *priv, const void *ns,\n\t\t\t\t\t struct lock_class_key *key)\n{\n\tstruct kernfs_node *kn;\n\tunsigned flags;\n\tint rc;\n\n\tflags = KERNFS_FILE;\n\n\tkn = kernfs_new_node(parent, name, (mode & S_IALLUGO) | S_IFREG, flags);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkn->attr.ops = ops;\n\tkn->attr.size = size;\n\tkn->ns = ns;\n\tkn->priv = priv;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (key) {\n\t\tlockdep_init_map(&kn->dep_map, \"s_active\", key, 0);\n\t\tkn->flags |= KERNFS_LOCKDEP;\n\t}\n#endif\n\n\t/*\n\t * kn->attr.ops is accesible only while holding active ref.  We\n\t * need to know whether some ops are implemented outside active\n\t * ref.  Cache their existence in flags.\n\t */\n\tif (ops->seq_show)\n\t\tkn->flags |= KERNFS_HAS_SEQ_SHOW;\n\tif (ops->mmap)\n\t\tkn->flags |= KERNFS_HAS_MMAP;\n\n\trc = kernfs_add_one(kn);\n\tif (rc) {\n\t\tkernfs_put(kn);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstruct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,\n\t\t\t\t\t const char *name,\n\t\t\t\t\t umode_t mode, loff_t size,\n\t\t\t\t\t const struct kernfs_ops *ops,\n\t\t\t\t\t void *priv, const void *ns,\n\t\t\t\t\t struct lock_class_key *key)\n{\n\tstruct kernfs_node *kn;\n\tunsigned flags;\n\tint rc;\n\n\tflags = KERNFS_FILE;\n\n\tkn = kernfs_new_node(parent, name, (mode & S_IALLUGO) | S_IFREG, flags);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkn->attr.ops = ops;\n\tkn->attr.size = size;\n\tkn->ns = ns;\n\tkn->priv = priv;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (key) {\n\t\tlockdep_init_map(&kn->dep_map, \"s_active\", key, 0);\n\t\tkn->flags |= KERNFS_LOCKDEP;\n\t}\n#endif\n\n\t/*\n\t * kn->attr.ops is accesible only while holding active ref.  We\n\t * need to know whether some ops are implemented outside active\n\t * ref.  Cache their existence in flags.\n\t */\n\tif (ops->seq_show)\n\t\tkn->flags |= KERNFS_HAS_SEQ_SHOW;\n\tif (ops->mmap)\n\t\tkn->flags |= KERNFS_HAS_MMAP;\n\n\trc = kernfs_add_one(kn);\n\tif (rc) {\n\t\tkernfs_put(kn);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!sysfs_ops",
            "KERN_ERR\n\t\t\t \"missing sysfs attribute operations for kobject: %s\\n\"",
            "kobject_name(kobj)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_name",
          "args": [
            "kobj"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic const struct kernfs_ops sysfs_file_kfops_empty = {\n};\nstatic const struct kernfs_ops sysfs_file_kfops_ro = {\n\t.seq_show\t= sysfs_kf_seq_show,\n};\nstatic const struct kernfs_ops sysfs_file_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n};\nstatic const struct kernfs_ops sysfs_file_kfops_rw = {\n\t.seq_show\t= sysfs_kf_seq_show,\n\t.write\t\t= sysfs_kf_write,\n};\nstatic const struct kernfs_ops sysfs_prealloc_kfops_ro = {\n\t.read\t\t= sysfs_kf_read,\n\t.prealloc\t= true,\n};\nstatic const struct kernfs_ops sysfs_prealloc_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};\nstatic const struct kernfs_ops sysfs_prealloc_kfops_rw = {\n\t.read\t\t= sysfs_kf_read,\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_ro = {\n\t.read\t\t= sysfs_kf_bin_read,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_wo = {\n\t.write\t\t= sysfs_kf_bin_write,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_rw = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_mmap = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n\t.mmap\t\t= sysfs_kf_bin_mmap,\n};\n\nint sysfs_add_file_mode_ns(struct kernfs_node *parent,\n\t\t\t   const struct attribute *attr, bool is_bin,\n\t\t\t   umode_t mode, const void *ns)\n{\n\tstruct lock_class_key *key = NULL;\n\tconst struct kernfs_ops *ops;\n\tstruct kernfs_node *kn;\n\tloff_t size;\n\n\tif (!is_bin) {\n\t\tstruct kobject *kobj = parent->priv;\n\t\tconst struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;\n\n\t\t/* every kobject with an attribute needs a ktype assigned */\n\t\tif (WARN(!sysfs_ops, KERN_ERR\n\t\t\t \"missing sysfs attribute operations for kobject: %s\\n\",\n\t\t\t kobject_name(kobj)))\n\t\t\treturn -EINVAL;\n\n\t\tif (sysfs_ops->show && sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_rw;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_rw;\n\t\t} else if (sysfs_ops->show) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_ro;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_ro;\n\t\t} else if (sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_wo;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_wo;\n\t\t} else\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = PAGE_SIZE;\n\t} else {\n\t\tstruct bin_attribute *battr = (void *)attr;\n\n\t\tif (battr->mmap)\n\t\t\tops = &sysfs_bin_kfops_mmap;\n\t\telse if (battr->read && battr->write)\n\t\t\tops = &sysfs_bin_kfops_rw;\n\t\telse if (battr->read)\n\t\t\tops = &sysfs_bin_kfops_ro;\n\t\telse if (battr->write)\n\t\t\tops = &sysfs_bin_kfops_wo;\n\t\telse\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = battr->size;\n\t}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!attr->ignore_lockdep)\n\t\tkey = attr->key ?: (struct lock_class_key *)&attr->skey;\n#endif\n\tkn = __kernfs_create_file(parent, attr->name, mode & 0777, size, ops,\n\t\t\t\t  (void *)attr, ns, key);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, attr->name);\n\t\treturn PTR_ERR(kn);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sysfs_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "165-184",
    "snippet": "void sysfs_notify(struct kobject *kobj, const char *dir, const char *attr)\n{\n\tstruct kernfs_node *kn = kobj->sd, *tmp;\n\n\tif (kn && dir)\n\t\tkn = kernfs_find_and_get(kn, dir);\n\telse\n\t\tkernfs_get(kn);\n\n\tif (kn && attr) {\n\t\ttmp = kernfs_find_and_get(kn, attr);\n\t\tkernfs_put(kn);\n\t\tkn = tmp;\n\t}\n\n\tif (kn) {\n\t\tkernfs_notify(kn);\n\t\tkernfs_put(kn);\n\t}\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_notify",
          "args": [
            "kn"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "867-883",
          "snippet": "void kernfs_notify(struct kernfs_node *kn)\n{\n\tstatic DECLARE_WORK(kernfs_notify_work, kernfs_notify_workfn);\n\tunsigned long flags;\n\n\tif (WARN_ON(kernfs_type(kn) != KERNFS_FILE))\n\t\treturn;\n\n\tspin_lock_irqsave(&kernfs_notify_lock, flags);\n\tif (!kn->attr.notify_next) {\n\t\tkernfs_get(kn);\n\t\tkn->attr.notify_next = kernfs_notify_list;\n\t\tkernfs_notify_list = kn;\n\t\tschedule_work(&kernfs_notify_work);\n\t}\n\tspin_unlock_irqrestore(&kernfs_notify_lock, flags);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kernfs_notify_lock);",
            "static struct kernfs_node *kernfs_notify_list = KERNFS_NOTIFY_EOL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(kernfs_notify_lock);\nstatic struct kernfs_node *kernfs_notify_list = KERNFS_NOTIFY_EOL;\n\nvoid kernfs_notify(struct kernfs_node *kn)\n{\n\tstatic DECLARE_WORK(kernfs_notify_work, kernfs_notify_workfn);\n\tunsigned long flags;\n\n\tif (WARN_ON(kernfs_type(kn) != KERNFS_FILE))\n\t\treturn;\n\n\tspin_lock_irqsave(&kernfs_notify_lock, flags);\n\tif (!kn->attr.notify_next) {\n\t\tkernfs_get(kn);\n\t\tkn->attr.notify_next = kernfs_notify_list;\n\t\tkernfs_notify_list = kn;\n\t\tschedule_work(&kernfs_notify_work);\n\t}\n\tspin_unlock_irqrestore(&kernfs_notify_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get",
          "args": [
            "kn",
            "attr"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "kn"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get",
          "args": [
            "kn",
            "dir"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nvoid sysfs_notify(struct kobject *kobj, const char *dir, const char *attr)\n{\n\tstruct kernfs_node *kn = kobj->sd, *tmp;\n\n\tif (kn && dir)\n\t\tkn = kernfs_find_and_get(kn, dir);\n\telse\n\t\tkernfs_get(kn);\n\n\tif (kn && attr) {\n\t\ttmp = kernfs_find_and_get(kn, attr);\n\t\tkernfs_put(kn);\n\t\tkn = tmp;\n\t}\n\n\tif (kn) {\n\t\tkernfs_notify(kn);\n\t\tkernfs_put(kn);\n\t}\n}"
  },
  {
    "function_name": "sysfs_kf_bin_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "156-163",
    "snippet": "static int sysfs_kf_bin_mmap(struct kernfs_open_file *of,\n\t\t\t     struct vm_area_struct *vma)\n{\n\tstruct bin_attribute *battr = of->kn->priv;\n\tstruct kobject *kobj = of->kn->parent->priv;\n\n\treturn battr->mmap(of->file, kobj, battr, vma);\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "battr->mmap",
          "args": [
            "of->file",
            "kobj",
            "battr",
            "vma"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic int sysfs_kf_bin_mmap(struct kernfs_open_file *of,\n\t\t\t     struct vm_area_struct *vma)\n{\n\tstruct bin_attribute *battr = of->kn->priv;\n\tstruct kobject *kobj = of->kn->parent->priv;\n\n\treturn battr->mmap(of->file, kobj, battr, vma);\n}"
  },
  {
    "function_name": "sysfs_kf_bin_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "135-154",
    "snippet": "static ssize_t sysfs_kf_bin_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t  size_t count, loff_t pos)\n{\n\tstruct bin_attribute *battr = of->kn->priv;\n\tstruct kobject *kobj = of->kn->parent->priv;\n\tloff_t size = file_inode(of->file)->i_size;\n\n\tif (size) {\n\t\tif (size <= pos)\n\t\t\treturn -EFBIG;\n\t\tcount = min_t(ssize_t, count, size - pos);\n\t}\n\tif (!count)\n\t\treturn 0;\n\n\tif (!battr->write)\n\t\treturn -EIO;\n\n\treturn battr->write(of->file, kobj, battr, buf, pos, count);\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "battr->write",
          "args": [
            "of->file",
            "kobj",
            "battr",
            "buf",
            "pos",
            "count"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "ssize_t",
            "count",
            "size - pos"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "of->file"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic ssize_t sysfs_kf_bin_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t  size_t count, loff_t pos)\n{\n\tstruct bin_attribute *battr = of->kn->priv;\n\tstruct kobject *kobj = of->kn->parent->priv;\n\tloff_t size = file_inode(of->file)->i_size;\n\n\tif (size) {\n\t\tif (size <= pos)\n\t\t\treturn -EFBIG;\n\t\tcount = min_t(ssize_t, count, size - pos);\n\t}\n\tif (!count)\n\t\treturn 0;\n\n\tif (!battr->write)\n\t\treturn -EIO;\n\n\treturn battr->write(of->file, kobj, battr, buf, pos, count);\n}"
  },
  {
    "function_name": "sysfs_kf_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "122-132",
    "snippet": "static ssize_t sysfs_kf_write(struct kernfs_open_file *of, char *buf,\n\t\t\t      size_t count, loff_t pos)\n{\n\tconst struct sysfs_ops *ops = sysfs_file_ops(of->kn);\n\tstruct kobject *kobj = of->kn->parent->priv;\n\n\tif (!count)\n\t\treturn 0;\n\n\treturn ops->store(kobj, of->kn->priv, buf, count);\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->store",
          "args": [
            "kobj",
            "of->kn->priv",
            "buf",
            "count"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_file_ops",
          "args": [
            "of->kn"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_file_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
          "lines": "28-35",
          "snippet": "static const struct sysfs_ops *sysfs_file_ops(struct kernfs_node *kn)\n{\n\tstruct kobject *kobj = kn->parent->priv;\n\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kobj->ktype ? kobj->ktype->sysfs_ops : NULL;\n}",
          "includes": [
            "#include \"../kernfs/kernfs-internal.h\"",
            "#include \"sysfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic const struct sysfs_ops *sysfs_file_ops(struct kernfs_node *kn)\n{\n\tstruct kobject *kobj = kn->parent->priv;\n\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kobj->ktype ? kobj->ktype->sysfs_ops : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic ssize_t sysfs_kf_write(struct kernfs_open_file *of, char *buf,\n\t\t\t      size_t count, loff_t pos)\n{\n\tconst struct sysfs_ops *ops = sysfs_file_ops(of->kn);\n\tstruct kobject *kobj = of->kn->parent->priv;\n\n\tif (!count)\n\t\treturn 0;\n\n\treturn ops->store(kobj, of->kn->priv, buf, count);\n}"
  },
  {
    "function_name": "sysfs_kf_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "106-119",
    "snippet": "static ssize_t sysfs_kf_read(struct kernfs_open_file *of, char *buf,\n\t\t\t     size_t count, loff_t pos)\n{\n\tconst struct sysfs_ops *ops = sysfs_file_ops(of->kn);\n\tstruct kobject *kobj = of->kn->parent->priv;\n\n\t/*\n\t * If buf != of->prealloc_buf, we don't know how\n\t * large it is, so cannot safely pass it to ->show\n\t */\n\tif (pos || WARN_ON_ONCE(buf != of->prealloc_buf))\n\t\treturn 0;\n\treturn ops->show(kobj, of->kn->priv, buf);\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->show",
          "args": [
            "kobj",
            "of->kn->priv",
            "buf"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "buf != of->prealloc_buf"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_file_ops",
          "args": [
            "of->kn"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_file_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
          "lines": "28-35",
          "snippet": "static const struct sysfs_ops *sysfs_file_ops(struct kernfs_node *kn)\n{\n\tstruct kobject *kobj = kn->parent->priv;\n\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kobj->ktype ? kobj->ktype->sysfs_ops : NULL;\n}",
          "includes": [
            "#include \"../kernfs/kernfs-internal.h\"",
            "#include \"sysfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic const struct sysfs_ops *sysfs_file_ops(struct kernfs_node *kn)\n{\n\tstruct kobject *kobj = kn->parent->priv;\n\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kobj->ktype ? kobj->ktype->sysfs_ops : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic ssize_t sysfs_kf_read(struct kernfs_open_file *of, char *buf,\n\t\t\t     size_t count, loff_t pos)\n{\n\tconst struct sysfs_ops *ops = sysfs_file_ops(of->kn);\n\tstruct kobject *kobj = of->kn->parent->priv;\n\n\t/*\n\t * If buf != of->prealloc_buf, we don't know how\n\t * large it is, so cannot safely pass it to ->show\n\t */\n\tif (pos || WARN_ON_ONCE(buf != of->prealloc_buf))\n\t\treturn 0;\n\treturn ops->show(kobj, of->kn->priv, buf);\n}"
  },
  {
    "function_name": "sysfs_kf_bin_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "82-103",
    "snippet": "static ssize_t sysfs_kf_bin_read(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t count, loff_t pos)\n{\n\tstruct bin_attribute *battr = of->kn->priv;\n\tstruct kobject *kobj = of->kn->parent->priv;\n\tloff_t size = file_inode(of->file)->i_size;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (size) {\n\t\tif (pos > size)\n\t\t\treturn 0;\n\t\tif (pos + count > size)\n\t\t\tcount = size - pos;\n\t}\n\n\tif (!battr->read)\n\t\treturn -EIO;\n\n\treturn battr->read(of->file, kobj, battr, buf, pos, count);\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "battr->read",
          "args": [
            "of->file",
            "kobj",
            "battr",
            "buf",
            "pos",
            "count"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "of->file"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic ssize_t sysfs_kf_bin_read(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t count, loff_t pos)\n{\n\tstruct bin_attribute *battr = of->kn->priv;\n\tstruct kobject *kobj = of->kn->parent->priv;\n\tloff_t size = file_inode(of->file)->i_size;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (size) {\n\t\tif (pos > size)\n\t\t\treturn 0;\n\t\tif (pos + count > size)\n\t\t\tcount = size - pos;\n\t}\n\n\tif (!battr->read)\n\t\treturn -EIO;\n\n\treturn battr->read(of->file, kobj, battr, buf, pos, count);\n}"
  },
  {
    "function_name": "sysfs_kf_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "42-80",
    "snippet": "static int sysfs_kf_seq_show(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tstruct kobject *kobj = of->kn->parent->priv;\n\tconst struct sysfs_ops *ops = sysfs_file_ops(of->kn);\n\tssize_t count;\n\tchar *buf;\n\n\t/* acquire buffer and ensure that it's >= PAGE_SIZE and clear */\n\tcount = seq_get_buf(sf, &buf);\n\tif (count < PAGE_SIZE) {\n\t\tseq_commit(sf, -1);\n\t\treturn 0;\n\t}\n\tmemset(buf, 0, PAGE_SIZE);\n\n\t/*\n\t * Invoke show().  Control may reach here via seq file lseek even\n\t * if @ops->show() isn't implemented.\n\t */\n\tif (ops->show) {\n\t\tcount = ops->show(kobj, of->kn->priv, buf);\n\t\tif (count < 0)\n\t\t\treturn count;\n\t}\n\n\t/*\n\t * The code works fine with PAGE_SIZE return but it's likely to\n\t * indicate truncated result or overflow in normal use cases.\n\t */\n\tif (count >= (ssize_t)PAGE_SIZE) {\n\t\tprint_symbol(\"fill_read_buffer: %s returned bad count\\n\",\n\t\t\t(unsigned long)ops->show);\n\t\t/* Try to struggle along */\n\t\tcount = PAGE_SIZE - 1;\n\t}\n\tseq_commit(sf, count);\n\treturn 0;\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_commit",
          "args": [
            "sf",
            "count"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_symbol",
          "args": [
            "\"fill_read_buffer: %s returned bad count\\n\"",
            "(unsigned long)ops->show"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->show",
          "args": [
            "kobj",
            "of->kn->priv",
            "buf"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "PAGE_SIZE"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_commit",
          "args": [
            "sf",
            "-1"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_get_buf",
          "args": [
            "sf",
            "&buf"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_file_ops",
          "args": [
            "of->kn"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_file_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
          "lines": "28-35",
          "snippet": "static const struct sysfs_ops *sysfs_file_ops(struct kernfs_node *kn)\n{\n\tstruct kobject *kobj = kn->parent->priv;\n\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kobj->ktype ? kobj->ktype->sysfs_ops : NULL;\n}",
          "includes": [
            "#include \"../kernfs/kernfs-internal.h\"",
            "#include \"sysfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic const struct sysfs_ops *sysfs_file_ops(struct kernfs_node *kn)\n{\n\tstruct kobject *kobj = kn->parent->priv;\n\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kobj->ktype ? kobj->ktype->sysfs_ops : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic int sysfs_kf_seq_show(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tstruct kobject *kobj = of->kn->parent->priv;\n\tconst struct sysfs_ops *ops = sysfs_file_ops(of->kn);\n\tssize_t count;\n\tchar *buf;\n\n\t/* acquire buffer and ensure that it's >= PAGE_SIZE and clear */\n\tcount = seq_get_buf(sf, &buf);\n\tif (count < PAGE_SIZE) {\n\t\tseq_commit(sf, -1);\n\t\treturn 0;\n\t}\n\tmemset(buf, 0, PAGE_SIZE);\n\n\t/*\n\t * Invoke show().  Control may reach here via seq file lseek even\n\t * if @ops->show() isn't implemented.\n\t */\n\tif (ops->show) {\n\t\tcount = ops->show(kobj, of->kn->priv, buf);\n\t\tif (count < 0)\n\t\t\treturn count;\n\t}\n\n\t/*\n\t * The code works fine with PAGE_SIZE return but it's likely to\n\t * indicate truncated result or overflow in normal use cases.\n\t */\n\tif (count >= (ssize_t)PAGE_SIZE) {\n\t\tprint_symbol(\"fill_read_buffer: %s returned bad count\\n\",\n\t\t\t(unsigned long)ops->show);\n\t\t/* Try to struggle along */\n\t\tcount = PAGE_SIZE - 1;\n\t}\n\tseq_commit(sf, count);\n\treturn 0;\n}"
  },
  {
    "function_name": "sysfs_file_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
    "lines": "28-35",
    "snippet": "static const struct sysfs_ops *sysfs_file_ops(struct kernfs_node *kn)\n{\n\tstruct kobject *kobj = kn->parent->priv;\n\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kobj->ktype ? kobj->ktype->sysfs_ops : NULL;\n}",
    "includes": [
      "#include \"../kernfs/kernfs-internal.h\"",
      "#include \"sysfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "kn"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic const struct sysfs_ops *sysfs_file_ops(struct kernfs_node *kn)\n{\n\tstruct kobject *kobj = kn->parent->priv;\n\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kobj->ktype ? kobj->ktype->sysfs_ops : NULL;\n}"
  }
]