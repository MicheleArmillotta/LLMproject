[
  {
    "function_name": "ocfs2_dentry_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
    "lines": "444-469",
    "snippet": "void ocfs2_dentry_move(struct dentry *dentry, struct dentry *target,\n\t\t       struct inode *old_dir, struct inode *new_dir)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(old_dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\n\t/*\n\t * Move within the same directory, so the actual lock info won't\n\t * change.\n\t *\n\t * XXX: Is there any advantage to dropping the lock here?\n\t */\n\tif (old_dir == new_dir)\n\t\tgoto out_move;\n\n\tocfs2_dentry_lock_put(osb, dentry->d_fsdata);\n\n\tdentry->d_fsdata = NULL;\n\tret = ocfs2_dentry_attach_lock(dentry, inode, OCFS2_I(new_dir)->ip_blkno);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_move:\n\td_move(dentry, target);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_move",
          "args": [
            "dentry",
            "target"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "d_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2634-2639",
          "snippet": "void d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nvoid d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_attach_lock",
          "args": [
            "dentry",
            "inode",
            "OCFS2_I(new_dir)->ip_blkno"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_attach_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "226-346",
          "snippet": "int ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "new_dir"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_lock_put",
          "args": [
            "osb",
            "dentry->d_fsdata"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "378-392",
          "snippet": "void ocfs2_dentry_lock_put(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tint unlock = 0;\n\n\tBUG_ON(dl->dl_count == 0);\n\n\tspin_lock(&dentry_attach_lock);\n\tdl->dl_count--;\n\tunlock = !dl->dl_count;\n\tspin_unlock(&dentry_attach_lock);\n\n\tif (unlock)\n\t\tocfs2_drop_dentry_lock(osb, dl);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dentry_lock_put(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tint unlock = 0;\n\n\tBUG_ON(dl->dl_count == 0);\n\n\tspin_lock(&dentry_attach_lock);\n\tdl->dl_count--;\n\tunlock = !dl->dl_count;\n\tspin_unlock(&dentry_attach_lock);\n\n\tif (unlock)\n\t\tocfs2_drop_dentry_lock(osb, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "old_dir->i_sb"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dentry_move(struct dentry *dentry, struct dentry *target,\n\t\t       struct inode *old_dir, struct inode *new_dir)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(old_dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\n\t/*\n\t * Move within the same directory, so the actual lock info won't\n\t * change.\n\t *\n\t * XXX: Is there any advantage to dropping the lock here?\n\t */\n\tif (old_dir == new_dir)\n\t\tgoto out_move;\n\n\tocfs2_dentry_lock_put(osb, dentry->d_fsdata);\n\n\tdentry->d_fsdata = NULL;\n\tret = ocfs2_dentry_attach_lock(dentry, inode, OCFS2_I(new_dir)->ip_blkno);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_move:\n\td_move(dentry, target);\n}"
  },
  {
    "function_name": "ocfs2_dentry_iput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
    "lines": "394-423",
    "snippet": "static void ocfs2_dentry_iput(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\tif (!dl) {\n\t\t/*\n\t\t * No dentry lock is ok if we're disconnected or\n\t\t * unhashed.\n\t\t */\n\t\tif (!(dentry->d_flags & DCACHE_DISCONNECTED) &&\n\t\t    !d_unhashed(dentry)) {\n\t\t\tunsigned long long ino = 0ULL;\n\t\t\tif (inode)\n\t\t\t\tino = (unsigned long long)OCFS2_I(inode)->ip_blkno;\n\t\t\tmlog(ML_ERROR, \"Dentry is missing cluster lock. \"\n\t\t\t     \"inode: %llu, d_flags: 0x%x, d_name: %pd\\n\",\n\t\t\t     ino, dentry->d_flags, dentry);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tmlog_bug_on_msg(dl->dl_count == 0, \"dentry: %pd, count: %u\\n\",\n\t\t\tdentry, dl->dl_count);\n\n\tocfs2_dentry_lock_put(OCFS2_SB(dentry->d_sb), dl);\n\nout:\n\tiput(inode);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_lock_put",
          "args": [
            "OCFS2_SB(dentry->d_sb)",
            "dl"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "378-392",
          "snippet": "void ocfs2_dentry_lock_put(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tint unlock = 0;\n\n\tBUG_ON(dl->dl_count == 0);\n\n\tspin_lock(&dentry_attach_lock);\n\tdl->dl_count--;\n\tunlock = !dl->dl_count;\n\tspin_unlock(&dentry_attach_lock);\n\n\tif (unlock)\n\t\tocfs2_drop_dentry_lock(osb, dl);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dentry_lock_put(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tint unlock = 0;\n\n\tBUG_ON(dl->dl_count == 0);\n\n\tspin_lock(&dentry_attach_lock);\n\tdl->dl_count--;\n\tunlock = !dl->dl_count;\n\tspin_unlock(&dentry_attach_lock);\n\n\tif (unlock)\n\t\tocfs2_drop_dentry_lock(osb, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "dl->dl_count == 0",
            "\"dentry: %pd, count: %u\\n\"",
            "dentry",
            "dl->dl_count"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Dentry is missing cluster lock. \"\n\t\t\t     \"inode: %llu, d_flags: 0x%x, d_name: %pd\\n\"",
            "ino",
            "dentry->d_flags",
            "dentry"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dentry_iput(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\tif (!dl) {\n\t\t/*\n\t\t * No dentry lock is ok if we're disconnected or\n\t\t * unhashed.\n\t\t */\n\t\tif (!(dentry->d_flags & DCACHE_DISCONNECTED) &&\n\t\t    !d_unhashed(dentry)) {\n\t\t\tunsigned long long ino = 0ULL;\n\t\t\tif (inode)\n\t\t\t\tino = (unsigned long long)OCFS2_I(inode)->ip_blkno;\n\t\t\tmlog(ML_ERROR, \"Dentry is missing cluster lock. \"\n\t\t\t     \"inode: %llu, d_flags: 0x%x, d_name: %pd\\n\",\n\t\t\t     ino, dentry->d_flags, dentry);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tmlog_bug_on_msg(dl->dl_count == 0, \"dentry: %pd, count: %u\\n\",\n\t\t\tdentry, dl->dl_count);\n\n\tocfs2_dentry_lock_put(OCFS2_SB(dentry->d_sb), dl);\n\nout:\n\tiput(inode);\n}"
  },
  {
    "function_name": "ocfs2_dentry_lock_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
    "lines": "378-392",
    "snippet": "void ocfs2_dentry_lock_put(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tint unlock = 0;\n\n\tBUG_ON(dl->dl_count == 0);\n\n\tspin_lock(&dentry_attach_lock);\n\tdl->dl_count--;\n\tunlock = !dl->dl_count;\n\tspin_unlock(&dentry_attach_lock);\n\n\tif (unlock)\n\t\tocfs2_drop_dentry_lock(osb, dl);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_drop_dentry_lock",
          "args": [
            "osb",
            "dl"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_dentry_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "369-376",
          "snippet": "static void ocfs2_drop_dentry_lock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tiput(dl->dl_inode);\n\tocfs2_simple_drop_lockres(osb, &dl->dl_lockres);\n\tocfs2_lock_res_free(&dl->dl_lockres);\n\tkfree(dl);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_drop_dentry_lock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tiput(dl->dl_inode);\n\tocfs2_simple_drop_lockres(osb, &dl->dl_lockres);\n\tocfs2_lock_res_free(&dl->dl_lockres);\n\tkfree(dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry_attach_lock"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry_attach_lock"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dl->dl_count == 0"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dentry_lock_put(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tint unlock = 0;\n\n\tBUG_ON(dl->dl_count == 0);\n\n\tspin_lock(&dentry_attach_lock);\n\tdl->dl_count--;\n\tunlock = !dl->dl_count;\n\tspin_unlock(&dentry_attach_lock);\n\n\tif (unlock)\n\t\tocfs2_drop_dentry_lock(osb, dl);\n}"
  },
  {
    "function_name": "ocfs2_drop_dentry_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
    "lines": "369-376",
    "snippet": "static void ocfs2_drop_dentry_lock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tiput(dl->dl_inode);\n\tocfs2_simple_drop_lockres(osb, &dl->dl_lockres);\n\tocfs2_lock_res_free(&dl->dl_lockres);\n\tkfree(dl);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dl"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_free",
          "args": [
            "&dl->dl_lockres"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "722-749",
          "snippet": "void ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_simple_drop_lockres",
          "args": [
            "osb",
            "&dl->dl_lockres"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_simple_drop_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3223-3232",
          "snippet": "void ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "dl->dl_inode"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_drop_dentry_lock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tiput(dl->dl_inode);\n\tocfs2_simple_drop_lockres(osb, &dl->dl_lockres);\n\tocfs2_lock_res_free(&dl->dl_lockres);\n\tkfree(dl);\n}"
  },
  {
    "function_name": "ocfs2_dentry_attach_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
    "lines": "226-346",
    "snippet": "int ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "alias"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dl"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry_attach_lock"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry_attach_lock"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dl->dl_count != 1"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_free",
          "args": [
            "&dl->dl_lockres"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "722-749",
          "snippet": "void ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_unlock",
          "args": [
            "dentry",
            "0"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2676-2684",
          "snippet": "void ocfs2_dentry_unlock(struct dentry *dentry, int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, &dl->dl_lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nvoid ocfs2_dentry_unlock(struct dentry *dentry, int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, &dl->dl_lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_lock",
          "args": [
            "dentry",
            "0"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "378-392",
          "snippet": "void ocfs2_dentry_lock_put(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tint unlock = 0;\n\n\tBUG_ON(dl->dl_count == 0);\n\n\tspin_lock(&dentry_attach_lock);\n\tdl->dl_count--;\n\tunlock = !dl->dl_count;\n\tspin_unlock(&dentry_attach_lock);\n\n\tif (unlock)\n\t\tocfs2_drop_dentry_lock(osb, dl);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dentry_lock_put(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tint unlock = 0;\n\n\tBUG_ON(dl->dl_count == 0);\n\n\tspin_lock(&dentry_attach_lock);\n\tdl->dl_count--;\n\tunlock = !dl->dl_count;\n\tspin_unlock(&dentry_attach_lock);\n\n\tif (unlock)\n\t\tocfs2_drop_dentry_lock(osb, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dentry_lock_res_init",
          "args": [
            "dl",
            "parent_blkno",
            "inode"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_lock_res_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "602-640",
          "snippet": "void ocfs2_dentry_lock_res_init(struct ocfs2_dentry_lock *dl,\n\t\t\t\tu64 parent, struct inode *inode)\n{\n\tint len;\n\tu64 inode_blkno = OCFS2_I(inode)->ip_blkno;\n\t__be64 inode_blkno_be = cpu_to_be64(inode_blkno);\n\tstruct ocfs2_lock_res *lockres = &dl->dl_lockres;\n\n\tocfs2_lock_res_init_once(lockres);\n\n\t/*\n\t * Unfortunately, the standard lock naming scheme won't work\n\t * here because we have two 16 byte values to use. Instead,\n\t * we'll stuff the inode number as a binary value. We still\n\t * want error prints to show something without garbling the\n\t * display, so drop a null byte in there before the inode\n\t * number. A future version of OCFS2 will likely use all\n\t * binary lock names. The stringified names have been a\n\t * tremendous aid in debugging, but now that the debugfs\n\t * interface exists, we can mangle things there if need be.\n\t *\n\t * NOTE: We also drop the standard \"pad\" value (the total lock\n\t * name size stays the same though - the last part is all\n\t * zeros due to the memset in ocfs2_lock_res_init_once()\n\t */\n\tlen = snprintf(lockres->l_name, OCFS2_DENTRY_LOCK_INO_START,\n\t\t       \"%c%016llx\",\n\t\t       ocfs2_lock_type_char(OCFS2_LOCK_TYPE_DENTRY),\n\t\t       (long long)parent);\n\n\tBUG_ON(len != (OCFS2_DENTRY_LOCK_INO_START - 1));\n\n\tmemcpy(&lockres->l_name[OCFS2_DENTRY_LOCK_INO_START], &inode_blkno_be,\n\t       sizeof(__be64));\n\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_DENTRY, &ocfs2_dentry_lops,\n\t\t\t\t   dl);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_lock_res_ops ocfs2_dentry_lops = {\n\t.get_osb\t= ocfs2_get_dentry_osb,\n\t.post_unlock\t= ocfs2_dentry_post_unlock,\n\t.downconvert_worker = ocfs2_dentry_convert_worker,\n\t.flags\t\t= 0,\n};",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_dentry_lops = {\n\t.get_osb\t= ocfs2_get_dentry_osb,\n\t.post_unlock\t= ocfs2_dentry_post_unlock,\n\t.downconvert_worker = ocfs2_dentry_convert_worker,\n\t.flags\t\t= 0,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_dentry_lock_res_init(struct ocfs2_dentry_lock *dl,\n\t\t\t\tu64 parent, struct inode *inode)\n{\n\tint len;\n\tu64 inode_blkno = OCFS2_I(inode)->ip_blkno;\n\t__be64 inode_blkno_be = cpu_to_be64(inode_blkno);\n\tstruct ocfs2_lock_res *lockres = &dl->dl_lockres;\n\n\tocfs2_lock_res_init_once(lockres);\n\n\t/*\n\t * Unfortunately, the standard lock naming scheme won't work\n\t * here because we have two 16 byte values to use. Instead,\n\t * we'll stuff the inode number as a binary value. We still\n\t * want error prints to show something without garbling the\n\t * display, so drop a null byte in there before the inode\n\t * number. A future version of OCFS2 will likely use all\n\t * binary lock names. The stringified names have been a\n\t * tremendous aid in debugging, but now that the debugfs\n\t * interface exists, we can mangle things there if need be.\n\t *\n\t * NOTE: We also drop the standard \"pad\" value (the total lock\n\t * name size stays the same though - the last part is all\n\t * zeros due to the memset in ocfs2_lock_res_init_once()\n\t */\n\tlen = snprintf(lockres->l_name, OCFS2_DENTRY_LOCK_INO_START,\n\t\t       \"%c%016llx\",\n\t\t       ocfs2_lock_type_char(OCFS2_LOCK_TYPE_DENTRY),\n\t\t       (long long)parent);\n\n\tBUG_ON(len != (OCFS2_DENTRY_LOCK_INO_START - 1));\n\n\tmemcpy(&lockres->l_name[OCFS2_DENTRY_LOCK_INO_START], &inode_blkno_be,\n\t       sizeof(__be64));\n\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_DENTRY, &ocfs2_dentry_lops,\n\t\t\t\t   dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*dl)",
            "GFP_NOFS"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dentry_attach_lock_found",
          "args": [
            "dl->dl_lockres.l_name",
            "(unsigned long long)parent_blkno",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "dl->dl_parent_blkno != parent_blkno",
            "\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\"",
            "dentry",
            "(unsigned long long)parent_blkno",
            "(unsigned long long)dl->dl_parent_blkno"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!dl",
            "\"parent %llu, ino %llu\\n\"",
            "(unsigned long long)parent_blkno",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_local_alias",
          "args": [
            "inode",
            "parent_blkno",
            "0"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_local_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "168-190",
          "snippet": "struct dentry *ocfs2_find_local_alias(struct inode *inode,\n\t\t\t\t      u64 parent_blkno,\n\t\t\t\t      int skip_unhashed)\n{\n\tstruct dentry *dentry;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (ocfs2_match_dentry(dentry, parent_blkno, skip_unhashed)) {\n\t\t\ttrace_ocfs2_find_local_alias(dentry->d_name.len,\n\t\t\t\t\t\t     dentry->d_name.name);\n\n\t\t\tdget_dlock(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn dentry;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct dentry *ocfs2_find_local_alias(struct inode *inode,\n\t\t\t\t      u64 parent_blkno,\n\t\t\t\t      int skip_unhashed)\n{\n\tstruct dentry *dentry;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (ocfs2_match_dentry(dentry, parent_blkno, skip_unhashed)) {\n\t\t\ttrace_ocfs2_find_local_alias(dentry->d_name.len,\n\t\t\t\t\t\t     dentry->d_name.name);\n\n\t\t\tdget_dlock(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn dentry;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "dl->dl_parent_blkno != parent_blkno",
            "\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\"",
            "dentry",
            "(unsigned long long)parent_blkno",
            "(unsigned long long)dl->dl_parent_blkno"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dentry_attach_lock",
          "args": [
            "dentry->d_name.len",
            "dentry->d_name.name",
            "(unsigned long long)parent_blkno",
            "dl"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t/*\n\t * Negative dentry. We ignore these for now.\n\t *\n\t * XXX: Could we can improve ocfs2_dentry_revalidate() by\n\t * tracking these?\n\t */\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!dentry->d_inode && dentry->d_fsdata) {\n\t\t/* Converting a negative dentry to positive\n\t\t   Clear dentry->d_fsdata */\n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t/*\n\t\t * Great, an alias exists, which means we must have a\n\t\t * dentry lock already. We can just grab the lock off\n\t\t * the alias and add it to the list.\n\t\t *\n\t\t * We're depending here on the fact that this dentry\n\t\t * was found and exists in the dcache and so must have\n\t\t * a reference to the dentry_lock because we can't\n\t\t * race creates. Final dput() cannot happen on it\n\t\t * since we have it pinned, so our reference is safe.\n\t\t */\n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t/*\n\t * There are no other aliases\n\t */\n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t/*\n\t * Does this have to happen below, for all attaches, in case\n\t * the struct inode gets blown away by the downconvert thread?\n\t */\n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * This actually gets us our PRMODE level lock. From now on,\n\t * we'll have a notification if one of these names is\n\t * destroyed on another node.\n\t */\n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t/*\n\t * In case of error, manually free the allocation and do the iput().\n\t * We need to do this because error here means no d_instantiate(),\n\t * which means iput() will not be called during dput(dentry).\n\t */\n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_local_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
    "lines": "168-190",
    "snippet": "struct dentry *ocfs2_find_local_alias(struct inode *inode,\n\t\t\t\t      u64 parent_blkno,\n\t\t\t\t      int skip_unhashed)\n{\n\tstruct dentry *dentry;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (ocfs2_match_dentry(dentry, parent_blkno, skip_unhashed)) {\n\t\t\ttrace_ocfs2_find_local_alias(dentry->d_name.len,\n\t\t\t\t\t\t     dentry->d_name.name);\n\n\t\t\tdget_dlock(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn dentry;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_dlock",
          "args": [
            "dentry"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__dget_dlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "767-770",
          "snippet": "static inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_find_local_alias",
          "args": [
            "dentry->d_name.len",
            "dentry->d_name.name"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_match_dentry",
          "args": [
            "dentry",
            "parent_blkno",
            "skip_unhashed"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_match_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "128-159",
          "snippet": "static int ocfs2_match_dentry(struct dentry *dentry,\n\t\t\t      u64 parent_blkno,\n\t\t\t      int skip_unhashed)\n{\n\tstruct inode *parent;\n\n\t/*\n\t * ocfs2_lookup() does a d_splice_alias() _before_ attaching\n\t * to the lock data, so we skip those here, otherwise\n\t * ocfs2_dentry_attach_lock() will get its original dentry\n\t * back.\n\t */\n\tif (!dentry->d_fsdata)\n\t\treturn 0;\n\n\tif (!dentry->d_parent)\n\t\treturn 0;\n\n\tif (skip_unhashed && d_unhashed(dentry))\n\t\treturn 0;\n\n\tparent = dentry->d_parent->d_inode;\n\t/* Negative parent dentry? */\n\tif (!parent)\n\t\treturn 0;\n\n\t/* Name is in a different directory. */\n\tif (OCFS2_I(parent)->ip_blkno != parent_blkno)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_match_dentry(struct dentry *dentry,\n\t\t\t      u64 parent_blkno,\n\t\t\t      int skip_unhashed)\n{\n\tstruct inode *parent;\n\n\t/*\n\t * ocfs2_lookup() does a d_splice_alias() _before_ attaching\n\t * to the lock data, so we skip those here, otherwise\n\t * ocfs2_dentry_attach_lock() will get its original dentry\n\t * back.\n\t */\n\tif (!dentry->d_fsdata)\n\t\treturn 0;\n\n\tif (!dentry->d_parent)\n\t\treturn 0;\n\n\tif (skip_unhashed && d_unhashed(dentry))\n\t\treturn 0;\n\n\tparent = dentry->d_parent->d_inode;\n\t/* Negative parent dentry? */\n\tif (!parent)\n\t\treturn 0;\n\n\t/* Name is in a different directory. */\n\tif (OCFS2_I(parent)->ip_blkno != parent_blkno)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "dentry",
            "&inode->i_dentry",
            "d_u.d_alias"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct dentry *ocfs2_find_local_alias(struct inode *inode,\n\t\t\t\t      u64 parent_blkno,\n\t\t\t\t      int skip_unhashed)\n{\n\tstruct dentry *dentry;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (ocfs2_match_dentry(dentry, parent_blkno, skip_unhashed)) {\n\t\t\ttrace_ocfs2_find_local_alias(dentry->d_name.len,\n\t\t\t\t\t\t     dentry->d_name.name);\n\n\t\t\tdget_dlock(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn dentry;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "ocfs2_match_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
    "lines": "128-159",
    "snippet": "static int ocfs2_match_dentry(struct dentry *dentry,\n\t\t\t      u64 parent_blkno,\n\t\t\t      int skip_unhashed)\n{\n\tstruct inode *parent;\n\n\t/*\n\t * ocfs2_lookup() does a d_splice_alias() _before_ attaching\n\t * to the lock data, so we skip those here, otherwise\n\t * ocfs2_dentry_attach_lock() will get its original dentry\n\t * back.\n\t */\n\tif (!dentry->d_fsdata)\n\t\treturn 0;\n\n\tif (!dentry->d_parent)\n\t\treturn 0;\n\n\tif (skip_unhashed && d_unhashed(dentry))\n\t\treturn 0;\n\n\tparent = dentry->d_parent->d_inode;\n\t/* Negative parent dentry? */\n\tif (!parent)\n\t\treturn 0;\n\n\t/* Name is in a different directory. */\n\tif (OCFS2_I(parent)->ip_blkno != parent_blkno)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "parent"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_match_dentry(struct dentry *dentry,\n\t\t\t      u64 parent_blkno,\n\t\t\t      int skip_unhashed)\n{\n\tstruct inode *parent;\n\n\t/*\n\t * ocfs2_lookup() does a d_splice_alias() _before_ attaching\n\t * to the lock data, so we skip those here, otherwise\n\t * ocfs2_dentry_attach_lock() will get its original dentry\n\t * back.\n\t */\n\tif (!dentry->d_fsdata)\n\t\treturn 0;\n\n\tif (!dentry->d_parent)\n\t\treturn 0;\n\n\tif (skip_unhashed && d_unhashed(dentry))\n\t\treturn 0;\n\n\tparent = dentry->d_parent->d_inode;\n\t/* Negative parent dentry? */\n\tif (!parent)\n\t\treturn 0;\n\n\t/* Name is in a different directory. */\n\tif (OCFS2_I(parent)->ip_blkno != parent_blkno)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ocfs2_dentry_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
    "lines": "51-126",
    "snippet": "static int ocfs2_dentry_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tint ret = 0;    /* if all else fails, just return false */\n\tstruct ocfs2_super *osb;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\tosb = OCFS2_SB(dentry->d_sb);\n\n\ttrace_ocfs2_dentry_revalidate(dentry, dentry->d_name.len,\n\t\t\t\t      dentry->d_name.name);\n\n\t/* For a negative dentry -\n\t * check the generation number of the parent and compare with the\n\t * one stored in the inode.\n\t */\n\tif (inode == NULL) {\n\t\tunsigned long gen = (unsigned long) dentry->d_fsdata;\n\t\tunsigned long pgen;\n\t\tspin_lock(&dentry->d_lock);\n\t\tpgen = OCFS2_I(dentry->d_parent->d_inode)->ip_dir_lock_gen;\n\t\tspin_unlock(&dentry->d_lock);\n\t\ttrace_ocfs2_dentry_revalidate_negative(dentry->d_name.len,\n\t\t\t\t\t\t       dentry->d_name.name,\n\t\t\t\t\t\t       pgen, gen);\n\t\tif (gen != pgen)\n\t\t\tgoto bail;\n\t\tgoto valid;\n\t}\n\n\tBUG_ON(!osb);\n\n\tif (inode == osb->root_inode || is_bad_inode(inode))\n\t\tgoto bail;\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\t/* did we or someone else delete this inode? */\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED) {\n\t\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t\ttrace_ocfs2_dentry_revalidate_delete(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tgoto bail;\n\t}\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\t/*\n\t * We don't need a cluster lock to test this because once an\n\t * inode nlink hits zero, it never goes back.\n\t */\n\tif (inode->i_nlink == 0) {\n\t\ttrace_ocfs2_dentry_revalidate_orphaned(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\tS_ISDIR(inode->i_mode));\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * If the last lookup failed to create dentry lock, let us\n\t * redo it.\n\t */\n\tif (!dentry->d_fsdata) {\n\t\ttrace_ocfs2_dentry_revalidate_nofsdata(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tgoto bail;\n\t}\n\nvalid:\n\tret = 1;\n\nbail:\n\ttrace_ocfs2_dentry_revalidate_ret(ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_dentry_revalidate_ret",
          "args": [
            "ret"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dentry_revalidate_nofsdata",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dentry_revalidate_orphaned",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "S_ISDIR(inode->i_mode)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(inode)->ip_lock"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dentry_revalidate_delete",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(inode)->ip_lock"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!osb"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dentry_revalidate_negative",
          "args": [
            "dentry->d_name.len",
            "dentry->d_name.name",
            "pgen",
            "gen"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dentry_revalidate",
          "args": [
            "dentry",
            "dentry->d_name.len",
            "dentry->d_name.name"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dentry_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tint ret = 0;    /* if all else fails, just return false */\n\tstruct ocfs2_super *osb;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\tosb = OCFS2_SB(dentry->d_sb);\n\n\ttrace_ocfs2_dentry_revalidate(dentry, dentry->d_name.len,\n\t\t\t\t      dentry->d_name.name);\n\n\t/* For a negative dentry -\n\t * check the generation number of the parent and compare with the\n\t * one stored in the inode.\n\t */\n\tif (inode == NULL) {\n\t\tunsigned long gen = (unsigned long) dentry->d_fsdata;\n\t\tunsigned long pgen;\n\t\tspin_lock(&dentry->d_lock);\n\t\tpgen = OCFS2_I(dentry->d_parent->d_inode)->ip_dir_lock_gen;\n\t\tspin_unlock(&dentry->d_lock);\n\t\ttrace_ocfs2_dentry_revalidate_negative(dentry->d_name.len,\n\t\t\t\t\t\t       dentry->d_name.name,\n\t\t\t\t\t\t       pgen, gen);\n\t\tif (gen != pgen)\n\t\t\tgoto bail;\n\t\tgoto valid;\n\t}\n\n\tBUG_ON(!osb);\n\n\tif (inode == osb->root_inode || is_bad_inode(inode))\n\t\tgoto bail;\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\t/* did we or someone else delete this inode? */\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED) {\n\t\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t\ttrace_ocfs2_dentry_revalidate_delete(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tgoto bail;\n\t}\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\t/*\n\t * We don't need a cluster lock to test this because once an\n\t * inode nlink hits zero, it never goes back.\n\t */\n\tif (inode->i_nlink == 0) {\n\t\ttrace_ocfs2_dentry_revalidate_orphaned(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\tS_ISDIR(inode->i_mode));\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * If the last lookup failed to create dentry lock, let us\n\t * redo it.\n\t */\n\tif (!dentry->d_fsdata) {\n\t\ttrace_ocfs2_dentry_revalidate_nofsdata(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tgoto bail;\n\t}\n\nvalid:\n\tret = 1;\n\nbail:\n\ttrace_ocfs2_dentry_revalidate_ret(ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dentry_attach_gen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
    "lines": "42-48",
    "snippet": "void ocfs2_dentry_attach_gen(struct dentry *dentry)\n{\n\tunsigned long gen =\n\t\tOCFS2_I(dentry->d_parent->d_inode)->ip_dir_lock_gen;\n\tBUG_ON(dentry->d_inode);\n\tdentry->d_fsdata = (void *)gen;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dentry->d_inode"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dentry->d_parent->d_inode"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dentry_attach_gen(struct dentry *dentry)\n{\n\tunsigned long gen =\n\t\tOCFS2_I(dentry->d_parent->d_inode)->ip_dir_lock_gen;\n\tBUG_ON(dentry->d_inode);\n\tdentry->d_fsdata = (void *)gen;\n}"
  }
]