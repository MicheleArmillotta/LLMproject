[
  {
    "function_name": "o2cb_stack_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "440-443",
    "snippet": "static void __exit o2cb_stack_exit(void)\n{\n\tocfs2_stack_glue_unregister(&o2cb_stack);\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_stack_plugin o2cb_stack;",
      "static struct ocfs2_stack_plugin o2cb_stack = {\n\t.sp_name\t= \"o2cb\",\n\t.sp_ops\t\t= &o2cb_stack_ops,\n\t.sp_owner\t= THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_stack_glue_unregister",
          "args": [
            "&o2cb_stack"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_stack_glue_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "195-213",
          "snippet": "void ocfs2_stack_glue_unregister(struct ocfs2_stack_plugin *plugin)\n{\n\tstruct ocfs2_stack_plugin *p;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tp = ocfs2_stack_lookup(plugin->sp_name);\n\tif (p) {\n\t\tBUG_ON(p != plugin);\n\t\tBUG_ON(plugin == active_stack);\n\t\tBUG_ON(plugin->sp_count != 0);\n\t\tlist_del_init(&plugin->sp_list);\n\t\tprintk(KERN_INFO \"ocfs2: Unregistered cluster interface %s\\n\",\n\t\t       plugin->sp_name);\n\t} else {\n\t\tprintk(KERN_ERR \"Stack \\\"%s\\\" is not registered\\n\",\n\t\t       plugin->sp_name);\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ocfs2_stack_lock);",
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic DEFINE_SPINLOCK(ocfs2_stack_lock);\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid ocfs2_stack_glue_unregister(struct ocfs2_stack_plugin *plugin)\n{\n\tstruct ocfs2_stack_plugin *p;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tp = ocfs2_stack_lookup(plugin->sp_name);\n\tif (p) {\n\t\tBUG_ON(p != plugin);\n\t\tBUG_ON(plugin == active_stack);\n\t\tBUG_ON(plugin->sp_count != 0);\n\t\tlist_del_init(&plugin->sp_list);\n\t\tprintk(KERN_INFO \"ocfs2: Unregistered cluster interface %s\\n\",\n\t\t       plugin->sp_name);\n\t} else {\n\t\tprintk(KERN_ERR \"Stack \\\"%s\\\" is not registered\\n\",\n\t\t       plugin->sp_name);\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic struct ocfs2_stack_plugin o2cb_stack;\nstatic struct ocfs2_stack_plugin o2cb_stack = {\n\t.sp_name\t= \"o2cb\",\n\t.sp_ops\t\t= &o2cb_stack_ops,\n\t.sp_owner\t= THIS_MODULE,\n};\n\nstatic void __exit o2cb_stack_exit(void)\n{\n\tocfs2_stack_glue_unregister(&o2cb_stack);\n}"
  },
  {
    "function_name": "o2cb_stack_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "435-438",
    "snippet": "static int __init o2cb_stack_init(void)\n{\n\treturn ocfs2_stack_glue_register(&o2cb_stack);\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_stack_plugin o2cb_stack;",
      "static struct ocfs2_stack_plugin o2cb_stack = {\n\t.sp_name\t= \"o2cb\",\n\t.sp_ops\t\t= &o2cb_stack_ops,\n\t.sp_owner\t= THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_stack_glue_register",
          "args": [
            "&o2cb_stack"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_stack_glue_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "172-192",
          "snippet": "int ocfs2_stack_glue_register(struct ocfs2_stack_plugin *plugin)\n{\n\tint rc;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tif (!ocfs2_stack_lookup(plugin->sp_name)) {\n\t\tplugin->sp_count = 0;\n\t\tplugin->sp_max_proto = locking_max_version;\n\t\tlist_add(&plugin->sp_list, &ocfs2_stack_list);\n\t\tprintk(KERN_INFO \"ocfs2: Registered cluster interface %s\\n\",\n\t\t       plugin->sp_name);\n\t\trc = 0;\n\t} else {\n\t\tprintk(KERN_ERR \"ocfs2: Stack \\\"%s\\\" already registered\\n\",\n\t\t       plugin->sp_name);\n\t\trc = -EEXIST;\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_protocol_version locking_max_version;",
            "static DEFINE_SPINLOCK(ocfs2_stack_lock);",
            "static LIST_HEAD(ocfs2_stack_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_protocol_version locking_max_version;\nstatic DEFINE_SPINLOCK(ocfs2_stack_lock);\nstatic LIST_HEAD(ocfs2_stack_list);\n\nint ocfs2_stack_glue_register(struct ocfs2_stack_plugin *plugin)\n{\n\tint rc;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tif (!ocfs2_stack_lookup(plugin->sp_name)) {\n\t\tplugin->sp_count = 0;\n\t\tplugin->sp_max_proto = locking_max_version;\n\t\tlist_add(&plugin->sp_list, &ocfs2_stack_list);\n\t\tprintk(KERN_INFO \"ocfs2: Registered cluster interface %s\\n\",\n\t\t       plugin->sp_name);\n\t\trc = 0;\n\t} else {\n\t\tprintk(KERN_ERR \"ocfs2: Stack \\\"%s\\\" already registered\\n\",\n\t\t       plugin->sp_name);\n\t\trc = -EEXIST;\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic struct ocfs2_stack_plugin o2cb_stack;\nstatic struct ocfs2_stack_plugin o2cb_stack = {\n\t.sp_name\t= \"o2cb\",\n\t.sp_ops\t\t= &o2cb_stack_ops,\n\t.sp_owner\t= THIS_MODULE,\n};\n\nstatic int __init o2cb_stack_init(void)\n{\n\treturn ocfs2_stack_glue_register(&o2cb_stack);\n}"
  },
  {
    "function_name": "o2cb_cluster_this_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "401-415",
    "snippet": "static int o2cb_cluster_this_node(struct ocfs2_cluster_connection *conn,\n\t\t\t\t  unsigned int *node)\n{\n\tint node_num;\n\n\tnode_num = o2nm_this_node();\n\tif (node_num == O2NM_INVALID_NODE_NUM)\n\t\treturn -ENOENT;\n\n\tif (node_num >= O2NM_MAX_NODES)\n\t\treturn -EOVERFLOW;\n\n\t*node = node_num;\n\treturn 0;\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2nm_this_node",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_this_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "143-151",
          "snippet": "u8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int o2cb_cluster_this_node(struct ocfs2_cluster_connection *conn,\n\t\t\t\t  unsigned int *node)\n{\n\tint node_num;\n\n\tnode_num = o2nm_this_node();\n\tif (node_num == O2NM_INVALID_NODE_NUM)\n\t\treturn -ENOENT;\n\n\tif (node_num >= O2NM_MAX_NODES)\n\t\treturn -EOVERFLOW;\n\n\t*node = node_num;\n\treturn 0;\n}"
  },
  {
    "function_name": "o2cb_cluster_disconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "386-399",
    "snippet": "static int o2cb_cluster_disconnect(struct ocfs2_cluster_connection *conn)\n{\n\tstruct dlm_ctxt *dlm = conn->cc_lockspace;\n\tstruct o2dlm_private *priv = conn->cc_private;\n\n\tdlm_unregister_eviction_cb(&priv->op_eviction_cb);\n\tconn->cc_private = NULL;\n\tkfree(priv);\n\n\tdlm_unregister_domain(dlm);\n\tconn->cc_lockspace = NULL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_unregister_domain",
          "args": [
            "dlm"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unregister_domain_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1713-1718",
          "snippet": "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm)\n{\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_up);\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_down);\n\to2net_unregister_handler_list(&dlm->dlm_domain_handlers);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm)\n{\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_up);\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_down);\n\to2net_unregister_handler_list(&dlm->dlm_domain_handlers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "priv"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_unregister_eviction_cb",
          "args": [
            "&priv->op_eviction_cb"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unregister_eviction_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "2311-2316",
          "snippet": "void dlm_unregister_eviction_cb(struct dlm_eviction_cb *cb)\n{\n\tdown_write(&dlm_callback_sem);\n\tlist_del_init(&cb->ec_item);\n\tup_write(&dlm_callback_sem);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(dlm_callback_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(dlm_callback_sem);\n\nvoid dlm_unregister_eviction_cb(struct dlm_eviction_cb *cb)\n{\n\tdown_write(&dlm_callback_sem);\n\tlist_del_init(&cb->ec_item);\n\tup_write(&dlm_callback_sem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int o2cb_cluster_disconnect(struct ocfs2_cluster_connection *conn)\n{\n\tstruct dlm_ctxt *dlm = conn->cc_lockspace;\n\tstruct o2dlm_private *priv = conn->cc_private;\n\n\tdlm_unregister_eviction_cb(&priv->op_eviction_cb);\n\tconn->cc_private = NULL;\n\tkfree(priv);\n\n\tdlm_unregister_domain(dlm);\n\tconn->cc_lockspace = NULL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "o2cb_cluster_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "328-384",
    "snippet": "static int o2cb_cluster_connect(struct ocfs2_cluster_connection *conn)\n{\n\tint rc = 0;\n\tu32 dlm_key;\n\tstruct dlm_ctxt *dlm;\n\tstruct o2dlm_private *priv;\n\tstruct dlm_protocol_version fs_version;\n\n\tBUG_ON(conn == NULL);\n\tBUG_ON(conn->cc_proto == NULL);\n\n\t/* Ensure cluster stack is up and all nodes are connected */\n\trc = o2cb_cluster_check();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"o2cb: Cluster check failed. Fix errors \"\n\t\t       \"before retrying.\\n\");\n\t\tgoto out;\n\t}\n\n\tpriv = kzalloc(sizeof(struct o2dlm_private), GFP_KERNEL);\n\tif (!priv) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* This just fills the structure in.  It is safe to pass conn. */\n\tdlm_setup_eviction_cb(&priv->op_eviction_cb, o2dlm_eviction_cb,\n\t\t\t      conn);\n\n\tconn->cc_private = priv;\n\n\t/* used by the dlm code to make message headers unique, each\n\t * node in this domain must agree on this. */\n\tdlm_key = crc32_le(0, conn->cc_name, conn->cc_namelen);\n\tfs_version.pv_major = conn->cc_version.pv_major;\n\tfs_version.pv_minor = conn->cc_version.pv_minor;\n\n\tdlm = dlm_register_domain(conn->cc_name, dlm_key, &fs_version);\n\tif (IS_ERR(dlm)) {\n\t\trc = PTR_ERR(dlm);\n\t\tmlog_errno(rc);\n\t\tgoto out_free;\n\t}\n\n\tconn->cc_version.pv_major = fs_version.pv_major;\n\tconn->cc_version.pv_minor = fs_version.pv_minor;\n\tconn->cc_lockspace = dlm;\n\n\tdlm_register_eviction_cb(dlm, &priv->op_eviction_cb);\n\nout_free:\n\tif (rc)\n\t\tkfree(conn->cc_private);\n\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "conn->cc_private"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_register_eviction_cb",
          "args": [
            "dlm",
            "&priv->op_eviction_cb"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_register_eviction_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "2302-2308",
          "snippet": "void dlm_register_eviction_cb(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_eviction_cb *cb)\n{\n\tdown_write(&dlm_callback_sem);\n\tlist_add_tail(&cb->ec_item, &dlm->dlm_eviction_callbacks);\n\tup_write(&dlm_callback_sem);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);",
            "static DECLARE_RWSEM(dlm_callback_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\nstatic DECLARE_RWSEM(dlm_callback_sem);\n\nvoid dlm_register_eviction_cb(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_eviction_cb *cb)\n{\n\tdown_write(&dlm_callback_sem);\n\tlist_add_tail(&cb->ec_item, &dlm->dlm_eviction_callbacks);\n\tup_write(&dlm_callback_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dlm"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dlm"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_register_domain",
          "args": [
            "conn->cc_name",
            "dlm_key",
            "&fs_version"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_register_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "2109-2213",
          "snippet": "struct dlm_ctxt * dlm_register_domain(const char *domain,\n\t\t\t       u32 key,\n\t\t\t       struct dlm_protocol_version *fs_proto)\n{\n\tint ret;\n\tstruct dlm_ctxt *dlm = NULL;\n\tstruct dlm_ctxt *new_ctxt = NULL;\n\n\tif (strlen(domain) >= O2NM_MAX_NAME_LEN) {\n\t\tret = -ENAMETOOLONG;\n\t\tmlog(ML_ERROR, \"domain name length too long\\n\");\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"register called for domain \\\"%s\\\"\\n\", domain);\n\nretry:\n\tdlm = NULL;\n\tif (signal_pending(current)) {\n\t\tret = -ERESTARTSYS;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&dlm_domain_lock);\n\n\tdlm = __dlm_lookup_domain(domain);\n\tif (dlm) {\n\t\tif (dlm->dlm_state != DLM_CTXT_JOINED) {\n\t\t\tspin_unlock(&dlm_domain_lock);\n\n\t\t\tmlog(0, \"This ctxt is not joined yet!\\n\");\n\t\t\twait_event_interruptible(dlm_domain_events,\n\t\t\t\t\t\t dlm_wait_on_domain_helper(\n\t\t\t\t\t\t\t domain));\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (dlm_protocol_compare(&dlm->fs_locking_proto, fs_proto)) {\n\t\t\tspin_unlock(&dlm_domain_lock);\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Requested locking protocol version is not \"\n\t\t\t     \"compatible with already registered domain \"\n\t\t\t     \"\\\"%s\\\"\\n\", domain);\n\t\t\tret = -EPROTO;\n\t\t\tgoto leave;\n\t\t}\n\n\t\t__dlm_get(dlm);\n\t\tdlm->num_joins++;\n\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\t/* doesn't exist */\n\tif (!new_ctxt) {\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\tnew_ctxt = dlm_alloc_ctxt(domain, key);\n\t\tif (new_ctxt)\n\t\t\tgoto retry;\n\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\t/* a little variable switch-a-roo here... */\n\tdlm = new_ctxt;\n\tnew_ctxt = NULL;\n\n\t/* add the new domain */\n\tlist_add_tail(&dlm->list, &dlm_domains);\n\tspin_unlock(&dlm_domain_lock);\n\n\t/*\n\t * Pass the locking protocol version into the join.  If the join\n\t * succeeds, it will have the negotiated protocol set.\n\t */\n\tdlm->dlm_locking_proto = dlm_protocol;\n\tdlm->fs_locking_proto = *fs_proto;\n\n\tret = dlm_join_domain(dlm);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tdlm_put(dlm);\n\t\tgoto leave;\n\t}\n\n\t/* Tell the caller what locking protocol we negotiated */\n\t*fs_proto = dlm->fs_locking_proto;\n\n\tret = 0;\nleave:\n\tif (new_ctxt)\n\t\tdlm_free_ctxt_mem(new_ctxt);\n\n\tif (ret < 0)\n\t\tdlm = ERR_PTR(ret);\n\n\treturn dlm;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);",
            "static const struct dlm_protocol_version dlm_protocol = {\n\t.pv_major = 1,\n\t.pv_minor = 2,\n};",
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);\nstatic const struct dlm_protocol_version dlm_protocol = {\n\t.pv_major = 1,\n\t.pv_minor = 2,\n};\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt * dlm_register_domain(const char *domain,\n\t\t\t       u32 key,\n\t\t\t       struct dlm_protocol_version *fs_proto)\n{\n\tint ret;\n\tstruct dlm_ctxt *dlm = NULL;\n\tstruct dlm_ctxt *new_ctxt = NULL;\n\n\tif (strlen(domain) >= O2NM_MAX_NAME_LEN) {\n\t\tret = -ENAMETOOLONG;\n\t\tmlog(ML_ERROR, \"domain name length too long\\n\");\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"register called for domain \\\"%s\\\"\\n\", domain);\n\nretry:\n\tdlm = NULL;\n\tif (signal_pending(current)) {\n\t\tret = -ERESTARTSYS;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&dlm_domain_lock);\n\n\tdlm = __dlm_lookup_domain(domain);\n\tif (dlm) {\n\t\tif (dlm->dlm_state != DLM_CTXT_JOINED) {\n\t\t\tspin_unlock(&dlm_domain_lock);\n\n\t\t\tmlog(0, \"This ctxt is not joined yet!\\n\");\n\t\t\twait_event_interruptible(dlm_domain_events,\n\t\t\t\t\t\t dlm_wait_on_domain_helper(\n\t\t\t\t\t\t\t domain));\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (dlm_protocol_compare(&dlm->fs_locking_proto, fs_proto)) {\n\t\t\tspin_unlock(&dlm_domain_lock);\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Requested locking protocol version is not \"\n\t\t\t     \"compatible with already registered domain \"\n\t\t\t     \"\\\"%s\\\"\\n\", domain);\n\t\t\tret = -EPROTO;\n\t\t\tgoto leave;\n\t\t}\n\n\t\t__dlm_get(dlm);\n\t\tdlm->num_joins++;\n\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\t/* doesn't exist */\n\tif (!new_ctxt) {\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\tnew_ctxt = dlm_alloc_ctxt(domain, key);\n\t\tif (new_ctxt)\n\t\t\tgoto retry;\n\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\t/* a little variable switch-a-roo here... */\n\tdlm = new_ctxt;\n\tnew_ctxt = NULL;\n\n\t/* add the new domain */\n\tlist_add_tail(&dlm->list, &dlm_domains);\n\tspin_unlock(&dlm_domain_lock);\n\n\t/*\n\t * Pass the locking protocol version into the join.  If the join\n\t * succeeds, it will have the negotiated protocol set.\n\t */\n\tdlm->dlm_locking_proto = dlm_protocol;\n\tdlm->fs_locking_proto = *fs_proto;\n\n\tret = dlm_join_domain(dlm);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tdlm_put(dlm);\n\t\tgoto leave;\n\t}\n\n\t/* Tell the caller what locking protocol we negotiated */\n\t*fs_proto = dlm->fs_locking_proto;\n\n\tret = 0;\nleave:\n\tif (new_ctxt)\n\t\tdlm_free_ctxt_mem(new_ctxt);\n\n\tif (ret < 0)\n\t\tdlm = ERR_PTR(ret);\n\n\treturn dlm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "0",
            "conn->cc_name",
            "conn->cc_namelen"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_setup_eviction_cb",
          "args": [
            "&priv->op_eviction_cb",
            "o2dlm_eviction_cb",
            "conn"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_setup_eviction_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "2292-2299",
          "snippet": "void dlm_setup_eviction_cb(struct dlm_eviction_cb *cb,\n\t\t\t   dlm_eviction_func *f,\n\t\t\t   void *data)\n{\n\tINIT_LIST_HEAD(&cb->ec_item);\n\tcb->ec_func = f;\n\tcb->ec_data = data;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nvoid dlm_setup_eviction_cb(struct dlm_eviction_cb *cb,\n\t\t\t   dlm_eviction_func *f,\n\t\t\t   void *data)\n{\n\tINIT_LIST_HEAD(&cb->ec_item);\n\tcb->ec_func = f;\n\tcb->ec_data = data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct o2dlm_private)",
            "GFP_KERNEL"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"o2cb: Cluster check failed. Fix errors \"\n\t\t       \"before retrying.\\n\""
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2cb_cluster_check",
          "args": [],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "o2cb_cluster_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
          "lines": "263-312",
          "snippet": "static int o2cb_cluster_check(void)\n{\n\tu8 node_num;\n\tint i;\n\tunsigned long hbmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long netmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\n\tnode_num = o2nm_this_node();\n\tif (node_num == O2NM_MAX_NODES) {\n\t\tprintk(KERN_ERR \"o2cb: This node has not been configured.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * o2dlm expects o2net sockets to be created. If not, then\n\t * dlm_join_domain() fails with a stack of errors which are both cryptic\n\t * and incomplete. The idea here is to detect upfront whether we have\n\t * managed to connect to all nodes or not. If not, then list the nodes\n\t * to allow the user to check the configuration (incorrect IP, firewall,\n\t * etc.) Yes, this is racy. But its not the end of the world.\n\t */\n#define\tO2CB_MAP_STABILIZE_COUNT\t60\n\tfor (i = 0; i < O2CB_MAP_STABILIZE_COUNT; ++i) {\n\t\to2hb_fill_node_map(hbmap, sizeof(hbmap));\n\t\tif (!test_bit(node_num, hbmap)) {\n\t\t\tprintk(KERN_ERR \"o2cb: %s heartbeat has not been \"\n\t\t\t       \"started.\\n\", (o2hb_global_heartbeat_active() ?\n\t\t\t\t\t      \"Global\" : \"Local\"));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\to2net_fill_node_map(netmap, sizeof(netmap));\n\t\t/* Force set the current node to allow easy compare */\n\t\tset_bit(node_num, netmap);\n\t\tif (!memcmp(hbmap, netmap, sizeof(hbmap)))\n\t\t\treturn 0;\n\t\tif (i < O2CB_MAP_STABILIZE_COUNT)\n\t\t\tmsleep(1000);\n\t}\n\n\tprintk(KERN_ERR \"o2cb: This node could not connect to nodes:\");\n\ti = -1;\n\twhile ((i = find_next_bit(hbmap, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (!test_bit(i, netmap))\n\t\t\tprintk(\" %u\", i);\n\t}\n\tprintk(\".\\n\");\n\n\treturn -ENOTCONN;\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/masklog.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define\tO2CB_MAP_STABILIZE_COUNT\t60"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\n#define\tO2CB_MAP_STABILIZE_COUNT\t60\n\nstatic int o2cb_cluster_check(void)\n{\n\tu8 node_num;\n\tint i;\n\tunsigned long hbmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long netmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\n\tnode_num = o2nm_this_node();\n\tif (node_num == O2NM_MAX_NODES) {\n\t\tprintk(KERN_ERR \"o2cb: This node has not been configured.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * o2dlm expects o2net sockets to be created. If not, then\n\t * dlm_join_domain() fails with a stack of errors which are both cryptic\n\t * and incomplete. The idea here is to detect upfront whether we have\n\t * managed to connect to all nodes or not. If not, then list the nodes\n\t * to allow the user to check the configuration (incorrect IP, firewall,\n\t * etc.) Yes, this is racy. But its not the end of the world.\n\t */\n#define\tO2CB_MAP_STABILIZE_COUNT\t60\n\tfor (i = 0; i < O2CB_MAP_STABILIZE_COUNT; ++i) {\n\t\to2hb_fill_node_map(hbmap, sizeof(hbmap));\n\t\tif (!test_bit(node_num, hbmap)) {\n\t\t\tprintk(KERN_ERR \"o2cb: %s heartbeat has not been \"\n\t\t\t       \"started.\\n\", (o2hb_global_heartbeat_active() ?\n\t\t\t\t\t      \"Global\" : \"Local\"));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\to2net_fill_node_map(netmap, sizeof(netmap));\n\t\t/* Force set the current node to allow easy compare */\n\t\tset_bit(node_num, netmap);\n\t\tif (!memcmp(hbmap, netmap, sizeof(hbmap)))\n\t\t\treturn 0;\n\t\tif (i < O2CB_MAP_STABILIZE_COUNT)\n\t\t\tmsleep(1000);\n\t}\n\n\tprintk(KERN_ERR \"o2cb: This node could not connect to nodes:\");\n\ti = -1;\n\twhile ((i = find_next_bit(hbmap, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (!test_bit(i, netmap))\n\t\t\tprintk(\" %u\", i);\n\t}\n\tprintk(\".\\n\");\n\n\treturn -ENOTCONN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "conn->cc_proto == NULL"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "conn == NULL"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int o2cb_cluster_connect(struct ocfs2_cluster_connection *conn)\n{\n\tint rc = 0;\n\tu32 dlm_key;\n\tstruct dlm_ctxt *dlm;\n\tstruct o2dlm_private *priv;\n\tstruct dlm_protocol_version fs_version;\n\n\tBUG_ON(conn == NULL);\n\tBUG_ON(conn->cc_proto == NULL);\n\n\t/* Ensure cluster stack is up and all nodes are connected */\n\trc = o2cb_cluster_check();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"o2cb: Cluster check failed. Fix errors \"\n\t\t       \"before retrying.\\n\");\n\t\tgoto out;\n\t}\n\n\tpriv = kzalloc(sizeof(struct o2dlm_private), GFP_KERNEL);\n\tif (!priv) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* This just fills the structure in.  It is safe to pass conn. */\n\tdlm_setup_eviction_cb(&priv->op_eviction_cb, o2dlm_eviction_cb,\n\t\t\t      conn);\n\n\tconn->cc_private = priv;\n\n\t/* used by the dlm code to make message headers unique, each\n\t * node in this domain must agree on this. */\n\tdlm_key = crc32_le(0, conn->cc_name, conn->cc_namelen);\n\tfs_version.pv_major = conn->cc_version.pv_major;\n\tfs_version.pv_minor = conn->cc_version.pv_minor;\n\n\tdlm = dlm_register_domain(conn->cc_name, dlm_key, &fs_version);\n\tif (IS_ERR(dlm)) {\n\t\trc = PTR_ERR(dlm);\n\t\tmlog_errno(rc);\n\t\tgoto out_free;\n\t}\n\n\tconn->cc_version.pv_major = fs_version.pv_major;\n\tconn->cc_version.pv_minor = fs_version.pv_minor;\n\tconn->cc_lockspace = dlm;\n\n\tdlm_register_eviction_cb(dlm, &priv->op_eviction_cb);\n\nout_free:\n\tif (rc)\n\t\tkfree(conn->cc_private);\n\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "o2dlm_eviction_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "318-326",
    "snippet": "static void o2dlm_eviction_cb(int node_num, void *data)\n{\n\tstruct ocfs2_cluster_connection *conn = data;\n\n\tprintk(KERN_NOTICE \"o2cb: o2dlm has evicted node %d from domain %.*s\\n\",\n\t       node_num, conn->cc_namelen, conn->cc_name);\n\n\tconn->cc_recovery_handler(node_num, conn->cc_recovery_data);\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "conn->cc_recovery_handler",
          "args": [
            "node_num",
            "conn->cc_recovery_data"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2cb: o2dlm has evicted node %d from domain %.*s\\n\"",
            "node_num",
            "conn->cc_namelen",
            "conn->cc_name"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic void o2dlm_eviction_cb(int node_num, void *data)\n{\n\tstruct ocfs2_cluster_connection *conn = data;\n\n\tprintk(KERN_NOTICE \"o2cb: o2dlm has evicted node %d from domain %.*s\\n\",\n\t       node_num, conn->cc_namelen, conn->cc_name);\n\n\tconn->cc_recovery_handler(node_num, conn->cc_recovery_data);\n}"
  },
  {
    "function_name": "o2cb_cluster_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "263-312",
    "snippet": "static int o2cb_cluster_check(void)\n{\n\tu8 node_num;\n\tint i;\n\tunsigned long hbmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long netmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\n\tnode_num = o2nm_this_node();\n\tif (node_num == O2NM_MAX_NODES) {\n\t\tprintk(KERN_ERR \"o2cb: This node has not been configured.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * o2dlm expects o2net sockets to be created. If not, then\n\t * dlm_join_domain() fails with a stack of errors which are both cryptic\n\t * and incomplete. The idea here is to detect upfront whether we have\n\t * managed to connect to all nodes or not. If not, then list the nodes\n\t * to allow the user to check the configuration (incorrect IP, firewall,\n\t * etc.) Yes, this is racy. But its not the end of the world.\n\t */\n#define\tO2CB_MAP_STABILIZE_COUNT\t60\n\tfor (i = 0; i < O2CB_MAP_STABILIZE_COUNT; ++i) {\n\t\to2hb_fill_node_map(hbmap, sizeof(hbmap));\n\t\tif (!test_bit(node_num, hbmap)) {\n\t\t\tprintk(KERN_ERR \"o2cb: %s heartbeat has not been \"\n\t\t\t       \"started.\\n\", (o2hb_global_heartbeat_active() ?\n\t\t\t\t\t      \"Global\" : \"Local\"));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\to2net_fill_node_map(netmap, sizeof(netmap));\n\t\t/* Force set the current node to allow easy compare */\n\t\tset_bit(node_num, netmap);\n\t\tif (!memcmp(hbmap, netmap, sizeof(hbmap)))\n\t\t\treturn 0;\n\t\tif (i < O2CB_MAP_STABILIZE_COUNT)\n\t\t\tmsleep(1000);\n\t}\n\n\tprintk(KERN_ERR \"o2cb: This node could not connect to nodes:\");\n\ti = -1;\n\twhile ((i = find_next_bit(hbmap, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (!test_bit(i, netmap))\n\t\t\tprintk(\" %u\", i);\n\t}\n\tprintk(\".\\n\");\n\n\treturn -ENOTCONN;\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define\tO2CB_MAP_STABILIZE_COUNT\t60"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\".\\n\""
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "netmap"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "hbmap",
            "O2NM_MAX_NODES",
            "i + 1"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1000"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "hbmap",
            "netmap",
            "sizeof(hbmap)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "node_num",
            "netmap"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_fill_node_map",
          "args": [
            "netmap",
            "sizeof(netmap)"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_fill_node_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1010-1026",
          "snippet": "void o2net_fill_node_map(unsigned long *map, unsigned bytes)\n{\n\tstruct o2net_sock_container *sc;\n\tint node, ret;\n\n\tBUG_ON(bytes < (BITS_TO_LONGS(O2NM_MAX_NODES) * sizeof(unsigned long)));\n\n\tmemset(map, 0, bytes);\n\tfor (node = 0; node < O2NM_MAX_NODES; ++node) {\n\t\tif (!o2net_tx_can_proceed(o2net_nn_from_num(node), &sc, &ret))\n\t\t\tcontinue;\n\t\tif (!ret) {\n\t\t\tset_bit(node, map);\n\t\t\tsc_put(sc);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nvoid o2net_fill_node_map(unsigned long *map, unsigned bytes)\n{\n\tstruct o2net_sock_container *sc;\n\tint node, ret;\n\n\tBUG_ON(bytes < (BITS_TO_LONGS(O2NM_MAX_NODES) * sizeof(unsigned long)));\n\n\tmemset(map, 0, bytes);\n\tfor (node = 0; node < O2NM_MAX_NODES; ++node) {\n\t\tif (!o2net_tx_can_proceed(o2net_nn_from_num(node), &sc, &ret))\n\t\t\tcontinue;\n\t\tif (!ret) {\n\t\t\tset_bit(node, map);\n\t\t\tsc_put(sc);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2hb_global_heartbeat_active",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_global_heartbeat_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2674-2677",
          "snippet": "int o2hb_global_heartbeat_active(void)\n{\n\treturn (o2hb_heartbeat_mode == O2HB_HEARTBEAT_GLOBAL);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int o2hb_heartbeat_mode = O2HB_HEARTBEAT_LOCAL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nunsigned int o2hb_heartbeat_mode = O2HB_HEARTBEAT_LOCAL;\n\nint o2hb_global_heartbeat_active(void)\n{\n\treturn (o2hb_heartbeat_mode == O2HB_HEARTBEAT_GLOBAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2hb_fill_node_map",
          "args": [
            "hbmap",
            "sizeof(hbmap)"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_fill_node_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "1417-1426",
          "snippet": "void o2hb_fill_node_map(unsigned long *map, unsigned bytes)\n{\n\t/* callers want to serialize this map and callbacks so that they\n\t * can trust that they don't miss nodes coming to the party */\n\tdown_read(&o2hb_callback_sem);\n\tspin_lock(&o2hb_live_lock);\n\to2hb_fill_node_map_from_callback(map, bytes);\n\tspin_unlock(&o2hb_live_lock);\n\tup_read(&o2hb_callback_sem);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(o2hb_callback_sem);",
            "static DEFINE_SPINLOCK(o2hb_live_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(o2hb_callback_sem);\nstatic DEFINE_SPINLOCK(o2hb_live_lock);\n\nvoid o2hb_fill_node_map(unsigned long *map, unsigned bytes)\n{\n\t/* callers want to serialize this map and callbacks so that they\n\t * can trust that they don't miss nodes coming to the party */\n\tdown_read(&o2hb_callback_sem);\n\tspin_lock(&o2hb_live_lock);\n\to2hb_fill_node_map_from_callback(map, bytes);\n\tspin_unlock(&o2hb_live_lock);\n\tup_read(&o2hb_callback_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_this_node",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_this_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "143-151",
          "snippet": "u8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "O2NM_MAX_NODES"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "O2NM_MAX_NODES"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\n#define\tO2CB_MAP_STABILIZE_COUNT\t60\n\nstatic int o2cb_cluster_check(void)\n{\n\tu8 node_num;\n\tint i;\n\tunsigned long hbmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long netmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\n\tnode_num = o2nm_this_node();\n\tif (node_num == O2NM_MAX_NODES) {\n\t\tprintk(KERN_ERR \"o2cb: This node has not been configured.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * o2dlm expects o2net sockets to be created. If not, then\n\t * dlm_join_domain() fails with a stack of errors which are both cryptic\n\t * and incomplete. The idea here is to detect upfront whether we have\n\t * managed to connect to all nodes or not. If not, then list the nodes\n\t * to allow the user to check the configuration (incorrect IP, firewall,\n\t * etc.) Yes, this is racy. But its not the end of the world.\n\t */\n#define\tO2CB_MAP_STABILIZE_COUNT\t60\n\tfor (i = 0; i < O2CB_MAP_STABILIZE_COUNT; ++i) {\n\t\to2hb_fill_node_map(hbmap, sizeof(hbmap));\n\t\tif (!test_bit(node_num, hbmap)) {\n\t\t\tprintk(KERN_ERR \"o2cb: %s heartbeat has not been \"\n\t\t\t       \"started.\\n\", (o2hb_global_heartbeat_active() ?\n\t\t\t\t\t      \"Global\" : \"Local\"));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\to2net_fill_node_map(netmap, sizeof(netmap));\n\t\t/* Force set the current node to allow easy compare */\n\t\tset_bit(node_num, netmap);\n\t\tif (!memcmp(hbmap, netmap, sizeof(hbmap)))\n\t\t\treturn 0;\n\t\tif (i < O2CB_MAP_STABILIZE_COUNT)\n\t\t\tmsleep(1000);\n\t}\n\n\tprintk(KERN_ERR \"o2cb: This node could not connect to nodes:\");\n\ti = -1;\n\twhile ((i = find_next_bit(hbmap, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (!test_bit(i, netmap))\n\t\t\tprintk(\" %u\", i);\n\t}\n\tprintk(\".\\n\");\n\n\treturn -ENOTCONN;\n}"
  },
  {
    "function_name": "o2cb_dump_lksb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "254-257",
    "snippet": "static void o2cb_dump_lksb(struct ocfs2_dlm_lksb *lksb)\n{\n\tdlm_print_one_lock(lksb->lksb_o2dlm.lockid);\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_print_one_lock",
          "args": [
            "lksb->lksb_o2dlm.lockid"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_one_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "133-136",
          "snippet": "void dlm_print_one_lock(struct dlm_lock *lockid)\n{\n\tdlm_print_one_lock_resource(lockid->lockres);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid dlm_print_one_lock(struct dlm_lock *lockid)\n{\n\tdlm_print_one_lock_resource(lockid->lockres);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic void o2cb_dump_lksb(struct ocfs2_dlm_lksb *lksb)\n{\n\tdlm_print_one_lock(lksb->lksb_o2dlm.lockid);\n}"
  },
  {
    "function_name": "o2cb_dlm_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "249-252",
    "snippet": "static void *o2cb_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn (void *)(lksb->lksb_o2dlm.lvb);\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic void *o2cb_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn (void *)(lksb->lksb_o2dlm.lvb);\n}"
  },
  {
    "function_name": "o2cb_dlm_lvb_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "244-247",
    "snippet": "static int o2cb_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int o2cb_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "o2cb_dlm_lock_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "234-237",
    "snippet": "static int o2cb_dlm_lock_status(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn dlm_status_to_errno(lksb->lksb_o2dlm.status);\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_status_to_errno",
          "args": [
            "lksb->lksb_o2dlm.status"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_status_to_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
          "lines": "157-162",
          "snippet": "static int dlm_status_to_errno(enum dlm_status status)\n{\n\tBUG_ON(status < 0 || status >= ARRAY_SIZE(status_map));\n\n\treturn status_map[status];\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/masklog.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int status_map[] = {\n\t[DLM_NORMAL]\t\t\t= 0,\t\t/* Success */\n\t[DLM_GRANTED]\t\t\t= -EINVAL,\n\t[DLM_DENIED]\t\t\t= -EACCES,\n\t[DLM_DENIED_NOLOCKS]\t\t= -EACCES,\n\t[DLM_WORKING]\t\t\t= -EACCES,\n\t[DLM_BLOCKED]\t\t\t= -EINVAL,\n\t[DLM_BLOCKED_ORPHAN]\t\t= -EINVAL,\n\t[DLM_DENIED_GRACE_PERIOD]\t= -EACCES,\n\t[DLM_SYSERR]\t\t\t= -ENOMEM,\t/* It is what it is */\n\t[DLM_NOSUPPORT]\t\t\t= -EPROTO,\n\t[DLM_CANCELGRANT]\t\t= -EBUSY,\t/* Cancel after grant */\n\t[DLM_IVLOCKID]\t\t\t= -EINVAL,\n\t[DLM_SYNC]\t\t\t= -EINVAL,\n\t[DLM_BADTYPE]\t\t\t= -EINVAL,\n\t[DLM_BADRESOURCE]\t\t= -EINVAL,\n\t[DLM_MAXHANDLES]\t\t= -ENOMEM,\n\t[DLM_NOCLINFO]\t\t\t= -EINVAL,\n\t[DLM_NOLOCKMGR]\t\t\t= -EINVAL,\n\t[DLM_NOPURGED]\t\t\t= -EINVAL,\n\t[DLM_BADARGS]\t\t\t= -EINVAL,\n\t[DLM_VOID]\t\t\t= -EINVAL,\n\t[DLM_NOTQUEUED]\t\t\t= -EAGAIN,\t/* Trylock failed */\n\t[DLM_IVBUFLEN]\t\t\t= -EINVAL,\n\t[DLM_CVTUNGRANT]\t\t= -EPERM,\n\t[DLM_BADPARAM]\t\t\t= -EINVAL,\n\t[DLM_VALNOTVALID]\t\t= -EINVAL,\n\t[DLM_REJECTED]\t\t\t= -EPERM,\n\t[DLM_ABORT]\t\t\t= -EINVAL,\n\t[DLM_CANCEL]\t\t\t= -DLM_ECANCEL,\t/* Successful cancel */\n\t[DLM_IVRESHANDLE]\t\t= -EINVAL,\n\t[DLM_DEADLOCK]\t\t\t= -EDEADLK,\n\t[DLM_DENIED_NOASTS]\t\t= -EINVAL,\n\t[DLM_FORWARD]\t\t\t= -EINVAL,\n\t[DLM_TIMEOUT]\t\t\t= -ETIMEDOUT,\n\t[DLM_IVGROUPID]\t\t\t= -EINVAL,\n\t[DLM_VERS_CONFLICT]\t\t= -EOPNOTSUPP,\n\t[DLM_BAD_DEVICE_PATH]\t\t= -ENOENT,\n\t[DLM_NO_DEVICE_PERMISSION]\t= -EPERM,\n\t[DLM_NO_CONTROL_DEVICE]\t\t= -ENOENT,\n\t[DLM_RECOVERING]\t\t= -ENOTCONN,\n\t[DLM_MIGRATING]\t\t\t= -ERESTART,\n\t[DLM_MAXSTATS]\t\t\t= -EINVAL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int status_map[] = {\n\t[DLM_NORMAL]\t\t\t= 0,\t\t/* Success */\n\t[DLM_GRANTED]\t\t\t= -EINVAL,\n\t[DLM_DENIED]\t\t\t= -EACCES,\n\t[DLM_DENIED_NOLOCKS]\t\t= -EACCES,\n\t[DLM_WORKING]\t\t\t= -EACCES,\n\t[DLM_BLOCKED]\t\t\t= -EINVAL,\n\t[DLM_BLOCKED_ORPHAN]\t\t= -EINVAL,\n\t[DLM_DENIED_GRACE_PERIOD]\t= -EACCES,\n\t[DLM_SYSERR]\t\t\t= -ENOMEM,\t/* It is what it is */\n\t[DLM_NOSUPPORT]\t\t\t= -EPROTO,\n\t[DLM_CANCELGRANT]\t\t= -EBUSY,\t/* Cancel after grant */\n\t[DLM_IVLOCKID]\t\t\t= -EINVAL,\n\t[DLM_SYNC]\t\t\t= -EINVAL,\n\t[DLM_BADTYPE]\t\t\t= -EINVAL,\n\t[DLM_BADRESOURCE]\t\t= -EINVAL,\n\t[DLM_MAXHANDLES]\t\t= -ENOMEM,\n\t[DLM_NOCLINFO]\t\t\t= -EINVAL,\n\t[DLM_NOLOCKMGR]\t\t\t= -EINVAL,\n\t[DLM_NOPURGED]\t\t\t= -EINVAL,\n\t[DLM_BADARGS]\t\t\t= -EINVAL,\n\t[DLM_VOID]\t\t\t= -EINVAL,\n\t[DLM_NOTQUEUED]\t\t\t= -EAGAIN,\t/* Trylock failed */\n\t[DLM_IVBUFLEN]\t\t\t= -EINVAL,\n\t[DLM_CVTUNGRANT]\t\t= -EPERM,\n\t[DLM_BADPARAM]\t\t\t= -EINVAL,\n\t[DLM_VALNOTVALID]\t\t= -EINVAL,\n\t[DLM_REJECTED]\t\t\t= -EPERM,\n\t[DLM_ABORT]\t\t\t= -EINVAL,\n\t[DLM_CANCEL]\t\t\t= -DLM_ECANCEL,\t/* Successful cancel */\n\t[DLM_IVRESHANDLE]\t\t= -EINVAL,\n\t[DLM_DEADLOCK]\t\t\t= -EDEADLK,\n\t[DLM_DENIED_NOASTS]\t\t= -EINVAL,\n\t[DLM_FORWARD]\t\t\t= -EINVAL,\n\t[DLM_TIMEOUT]\t\t\t= -ETIMEDOUT,\n\t[DLM_IVGROUPID]\t\t\t= -EINVAL,\n\t[DLM_VERS_CONFLICT]\t\t= -EOPNOTSUPP,\n\t[DLM_BAD_DEVICE_PATH]\t\t= -ENOENT,\n\t[DLM_NO_DEVICE_PERMISSION]\t= -EPERM,\n\t[DLM_NO_CONTROL_DEVICE]\t\t= -ENOENT,\n\t[DLM_RECOVERING]\t\t= -ENOTCONN,\n\t[DLM_MIGRATING]\t\t\t= -ERESTART,\n\t[DLM_MAXSTATS]\t\t\t= -EINVAL,\n};\n\nstatic int dlm_status_to_errno(enum dlm_status status)\n{\n\tBUG_ON(status < 0 || status >= ARRAY_SIZE(status_map));\n\n\treturn status_map[status];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int o2cb_dlm_lock_status(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn dlm_status_to_errno(lksb->lksb_o2dlm.status);\n}"
  },
  {
    "function_name": "o2cb_dlm_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "220-232",
    "snippet": "static int o2cb_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t\t   u32 flags)\n{\n\tenum dlm_status status;\n\tint o2dlm_flags = flags_to_o2dlm(flags);\n\tint ret;\n\n\tstatus = dlmunlock(conn->cc_lockspace, &lksb->lksb_o2dlm,\n\t\t\t   o2dlm_flags, o2dlm_unlock_ast_wrapper, lksb);\n\tret = dlm_status_to_errno(status);\n\treturn ret;\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_status_to_errno",
          "args": [
            "status"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_status_to_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
          "lines": "157-162",
          "snippet": "static int dlm_status_to_errno(enum dlm_status status)\n{\n\tBUG_ON(status < 0 || status >= ARRAY_SIZE(status_map));\n\n\treturn status_map[status];\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/masklog.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int status_map[] = {\n\t[DLM_NORMAL]\t\t\t= 0,\t\t/* Success */\n\t[DLM_GRANTED]\t\t\t= -EINVAL,\n\t[DLM_DENIED]\t\t\t= -EACCES,\n\t[DLM_DENIED_NOLOCKS]\t\t= -EACCES,\n\t[DLM_WORKING]\t\t\t= -EACCES,\n\t[DLM_BLOCKED]\t\t\t= -EINVAL,\n\t[DLM_BLOCKED_ORPHAN]\t\t= -EINVAL,\n\t[DLM_DENIED_GRACE_PERIOD]\t= -EACCES,\n\t[DLM_SYSERR]\t\t\t= -ENOMEM,\t/* It is what it is */\n\t[DLM_NOSUPPORT]\t\t\t= -EPROTO,\n\t[DLM_CANCELGRANT]\t\t= -EBUSY,\t/* Cancel after grant */\n\t[DLM_IVLOCKID]\t\t\t= -EINVAL,\n\t[DLM_SYNC]\t\t\t= -EINVAL,\n\t[DLM_BADTYPE]\t\t\t= -EINVAL,\n\t[DLM_BADRESOURCE]\t\t= -EINVAL,\n\t[DLM_MAXHANDLES]\t\t= -ENOMEM,\n\t[DLM_NOCLINFO]\t\t\t= -EINVAL,\n\t[DLM_NOLOCKMGR]\t\t\t= -EINVAL,\n\t[DLM_NOPURGED]\t\t\t= -EINVAL,\n\t[DLM_BADARGS]\t\t\t= -EINVAL,\n\t[DLM_VOID]\t\t\t= -EINVAL,\n\t[DLM_NOTQUEUED]\t\t\t= -EAGAIN,\t/* Trylock failed */\n\t[DLM_IVBUFLEN]\t\t\t= -EINVAL,\n\t[DLM_CVTUNGRANT]\t\t= -EPERM,\n\t[DLM_BADPARAM]\t\t\t= -EINVAL,\n\t[DLM_VALNOTVALID]\t\t= -EINVAL,\n\t[DLM_REJECTED]\t\t\t= -EPERM,\n\t[DLM_ABORT]\t\t\t= -EINVAL,\n\t[DLM_CANCEL]\t\t\t= -DLM_ECANCEL,\t/* Successful cancel */\n\t[DLM_IVRESHANDLE]\t\t= -EINVAL,\n\t[DLM_DEADLOCK]\t\t\t= -EDEADLK,\n\t[DLM_DENIED_NOASTS]\t\t= -EINVAL,\n\t[DLM_FORWARD]\t\t\t= -EINVAL,\n\t[DLM_TIMEOUT]\t\t\t= -ETIMEDOUT,\n\t[DLM_IVGROUPID]\t\t\t= -EINVAL,\n\t[DLM_VERS_CONFLICT]\t\t= -EOPNOTSUPP,\n\t[DLM_BAD_DEVICE_PATH]\t\t= -ENOENT,\n\t[DLM_NO_DEVICE_PERMISSION]\t= -EPERM,\n\t[DLM_NO_CONTROL_DEVICE]\t\t= -ENOENT,\n\t[DLM_RECOVERING]\t\t= -ENOTCONN,\n\t[DLM_MIGRATING]\t\t\t= -ERESTART,\n\t[DLM_MAXSTATS]\t\t\t= -EINVAL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int status_map[] = {\n\t[DLM_NORMAL]\t\t\t= 0,\t\t/* Success */\n\t[DLM_GRANTED]\t\t\t= -EINVAL,\n\t[DLM_DENIED]\t\t\t= -EACCES,\n\t[DLM_DENIED_NOLOCKS]\t\t= -EACCES,\n\t[DLM_WORKING]\t\t\t= -EACCES,\n\t[DLM_BLOCKED]\t\t\t= -EINVAL,\n\t[DLM_BLOCKED_ORPHAN]\t\t= -EINVAL,\n\t[DLM_DENIED_GRACE_PERIOD]\t= -EACCES,\n\t[DLM_SYSERR]\t\t\t= -ENOMEM,\t/* It is what it is */\n\t[DLM_NOSUPPORT]\t\t\t= -EPROTO,\n\t[DLM_CANCELGRANT]\t\t= -EBUSY,\t/* Cancel after grant */\n\t[DLM_IVLOCKID]\t\t\t= -EINVAL,\n\t[DLM_SYNC]\t\t\t= -EINVAL,\n\t[DLM_BADTYPE]\t\t\t= -EINVAL,\n\t[DLM_BADRESOURCE]\t\t= -EINVAL,\n\t[DLM_MAXHANDLES]\t\t= -ENOMEM,\n\t[DLM_NOCLINFO]\t\t\t= -EINVAL,\n\t[DLM_NOLOCKMGR]\t\t\t= -EINVAL,\n\t[DLM_NOPURGED]\t\t\t= -EINVAL,\n\t[DLM_BADARGS]\t\t\t= -EINVAL,\n\t[DLM_VOID]\t\t\t= -EINVAL,\n\t[DLM_NOTQUEUED]\t\t\t= -EAGAIN,\t/* Trylock failed */\n\t[DLM_IVBUFLEN]\t\t\t= -EINVAL,\n\t[DLM_CVTUNGRANT]\t\t= -EPERM,\n\t[DLM_BADPARAM]\t\t\t= -EINVAL,\n\t[DLM_VALNOTVALID]\t\t= -EINVAL,\n\t[DLM_REJECTED]\t\t\t= -EPERM,\n\t[DLM_ABORT]\t\t\t= -EINVAL,\n\t[DLM_CANCEL]\t\t\t= -DLM_ECANCEL,\t/* Successful cancel */\n\t[DLM_IVRESHANDLE]\t\t= -EINVAL,\n\t[DLM_DEADLOCK]\t\t\t= -EDEADLK,\n\t[DLM_DENIED_NOASTS]\t\t= -EINVAL,\n\t[DLM_FORWARD]\t\t\t= -EINVAL,\n\t[DLM_TIMEOUT]\t\t\t= -ETIMEDOUT,\n\t[DLM_IVGROUPID]\t\t\t= -EINVAL,\n\t[DLM_VERS_CONFLICT]\t\t= -EOPNOTSUPP,\n\t[DLM_BAD_DEVICE_PATH]\t\t= -ENOENT,\n\t[DLM_NO_DEVICE_PERMISSION]\t= -EPERM,\n\t[DLM_NO_CONTROL_DEVICE]\t\t= -ENOENT,\n\t[DLM_RECOVERING]\t\t= -ENOTCONN,\n\t[DLM_MIGRATING]\t\t\t= -ERESTART,\n\t[DLM_MAXSTATS]\t\t\t= -EINVAL,\n};\n\nstatic int dlm_status_to_errno(enum dlm_status status)\n{\n\tBUG_ON(status < 0 || status >= ARRAY_SIZE(status_map));\n\n\treturn status_map[status];\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlmunlock",
          "args": [
            "conn->cc_lockspace",
            "&lksb->lksb_o2dlm",
            "o2dlm_flags",
            "o2dlm_unlock_ast_wrapper",
            "lksb"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "dlmunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
          "lines": "587-696",
          "snippet": "enum dlm_status dlmunlock(struct dlm_ctxt *dlm, struct dlm_lockstatus *lksb,\n\t\t\t  int flags, dlm_astunlockfunc_t *unlockast, void *data)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_lock *lock = NULL;\n\tint call_ast, is_master;\n\n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tif (flags & ~(LKM_CANCEL | LKM_VALBLK | LKM_INVVALBLK)) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tif ((flags & (LKM_VALBLK | LKM_CANCEL)) == (LKM_VALBLK | LKM_CANCEL)) {\n\t\tmlog(0, \"VALBLK given with CANCEL: ignoring VALBLK\\n\");\n\t\tflags &= ~LKM_VALBLK;\n\t}\n\n\tif (!lksb->lockid || !lksb->lockid->lockres) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tlock = lksb->lockid;\n\tBUG_ON(!lock);\n\tdlm_lock_get(lock);\n\n\tres = lock->lockres;\n\tBUG_ON(!res);\n\tdlm_lockres_get(res);\nretry:\n\tcall_ast = 0;\n\t/* need to retry up here because owner may have changed */\n\tmlog(0, \"lock=%p res=%p\\n\", lock, res);\n\n\tspin_lock(&res->spinlock);\n\tis_master = (res->owner == dlm->node_num);\n\tif (flags & LKM_VALBLK && lock->ml.type != LKM_EXMODE)\n\t\tflags &= ~LKM_VALBLK;\n\tspin_unlock(&res->spinlock);\n\n\tif (is_master) {\n\t\tstatus = dlmunlock_master(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_master: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t} else {\n\t\tstatus = dlmunlock_remote(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_remote: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t}\n\n\tif (status == DLM_RECOVERING ||\n\t    status == DLM_MIGRATING ||\n\t    status == DLM_FORWARD ||\n\t    status == DLM_NOLOCKMGR) {\n\n\t\t/* We want to go away for a tiny bit to allow recovery\n\t\t * / migration to complete on this resource. I don't\n\t\t * know of any wait queue we could sleep on as this\n\t\t * may be happening on another node. Perhaps the\n\t\t * proper solution is to queue up requests on the\n\t\t * other end? */\n\n\t\t/* do we want to yield(); ?? */\n\t\tmsleep(50);\n\n\t\tmlog(0, \"retrying unlock due to pending recovery/\"\n\t\t     \"migration/in-progress/reconnect\\n\");\n\t\tgoto retry;\n\t}\n\n\tif (call_ast) {\n\t\tmlog(0, \"calling unlockast(%p, %d)\\n\", data, status);\n\t\tif (is_master) {\n\t\t\t/* it is possible that there is one last bast\n\t\t\t * pending.  make sure it is flushed, then\n\t\t\t * call the unlockast.\n\t\t\t * not an issue if this is a mastered remotely,\n\t\t\t * since this lock has been removed from the\n\t\t\t * lockres queues and cannot be found. */\n\t\t\tdlm_kick_thread(dlm, NULL);\n\t\t\twait_event(dlm->ast_wq,\n\t\t\t\t   dlm_lock_basts_flushed(dlm, lock));\n\t\t}\n\t\t(*unlockast)(data, status);\n\t}\n\n\tif (status == DLM_CANCELGRANT)\n\t\tstatus = DLM_NORMAL;\n\n\tif (status == DLM_NORMAL) {\n\t\tmlog(0, \"kicking the thread\\n\");\n\t\tdlm_kick_thread(dlm, res);\n\t} else\n\t\tdlm_error(status);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tdlm_lockres_put(res);\n\tdlm_lock_put(lock);\n\n\tmlog(0, \"returning status=%d!\\n\", status);\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);\n\nenum dlm_status dlmunlock(struct dlm_ctxt *dlm, struct dlm_lockstatus *lksb,\n\t\t\t  int flags, dlm_astunlockfunc_t *unlockast, void *data)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_lock *lock = NULL;\n\tint call_ast, is_master;\n\n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tif (flags & ~(LKM_CANCEL | LKM_VALBLK | LKM_INVVALBLK)) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tif ((flags & (LKM_VALBLK | LKM_CANCEL)) == (LKM_VALBLK | LKM_CANCEL)) {\n\t\tmlog(0, \"VALBLK given with CANCEL: ignoring VALBLK\\n\");\n\t\tflags &= ~LKM_VALBLK;\n\t}\n\n\tif (!lksb->lockid || !lksb->lockid->lockres) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tlock = lksb->lockid;\n\tBUG_ON(!lock);\n\tdlm_lock_get(lock);\n\n\tres = lock->lockres;\n\tBUG_ON(!res);\n\tdlm_lockres_get(res);\nretry:\n\tcall_ast = 0;\n\t/* need to retry up here because owner may have changed */\n\tmlog(0, \"lock=%p res=%p\\n\", lock, res);\n\n\tspin_lock(&res->spinlock);\n\tis_master = (res->owner == dlm->node_num);\n\tif (flags & LKM_VALBLK && lock->ml.type != LKM_EXMODE)\n\t\tflags &= ~LKM_VALBLK;\n\tspin_unlock(&res->spinlock);\n\n\tif (is_master) {\n\t\tstatus = dlmunlock_master(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_master: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t} else {\n\t\tstatus = dlmunlock_remote(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_remote: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t}\n\n\tif (status == DLM_RECOVERING ||\n\t    status == DLM_MIGRATING ||\n\t    status == DLM_FORWARD ||\n\t    status == DLM_NOLOCKMGR) {\n\n\t\t/* We want to go away for a tiny bit to allow recovery\n\t\t * / migration to complete on this resource. I don't\n\t\t * know of any wait queue we could sleep on as this\n\t\t * may be happening on another node. Perhaps the\n\t\t * proper solution is to queue up requests on the\n\t\t * other end? */\n\n\t\t/* do we want to yield(); ?? */\n\t\tmsleep(50);\n\n\t\tmlog(0, \"retrying unlock due to pending recovery/\"\n\t\t     \"migration/in-progress/reconnect\\n\");\n\t\tgoto retry;\n\t}\n\n\tif (call_ast) {\n\t\tmlog(0, \"calling unlockast(%p, %d)\\n\", data, status);\n\t\tif (is_master) {\n\t\t\t/* it is possible that there is one last bast\n\t\t\t * pending.  make sure it is flushed, then\n\t\t\t * call the unlockast.\n\t\t\t * not an issue if this is a mastered remotely,\n\t\t\t * since this lock has been removed from the\n\t\t\t * lockres queues and cannot be found. */\n\t\t\tdlm_kick_thread(dlm, NULL);\n\t\t\twait_event(dlm->ast_wq,\n\t\t\t\t   dlm_lock_basts_flushed(dlm, lock));\n\t\t}\n\t\t(*unlockast)(data, status);\n\t}\n\n\tif (status == DLM_CANCELGRANT)\n\t\tstatus = DLM_NORMAL;\n\n\tif (status == DLM_NORMAL) {\n\t\tmlog(0, \"kicking the thread\\n\");\n\t\tdlm_kick_thread(dlm, res);\n\t} else\n\t\tdlm_error(status);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tdlm_lockres_put(res);\n\tdlm_lock_put(lock);\n\n\tmlog(0, \"returning status=%d!\\n\", status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flags_to_o2dlm",
          "args": [
            "flags"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "flags_to_o2dlm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
          "lines": "75-93",
          "snippet": "static int flags_to_o2dlm(u32 flags)\n{\n\tint o2dlm_flags = 0;\n\n\tmap_flag(DLM_LKF_NOQUEUE, LKM_NOQUEUE);\n\tmap_flag(DLM_LKF_CANCEL, LKM_CANCEL);\n\tmap_flag(DLM_LKF_CONVERT, LKM_CONVERT);\n\tmap_flag(DLM_LKF_VALBLK, LKM_VALBLK);\n\tmap_flag(DLM_LKF_IVVALBLK, LKM_INVVALBLK);\n\tmap_flag(DLM_LKF_ORPHAN, LKM_ORPHAN);\n\tmap_flag(DLM_LKF_FORCEUNLOCK, LKM_FORCE);\n\tmap_flag(DLM_LKF_TIMEOUT, LKM_TIMEOUT);\n\tmap_flag(DLM_LKF_LOCAL, LKM_LOCAL);\n\n\t/* map_flag() should have cleared every flag passed in */\n\tBUG_ON(flags != 0);\n\n\treturn o2dlm_flags;\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/masklog.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int flags_to_o2dlm(u32 flags)\n{\n\tint o2dlm_flags = 0;\n\n\tmap_flag(DLM_LKF_NOQUEUE, LKM_NOQUEUE);\n\tmap_flag(DLM_LKF_CANCEL, LKM_CANCEL);\n\tmap_flag(DLM_LKF_CONVERT, LKM_CONVERT);\n\tmap_flag(DLM_LKF_VALBLK, LKM_VALBLK);\n\tmap_flag(DLM_LKF_IVVALBLK, LKM_INVVALBLK);\n\tmap_flag(DLM_LKF_ORPHAN, LKM_ORPHAN);\n\tmap_flag(DLM_LKF_FORCEUNLOCK, LKM_FORCE);\n\tmap_flag(DLM_LKF_TIMEOUT, LKM_TIMEOUT);\n\tmap_flag(DLM_LKF_LOCAL, LKM_LOCAL);\n\n\t/* map_flag() should have cleared every flag passed in */\n\tBUG_ON(flags != 0);\n\n\treturn o2dlm_flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int o2cb_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t\t   u32 flags)\n{\n\tenum dlm_status status;\n\tint o2dlm_flags = flags_to_o2dlm(flags);\n\tint ret;\n\n\tstatus = dlmunlock(conn->cc_lockspace, &lksb->lksb_o2dlm,\n\t\t\t   o2dlm_flags, o2dlm_unlock_ast_wrapper, lksb);\n\tret = dlm_status_to_errno(status);\n\treturn ret;\n}"
  },
  {
    "function_name": "o2cb_dlm_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "200-218",
    "snippet": "static int o2cb_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t\t int mode,\n\t\t\t struct ocfs2_dlm_lksb *lksb,\n\t\t\t u32 flags,\n\t\t\t void *name,\n\t\t\t unsigned int namelen)\n{\n\tenum dlm_status status;\n\tint o2dlm_mode = mode_to_o2dlm(mode);\n\tint o2dlm_flags = flags_to_o2dlm(flags);\n\tint ret;\n\n\tstatus = dlmlock(conn->cc_lockspace, o2dlm_mode, &lksb->lksb_o2dlm,\n\t\t\t o2dlm_flags, name, namelen,\n\t\t\t o2dlm_lock_ast_wrapper, lksb,\n\t\t\t o2dlm_blocking_ast_wrapper);\n\tret = dlm_status_to_errno(status);\n\treturn ret;\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_status_to_errno",
          "args": [
            "status"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_status_to_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
          "lines": "157-162",
          "snippet": "static int dlm_status_to_errno(enum dlm_status status)\n{\n\tBUG_ON(status < 0 || status >= ARRAY_SIZE(status_map));\n\n\treturn status_map[status];\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/masklog.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int status_map[] = {\n\t[DLM_NORMAL]\t\t\t= 0,\t\t/* Success */\n\t[DLM_GRANTED]\t\t\t= -EINVAL,\n\t[DLM_DENIED]\t\t\t= -EACCES,\n\t[DLM_DENIED_NOLOCKS]\t\t= -EACCES,\n\t[DLM_WORKING]\t\t\t= -EACCES,\n\t[DLM_BLOCKED]\t\t\t= -EINVAL,\n\t[DLM_BLOCKED_ORPHAN]\t\t= -EINVAL,\n\t[DLM_DENIED_GRACE_PERIOD]\t= -EACCES,\n\t[DLM_SYSERR]\t\t\t= -ENOMEM,\t/* It is what it is */\n\t[DLM_NOSUPPORT]\t\t\t= -EPROTO,\n\t[DLM_CANCELGRANT]\t\t= -EBUSY,\t/* Cancel after grant */\n\t[DLM_IVLOCKID]\t\t\t= -EINVAL,\n\t[DLM_SYNC]\t\t\t= -EINVAL,\n\t[DLM_BADTYPE]\t\t\t= -EINVAL,\n\t[DLM_BADRESOURCE]\t\t= -EINVAL,\n\t[DLM_MAXHANDLES]\t\t= -ENOMEM,\n\t[DLM_NOCLINFO]\t\t\t= -EINVAL,\n\t[DLM_NOLOCKMGR]\t\t\t= -EINVAL,\n\t[DLM_NOPURGED]\t\t\t= -EINVAL,\n\t[DLM_BADARGS]\t\t\t= -EINVAL,\n\t[DLM_VOID]\t\t\t= -EINVAL,\n\t[DLM_NOTQUEUED]\t\t\t= -EAGAIN,\t/* Trylock failed */\n\t[DLM_IVBUFLEN]\t\t\t= -EINVAL,\n\t[DLM_CVTUNGRANT]\t\t= -EPERM,\n\t[DLM_BADPARAM]\t\t\t= -EINVAL,\n\t[DLM_VALNOTVALID]\t\t= -EINVAL,\n\t[DLM_REJECTED]\t\t\t= -EPERM,\n\t[DLM_ABORT]\t\t\t= -EINVAL,\n\t[DLM_CANCEL]\t\t\t= -DLM_ECANCEL,\t/* Successful cancel */\n\t[DLM_IVRESHANDLE]\t\t= -EINVAL,\n\t[DLM_DEADLOCK]\t\t\t= -EDEADLK,\n\t[DLM_DENIED_NOASTS]\t\t= -EINVAL,\n\t[DLM_FORWARD]\t\t\t= -EINVAL,\n\t[DLM_TIMEOUT]\t\t\t= -ETIMEDOUT,\n\t[DLM_IVGROUPID]\t\t\t= -EINVAL,\n\t[DLM_VERS_CONFLICT]\t\t= -EOPNOTSUPP,\n\t[DLM_BAD_DEVICE_PATH]\t\t= -ENOENT,\n\t[DLM_NO_DEVICE_PERMISSION]\t= -EPERM,\n\t[DLM_NO_CONTROL_DEVICE]\t\t= -ENOENT,\n\t[DLM_RECOVERING]\t\t= -ENOTCONN,\n\t[DLM_MIGRATING]\t\t\t= -ERESTART,\n\t[DLM_MAXSTATS]\t\t\t= -EINVAL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int status_map[] = {\n\t[DLM_NORMAL]\t\t\t= 0,\t\t/* Success */\n\t[DLM_GRANTED]\t\t\t= -EINVAL,\n\t[DLM_DENIED]\t\t\t= -EACCES,\n\t[DLM_DENIED_NOLOCKS]\t\t= -EACCES,\n\t[DLM_WORKING]\t\t\t= -EACCES,\n\t[DLM_BLOCKED]\t\t\t= -EINVAL,\n\t[DLM_BLOCKED_ORPHAN]\t\t= -EINVAL,\n\t[DLM_DENIED_GRACE_PERIOD]\t= -EACCES,\n\t[DLM_SYSERR]\t\t\t= -ENOMEM,\t/* It is what it is */\n\t[DLM_NOSUPPORT]\t\t\t= -EPROTO,\n\t[DLM_CANCELGRANT]\t\t= -EBUSY,\t/* Cancel after grant */\n\t[DLM_IVLOCKID]\t\t\t= -EINVAL,\n\t[DLM_SYNC]\t\t\t= -EINVAL,\n\t[DLM_BADTYPE]\t\t\t= -EINVAL,\n\t[DLM_BADRESOURCE]\t\t= -EINVAL,\n\t[DLM_MAXHANDLES]\t\t= -ENOMEM,\n\t[DLM_NOCLINFO]\t\t\t= -EINVAL,\n\t[DLM_NOLOCKMGR]\t\t\t= -EINVAL,\n\t[DLM_NOPURGED]\t\t\t= -EINVAL,\n\t[DLM_BADARGS]\t\t\t= -EINVAL,\n\t[DLM_VOID]\t\t\t= -EINVAL,\n\t[DLM_NOTQUEUED]\t\t\t= -EAGAIN,\t/* Trylock failed */\n\t[DLM_IVBUFLEN]\t\t\t= -EINVAL,\n\t[DLM_CVTUNGRANT]\t\t= -EPERM,\n\t[DLM_BADPARAM]\t\t\t= -EINVAL,\n\t[DLM_VALNOTVALID]\t\t= -EINVAL,\n\t[DLM_REJECTED]\t\t\t= -EPERM,\n\t[DLM_ABORT]\t\t\t= -EINVAL,\n\t[DLM_CANCEL]\t\t\t= -DLM_ECANCEL,\t/* Successful cancel */\n\t[DLM_IVRESHANDLE]\t\t= -EINVAL,\n\t[DLM_DEADLOCK]\t\t\t= -EDEADLK,\n\t[DLM_DENIED_NOASTS]\t\t= -EINVAL,\n\t[DLM_FORWARD]\t\t\t= -EINVAL,\n\t[DLM_TIMEOUT]\t\t\t= -ETIMEDOUT,\n\t[DLM_IVGROUPID]\t\t\t= -EINVAL,\n\t[DLM_VERS_CONFLICT]\t\t= -EOPNOTSUPP,\n\t[DLM_BAD_DEVICE_PATH]\t\t= -ENOENT,\n\t[DLM_NO_DEVICE_PERMISSION]\t= -EPERM,\n\t[DLM_NO_CONTROL_DEVICE]\t\t= -ENOENT,\n\t[DLM_RECOVERING]\t\t= -ENOTCONN,\n\t[DLM_MIGRATING]\t\t\t= -ERESTART,\n\t[DLM_MAXSTATS]\t\t\t= -EINVAL,\n};\n\nstatic int dlm_status_to_errno(enum dlm_status status)\n{\n\tBUG_ON(status < 0 || status >= ARRAY_SIZE(status_map));\n\n\treturn status_map[status];\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlmlock",
          "args": [
            "conn->cc_lockspace",
            "o2dlm_mode",
            "&lksb->lksb_o2dlm",
            "o2dlm_flags",
            "name",
            "namelen",
            "o2dlm_lock_ast_wrapper",
            "lksb",
            "o2dlm_blocking_ast_wrapper"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "dlmlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "558-760",
          "snippet": "enum dlm_status dlmlock(struct dlm_ctxt *dlm, int mode,\n\t\t\tstruct dlm_lockstatus *lksb, int flags,\n\t\t\tconst char *name, int namelen, dlm_astlockfunc_t *ast,\n\t\t\tvoid *data, dlm_bastlockfunc_t *bast)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tint convert = 0, recovery = 0;\n\n\t/* yes this function is a mess.\n\t * TODO: clean this up.  lots of common code in the\n\t *       lock and convert paths, especially in the retry blocks */\n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tstatus = DLM_BADPARAM;\n\tif (mode != LKM_EXMODE && mode != LKM_PRMODE && mode != LKM_NLMODE) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tif (flags & ~LKM_VALID_FLAGS) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tconvert = (flags & LKM_CONVERT);\n\trecovery = (flags & LKM_RECOVERY);\n\n\tif (recovery &&\n\t    (!dlm_is_recovery_lock(name, namelen) || convert) ) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\tif (convert && (flags & LKM_LOCAL)) {\n\t\tmlog(ML_ERROR, \"strange LOCAL convert request!\\n\");\n\t\tgoto error;\n\t}\n\n\tif (convert) {\n\t\t/* CONVERT request */\n\n\t\t/* if converting, must pass in a valid dlm_lock */\n\t\tlock = lksb->lockid;\n\t\tif (!lock) {\n\t\t\tmlog(ML_ERROR, \"NULL lock pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tres = lock->lockres;\n\t\tif (!res) {\n\t\t\tmlog(ML_ERROR, \"NULL lockres pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tdlm_lockres_get(res);\n\n\t\t/* XXX: for ocfs2 purposes, the ast/bast/astdata/lksb are\n\t \t * static after the original lock call.  convert requests will\n\t\t * ensure that everything is the same, or return DLM_BADARGS.\n\t \t * this means that DLM_DENIED_NOASTS will never be returned.\n\t \t */\n\t\tif (lock->lksb != lksb || lock->ast != ast ||\n\t\t    lock->bast != bast || lock->astdata != data) {\n\t\t\tstatus = DLM_BADARGS;\n\t\t\tmlog(ML_ERROR, \"new args:  lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lksb, ast, bast, data);\n\t\t\tmlog(ML_ERROR, \"orig args: lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lock->lksb, lock->ast,\n\t\t\t     lock->bast, lock->astdata);\n\t\t\tgoto error;\n\t\t}\nretry_convert:\n\t\tdlm_wait_for_recovery(dlm);\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmconvert_master(dlm, res, lock, flags, mode);\n\t\telse\n\t\t\tstatus = dlmconvert_remote(dlm, res, lock, flags, mode);\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\t/* for now, see how this works without sleeping\n\t\t\t * and just retry right away.  I suspect the reco\n\t\t\t * or migration will complete fast enough that\n\t\t\t * no waiting will be necessary */\n\t\t\tmlog(0, \"retrying convert with migration/recovery/\"\n\t\t\t     \"in-progress\\n\");\n\t\t\tmsleep(100);\n\t\t\tgoto retry_convert;\n\t\t}\n\t} else {\n\t\tu64 tmpcookie;\n\n\t\t/* LOCK request */\n\t\tstatus = DLM_BADARGS;\n\t\tif (!name) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tstatus = DLM_IVBUFLEN;\n\t\tif (namelen > DLM_LOCKID_NAME_MAX || namelen < 1) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tdlm_get_next_cookie(dlm->node_num, &tmpcookie);\n\t\tlock = dlm_new_lock(mode, dlm->node_num, tmpcookie, lksb);\n\t\tif (!lock) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!recovery)\n\t\t\tdlm_wait_for_recovery(dlm);\n\n\t\t/* find or create the lock resource */\n\t\tres = dlm_get_lock_resource(dlm, name, namelen, flags);\n\t\tif (!res) {\n\t\t\tstatus = DLM_IVLOCKID;\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tmlog(0, \"type=%d, flags = 0x%x\\n\", mode, flags);\n\t\tmlog(0, \"creating lock: lock=%p res=%p\\n\", lock, res);\n\n\t\tdlm_lock_attach_lockres(lock, res);\n\t\tlock->ast = ast;\n\t\tlock->bast = bast;\n\t\tlock->astdata = data;\n\nretry_lock:\n\t\tif (flags & LKM_VALBLK) {\n\t\t\tmlog(0, \"LKM_VALBLK passed by caller\\n\");\n\n\t\t\t/* LVB requests for non PR, PW or EX locks are\n\t\t\t * ignored. */\n\t\t\tif (mode < LKM_PRMODE)\n\t\t\t\tflags &= ~LKM_VALBLK;\n\t\t\telse {\n\t\t\t\tflags |= LKM_GET_LVB;\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t}\n\t\t}\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmlock_master(dlm, res, lock, flags);\n\t\telse\n\t\t\tstatus = dlmlock_remote(dlm, res, lock, flags);\n\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\tmsleep(100);\n\t\t\tif (recovery) {\n\t\t\t\tif (status != DLM_RECOVERING)\n\t\t\t\t\tgoto retry_lock;\n\t\t\t\t/* wait to see the node go down, then\n\t\t\t\t * drop down and allow the lockres to\n\t\t\t\t * get cleaned up.  need to remaster. */\n\t\t\t\tdlm_wait_for_node_death(dlm, res->owner,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\t\t} else {\n\t\t\t\tdlm_wait_for_recovery(dlm);\n\t\t\t\tgoto retry_lock;\n\t\t\t}\n\t\t}\n\n\t\t/* Inflight taken in dlm_get_lock_resource() is dropped here */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_lockres_drop_inflight_ref(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\n\t\tdlm_lockres_calc_usage(dlm, res);\n\t\tdlm_kick_thread(dlm, res);\n\n\t\tif (status != DLM_NORMAL) {\n\t\t\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n\t\t\tif (status != DLM_NOTQUEUED)\n\t\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\t}\n\nerror:\n\tif (status != DLM_NORMAL) {\n\t\tif (lock && !convert)\n\t\t\tdlm_lock_put(lock);\n\t\t// this is kind of unnecessary\n\t\tlksb->status = status;\n\t}\n\n\t/* put lockres ref from the convert path\n\t * or from dlm_get_lock_resource */\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nenum dlm_status dlmlock(struct dlm_ctxt *dlm, int mode,\n\t\t\tstruct dlm_lockstatus *lksb, int flags,\n\t\t\tconst char *name, int namelen, dlm_astlockfunc_t *ast,\n\t\t\tvoid *data, dlm_bastlockfunc_t *bast)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tint convert = 0, recovery = 0;\n\n\t/* yes this function is a mess.\n\t * TODO: clean this up.  lots of common code in the\n\t *       lock and convert paths, especially in the retry blocks */\n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tstatus = DLM_BADPARAM;\n\tif (mode != LKM_EXMODE && mode != LKM_PRMODE && mode != LKM_NLMODE) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tif (flags & ~LKM_VALID_FLAGS) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tconvert = (flags & LKM_CONVERT);\n\trecovery = (flags & LKM_RECOVERY);\n\n\tif (recovery &&\n\t    (!dlm_is_recovery_lock(name, namelen) || convert) ) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\tif (convert && (flags & LKM_LOCAL)) {\n\t\tmlog(ML_ERROR, \"strange LOCAL convert request!\\n\");\n\t\tgoto error;\n\t}\n\n\tif (convert) {\n\t\t/* CONVERT request */\n\n\t\t/* if converting, must pass in a valid dlm_lock */\n\t\tlock = lksb->lockid;\n\t\tif (!lock) {\n\t\t\tmlog(ML_ERROR, \"NULL lock pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tres = lock->lockres;\n\t\tif (!res) {\n\t\t\tmlog(ML_ERROR, \"NULL lockres pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tdlm_lockres_get(res);\n\n\t\t/* XXX: for ocfs2 purposes, the ast/bast/astdata/lksb are\n\t \t * static after the original lock call.  convert requests will\n\t\t * ensure that everything is the same, or return DLM_BADARGS.\n\t \t * this means that DLM_DENIED_NOASTS will never be returned.\n\t \t */\n\t\tif (lock->lksb != lksb || lock->ast != ast ||\n\t\t    lock->bast != bast || lock->astdata != data) {\n\t\t\tstatus = DLM_BADARGS;\n\t\t\tmlog(ML_ERROR, \"new args:  lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lksb, ast, bast, data);\n\t\t\tmlog(ML_ERROR, \"orig args: lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lock->lksb, lock->ast,\n\t\t\t     lock->bast, lock->astdata);\n\t\t\tgoto error;\n\t\t}\nretry_convert:\n\t\tdlm_wait_for_recovery(dlm);\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmconvert_master(dlm, res, lock, flags, mode);\n\t\telse\n\t\t\tstatus = dlmconvert_remote(dlm, res, lock, flags, mode);\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\t/* for now, see how this works without sleeping\n\t\t\t * and just retry right away.  I suspect the reco\n\t\t\t * or migration will complete fast enough that\n\t\t\t * no waiting will be necessary */\n\t\t\tmlog(0, \"retrying convert with migration/recovery/\"\n\t\t\t     \"in-progress\\n\");\n\t\t\tmsleep(100);\n\t\t\tgoto retry_convert;\n\t\t}\n\t} else {\n\t\tu64 tmpcookie;\n\n\t\t/* LOCK request */\n\t\tstatus = DLM_BADARGS;\n\t\tif (!name) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tstatus = DLM_IVBUFLEN;\n\t\tif (namelen > DLM_LOCKID_NAME_MAX || namelen < 1) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tdlm_get_next_cookie(dlm->node_num, &tmpcookie);\n\t\tlock = dlm_new_lock(mode, dlm->node_num, tmpcookie, lksb);\n\t\tif (!lock) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!recovery)\n\t\t\tdlm_wait_for_recovery(dlm);\n\n\t\t/* find or create the lock resource */\n\t\tres = dlm_get_lock_resource(dlm, name, namelen, flags);\n\t\tif (!res) {\n\t\t\tstatus = DLM_IVLOCKID;\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tmlog(0, \"type=%d, flags = 0x%x\\n\", mode, flags);\n\t\tmlog(0, \"creating lock: lock=%p res=%p\\n\", lock, res);\n\n\t\tdlm_lock_attach_lockres(lock, res);\n\t\tlock->ast = ast;\n\t\tlock->bast = bast;\n\t\tlock->astdata = data;\n\nretry_lock:\n\t\tif (flags & LKM_VALBLK) {\n\t\t\tmlog(0, \"LKM_VALBLK passed by caller\\n\");\n\n\t\t\t/* LVB requests for non PR, PW or EX locks are\n\t\t\t * ignored. */\n\t\t\tif (mode < LKM_PRMODE)\n\t\t\t\tflags &= ~LKM_VALBLK;\n\t\t\telse {\n\t\t\t\tflags |= LKM_GET_LVB;\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t}\n\t\t}\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmlock_master(dlm, res, lock, flags);\n\t\telse\n\t\t\tstatus = dlmlock_remote(dlm, res, lock, flags);\n\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\tmsleep(100);\n\t\t\tif (recovery) {\n\t\t\t\tif (status != DLM_RECOVERING)\n\t\t\t\t\tgoto retry_lock;\n\t\t\t\t/* wait to see the node go down, then\n\t\t\t\t * drop down and allow the lockres to\n\t\t\t\t * get cleaned up.  need to remaster. */\n\t\t\t\tdlm_wait_for_node_death(dlm, res->owner,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\t\t} else {\n\t\t\t\tdlm_wait_for_recovery(dlm);\n\t\t\t\tgoto retry_lock;\n\t\t\t}\n\t\t}\n\n\t\t/* Inflight taken in dlm_get_lock_resource() is dropped here */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_lockres_drop_inflight_ref(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\n\t\tdlm_lockres_calc_usage(dlm, res);\n\t\tdlm_kick_thread(dlm, res);\n\n\t\tif (status != DLM_NORMAL) {\n\t\t\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n\t\t\tif (status != DLM_NOTQUEUED)\n\t\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\t}\n\nerror:\n\tif (status != DLM_NORMAL) {\n\t\tif (lock && !convert)\n\t\t\tdlm_lock_put(lock);\n\t\t// this is kind of unnecessary\n\t\tlksb->status = status;\n\t}\n\n\t/* put lockres ref from the convert path\n\t * or from dlm_get_lock_resource */\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flags_to_o2dlm",
          "args": [
            "flags"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "flags_to_o2dlm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
          "lines": "75-93",
          "snippet": "static int flags_to_o2dlm(u32 flags)\n{\n\tint o2dlm_flags = 0;\n\n\tmap_flag(DLM_LKF_NOQUEUE, LKM_NOQUEUE);\n\tmap_flag(DLM_LKF_CANCEL, LKM_CANCEL);\n\tmap_flag(DLM_LKF_CONVERT, LKM_CONVERT);\n\tmap_flag(DLM_LKF_VALBLK, LKM_VALBLK);\n\tmap_flag(DLM_LKF_IVVALBLK, LKM_INVVALBLK);\n\tmap_flag(DLM_LKF_ORPHAN, LKM_ORPHAN);\n\tmap_flag(DLM_LKF_FORCEUNLOCK, LKM_FORCE);\n\tmap_flag(DLM_LKF_TIMEOUT, LKM_TIMEOUT);\n\tmap_flag(DLM_LKF_LOCAL, LKM_LOCAL);\n\n\t/* map_flag() should have cleared every flag passed in */\n\tBUG_ON(flags != 0);\n\n\treturn o2dlm_flags;\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/masklog.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int flags_to_o2dlm(u32 flags)\n{\n\tint o2dlm_flags = 0;\n\n\tmap_flag(DLM_LKF_NOQUEUE, LKM_NOQUEUE);\n\tmap_flag(DLM_LKF_CANCEL, LKM_CANCEL);\n\tmap_flag(DLM_LKF_CONVERT, LKM_CONVERT);\n\tmap_flag(DLM_LKF_VALBLK, LKM_VALBLK);\n\tmap_flag(DLM_LKF_IVVALBLK, LKM_INVVALBLK);\n\tmap_flag(DLM_LKF_ORPHAN, LKM_ORPHAN);\n\tmap_flag(DLM_LKF_FORCEUNLOCK, LKM_FORCE);\n\tmap_flag(DLM_LKF_TIMEOUT, LKM_TIMEOUT);\n\tmap_flag(DLM_LKF_LOCAL, LKM_LOCAL);\n\n\t/* map_flag() should have cleared every flag passed in */\n\tBUG_ON(flags != 0);\n\n\treturn o2dlm_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mode_to_o2dlm",
          "args": [
            "mode"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "mode_to_o2dlm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
          "lines": "63-68",
          "snippet": "static inline int mode_to_o2dlm(int mode)\n{\n\tBUG_ON(mode > LKM_MAXMODE);\n\n\treturn mode;\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/masklog.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic inline int mode_to_o2dlm(int mode)\n{\n\tBUG_ON(mode > LKM_MAXMODE);\n\n\treturn mode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int o2cb_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t\t int mode,\n\t\t\t struct ocfs2_dlm_lksb *lksb,\n\t\t\t u32 flags,\n\t\t\t void *name,\n\t\t\t unsigned int namelen)\n{\n\tenum dlm_status status;\n\tint o2dlm_mode = mode_to_o2dlm(mode);\n\tint o2dlm_flags = flags_to_o2dlm(flags);\n\tint ret;\n\n\tstatus = dlmlock(conn->cc_lockspace, o2dlm_mode, &lksb->lksb_o2dlm,\n\t\t\t o2dlm_flags, name, namelen,\n\t\t\t o2dlm_lock_ast_wrapper, lksb,\n\t\t\t o2dlm_blocking_ast_wrapper);\n\tret = dlm_status_to_errno(status);\n\treturn ret;\n}"
  },
  {
    "function_name": "o2dlm_unlock_ast_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "178-198",
    "snippet": "static void o2dlm_unlock_ast_wrapper(void *astarg, enum dlm_status status)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\tint error = dlm_status_to_errno(status);\n\n\t/*\n\t * In o2dlm, you can get both the lock_ast() for the lock being\n\t * granted and the unlock_ast() for the CANCEL failing.  A\n\t * successful cancel sends DLM_NORMAL here.  If the\n\t * lock grant happened before the cancel arrived, you get\n\t * DLM_CANCELGRANT.\n\t *\n\t * There's no need for the double-ast.  If we see DLM_CANCELGRANT,\n\t * we just ignore it.  We expect the lock_ast() to handle the\n\t * granted lock.\n\t */\n\tif (status == DLM_CANCELGRANT)\n\t\treturn;\n\n\tlksb->lksb_conn->cc_proto->lp_unlock_ast(lksb, error);\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lksb->lksb_conn->cc_proto->lp_unlock_ast",
          "args": [
            "lksb",
            "error"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_status_to_errno",
          "args": [
            "status"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_status_to_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
          "lines": "157-162",
          "snippet": "static int dlm_status_to_errno(enum dlm_status status)\n{\n\tBUG_ON(status < 0 || status >= ARRAY_SIZE(status_map));\n\n\treturn status_map[status];\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/masklog.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int status_map[] = {\n\t[DLM_NORMAL]\t\t\t= 0,\t\t/* Success */\n\t[DLM_GRANTED]\t\t\t= -EINVAL,\n\t[DLM_DENIED]\t\t\t= -EACCES,\n\t[DLM_DENIED_NOLOCKS]\t\t= -EACCES,\n\t[DLM_WORKING]\t\t\t= -EACCES,\n\t[DLM_BLOCKED]\t\t\t= -EINVAL,\n\t[DLM_BLOCKED_ORPHAN]\t\t= -EINVAL,\n\t[DLM_DENIED_GRACE_PERIOD]\t= -EACCES,\n\t[DLM_SYSERR]\t\t\t= -ENOMEM,\t/* It is what it is */\n\t[DLM_NOSUPPORT]\t\t\t= -EPROTO,\n\t[DLM_CANCELGRANT]\t\t= -EBUSY,\t/* Cancel after grant */\n\t[DLM_IVLOCKID]\t\t\t= -EINVAL,\n\t[DLM_SYNC]\t\t\t= -EINVAL,\n\t[DLM_BADTYPE]\t\t\t= -EINVAL,\n\t[DLM_BADRESOURCE]\t\t= -EINVAL,\n\t[DLM_MAXHANDLES]\t\t= -ENOMEM,\n\t[DLM_NOCLINFO]\t\t\t= -EINVAL,\n\t[DLM_NOLOCKMGR]\t\t\t= -EINVAL,\n\t[DLM_NOPURGED]\t\t\t= -EINVAL,\n\t[DLM_BADARGS]\t\t\t= -EINVAL,\n\t[DLM_VOID]\t\t\t= -EINVAL,\n\t[DLM_NOTQUEUED]\t\t\t= -EAGAIN,\t/* Trylock failed */\n\t[DLM_IVBUFLEN]\t\t\t= -EINVAL,\n\t[DLM_CVTUNGRANT]\t\t= -EPERM,\n\t[DLM_BADPARAM]\t\t\t= -EINVAL,\n\t[DLM_VALNOTVALID]\t\t= -EINVAL,\n\t[DLM_REJECTED]\t\t\t= -EPERM,\n\t[DLM_ABORT]\t\t\t= -EINVAL,\n\t[DLM_CANCEL]\t\t\t= -DLM_ECANCEL,\t/* Successful cancel */\n\t[DLM_IVRESHANDLE]\t\t= -EINVAL,\n\t[DLM_DEADLOCK]\t\t\t= -EDEADLK,\n\t[DLM_DENIED_NOASTS]\t\t= -EINVAL,\n\t[DLM_FORWARD]\t\t\t= -EINVAL,\n\t[DLM_TIMEOUT]\t\t\t= -ETIMEDOUT,\n\t[DLM_IVGROUPID]\t\t\t= -EINVAL,\n\t[DLM_VERS_CONFLICT]\t\t= -EOPNOTSUPP,\n\t[DLM_BAD_DEVICE_PATH]\t\t= -ENOENT,\n\t[DLM_NO_DEVICE_PERMISSION]\t= -EPERM,\n\t[DLM_NO_CONTROL_DEVICE]\t\t= -ENOENT,\n\t[DLM_RECOVERING]\t\t= -ENOTCONN,\n\t[DLM_MIGRATING]\t\t\t= -ERESTART,\n\t[DLM_MAXSTATS]\t\t\t= -EINVAL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int status_map[] = {\n\t[DLM_NORMAL]\t\t\t= 0,\t\t/* Success */\n\t[DLM_GRANTED]\t\t\t= -EINVAL,\n\t[DLM_DENIED]\t\t\t= -EACCES,\n\t[DLM_DENIED_NOLOCKS]\t\t= -EACCES,\n\t[DLM_WORKING]\t\t\t= -EACCES,\n\t[DLM_BLOCKED]\t\t\t= -EINVAL,\n\t[DLM_BLOCKED_ORPHAN]\t\t= -EINVAL,\n\t[DLM_DENIED_GRACE_PERIOD]\t= -EACCES,\n\t[DLM_SYSERR]\t\t\t= -ENOMEM,\t/* It is what it is */\n\t[DLM_NOSUPPORT]\t\t\t= -EPROTO,\n\t[DLM_CANCELGRANT]\t\t= -EBUSY,\t/* Cancel after grant */\n\t[DLM_IVLOCKID]\t\t\t= -EINVAL,\n\t[DLM_SYNC]\t\t\t= -EINVAL,\n\t[DLM_BADTYPE]\t\t\t= -EINVAL,\n\t[DLM_BADRESOURCE]\t\t= -EINVAL,\n\t[DLM_MAXHANDLES]\t\t= -ENOMEM,\n\t[DLM_NOCLINFO]\t\t\t= -EINVAL,\n\t[DLM_NOLOCKMGR]\t\t\t= -EINVAL,\n\t[DLM_NOPURGED]\t\t\t= -EINVAL,\n\t[DLM_BADARGS]\t\t\t= -EINVAL,\n\t[DLM_VOID]\t\t\t= -EINVAL,\n\t[DLM_NOTQUEUED]\t\t\t= -EAGAIN,\t/* Trylock failed */\n\t[DLM_IVBUFLEN]\t\t\t= -EINVAL,\n\t[DLM_CVTUNGRANT]\t\t= -EPERM,\n\t[DLM_BADPARAM]\t\t\t= -EINVAL,\n\t[DLM_VALNOTVALID]\t\t= -EINVAL,\n\t[DLM_REJECTED]\t\t\t= -EPERM,\n\t[DLM_ABORT]\t\t\t= -EINVAL,\n\t[DLM_CANCEL]\t\t\t= -DLM_ECANCEL,\t/* Successful cancel */\n\t[DLM_IVRESHANDLE]\t\t= -EINVAL,\n\t[DLM_DEADLOCK]\t\t\t= -EDEADLK,\n\t[DLM_DENIED_NOASTS]\t\t= -EINVAL,\n\t[DLM_FORWARD]\t\t\t= -EINVAL,\n\t[DLM_TIMEOUT]\t\t\t= -ETIMEDOUT,\n\t[DLM_IVGROUPID]\t\t\t= -EINVAL,\n\t[DLM_VERS_CONFLICT]\t\t= -EOPNOTSUPP,\n\t[DLM_BAD_DEVICE_PATH]\t\t= -ENOENT,\n\t[DLM_NO_DEVICE_PERMISSION]\t= -EPERM,\n\t[DLM_NO_CONTROL_DEVICE]\t\t= -ENOENT,\n\t[DLM_RECOVERING]\t\t= -ENOTCONN,\n\t[DLM_MIGRATING]\t\t\t= -ERESTART,\n\t[DLM_MAXSTATS]\t\t\t= -EINVAL,\n};\n\nstatic int dlm_status_to_errno(enum dlm_status status)\n{\n\tBUG_ON(status < 0 || status >= ARRAY_SIZE(status_map));\n\n\treturn status_map[status];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic void o2dlm_unlock_ast_wrapper(void *astarg, enum dlm_status status)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\tint error = dlm_status_to_errno(status);\n\n\t/*\n\t * In o2dlm, you can get both the lock_ast() for the lock being\n\t * granted and the unlock_ast() for the CANCEL failing.  A\n\t * successful cancel sends DLM_NORMAL here.  If the\n\t * lock grant happened before the cancel arrived, you get\n\t * DLM_CANCELGRANT.\n\t *\n\t * There's no need for the double-ast.  If we see DLM_CANCELGRANT,\n\t * we just ignore it.  We expect the lock_ast() to handle the\n\t * granted lock.\n\t */\n\tif (status == DLM_CANCELGRANT)\n\t\treturn;\n\n\tlksb->lksb_conn->cc_proto->lp_unlock_ast(lksb, error);\n}"
  },
  {
    "function_name": "o2dlm_blocking_ast_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "171-176",
    "snippet": "static void o2dlm_blocking_ast_wrapper(void *astarg, int level)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_blocking_ast(lksb, level);\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lksb->lksb_conn->cc_proto->lp_blocking_ast",
          "args": [
            "lksb",
            "level"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic void o2dlm_blocking_ast_wrapper(void *astarg, int level)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_blocking_ast(lksb, level);\n}"
  },
  {
    "function_name": "o2dlm_lock_ast_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "164-169",
    "snippet": "static void o2dlm_lock_ast_wrapper(void *astarg)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_lock_ast(lksb);\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lksb->lksb_conn->cc_proto->lp_lock_ast",
          "args": [
            "lksb"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic void o2dlm_lock_ast_wrapper(void *astarg)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_lock_ast(lksb);\n}"
  },
  {
    "function_name": "dlm_status_to_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "157-162",
    "snippet": "static int dlm_status_to_errno(enum dlm_status status)\n{\n\tBUG_ON(status < 0 || status >= ARRAY_SIZE(status_map));\n\n\treturn status_map[status];\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int status_map[] = {\n\t[DLM_NORMAL]\t\t\t= 0,\t\t/* Success */\n\t[DLM_GRANTED]\t\t\t= -EINVAL,\n\t[DLM_DENIED]\t\t\t= -EACCES,\n\t[DLM_DENIED_NOLOCKS]\t\t= -EACCES,\n\t[DLM_WORKING]\t\t\t= -EACCES,\n\t[DLM_BLOCKED]\t\t\t= -EINVAL,\n\t[DLM_BLOCKED_ORPHAN]\t\t= -EINVAL,\n\t[DLM_DENIED_GRACE_PERIOD]\t= -EACCES,\n\t[DLM_SYSERR]\t\t\t= -ENOMEM,\t/* It is what it is */\n\t[DLM_NOSUPPORT]\t\t\t= -EPROTO,\n\t[DLM_CANCELGRANT]\t\t= -EBUSY,\t/* Cancel after grant */\n\t[DLM_IVLOCKID]\t\t\t= -EINVAL,\n\t[DLM_SYNC]\t\t\t= -EINVAL,\n\t[DLM_BADTYPE]\t\t\t= -EINVAL,\n\t[DLM_BADRESOURCE]\t\t= -EINVAL,\n\t[DLM_MAXHANDLES]\t\t= -ENOMEM,\n\t[DLM_NOCLINFO]\t\t\t= -EINVAL,\n\t[DLM_NOLOCKMGR]\t\t\t= -EINVAL,\n\t[DLM_NOPURGED]\t\t\t= -EINVAL,\n\t[DLM_BADARGS]\t\t\t= -EINVAL,\n\t[DLM_VOID]\t\t\t= -EINVAL,\n\t[DLM_NOTQUEUED]\t\t\t= -EAGAIN,\t/* Trylock failed */\n\t[DLM_IVBUFLEN]\t\t\t= -EINVAL,\n\t[DLM_CVTUNGRANT]\t\t= -EPERM,\n\t[DLM_BADPARAM]\t\t\t= -EINVAL,\n\t[DLM_VALNOTVALID]\t\t= -EINVAL,\n\t[DLM_REJECTED]\t\t\t= -EPERM,\n\t[DLM_ABORT]\t\t\t= -EINVAL,\n\t[DLM_CANCEL]\t\t\t= -DLM_ECANCEL,\t/* Successful cancel */\n\t[DLM_IVRESHANDLE]\t\t= -EINVAL,\n\t[DLM_DEADLOCK]\t\t\t= -EDEADLK,\n\t[DLM_DENIED_NOASTS]\t\t= -EINVAL,\n\t[DLM_FORWARD]\t\t\t= -EINVAL,\n\t[DLM_TIMEOUT]\t\t\t= -ETIMEDOUT,\n\t[DLM_IVGROUPID]\t\t\t= -EINVAL,\n\t[DLM_VERS_CONFLICT]\t\t= -EOPNOTSUPP,\n\t[DLM_BAD_DEVICE_PATH]\t\t= -ENOENT,\n\t[DLM_NO_DEVICE_PERMISSION]\t= -EPERM,\n\t[DLM_NO_CONTROL_DEVICE]\t\t= -ENOENT,\n\t[DLM_RECOVERING]\t\t= -ENOTCONN,\n\t[DLM_MIGRATING]\t\t\t= -ERESTART,\n\t[DLM_MAXSTATS]\t\t\t= -EINVAL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "status < 0 || status >= ARRAY_SIZE(status_map)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "status_map"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int status_map[] = {\n\t[DLM_NORMAL]\t\t\t= 0,\t\t/* Success */\n\t[DLM_GRANTED]\t\t\t= -EINVAL,\n\t[DLM_DENIED]\t\t\t= -EACCES,\n\t[DLM_DENIED_NOLOCKS]\t\t= -EACCES,\n\t[DLM_WORKING]\t\t\t= -EACCES,\n\t[DLM_BLOCKED]\t\t\t= -EINVAL,\n\t[DLM_BLOCKED_ORPHAN]\t\t= -EINVAL,\n\t[DLM_DENIED_GRACE_PERIOD]\t= -EACCES,\n\t[DLM_SYSERR]\t\t\t= -ENOMEM,\t/* It is what it is */\n\t[DLM_NOSUPPORT]\t\t\t= -EPROTO,\n\t[DLM_CANCELGRANT]\t\t= -EBUSY,\t/* Cancel after grant */\n\t[DLM_IVLOCKID]\t\t\t= -EINVAL,\n\t[DLM_SYNC]\t\t\t= -EINVAL,\n\t[DLM_BADTYPE]\t\t\t= -EINVAL,\n\t[DLM_BADRESOURCE]\t\t= -EINVAL,\n\t[DLM_MAXHANDLES]\t\t= -ENOMEM,\n\t[DLM_NOCLINFO]\t\t\t= -EINVAL,\n\t[DLM_NOLOCKMGR]\t\t\t= -EINVAL,\n\t[DLM_NOPURGED]\t\t\t= -EINVAL,\n\t[DLM_BADARGS]\t\t\t= -EINVAL,\n\t[DLM_VOID]\t\t\t= -EINVAL,\n\t[DLM_NOTQUEUED]\t\t\t= -EAGAIN,\t/* Trylock failed */\n\t[DLM_IVBUFLEN]\t\t\t= -EINVAL,\n\t[DLM_CVTUNGRANT]\t\t= -EPERM,\n\t[DLM_BADPARAM]\t\t\t= -EINVAL,\n\t[DLM_VALNOTVALID]\t\t= -EINVAL,\n\t[DLM_REJECTED]\t\t\t= -EPERM,\n\t[DLM_ABORT]\t\t\t= -EINVAL,\n\t[DLM_CANCEL]\t\t\t= -DLM_ECANCEL,\t/* Successful cancel */\n\t[DLM_IVRESHANDLE]\t\t= -EINVAL,\n\t[DLM_DEADLOCK]\t\t\t= -EDEADLK,\n\t[DLM_DENIED_NOASTS]\t\t= -EINVAL,\n\t[DLM_FORWARD]\t\t\t= -EINVAL,\n\t[DLM_TIMEOUT]\t\t\t= -ETIMEDOUT,\n\t[DLM_IVGROUPID]\t\t\t= -EINVAL,\n\t[DLM_VERS_CONFLICT]\t\t= -EOPNOTSUPP,\n\t[DLM_BAD_DEVICE_PATH]\t\t= -ENOENT,\n\t[DLM_NO_DEVICE_PERMISSION]\t= -EPERM,\n\t[DLM_NO_CONTROL_DEVICE]\t\t= -ENOENT,\n\t[DLM_RECOVERING]\t\t= -ENOTCONN,\n\t[DLM_MIGRATING]\t\t\t= -ERESTART,\n\t[DLM_MAXSTATS]\t\t\t= -EINVAL,\n};\n\nstatic int dlm_status_to_errno(enum dlm_status status)\n{\n\tBUG_ON(status < 0 || status >= ARRAY_SIZE(status_map));\n\n\treturn status_map[status];\n}"
  },
  {
    "function_name": "flags_to_o2dlm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "75-93",
    "snippet": "static int flags_to_o2dlm(u32 flags)\n{\n\tint o2dlm_flags = 0;\n\n\tmap_flag(DLM_LKF_NOQUEUE, LKM_NOQUEUE);\n\tmap_flag(DLM_LKF_CANCEL, LKM_CANCEL);\n\tmap_flag(DLM_LKF_CONVERT, LKM_CONVERT);\n\tmap_flag(DLM_LKF_VALBLK, LKM_VALBLK);\n\tmap_flag(DLM_LKF_IVVALBLK, LKM_INVVALBLK);\n\tmap_flag(DLM_LKF_ORPHAN, LKM_ORPHAN);\n\tmap_flag(DLM_LKF_FORCEUNLOCK, LKM_FORCE);\n\tmap_flag(DLM_LKF_TIMEOUT, LKM_TIMEOUT);\n\tmap_flag(DLM_LKF_LOCAL, LKM_LOCAL);\n\n\t/* map_flag() should have cleared every flag passed in */\n\tBUG_ON(flags != 0);\n\n\treturn o2dlm_flags;\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "flags != 0"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_flag",
          "args": [
            "DLM_LKF_LOCAL",
            "LKM_LOCAL"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_flag",
          "args": [
            "DLM_LKF_TIMEOUT",
            "LKM_TIMEOUT"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_flag",
          "args": [
            "DLM_LKF_FORCEUNLOCK",
            "LKM_FORCE"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_flag",
          "args": [
            "DLM_LKF_ORPHAN",
            "LKM_ORPHAN"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_flag",
          "args": [
            "DLM_LKF_IVVALBLK",
            "LKM_INVVALBLK"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_flag",
          "args": [
            "DLM_LKF_VALBLK",
            "LKM_VALBLK"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_flag",
          "args": [
            "DLM_LKF_CONVERT",
            "LKM_CONVERT"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_flag",
          "args": [
            "DLM_LKF_CANCEL",
            "LKM_CANCEL"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_flag",
          "args": [
            "DLM_LKF_NOQUEUE",
            "LKM_NOQUEUE"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic int flags_to_o2dlm(u32 flags)\n{\n\tint o2dlm_flags = 0;\n\n\tmap_flag(DLM_LKF_NOQUEUE, LKM_NOQUEUE);\n\tmap_flag(DLM_LKF_CANCEL, LKM_CANCEL);\n\tmap_flag(DLM_LKF_CONVERT, LKM_CONVERT);\n\tmap_flag(DLM_LKF_VALBLK, LKM_VALBLK);\n\tmap_flag(DLM_LKF_IVVALBLK, LKM_INVVALBLK);\n\tmap_flag(DLM_LKF_ORPHAN, LKM_ORPHAN);\n\tmap_flag(DLM_LKF_FORCEUNLOCK, LKM_FORCE);\n\tmap_flag(DLM_LKF_TIMEOUT, LKM_TIMEOUT);\n\tmap_flag(DLM_LKF_LOCAL, LKM_LOCAL);\n\n\t/* map_flag() should have cleared every flag passed in */\n\tBUG_ON(flags != 0);\n\n\treturn o2dlm_flags;\n}"
  },
  {
    "function_name": "mode_to_o2dlm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_o2cb.c",
    "lines": "63-68",
    "snippet": "static inline int mode_to_o2dlm(int mode)\n{\n\tBUG_ON(mode > LKM_MAXMODE);\n\n\treturn mode;\n}",
    "includes": [
      "#include \"stackglue.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/masklog.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mode > LKM_MAXMODE"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stackglue.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/masklog.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n\nstatic inline int mode_to_o2dlm(int mode)\n{\n\tBUG_ON(mode > LKM_MAXMODE);\n\n\treturn mode;\n}"
  }
]