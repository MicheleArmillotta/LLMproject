[
  {
    "function_name": "smb2_push_mandatory_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2file.c",
    "lines": "227-265",
    "snippet": "int\nsmb2_push_mandatory_locks(struct cifsFileInfo *cfile)\n{\n\tint rc = 0, stored_rc;\n\tunsigned int xid;\n\tunsigned int max_num, max_buf;\n\tstruct smb2_lock_element *buf;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifs_fid_locks *fdlocks;\n\n\txid = get_xid();\n\n\t/*\n\t * Accessing maxBuf is racy with cifs_reconnect - need to store value\n\t * and check it for zero before using.\n\t */\n\tmax_buf = tlink_tcon(cfile->tlink)->ses->server->maxBuf;\n\tif (!max_buf) {\n\t\tfree_xid(xid);\n\t\treturn -EINVAL;\n\t}\n\n\tmax_num = max_buf / sizeof(struct smb2_lock_element);\n\tbuf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL);\n\tif (!buf) {\n\t\tfree_xid(xid);\n\t\treturn -ENOMEM;\n\t}\n\n\tlist_for_each_entry(fdlocks, &cinode->llist, llist) {\n\t\tstored_rc = smb2_push_mand_fdlocks(fdlocks, xid, buf, max_num);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t}\n\n\tkfree(buf);\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb2_push_mand_fdlocks",
          "args": [
            "fdlocks",
            "xid",
            "buf",
            "max_num"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_push_mand_fdlocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2file.c",
          "lines": "187-225",
          "snippet": "static int\nsmb2_push_mand_fdlocks(struct cifs_fid_locks *fdlocks, const unsigned int xid,\n\t\t       struct smb2_lock_element *buf, unsigned int max_num)\n{\n\tint rc = 0, stored_rc;\n\tstruct cifsFileInfo *cfile = fdlocks->cfile;\n\tstruct cifsLockInfo *li;\n\tunsigned int num = 0;\n\tstruct smb2_lock_element *cur = buf;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\n\tlist_for_each_entry(li, &fdlocks->locks, llist) {\n\t\tcur->Length = cpu_to_le64(li->length);\n\t\tcur->Offset = cpu_to_le64(li->offset);\n\t\tcur->Flags = cpu_to_le32(li->type |\n\t\t\t\t\t\tSMB2_LOCKFLAG_FAIL_IMMEDIATELY);\n\t\tif (++num == max_num) {\n\t\t\tstored_rc = smb2_lockv(xid, tcon,\n\t\t\t\t\t       cfile->fid.persistent_fid,\n\t\t\t\t\t       cfile->fid.volatile_fid,\n\t\t\t\t\t       current->tgid, num, buf);\n\t\t\tif (stored_rc)\n\t\t\t\trc = stored_rc;\n\t\t\tcur = buf;\n\t\t\tnum = 0;\n\t\t} else\n\t\t\tcur++;\n\t}\n\tif (num) {\n\t\tstored_rc = smb2_lockv(xid, tcon,\n\t\t\t\t       cfile->fid.persistent_fid,\n\t\t\t\t       cfile->fid.volatile_fid,\n\t\t\t\t       current->tgid, num, buf);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_push_mand_fdlocks(struct cifs_fid_locks *fdlocks, const unsigned int xid,\n\t\t       struct smb2_lock_element *buf, unsigned int max_num)\n{\n\tint rc = 0, stored_rc;\n\tstruct cifsFileInfo *cfile = fdlocks->cfile;\n\tstruct cifsLockInfo *li;\n\tunsigned int num = 0;\n\tstruct smb2_lock_element *cur = buf;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\n\tlist_for_each_entry(li, &fdlocks->locks, llist) {\n\t\tcur->Length = cpu_to_le64(li->length);\n\t\tcur->Offset = cpu_to_le64(li->offset);\n\t\tcur->Flags = cpu_to_le32(li->type |\n\t\t\t\t\t\tSMB2_LOCKFLAG_FAIL_IMMEDIATELY);\n\t\tif (++num == max_num) {\n\t\t\tstored_rc = smb2_lockv(xid, tcon,\n\t\t\t\t\t       cfile->fid.persistent_fid,\n\t\t\t\t\t       cfile->fid.volatile_fid,\n\t\t\t\t\t       current->tgid, num, buf);\n\t\t\tif (stored_rc)\n\t\t\t\trc = stored_rc;\n\t\t\tcur = buf;\n\t\t\tnum = 0;\n\t\t} else\n\t\t\tcur++;\n\t}\n\tif (num) {\n\t\tstored_rc = smb2_lockv(xid, tcon,\n\t\t\t\t       cfile->fid.persistent_fid,\n\t\t\t\t       cfile->fid.volatile_fid,\n\t\t\t\t       current->tgid, num, buf);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fdlocks",
            "&cinode->llist",
            "llist"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "max_num",
            "sizeof(struct smb2_lock_element)",
            "GFP_KERNEL"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "cfile->dentry->d_inode"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\nsmb2_push_mandatory_locks(struct cifsFileInfo *cfile)\n{\n\tint rc = 0, stored_rc;\n\tunsigned int xid;\n\tunsigned int max_num, max_buf;\n\tstruct smb2_lock_element *buf;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifs_fid_locks *fdlocks;\n\n\txid = get_xid();\n\n\t/*\n\t * Accessing maxBuf is racy with cifs_reconnect - need to store value\n\t * and check it for zero before using.\n\t */\n\tmax_buf = tlink_tcon(cfile->tlink)->ses->server->maxBuf;\n\tif (!max_buf) {\n\t\tfree_xid(xid);\n\t\treturn -EINVAL;\n\t}\n\n\tmax_num = max_buf / sizeof(struct smb2_lock_element);\n\tbuf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL);\n\tif (!buf) {\n\t\tfree_xid(xid);\n\t\treturn -ENOMEM;\n\t}\n\n\tlist_for_each_entry(fdlocks, &cinode->llist, llist) {\n\t\tstored_rc = smb2_push_mand_fdlocks(fdlocks, xid, buf, max_num);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t}\n\n\tkfree(buf);\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_push_mand_fdlocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2file.c",
    "lines": "187-225",
    "snippet": "static int\nsmb2_push_mand_fdlocks(struct cifs_fid_locks *fdlocks, const unsigned int xid,\n\t\t       struct smb2_lock_element *buf, unsigned int max_num)\n{\n\tint rc = 0, stored_rc;\n\tstruct cifsFileInfo *cfile = fdlocks->cfile;\n\tstruct cifsLockInfo *li;\n\tunsigned int num = 0;\n\tstruct smb2_lock_element *cur = buf;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\n\tlist_for_each_entry(li, &fdlocks->locks, llist) {\n\t\tcur->Length = cpu_to_le64(li->length);\n\t\tcur->Offset = cpu_to_le64(li->offset);\n\t\tcur->Flags = cpu_to_le32(li->type |\n\t\t\t\t\t\tSMB2_LOCKFLAG_FAIL_IMMEDIATELY);\n\t\tif (++num == max_num) {\n\t\t\tstored_rc = smb2_lockv(xid, tcon,\n\t\t\t\t\t       cfile->fid.persistent_fid,\n\t\t\t\t\t       cfile->fid.volatile_fid,\n\t\t\t\t\t       current->tgid, num, buf);\n\t\t\tif (stored_rc)\n\t\t\t\trc = stored_rc;\n\t\t\tcur = buf;\n\t\t\tnum = 0;\n\t\t} else\n\t\t\tcur++;\n\t}\n\tif (num) {\n\t\tstored_rc = smb2_lockv(xid, tcon,\n\t\t\t\t       cfile->fid.persistent_fid,\n\t\t\t\t       cfile->fid.volatile_fid,\n\t\t\t\t       current->tgid, num, buf);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smb2_lockv",
          "args": [
            "xid",
            "tcon",
            "cfile->fid.persistent_fid",
            "cfile->fid.volatile_fid",
            "current->tgid",
            "num",
            "buf"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_lockv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2570-2610",
          "snippet": "int\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t   const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t   const __u32 num_lock, struct smb2_lock_element *buf)\n{\n\tint rc = 0;\n\tstruct smb2_lock_req *req = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\tunsigned int count;\n\n\tcifs_dbg(FYI, \"smb2_lockv num lock %d\\n\", num_lock);\n\n\trc = small_smb2_init(SMB2_LOCK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\treq->LockCount = cpu_to_le16(num_lock);\n\n\treq->PersistentFileId = persist_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tcount = num_lock * sizeof(struct smb2_lock_element);\n\tinc_rfc1001_len(req, count - sizeof(struct smb2_lock_element));\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and count for all locks */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - count;\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = count;\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in smb2_lockv = %d\\n\", rc);\n\t\tcifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t   const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t   const __u32 num_lock, struct smb2_lock_element *buf)\n{\n\tint rc = 0;\n\tstruct smb2_lock_req *req = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\tunsigned int count;\n\n\tcifs_dbg(FYI, \"smb2_lockv num lock %d\\n\", num_lock);\n\n\trc = small_smb2_init(SMB2_LOCK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\treq->LockCount = cpu_to_le16(num_lock);\n\n\treq->PersistentFileId = persist_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tcount = num_lock * sizeof(struct smb2_lock_element);\n\tinc_rfc1001_len(req, count - sizeof(struct smb2_lock_element));\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and count for all locks */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - count;\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = count;\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in smb2_lockv = %d\\n\", rc);\n\t\tcifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "li->type |\n\t\t\t\t\t\tSMB2_LOCKFLAG_FAIL_IMMEDIATELY"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "li->offset"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "li->length"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "li",
            "&fdlocks->locks",
            "llist"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_push_mand_fdlocks(struct cifs_fid_locks *fdlocks, const unsigned int xid,\n\t\t       struct smb2_lock_element *buf, unsigned int max_num)\n{\n\tint rc = 0, stored_rc;\n\tstruct cifsFileInfo *cfile = fdlocks->cfile;\n\tstruct cifsLockInfo *li;\n\tunsigned int num = 0;\n\tstruct smb2_lock_element *cur = buf;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\n\tlist_for_each_entry(li, &fdlocks->locks, llist) {\n\t\tcur->Length = cpu_to_le64(li->length);\n\t\tcur->Offset = cpu_to_le64(li->offset);\n\t\tcur->Flags = cpu_to_le32(li->type |\n\t\t\t\t\t\tSMB2_LOCKFLAG_FAIL_IMMEDIATELY);\n\t\tif (++num == max_num) {\n\t\t\tstored_rc = smb2_lockv(xid, tcon,\n\t\t\t\t\t       cfile->fid.persistent_fid,\n\t\t\t\t\t       cfile->fid.volatile_fid,\n\t\t\t\t\t       current->tgid, num, buf);\n\t\t\tif (stored_rc)\n\t\t\t\trc = stored_rc;\n\t\t\tcur = buf;\n\t\t\tnum = 0;\n\t\t} else\n\t\t\tcur++;\n\t}\n\tif (num) {\n\t\tstored_rc = smb2_lockv(xid, tcon,\n\t\t\t\t       cfile->fid.persistent_fid,\n\t\t\t\t       cfile->fid.volatile_fid,\n\t\t\t\t       current->tgid, num, buf);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_unlock_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2file.c",
    "lines": "90-185",
    "snippet": "int\nsmb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,\n\t\t  const unsigned int xid)\n{\n\tint rc = 0, stored_rc;\n\tunsigned int max_num, num = 0, max_buf;\n\tstruct smb2_lock_element *buf, *cur;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifsLockInfo *li, *tmp;\n\t__u64 length = 1 + flock->fl_end - flock->fl_start;\n\tstruct list_head tmp_llist;\n\n\tINIT_LIST_HEAD(&tmp_llist);\n\n\t/*\n\t * Accessing maxBuf is racy with cifs_reconnect - need to store value\n\t * and check it for zero before using.\n\t */\n\tmax_buf = tcon->ses->server->maxBuf;\n\tif (!max_buf)\n\t\treturn -EINVAL;\n\n\tmax_num = max_buf / sizeof(struct smb2_lock_element);\n\tbuf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tcur = buf;\n\n\tdown_write(&cinode->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cfile->llist->locks, llist) {\n\t\tif (flock->fl_start > li->offset ||\n\t\t    (flock->fl_start + length) <\n\t\t    (li->offset + li->length))\n\t\t\tcontinue;\n\t\tif (current->tgid != li->pid)\n\t\t\tcontinue;\n\t\tif (cinode->can_cache_brlcks) {\n\t\t\t/*\n\t\t\t * We can cache brlock requests - simply remove a lock\n\t\t\t * from the file's list.\n\t\t\t */\n\t\t\tlist_del(&li->llist);\n\t\t\tcifs_del_lock_waiters(li);\n\t\t\tkfree(li);\n\t\t\tcontinue;\n\t\t}\n\t\tcur->Length = cpu_to_le64(li->length);\n\t\tcur->Offset = cpu_to_le64(li->offset);\n\t\tcur->Flags = cpu_to_le32(SMB2_LOCKFLAG_UNLOCK);\n\t\t/*\n\t\t * We need to save a lock here to let us add it again to the\n\t\t * file's list if the unlock range request fails on the server.\n\t\t */\n\t\tlist_move(&li->llist, &tmp_llist);\n\t\tif (++num == max_num) {\n\t\t\tstored_rc = smb2_lockv(xid, tcon,\n\t\t\t\t\t       cfile->fid.persistent_fid,\n\t\t\t\t\t       cfile->fid.volatile_fid,\n\t\t\t\t\t       current->tgid, num, buf);\n\t\t\tif (stored_rc) {\n\t\t\t\t/*\n\t\t\t\t * We failed on the unlock range request - add\n\t\t\t\t * all locks from the tmp list to the head of\n\t\t\t\t * the file's list.\n\t\t\t\t */\n\t\t\t\tcifs_move_llist(&tmp_llist,\n\t\t\t\t\t\t&cfile->llist->locks);\n\t\t\t\trc = stored_rc;\n\t\t\t} else\n\t\t\t\t/*\n\t\t\t\t * The unlock range request succeed - free the\n\t\t\t\t * tmp list.\n\t\t\t\t */\n\t\t\t\tcifs_free_llist(&tmp_llist);\n\t\t\tcur = buf;\n\t\t\tnum = 0;\n\t\t} else\n\t\t\tcur++;\n\t}\n\tif (num) {\n\t\tstored_rc = smb2_lockv(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t\t       cfile->fid.volatile_fid, current->tgid,\n\t\t\t\t       num, buf);\n\t\tif (stored_rc) {\n\t\t\tcifs_move_llist(&tmp_llist, &cfile->llist->locks);\n\t\t\trc = stored_rc;\n\t\t} else\n\t\t\tcifs_free_llist(&tmp_llist);\n\t}\n\tup_write(&cinode->lock_sem);\n\n\tkfree(buf);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_free_llist",
          "args": [
            "&tmp_llist"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_free_llist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1363-1372",
          "snippet": "void\ncifs_free_llist(struct list_head *llist)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, llist, llist) {\n\t\tcifs_del_lock_waiters(li);\n\t\tlist_del(&li->llist);\n\t\tkfree(li);\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_free_llist(struct list_head *llist)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, llist, llist) {\n\t\tcifs_del_lock_waiters(li);\n\t\tlist_del(&li->llist);\n\t\tkfree(li);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_move_llist",
          "args": [
            "&tmp_llist",
            "&cfile->llist->locks"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_move_llist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1355-1361",
          "snippet": "void\ncifs_move_llist(struct list_head *source, struct list_head *dest)\n{\n\tstruct list_head *li, *tmp;\n\tlist_for_each_safe(li, tmp, source)\n\t\tlist_move(li, dest);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_move_llist(struct list_head *source, struct list_head *dest)\n{\n\tstruct list_head *li, *tmp;\n\tlist_for_each_safe(li, tmp, source)\n\t\tlist_move(li, dest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb2_lockv",
          "args": [
            "xid",
            "tcon",
            "cfile->fid.persistent_fid",
            "cfile->fid.volatile_fid",
            "current->tgid",
            "num",
            "buf"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_lockv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2570-2610",
          "snippet": "int\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t   const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t   const __u32 num_lock, struct smb2_lock_element *buf)\n{\n\tint rc = 0;\n\tstruct smb2_lock_req *req = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\tunsigned int count;\n\n\tcifs_dbg(FYI, \"smb2_lockv num lock %d\\n\", num_lock);\n\n\trc = small_smb2_init(SMB2_LOCK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\treq->LockCount = cpu_to_le16(num_lock);\n\n\treq->PersistentFileId = persist_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tcount = num_lock * sizeof(struct smb2_lock_element);\n\tinc_rfc1001_len(req, count - sizeof(struct smb2_lock_element));\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and count for all locks */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - count;\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = count;\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in smb2_lockv = %d\\n\", rc);\n\t\tcifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t   const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t   const __u32 num_lock, struct smb2_lock_element *buf)\n{\n\tint rc = 0;\n\tstruct smb2_lock_req *req = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\tunsigned int count;\n\n\tcifs_dbg(FYI, \"smb2_lockv num lock %d\\n\", num_lock);\n\n\trc = small_smb2_init(SMB2_LOCK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\treq->LockCount = cpu_to_le16(num_lock);\n\n\treq->PersistentFileId = persist_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tcount = num_lock * sizeof(struct smb2_lock_element);\n\tinc_rfc1001_len(req, count - sizeof(struct smb2_lock_element));\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and count for all locks */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - count;\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = count;\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in smb2_lockv = %d\\n\", rc);\n\t\tcifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&li->llist",
            "&tmp_llist"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "SMB2_LOCKFLAG_UNLOCK"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "li->offset"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "li->length"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "li"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_del_lock_waiters",
          "args": [
            "li"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_del_lock_waiters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "824-832",
          "snippet": "void\ncifs_del_lock_waiters(struct cifsLockInfo *lock)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, &lock->blist, blist) {\n\t\tlist_del_init(&li->blist);\n\t\twake_up(&li->block_q);\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_del_lock_waiters(struct cifsLockInfo *lock)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, &lock->blist, blist) {\n\t\tlist_del_init(&li->blist);\n\t\twake_up(&li->block_q);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&li->llist"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "li",
            "tmp",
            "&cfile->llist->locks",
            "llist"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "max_num",
            "sizeof(struct smb2_lock_element)",
            "GFP_KERNEL"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tmp_llist"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "cfile->dentry->d_inode"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\nsmb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,\n\t\t  const unsigned int xid)\n{\n\tint rc = 0, stored_rc;\n\tunsigned int max_num, num = 0, max_buf;\n\tstruct smb2_lock_element *buf, *cur;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifsLockInfo *li, *tmp;\n\t__u64 length = 1 + flock->fl_end - flock->fl_start;\n\tstruct list_head tmp_llist;\n\n\tINIT_LIST_HEAD(&tmp_llist);\n\n\t/*\n\t * Accessing maxBuf is racy with cifs_reconnect - need to store value\n\t * and check it for zero before using.\n\t */\n\tmax_buf = tcon->ses->server->maxBuf;\n\tif (!max_buf)\n\t\treturn -EINVAL;\n\n\tmax_num = max_buf / sizeof(struct smb2_lock_element);\n\tbuf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tcur = buf;\n\n\tdown_write(&cinode->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cfile->llist->locks, llist) {\n\t\tif (flock->fl_start > li->offset ||\n\t\t    (flock->fl_start + length) <\n\t\t    (li->offset + li->length))\n\t\t\tcontinue;\n\t\tif (current->tgid != li->pid)\n\t\t\tcontinue;\n\t\tif (cinode->can_cache_brlcks) {\n\t\t\t/*\n\t\t\t * We can cache brlock requests - simply remove a lock\n\t\t\t * from the file's list.\n\t\t\t */\n\t\t\tlist_del(&li->llist);\n\t\t\tcifs_del_lock_waiters(li);\n\t\t\tkfree(li);\n\t\t\tcontinue;\n\t\t}\n\t\tcur->Length = cpu_to_le64(li->length);\n\t\tcur->Offset = cpu_to_le64(li->offset);\n\t\tcur->Flags = cpu_to_le32(SMB2_LOCKFLAG_UNLOCK);\n\t\t/*\n\t\t * We need to save a lock here to let us add it again to the\n\t\t * file's list if the unlock range request fails on the server.\n\t\t */\n\t\tlist_move(&li->llist, &tmp_llist);\n\t\tif (++num == max_num) {\n\t\t\tstored_rc = smb2_lockv(xid, tcon,\n\t\t\t\t\t       cfile->fid.persistent_fid,\n\t\t\t\t\t       cfile->fid.volatile_fid,\n\t\t\t\t\t       current->tgid, num, buf);\n\t\t\tif (stored_rc) {\n\t\t\t\t/*\n\t\t\t\t * We failed on the unlock range request - add\n\t\t\t\t * all locks from the tmp list to the head of\n\t\t\t\t * the file's list.\n\t\t\t\t */\n\t\t\t\tcifs_move_llist(&tmp_llist,\n\t\t\t\t\t\t&cfile->llist->locks);\n\t\t\t\trc = stored_rc;\n\t\t\t} else\n\t\t\t\t/*\n\t\t\t\t * The unlock range request succeed - free the\n\t\t\t\t * tmp list.\n\t\t\t\t */\n\t\t\t\tcifs_free_llist(&tmp_llist);\n\t\t\tcur = buf;\n\t\t\tnum = 0;\n\t\t} else\n\t\t\tcur++;\n\t}\n\tif (num) {\n\t\tstored_rc = smb2_lockv(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t\t       cfile->fid.volatile_fid, current->tgid,\n\t\t\t\t       num, buf);\n\t\tif (stored_rc) {\n\t\t\tcifs_move_llist(&tmp_llist, &cfile->llist->locks);\n\t\t\trc = stored_rc;\n\t\t} else\n\t\t\tcifs_free_llist(&tmp_llist);\n\t}\n\tup_write(&cinode->lock_sem);\n\n\tkfree(buf);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_open_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2file.c",
    "lines": "37-88",
    "snippet": "int\nsmb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,\n\t       __u32 *oplock, FILE_ALL_INFO *buf)\n{\n\tint rc;\n\t__le16 *smb2_path;\n\tstruct smb2_file_all_info *smb2_data = NULL;\n\t__u8 smb2_oplock[17];\n\tstruct cifs_fid *fid = oparms->fid;\n\n\tsmb2_path = cifs_convert_path_to_utf16(oparms->path, oparms->cifs_sb);\n\tif (smb2_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsmb2_data = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t    GFP_KERNEL);\n\tif (smb2_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\toparms->desired_access |= FILE_READ_ATTRIBUTES;\n\t*smb2_oplock = SMB2_OPLOCK_LEVEL_BATCH;\n\n\tif (oparms->tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)\n\t\tmemcpy(smb2_oplock + 1, fid->lease_key, SMB2_LEASE_KEY_SIZE);\n\n\trc = SMB2_open(xid, oparms, smb2_path, smb2_oplock, smb2_data, NULL);\n\tif (rc)\n\t\tgoto out;\n\n\tif (buf) {\n\t\t/* open response does not have IndexNumber field - get it */\n\t\trc = SMB2_get_srv_num(xid, oparms->tcon, fid->persistent_fid,\n\t\t\t\t      fid->volatile_fid,\n\t\t\t\t      &smb2_data->IndexNumber);\n\t\tif (rc) {\n\t\t\t/* let get_inode_info disable server inode numbers */\n\t\t\tsmb2_data->IndexNumber = 0;\n\t\t\trc = 0;\n\t\t}\n\t\tmove_smb2_info_to_cifs(buf, smb2_data);\n\t}\n\n\t*oplock = *smb2_oplock;\nout:\n\tkfree(smb2_data);\n\tkfree(smb2_path);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "smb2_path"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "smb2_data"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_smb2_info_to_cifs",
          "args": [
            "buf",
            "smb2_data"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "move_smb2_info_to_cifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
          "lines": "113-121",
          "snippet": "void\nmove_smb2_info_to_cifs(FILE_ALL_INFO *dst, struct smb2_file_all_info *src)\n{\n\tmemcpy(dst, src, (size_t)(&src->CurrentByteOffset) - (size_t)src);\n\tdst->CurrentByteOffset = src->CurrentByteOffset;\n\tdst->Mode = src->Mode;\n\tdst->AlignmentRequirement = src->AlignmentRequirement;\n\tdst->IndexNumber1 = 0; /* we don't use it */\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nvoid\nmove_smb2_info_to_cifs(FILE_ALL_INFO *dst, struct smb2_file_all_info *src)\n{\n\tmemcpy(dst, src, (size_t)(&src->CurrentByteOffset) - (size_t)src);\n\tdst->CurrentByteOffset = src->CurrentByteOffset;\n\tdst->Mode = src->Mode;\n\tdst->AlignmentRequirement = src->AlignmentRequirement;\n\tdst->IndexNumber1 = 0; /* we don't use it */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_get_srv_num",
          "args": [
            "xid",
            "oparms->tcon",
            "fid->persistent_fid",
            "fid->volatile_fid",
            "&smb2_data->IndexNumber"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_get_srv_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1540-1548",
          "snippet": "int\nSMB2_get_srv_num(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u64 persistent_fid, u64 volatile_fid, __le64 *uniqueid)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_INTERNAL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_internal_info),\n\t\t\t  sizeof(struct smb2_file_internal_info), uniqueid);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_get_srv_num(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u64 persistent_fid, u64 volatile_fid, __le64 *uniqueid)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_INTERNAL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_internal_info),\n\t\t\t  sizeof(struct smb2_file_internal_info), uniqueid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_open",
          "args": [
            "xid",
            "oparms",
            "smb2_path",
            "smb2_oplock",
            "smb2_data",
            "NULL"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1067-1208",
          "snippet": "int\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "smb2_oplock + 1",
            "fid->lease_key",
            "SMB2_LEASE_KEY_SIZE"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct smb2_file_all_info) + PATH_MAX * 2",
            "GFP_KERNEL"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_convert_path_to_utf16",
          "args": [
            "oparms->path",
            "oparms->cifs_sb"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_convert_path_to_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "378-401",
          "snippet": "__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\n__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\nsmb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,\n\t       __u32 *oplock, FILE_ALL_INFO *buf)\n{\n\tint rc;\n\t__le16 *smb2_path;\n\tstruct smb2_file_all_info *smb2_data = NULL;\n\t__u8 smb2_oplock[17];\n\tstruct cifs_fid *fid = oparms->fid;\n\n\tsmb2_path = cifs_convert_path_to_utf16(oparms->path, oparms->cifs_sb);\n\tif (smb2_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsmb2_data = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t    GFP_KERNEL);\n\tif (smb2_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\toparms->desired_access |= FILE_READ_ATTRIBUTES;\n\t*smb2_oplock = SMB2_OPLOCK_LEVEL_BATCH;\n\n\tif (oparms->tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)\n\t\tmemcpy(smb2_oplock + 1, fid->lease_key, SMB2_LEASE_KEY_SIZE);\n\n\trc = SMB2_open(xid, oparms, smb2_path, smb2_oplock, smb2_data, NULL);\n\tif (rc)\n\t\tgoto out;\n\n\tif (buf) {\n\t\t/* open response does not have IndexNumber field - get it */\n\t\trc = SMB2_get_srv_num(xid, oparms->tcon, fid->persistent_fid,\n\t\t\t\t      fid->volatile_fid,\n\t\t\t\t      &smb2_data->IndexNumber);\n\t\tif (rc) {\n\t\t\t/* let get_inode_info disable server inode numbers */\n\t\t\tsmb2_data->IndexNumber = 0;\n\t\t\trc = 0;\n\t\t}\n\t\tmove_smb2_info_to_cifs(buf, smb2_data);\n\t}\n\n\t*oplock = *smb2_oplock;\nout:\n\tkfree(smb2_data);\n\tkfree(smb2_path);\n\treturn rc;\n}"
  }
]