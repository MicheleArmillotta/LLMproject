[
  {
    "function_name": "fs2_garbage_collect_thread(v",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/background.c",
    "lines": "75-168",
    "snippet": "atic int jffs2_garbage_collect_thread(void *_c)\n{\n\tstruct jffs2_sb_info *c = _c;\n\tsigset_t hupmask;\n\n\tsiginitset(&hupmask, sigmask(SIGHUP));\n\tallow_signal(SIGKILL);\n\tallow_signal(SIGSTOP);\n\tallow_signal(SIGCONT);\n\tallow_signal(SIGHUP);\n\n\tc->gc_task = current;\n\tcomplete(&c->gc_thread_start);\n\n\tset_user_nice(current, 10);\n\n\tset_freezable();\n\tfor (;;) {\n\t\tsigprocmask(SIG_UNBLOCK, &hupmask, NULL);\n\tagain:\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tif (!jffs2_thread_should_wake(c)) {\n\t\t\tset_current_state (TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_dbg(1, \"%s(): sleeping...\\n\", __func__);\n\t\t\tschedule();\n\t\t} else {\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t}\n\t\t/* Problem - immediately after bootup, the GCD spends a lot\n\t\t * of time in places like jffs2_kill_fragtree(); so much so\n\t\t * that userspace processes (like gdm and X) are starved\n\t\t * despite plenty of cond_resched()s and renicing.  Yield()\n\t\t * doesn't help, either (presumably because userspace and GCD\n\t\t * are generally competing for a higher latency resource -\n\t\t * disk).\n\t\t * This forces the GCD to slow the hell down.   Pulling an\n\t\t * inode in with read_inode() is much preferable to having\n\t\t * the GC thread get there first. */\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(50));\n\n\t\tif (kthread_should_stop()) {\n\t\t\tjffs2_dbg(1, \"%s(): kthread_stop() called\\n\", __func__);\n\t\t\tgoto die;\n\t\t}\n\n\t\t/* Put_super will send a SIGKILL and then wait on the sem.\n\t\t */\n\t\twhile (signal_pending(current) || freezing(current)) {\n\t\t\tsiginfo_t info;\n\t\t\tunsigned long signr;\n\n\t\t\tif (try_to_freeze())\n\t\t\t\tgoto again;\n\n\t\t\tsignr = dequeue_signal_lock(current, &current->blocked, &info);\n\n\t\t\tswitch(signr) {\n\t\t\tcase SIGSTOP:\n\t\t\t\tjffs2_dbg(1, \"%s(): SIGSTOP received\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tset_current_state(TASK_STOPPED);\n\t\t\t\tschedule();\n\t\t\t\tbreak;\n\n\t\t\tcase SIGKILL:\n\t\t\t\tjffs2_dbg(1, \"%s(): SIGKILL received\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tgoto die;\n\n\t\t\tcase SIGHUP:\n\t\t\t\tjffs2_dbg(1, \"%s(): SIGHUP received\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tjffs2_dbg(1, \"%s(): signal %ld received\\n\",\n\t\t\t\t\t  __func__, signr);\n\t\t\t}\n\t\t}\n\t\t/* We don't want SIGHUP to interrupt us. STOP and KILL are OK though. */\n\t\tsigprocmask(SIG_BLOCK, &hupmask, NULL);\n\n\t\tjffs2_dbg(1, \"%s(): pass\\n\", __func__);\n\t\tif (jffs2_garbage_collect_pass(c) == -ENOSPC) {\n\t\t\tpr_notice(\"No space for garbage collection. Aborting GC thread\\n\");\n\t\t\tgoto die;\n\t\t}\n\t}\n die:\n\tspin_lock(&c->erase_completion_lock);\n\tc->gc_task = NULL;\n\tspin_unlock(&c->erase_completion_lock);\n\tcomplete_and_exit(&c->gc_thread_exit, 0);\n}",
    "includes": [
      "nclude \"nodelist.h\"",
      "nclude <linux/kthread.h>\n#i",
      "nclude <linux/freezer.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/completion.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/jffs2.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_garbage_collect_thread(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mplete_and_exit(&",
          "args": [
            "->gc_thread_exit,",
            ";"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notice(\"",
          "args": [
            "o space for garbage collection. Aborting GC thread\\n\");"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_pass(c",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): pass\\n\",",
            "func__);"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gprocmask(S",
          "args": [
            "G_BLOCK,",
            "upmask,",
            "LL);"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): signal %ld received\\n\",",
            "func__,",
            "gnr);"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): SIGHUP received\\n\",",
            "func__);"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): SIGKILL received\\n\",",
            "func__);"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hedule()",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_current_state(T",
          "args": [
            "SK_STOPPED);"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): SIGSTOP received\\n\",",
            "func__);"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_signal_lock(c",
          "args": [
            "rrent,",
            "urrent->blocked,",
            "nfo);"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y_to_freeze()",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eezing(c",
          "args": [
            "rrent))"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnal_pending(c",
          "args": [
            "rrent)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): kthread_stop() called\\n\",",
            "func__);"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hread_should_stop()",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hedule_timeout_interruptible(m",
          "args": [
            "ecs_to_jiffies(50));"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecs_to_jiffies(5",
          "args": [
            "))"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hedule()",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): sleeping...\\n\",",
            "func__);"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_current_state (",
          "args": [
            "SK_INTERRUPTIBLE);"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_thread_should_wake(c",
          "args": [
            ")"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gprocmask(S",
          "args": [
            "G_UNBLOCK,",
            "upmask,",
            "LL);"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_freezable()",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_user_nice(c",
          "args": [
            "rrent,",
            ");"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mplete(&",
          "args": [
            "->gc_thread_start);"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_signal(S",
          "args": [
            "GHUP);"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_signal(S",
          "args": [
            "GCONT);"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_signal(S",
          "args": [
            "GSTOP);"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_signal(S",
          "args": [
            "GKILL);"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ginitset(&",
          "args": [
            "upmask,",
            "gmask(SIGHUP));"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gmask(S",
          "args": [
            "GHUP))"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\nnclude <linux/kthread.h>\n#i\nnclude <linux/freezer.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/completion.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic int jffs2_garbage_collect_thread(void *);\n\natic int jffs2_garbage_collect_thread(void *_c)\n{\n\tstruct jffs2_sb_info *c = _c;\n\tsigset_t hupmask;\n\n\tsiginitset(&hupmask, sigmask(SIGHUP));\n\tallow_signal(SIGKILL);\n\tallow_signal(SIGSTOP);\n\tallow_signal(SIGCONT);\n\tallow_signal(SIGHUP);\n\n\tc->gc_task = current;\n\tcomplete(&c->gc_thread_start);\n\n\tset_user_nice(current, 10);\n\n\tset_freezable();\n\tfor (;;) {\n\t\tsigprocmask(SIG_UNBLOCK, &hupmask, NULL);\n\tagain:\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tif (!jffs2_thread_should_wake(c)) {\n\t\t\tset_current_state (TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_dbg(1, \"%s(): sleeping...\\n\", __func__);\n\t\t\tschedule();\n\t\t} else {\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t}\n\t\t/* Problem - immediately after bootup, the GCD spends a lot\n\t\t * of time in places like jffs2_kill_fragtree(); so much so\n\t\t * that userspace processes (like gdm and X) are starved\n\t\t * despite plenty of cond_resched()s and renicing.  Yield()\n\t\t * doesn't help, either (presumably because userspace and GCD\n\t\t * are generally competing for a higher latency resource -\n\t\t * disk).\n\t\t * This forces the GCD to slow the hell down.   Pulling an\n\t\t * inode in with read_inode() is much preferable to having\n\t\t * the GC thread get there first. */\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(50));\n\n\t\tif (kthread_should_stop()) {\n\t\t\tjffs2_dbg(1, \"%s(): kthread_stop() called\\n\", __func__);\n\t\t\tgoto die;\n\t\t}\n\n\t\t/* Put_super will send a SIGKILL and then wait on the sem.\n\t\t */\n\t\twhile (signal_pending(current) || freezing(current)) {\n\t\t\tsiginfo_t info;\n\t\t\tunsigned long signr;\n\n\t\t\tif (try_to_freeze())\n\t\t\t\tgoto again;\n\n\t\t\tsignr = dequeue_signal_lock(current, &current->blocked, &info);\n\n\t\t\tswitch(signr) {\n\t\t\tcase SIGSTOP:\n\t\t\t\tjffs2_dbg(1, \"%s(): SIGSTOP received\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tset_current_state(TASK_STOPPED);\n\t\t\t\tschedule();\n\t\t\t\tbreak;\n\n\t\t\tcase SIGKILL:\n\t\t\t\tjffs2_dbg(1, \"%s(): SIGKILL received\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tgoto die;\n\n\t\t\tcase SIGHUP:\n\t\t\t\tjffs2_dbg(1, \"%s(): SIGHUP received\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tjffs2_dbg(1, \"%s(): signal %ld received\\n\",\n\t\t\t\t\t  __func__, signr);\n\t\t\t}\n\t\t}\n\t\t/* We don't want SIGHUP to interrupt us. STOP and KILL are OK though. */\n\t\tsigprocmask(SIG_BLOCK, &hupmask, NULL);\n\n\t\tjffs2_dbg(1, \"%s(): pass\\n\", __func__);\n\t\tif (jffs2_garbage_collect_pass(c) == -ENOSPC) {\n\t\t\tpr_notice(\"No space for garbage collection. Aborting GC thread\\n\");\n\t\t\tgoto die;\n\t\t}\n\t}\n die:\n\tspin_lock(&c->erase_completion_lock);\n\tc->gc_task = NULL;\n\tspin_unlock(&c->erase_completion_lock);\n\tcomplete_and_exit(&c->gc_thread_exit, 0);\n}"
  },
  {
    "function_name": "fs2_stop_garbage_collect_thread(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/background.c",
    "lines": "61-73",
    "snippet": "id jffs2_stop_garbage_collect_thread(struct jffs2_sb_info *c)\n{\n\tint wait = 0;\n\tspin_lock(&c->erase_completion_lock);\n\tif (c->gc_task) {\n\t\tjffs2_dbg(1, \"Killing GC task %d\\n\", c->gc_task->pid);\n\t\tsend_sig(SIGKILL, c->gc_task, 1);\n\t\twait = 1;\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\tif (wait)\n\t\twait_for_completion(&c->gc_thread_exit);\n}",
    "includes": [
      "nclude \"nodelist.h\"",
      "nclude <linux/kthread.h>\n#i",
      "nclude <linux/freezer.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/completion.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/jffs2.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "it_for_completion(&",
          "args": [
            "->gc_thread_exit);"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_sig(S",
          "args": [
            "GKILL,",
            ">gc_task,",
            ";"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "illing GC task %d\\n\",",
            ">gc_task->pid);"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\nnclude <linux/kthread.h>\n#i\nnclude <linux/freezer.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/completion.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid jffs2_stop_garbage_collect_thread(struct jffs2_sb_info *c)\n{\n\tint wait = 0;\n\tspin_lock(&c->erase_completion_lock);\n\tif (c->gc_task) {\n\t\tjffs2_dbg(1, \"Killing GC task %d\\n\", c->gc_task->pid);\n\t\tsend_sig(SIGKILL, c->gc_task, 1);\n\t\twait = 1;\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\tif (wait)\n\t\twait_for_completion(&c->gc_thread_exit);\n}"
  },
  {
    "function_name": "fs2_start_garbage_collect_thread(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/background.c",
    "lines": "35-59",
    "snippet": "t jffs2_start_garbage_collect_thread(struct jffs2_sb_info *c)\n{\n\tstruct task_struct *tsk;\n\tint ret = 0;\n\n\tBUG_ON(c->gc_task);\n\n\tinit_completion(&c->gc_thread_start);\n\tinit_completion(&c->gc_thread_exit);\n\n\ttsk = kthread_run(jffs2_garbage_collect_thread, c, \"jffs2_gcd_mtd%d\", c->mtd->index);\n\tif (IS_ERR(tsk)) {\n\t\tpr_warn(\"fork failed for JFFS2 garbage collect thread: %ld\\n\",\n\t\t\t-PTR_ERR(tsk));\n\t\tcomplete(&c->gc_thread_exit);\n\t\tret = PTR_ERR(tsk);\n\t} else {\n\t\t/* Wait for it... */\n\t\tjffs2_dbg(1, \"Garbage collect thread is pid %d\\n\", tsk->pid);\n\t\twait_for_completion(&c->gc_thread_start);\n\t\tret = tsk->pid;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "nclude \"nodelist.h\"",
      "nclude <linux/kthread.h>\n#i",
      "nclude <linux/freezer.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/completion.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/jffs2.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_garbage_collect_thread(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "it_for_completion(&",
          "args": [
            "->gc_thread_start);"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "arbage collect thread is pid %d\\n\",",
            "k->pid);"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(t",
          "args": [
            "k);"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mplete(&",
          "args": [
            "->gc_thread_exit);"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ork failed for JFFS2 garbage collect thread: %ld\\n\",",
            "TR_ERR(tsk));"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(t",
          "args": [
            "k))"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ERR(t",
          "args": [
            "k))"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hread_run(j",
          "args": [
            "fs2_garbage_collect_thread,",
            "ffs2_gcd_mtd%d\",",
            ">mtd->index);"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it_completion(&",
          "args": [
            "->gc_thread_exit);"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it_completion(&",
          "args": [
            "->gc_thread_start);"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(c",
          "args": [
            ">gc_task);"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\nnclude <linux/kthread.h>\n#i\nnclude <linux/freezer.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/completion.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic int jffs2_garbage_collect_thread(void *);\n\nt jffs2_start_garbage_collect_thread(struct jffs2_sb_info *c)\n{\n\tstruct task_struct *tsk;\n\tint ret = 0;\n\n\tBUG_ON(c->gc_task);\n\n\tinit_completion(&c->gc_thread_start);\n\tinit_completion(&c->gc_thread_exit);\n\n\ttsk = kthread_run(jffs2_garbage_collect_thread, c, \"jffs2_gcd_mtd%d\", c->mtd->index);\n\tif (IS_ERR(tsk)) {\n\t\tpr_warn(\"fork failed for JFFS2 garbage collect thread: %ld\\n\",\n\t\t\t-PTR_ERR(tsk));\n\t\tcomplete(&c->gc_thread_exit);\n\t\tret = PTR_ERR(tsk);\n\t} else {\n\t\t/* Wait for it... */\n\t\tjffs2_dbg(1, \"Garbage collect thread is pid %d\\n\", tsk->pid);\n\t\twait_for_completion(&c->gc_thread_start);\n\t\tret = tsk->pid;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fs2_garbage_collect_trigger(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/background.c",
    "lines": "27-32",
    "snippet": "id jffs2_garbage_collect_trigger(struct jffs2_sb_info *c)\n{\n\tassert_spin_locked(&c->erase_completion_lock);\n\tif (c->gc_task && jffs2_thread_should_wake(c))\n\t\tsend_sig(SIGHUP, c->gc_task, 1);\n}",
    "includes": [
      "nclude \"nodelist.h\"",
      "nclude <linux/kthread.h>\n#i",
      "nclude <linux/freezer.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/completion.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/jffs2.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_sig(S",
          "args": [
            "GHUP,",
            ">gc_task,",
            ";"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_thread_should_wake(c",
          "args": [
            ")"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sert_spin_locked(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\nnclude <linux/kthread.h>\n#i\nnclude <linux/freezer.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/completion.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid jffs2_garbage_collect_trigger(struct jffs2_sb_info *c)\n{\n\tassert_spin_locked(&c->erase_completion_lock);\n\tif (c->gc_task && jffs2_thread_should_wake(c))\n\t\tsend_sig(SIGHUP, c->gc_task, 1);\n}"
  }
]