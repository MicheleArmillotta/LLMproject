[
  {
    "function_name": "v9fs_xattr_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
    "lines": "281-367",
    "snippet": "static int v9fs_xattr_set_acl(struct dentry *dentry, const char *name,\n\t\t\t      const void *value, size_t size,\n\t\t\t      int flags, int type)\n{\n\tint retval;\n\tstruct posix_acl *acl;\n\tstruct v9fs_session_info *v9ses;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (strcmp(name, \"\") != 0)\n\t\treturn -EINVAL;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\t/*\n\t * set the attribute on the remote. Without even looking at the\n\t * xattr value. We leave it to the server to validate\n\t */\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)\n\t\treturn v9fs_remote_set_acl(dentry, name,\n\t\t\t\t\t   value, size, flags, type);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\tif (value) {\n\t\t/* update the cached acl value */\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\telse if (acl) {\n\t\t\tretval = posix_acl_valid(acl);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else\n\t\tacl = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err_out;\n\t\t\telse {\n\t\t\t\tstruct iattr iattr;\n\t\t\t\tif (retval == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * ACL can be represented\n\t\t\t\t\t * by the mode bits. So don't\n\t\t\t\t\t * update ACL.\n\t\t\t\t\t */\n\t\t\t\t\tacl = NULL;\n\t\t\t\t\tvalue = NULL;\n\t\t\t\t\tsize = 0;\n\t\t\t\t}\n\t\t\t\t/* Updte the mode bits */\n\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n\t\t\t\tiattr.ia_valid = ATTR_MODE;\n\t\t\t\t/* FIXME should we update ctime ?\n\t\t\t\t * What is the following setxattr update the\n\t\t\t\t * mode ?\n\t\t\t\t */\n\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tretval = acl ? -EINVAL : 0;\n\t\t\tgoto err_out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_xattr_set(dentry, name, value, size, flags);\n\tif (!retval)\n\t\tset_cached_acl(inode, type, acl);\nerr_out:\n\tposix_acl_release(acl);\n\treturn retval;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_xattr_set",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/xattr.c",
          "lines": "111-118",
          "snippet": "int v9fs_xattr_set(struct dentry *dentry, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct p9_fid *fid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\treturn v9fs_fid_xattr_set(fid, name, value, value_len, flags);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"fid.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"fid.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_xattr_set(struct dentry *dentry, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct p9_fid *fid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\treturn v9fs_fid_xattr_set(fid, name, value, value_len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_vfs_setattr_dotl",
          "args": [
            "dentry",
            "&iattr"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_vfs_setattr_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "555-604",
          "snippet": "int v9fs_vfs_setattr_dotl(struct dentry *dentry, struct iattr *iattr)\n{\n\tint retval;\n\tstruct p9_fid *fid;\n\tstruct p9_iattr_dotl p9attr;\n\tstruct inode *inode = dentry->d_inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tretval = inode_change_ok(inode, iattr);\n\tif (retval)\n\t\treturn retval;\n\n\tp9attr.valid = v9fs_mapped_iattr_valid(iattr->ia_valid);\n\tp9attr.mode = iattr->ia_mode;\n\tp9attr.uid = iattr->ia_uid;\n\tp9attr.gid = iattr->ia_gid;\n\tp9attr.size = iattr->ia_size;\n\tp9attr.atime_sec = iattr->ia_atime.tv_sec;\n\tp9attr.atime_nsec = iattr->ia_atime.tv_nsec;\n\tp9attr.mtime_sec = iattr->ia_mtime.tv_sec;\n\tp9attr.mtime_nsec = iattr->ia_mtime.tv_nsec;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\t/* Write all dirty data */\n\tif (S_ISREG(inode->i_mode))\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\n\tretval = p9_client_setattr(fid, &p9attr);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tif ((iattr->ia_valid & ATTR_SIZE) &&\n\t    iattr->ia_size != i_size_read(inode))\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\n\tv9fs_invalidate_inode_attr(inode);\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\tif (iattr->ia_valid & ATTR_MODE) {\n\t\t/* We also want to update ACL when we update mode bits */\n\t\tretval = v9fs_acl_chmod(inode, fid);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_vfs_setattr_dotl(struct dentry *dentry, struct iattr *iattr)\n{\n\tint retval;\n\tstruct p9_fid *fid;\n\tstruct p9_iattr_dotl p9attr;\n\tstruct inode *inode = dentry->d_inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tretval = inode_change_ok(inode, iattr);\n\tif (retval)\n\t\treturn retval;\n\n\tp9attr.valid = v9fs_mapped_iattr_valid(iattr->ia_valid);\n\tp9attr.mode = iattr->ia_mode;\n\tp9attr.uid = iattr->ia_uid;\n\tp9attr.gid = iattr->ia_gid;\n\tp9attr.size = iattr->ia_size;\n\tp9attr.atime_sec = iattr->ia_atime.tv_sec;\n\tp9attr.atime_nsec = iattr->ia_atime.tv_nsec;\n\tp9attr.mtime_sec = iattr->ia_mtime.tv_sec;\n\tp9attr.mtime_nsec = iattr->ia_mtime.tv_nsec;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\t/* Write all dirty data */\n\tif (S_ISREG(inode->i_mode))\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\n\tretval = p9_client_setattr(fid, &p9attr);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tif ((iattr->ia_valid & ATTR_SIZE) &&\n\t    iattr->ia_size != i_size_read(inode))\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\n\tv9fs_invalidate_inode_attr(inode);\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\tif (iattr->ia_valid & ATTR_MODE) {\n\t\t/* We also want to update ACL when we update mode bits */\n\t\tretval = v9fs_acl_chmod(inode, fid);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_equiv_mode",
          "args": [
            "acl",
            "&mode"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_equiv_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "242-282",
          "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_valid",
          "args": [
            "acl"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "173-235",
          "snippet": "int\nposix_acl_valid(const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tint state = ACL_USER_OBJ;\n\tint needs_mask = 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tif (pa->e_perm & ~(ACL_READ|ACL_WRITE|ACL_EXECUTE))\n\t\t\treturn -EINVAL;\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tif (state == ACL_USER_OBJ) {\n\t\t\t\t\tstate = ACL_USER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tif (state != ACL_USER)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!uid_valid(pa->e_uid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tif (state == ACL_USER) {\n\t\t\t\t\tstate = ACL_GROUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!gid_valid(pa->e_gid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tstate = ACL_OTHER;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tif (state == ACL_OTHER ||\n\t\t\t\t    (state == ACL_GROUP && !needs_mask)) {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (state == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_valid(const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tint state = ACL_USER_OBJ;\n\tint needs_mask = 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tif (pa->e_perm & ~(ACL_READ|ACL_WRITE|ACL_EXECUTE))\n\t\t\treturn -EINVAL;\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tif (state == ACL_USER_OBJ) {\n\t\t\t\t\tstate = ACL_USER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tif (state != ACL_USER)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!uid_valid(pa->e_uid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tif (state == ACL_USER) {\n\t\t\t\t\tstate = ACL_GROUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!gid_valid(pa->e_gid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tstate = ACL_OTHER;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tif (state == ACL_OTHER ||\n\t\t\t\t    (state == ACL_GROUP && !needs_mask)) {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (state == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "acl"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_from_xattr",
          "args": [
            "&init_user_ns",
            "value",
            "size"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_from_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "662-725",
          "snippet": "struct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_remote_set_acl",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags",
            "type"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_remote_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "261-278",
          "snippet": "static int v9fs_remote_set_acl(struct dentry *dentry, const char *name,\n\t\t\t      const void *value, size_t size,\n\t\t\t      int flags, int type)\n{\n\tchar *full_name;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tfull_name =  POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tfull_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn v9fs_xattr_set(dentry, full_name, value, size, flags);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int v9fs_remote_set_acl(struct dentry *dentry, const char *name,\n\t\t\t      const void *value, size_t size,\n\t\t\t      int flags, int type)\n{\n\tchar *full_name;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tfull_name =  POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tfull_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn v9fs_xattr_set(dentry, full_name, value, size, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_dentry2v9ses",
          "args": [
            "dentry"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_dentry2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "177-180",
          "snippet": "static inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int v9fs_xattr_set_acl(struct dentry *dentry, const char *name,\n\t\t\t      const void *value, size_t size,\n\t\t\t      int flags, int type)\n{\n\tint retval;\n\tstruct posix_acl *acl;\n\tstruct v9fs_session_info *v9ses;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (strcmp(name, \"\") != 0)\n\t\treturn -EINVAL;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\t/*\n\t * set the attribute on the remote. Without even looking at the\n\t * xattr value. We leave it to the server to validate\n\t */\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)\n\t\treturn v9fs_remote_set_acl(dentry, name,\n\t\t\t\t\t   value, size, flags, type);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\tif (value) {\n\t\t/* update the cached acl value */\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\telse if (acl) {\n\t\t\tretval = posix_acl_valid(acl);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else\n\t\tacl = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err_out;\n\t\t\telse {\n\t\t\t\tstruct iattr iattr;\n\t\t\t\tif (retval == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * ACL can be represented\n\t\t\t\t\t * by the mode bits. So don't\n\t\t\t\t\t * update ACL.\n\t\t\t\t\t */\n\t\t\t\t\tacl = NULL;\n\t\t\t\t\tvalue = NULL;\n\t\t\t\t\tsize = 0;\n\t\t\t\t}\n\t\t\t\t/* Updte the mode bits */\n\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n\t\t\t\tiattr.ia_valid = ATTR_MODE;\n\t\t\t\t/* FIXME should we update ctime ?\n\t\t\t\t * What is the following setxattr update the\n\t\t\t\t * mode ?\n\t\t\t\t */\n\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tretval = acl ? -EINVAL : 0;\n\t\t\tgoto err_out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_xattr_set(dentry, name, value, size, flags);\n\tif (!retval)\n\t\tset_cached_acl(inode, type, acl);\nerr_out:\n\tposix_acl_release(acl);\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_remote_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
    "lines": "261-278",
    "snippet": "static int v9fs_remote_set_acl(struct dentry *dentry, const char *name,\n\t\t\t      const void *value, size_t size,\n\t\t\t      int flags, int type)\n{\n\tchar *full_name;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tfull_name =  POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tfull_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn v9fs_xattr_set(dentry, full_name, value, size, flags);\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_xattr_set",
          "args": [
            "dentry",
            "full_name",
            "value",
            "size",
            "flags"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/xattr.c",
          "lines": "111-118",
          "snippet": "int v9fs_xattr_set(struct dentry *dentry, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct p9_fid *fid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\treturn v9fs_fid_xattr_set(fid, name, value, value_len, flags);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"fid.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"fid.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_xattr_set(struct dentry *dentry, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct p9_fid *fid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\treturn v9fs_fid_xattr_set(fid, name, value, value_len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int v9fs_remote_set_acl(struct dentry *dentry, const char *name,\n\t\t\t      const void *value, size_t size,\n\t\t\t      int flags, int type)\n{\n\tchar *full_name;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tfull_name =  POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tfull_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn v9fs_xattr_set(dentry, full_name, value, size, flags);\n}"
  },
  {
    "function_name": "v9fs_xattr_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
    "lines": "233-259",
    "snippet": "static int v9fs_xattr_get_acl(struct dentry *dentry, const char *name,\n\t\t\t      void *buffer, size_t size, int type)\n{\n\tstruct v9fs_session_info *v9ses;\n\tstruct posix_acl *acl;\n\tint error;\n\n\tif (strcmp(name, \"\") != 0)\n\t\treturn -EINVAL;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\t/*\n\t * We allow set/get/list of acl when access=client is not specified\n\t */\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)\n\t\treturn v9fs_remote_get_acl(dentry, name, buffer, size, type);\n\n\tacl = v9fs_get_cached_acl(dentry->d_inode, type);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl == NULL)\n\t\treturn -ENODATA;\n\terror = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\n\tposix_acl_release(acl);\n\n\treturn error;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_to_xattr",
          "args": [
            "&init_user_ns",
            "acl",
            "buffer",
            "size"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_to_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "731-767",
          "snippet": "int\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "acl"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_get_cached_acl",
          "args": [
            "dentry->d_inode",
            "type"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "88-98",
          "snippet": "static struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(acl == ACL_NOT_CACHED);\n\treturn acl;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(acl == ACL_NOT_CACHED);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_remote_get_acl",
          "args": [
            "dentry",
            "name",
            "buffer",
            "size",
            "type"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_remote_get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "215-231",
          "snippet": "static int v9fs_remote_get_acl(struct dentry *dentry, const char *name,\n\t\t\t       void *buffer, size_t size, int type)\n{\n\tchar *full_name;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tfull_name =  POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tfull_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn v9fs_xattr_get(dentry, full_name, buffer, size);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int v9fs_remote_get_acl(struct dentry *dentry, const char *name,\n\t\t\t       void *buffer, size_t size, int type)\n{\n\tchar *full_name;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tfull_name =  POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tfull_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn v9fs_xattr_get(dentry, full_name, buffer, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_dentry2v9ses",
          "args": [
            "dentry"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_dentry2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "177-180",
          "snippet": "static inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int v9fs_xattr_get_acl(struct dentry *dentry, const char *name,\n\t\t\t      void *buffer, size_t size, int type)\n{\n\tstruct v9fs_session_info *v9ses;\n\tstruct posix_acl *acl;\n\tint error;\n\n\tif (strcmp(name, \"\") != 0)\n\t\treturn -EINVAL;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\t/*\n\t * We allow set/get/list of acl when access=client is not specified\n\t */\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)\n\t\treturn v9fs_remote_get_acl(dentry, name, buffer, size, type);\n\n\tacl = v9fs_get_cached_acl(dentry->d_inode, type);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl == NULL)\n\t\treturn -ENODATA;\n\terror = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\n\tposix_acl_release(acl);\n\n\treturn error;\n}"
  },
  {
    "function_name": "v9fs_remote_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
    "lines": "215-231",
    "snippet": "static int v9fs_remote_get_acl(struct dentry *dentry, const char *name,\n\t\t\t       void *buffer, size_t size, int type)\n{\n\tchar *full_name;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tfull_name =  POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tfull_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn v9fs_xattr_get(dentry, full_name, buffer, size);\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_xattr_get",
          "args": [
            "dentry",
            "full_name",
            "buffer",
            "size"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/xattr.c",
          "lines": "85-97",
          "snippet": "ssize_t v9fs_xattr_get(struct dentry *dentry, const char *name,\n\t\t       void *buffer, size_t buffer_size)\n{\n\tstruct p9_fid *fid;\n\n\tp9_debug(P9_DEBUG_VFS, \"name = %s value_len = %zu\\n\",\n\t\t name, buffer_size);\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\treturn v9fs_fid_xattr_get(fid, name, buffer, buffer_size);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"fid.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"fid.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nssize_t v9fs_xattr_get(struct dentry *dentry, const char *name,\n\t\t       void *buffer, size_t buffer_size)\n{\n\tstruct p9_fid *fid;\n\n\tp9_debug(P9_DEBUG_VFS, \"name = %s value_len = %zu\\n\",\n\t\t name, buffer_size);\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\treturn v9fs_fid_xattr_get(fid, name, buffer, buffer_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int v9fs_remote_get_acl(struct dentry *dentry, const char *name,\n\t\t\t       void *buffer, size_t size, int type)\n{\n\tchar *full_name;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tfull_name =  POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tfull_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn v9fs_xattr_get(dentry, full_name, buffer, size);\n}"
  },
  {
    "function_name": "v9fs_acl_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
    "lines": "186-213",
    "snippet": "int v9fs_acl_mode(struct inode *dir, umode_t *modep,\n\t\t  struct posix_acl **dpacl, struct posix_acl **pacl)\n{\n\tint retval = 0;\n\tumode_t mode = *modep;\n\tstruct posix_acl *acl = NULL;\n\n\tif (!S_ISLNK(mode)) {\n\t\tacl = v9fs_get_cached_acl(dir, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\tif (!acl)\n\t\t\tmode &= ~current_umask();\n\t}\n\tif (acl) {\n\t\tif (S_ISDIR(mode))\n\t\t\t*dpacl = posix_acl_dup(acl);\n\t\tretval = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval > 0)\n\t\t\t*pacl = acl;\n\t\telse\n\t\t\tposix_acl_release(acl);\n\t}\n\t*modep  = mode;\n\treturn 0;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__posix_acl_create",
          "args": [
            "&acl",
            "GFP_NOFS",
            "&mode"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "__posix_acl_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "482-497",
          "snippet": "int\n__posix_acl_create(struct posix_acl **acl, gfp_t gfp, umode_t *mode_p)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = posix_acl_create_masq(clone, mode_p);\n\t\tif (err < 0) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\n__posix_acl_create(struct posix_acl **acl, gfp_t gfp, umode_t *mode_p)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = posix_acl_create_masq(clone, mode_p);\n\t\tif (err < 0) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_dup",
          "args": [
            "acl"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "acl"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_get_cached_acl",
          "args": [
            "dir",
            "ACL_TYPE_DEFAULT"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "88-98",
          "snippet": "static struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(acl == ACL_NOT_CACHED);\n\treturn acl;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(acl == ACL_NOT_CACHED);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_acl_mode(struct inode *dir, umode_t *modep,\n\t\t  struct posix_acl **dpacl, struct posix_acl **pacl)\n{\n\tint retval = 0;\n\tumode_t mode = *modep;\n\tstruct posix_acl *acl = NULL;\n\n\tif (!S_ISLNK(mode)) {\n\t\tacl = v9fs_get_cached_acl(dir, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\tif (!acl)\n\t\t\tmode &= ~current_umask();\n\t}\n\tif (acl) {\n\t\tif (S_ISDIR(mode))\n\t\t\t*dpacl = posix_acl_dup(acl);\n\t\tretval = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval > 0)\n\t\t\t*pacl = acl;\n\t\telse\n\t\t\tposix_acl_release(acl);\n\t}\n\t*modep  = mode;\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_put_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
    "lines": "179-184",
    "snippet": "void v9fs_put_acl(struct posix_acl *dacl,\n\t\t  struct posix_acl *acl)\n{\n\tposix_acl_release(dacl);\n\tposix_acl_release(acl);\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "dacl"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid v9fs_put_acl(struct posix_acl *dacl,\n\t\t  struct posix_acl *acl)\n{\n\tposix_acl_release(dacl);\n\tposix_acl_release(acl);\n}"
  },
  {
    "function_name": "v9fs_set_create_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
    "lines": "169-177",
    "snippet": "int v9fs_set_create_acl(struct inode *inode, struct p9_fid *fid,\n\t\t\tstruct posix_acl *dacl, struct posix_acl *acl)\n{\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\tv9fs_set_acl(fid, ACL_TYPE_DEFAULT, dacl);\n\tv9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\treturn 0;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_set_acl",
          "args": [
            "fid",
            "ACL_TYPE_ACCESS",
            "acl"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "117-148",
          "snippet": "static int v9fs_set_acl(struct p9_fid *fid, int type, struct posix_acl *acl)\n{\n\tint retval;\n\tchar *name;\n\tsize_t size;\n\tvoid *buffer;\n\tif (!acl)\n\t\treturn 0;\n\n\t/* Set a setxattr request to server */\n\tsize = posix_acl_xattr_size(acl->a_count);\n\tbuffer = kmalloc(size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tretval = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\n\tif (retval < 0)\n\t\tgoto err_free_out;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_fid_xattr_set(fid, name, buffer, size, 0);\nerr_free_out:\n\tkfree(buffer);\n\treturn retval;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int v9fs_set_acl(struct p9_fid *fid, int type, struct posix_acl *acl)\n{\n\tint retval;\n\tchar *name;\n\tsize_t size;\n\tvoid *buffer;\n\tif (!acl)\n\t\treturn 0;\n\n\t/* Set a setxattr request to server */\n\tsize = posix_acl_xattr_size(acl->a_count);\n\tbuffer = kmalloc(size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tretval = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\n\tif (retval < 0)\n\t\tgoto err_free_out;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_fid_xattr_set(fid, name, buffer, size, 0);\nerr_free_out:\n\tkfree(buffer);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "ACL_TYPE_ACCESS",
            "acl"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_set_create_acl(struct inode *inode, struct p9_fid *fid,\n\t\t\tstruct posix_acl *dacl, struct posix_acl *acl)\n{\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\tv9fs_set_acl(fid, ACL_TYPE_DEFAULT, dacl);\n\tv9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_acl_chmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
    "lines": "150-167",
    "snippet": "int v9fs_acl_chmod(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *acl;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tacl = v9fs_get_cached_acl(inode, ACL_TYPE_ACCESS);\n\tif (acl) {\n\t\tretval = __posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\tretval = v9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_set_acl",
          "args": [
            "fid",
            "ACL_TYPE_ACCESS",
            "acl"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "117-148",
          "snippet": "static int v9fs_set_acl(struct p9_fid *fid, int type, struct posix_acl *acl)\n{\n\tint retval;\n\tchar *name;\n\tsize_t size;\n\tvoid *buffer;\n\tif (!acl)\n\t\treturn 0;\n\n\t/* Set a setxattr request to server */\n\tsize = posix_acl_xattr_size(acl->a_count);\n\tbuffer = kmalloc(size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tretval = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\n\tif (retval < 0)\n\t\tgoto err_free_out;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_fid_xattr_set(fid, name, buffer, size, 0);\nerr_free_out:\n\tkfree(buffer);\n\treturn retval;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int v9fs_set_acl(struct p9_fid *fid, int type, struct posix_acl *acl)\n{\n\tint retval;\n\tchar *name;\n\tsize_t size;\n\tvoid *buffer;\n\tif (!acl)\n\t\treturn 0;\n\n\t/* Set a setxattr request to server */\n\tsize = posix_acl_xattr_size(acl->a_count);\n\tbuffer = kmalloc(size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tretval = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\n\tif (retval < 0)\n\t\tgoto err_free_out;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_fid_xattr_set(fid, name, buffer, size, 0);\nerr_free_out:\n\tkfree(buffer);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "ACL_TYPE_ACCESS",
            "acl"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__posix_acl_chmod",
          "args": [
            "&acl",
            "GFP_KERNEL",
            "inode->i_mode"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "__posix_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "500-515",
          "snippet": "int\n__posix_acl_chmod(struct posix_acl **acl, gfp_t gfp, umode_t mode)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = __posix_acl_chmod_masq(clone, mode);\n\t\tif (err) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\n__posix_acl_chmod(struct posix_acl **acl, gfp_t gfp, umode_t mode)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = __posix_acl_chmod_masq(clone, mode);\n\t\tif (err) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_get_cached_acl",
          "args": [
            "inode",
            "ACL_TYPE_ACCESS"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "88-98",
          "snippet": "static struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(acl == ACL_NOT_CACHED);\n\treturn acl;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(acl == ACL_NOT_CACHED);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_acl_chmod(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *acl;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tacl = v9fs_get_cached_acl(inode, ACL_TYPE_ACCESS);\n\tif (acl) {\n\t\tretval = __posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\tretval = v9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
    "lines": "117-148",
    "snippet": "static int v9fs_set_acl(struct p9_fid *fid, int type, struct posix_acl *acl)\n{\n\tint retval;\n\tchar *name;\n\tsize_t size;\n\tvoid *buffer;\n\tif (!acl)\n\t\treturn 0;\n\n\t/* Set a setxattr request to server */\n\tsize = posix_acl_xattr_size(acl->a_count);\n\tbuffer = kmalloc(size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tretval = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\n\tif (retval < 0)\n\t\tgoto err_free_out;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_fid_xattr_set(fid, name, buffer, size, 0);\nerr_free_out:\n\tkfree(buffer);\n\treturn retval;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_xattr_set",
          "args": [
            "fid",
            "name",
            "buffer",
            "size",
            "0"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/xattr.c",
          "lines": "120-163",
          "snippet": "int v9fs_fid_xattr_set(struct p9_fid *fid, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tu64 offset = 0;\n\tint retval, msize, write_count;\n\n\tp9_debug(P9_DEBUG_VFS, \"name = %s value_len = %zu flags = %d\\n\",\n\t\t name, value_len, flags);\n\n\t/* Clone it */\n\tfid = p9_client_walk(fid, 0, NULL, 1);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\t/*\n\t * On success fid points to xattr\n\t */\n\tretval = p9_client_xattrcreate(fid, name, value_len, flags);\n\tif (retval < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_xattrcreate failed %d\\n\",\n\t\t\t retval);\n\t\tgoto err;\n\t}\n\tmsize = fid->clnt->msize;\n\twhile (value_len) {\n\t\tif (value_len > (msize - P9_IOHDRSZ))\n\t\t\twrite_count = msize - P9_IOHDRSZ;\n\t\telse\n\t\t\twrite_count = value_len;\n\t\twrite_count = p9_client_write(fid, ((char *)value)+offset,\n\t\t\t\t\tNULL, offset, write_count);\n\t\tif (write_count < 0) {\n\t\t\t/* error in xattr write */\n\t\t\tretval = write_count;\n\t\t\tgoto err;\n\t\t}\n\t\toffset += write_count;\n\t\tvalue_len -= write_count;\n\t}\n\tretval = 0;\nerr:\n\tp9_client_clunk(fid);\n\treturn retval;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"fid.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"fid.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_fid_xattr_set(struct p9_fid *fid, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tu64 offset = 0;\n\tint retval, msize, write_count;\n\n\tp9_debug(P9_DEBUG_VFS, \"name = %s value_len = %zu flags = %d\\n\",\n\t\t name, value_len, flags);\n\n\t/* Clone it */\n\tfid = p9_client_walk(fid, 0, NULL, 1);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\t/*\n\t * On success fid points to xattr\n\t */\n\tretval = p9_client_xattrcreate(fid, name, value_len, flags);\n\tif (retval < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_xattrcreate failed %d\\n\",\n\t\t\t retval);\n\t\tgoto err;\n\t}\n\tmsize = fid->clnt->msize;\n\twhile (value_len) {\n\t\tif (value_len > (msize - P9_IOHDRSZ))\n\t\t\twrite_count = msize - P9_IOHDRSZ;\n\t\telse\n\t\t\twrite_count = value_len;\n\t\twrite_count = p9_client_write(fid, ((char *)value)+offset,\n\t\t\t\t\tNULL, offset, write_count);\n\t\tif (write_count < 0) {\n\t\t\t/* error in xattr write */\n\t\t\tretval = write_count;\n\t\t\tgoto err;\n\t\t}\n\t\toffset += write_count;\n\t\tvalue_len -= write_count;\n\t}\n\tretval = 0;\nerr:\n\tp9_client_clunk(fid);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_to_xattr",
          "args": [
            "&init_user_ns",
            "acl",
            "buffer",
            "size"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_to_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "731-767",
          "snippet": "int\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_xattr_size",
          "args": [
            "acl->a_count"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int v9fs_set_acl(struct p9_fid *fid, int type, struct posix_acl *acl)\n{\n\tint retval;\n\tchar *name;\n\tsize_t size;\n\tvoid *buffer;\n\tif (!acl)\n\t\treturn 0;\n\n\t/* Set a setxattr request to server */\n\tsize = posix_acl_xattr_size(acl->a_count);\n\tbuffer = kmalloc(size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tretval = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\n\tif (retval < 0)\n\t\tgoto err_free_out;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_fid_xattr_set(fid, name, buffer, size, 0);\nerr_free_out:\n\tkfree(buffer);\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_iop_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
    "lines": "100-115",
    "snippet": "struct posix_acl *v9fs_iop_get_acl(struct inode *inode, int type)\n{\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\t/*\n\t\t * On access = client  and acl = on mode get the acl\n\t\t * values from the server\n\t\t */\n\t\treturn NULL;\n\t}\n\treturn v9fs_get_cached_acl(inode, type);\n\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_get_cached_acl",
          "args": [
            "inode",
            "type"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "88-98",
          "snippet": "static struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(acl == ACL_NOT_CACHED);\n\treturn acl;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(acl == ACL_NOT_CACHED);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "inode"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct posix_acl *v9fs_iop_get_acl(struct inode *inode, int type)\n{\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\t/*\n\t\t * On access = client  and acl = on mode get the acl\n\t\t * values from the server\n\t\t */\n\t\treturn NULL;\n\t}\n\treturn v9fs_get_cached_acl(inode, type);\n\n}"
  },
  {
    "function_name": "v9fs_get_cached_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
    "lines": "88-98",
    "snippet": "static struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(acl == ACL_NOT_CACHED);\n\treturn acl;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "acl == ACL_NOT_CACHED"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cached_acl",
          "args": [
            "inode",
            "type"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "88-98",
          "snippet": "static struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(acl == ACL_NOT_CACHED);\n\treturn acl;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(acl == ACL_NOT_CACHED);\n\treturn acl;\n}"
  },
  {
    "function_name": "v9fs_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
    "lines": "56-86",
    "snippet": "int v9fs_get_acl(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *pacl, *dacl;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, NULL);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, NULL);\n\t\treturn 0;\n\t}\n\t/* get the default/access acl values and cache them */\n\tdacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_DEFAULT);\n\tpacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_ACCESS);\n\n\tif (!IS_ERR(dacl) && !IS_ERR(pacl)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, pacl);\n\t} else\n\t\tretval = -EIO;\n\n\tif (!IS_ERR(dacl))\n\t\tposix_acl_release(dacl);\n\n\tif (!IS_ERR(pacl))\n\t\tposix_acl_release(pacl);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "pacl"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pacl"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "dacl"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dacl"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "ACL_TYPE_ACCESS",
            "pacl"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pacl"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dacl"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__v9fs_get_acl",
          "args": [
            "fid",
            "POSIX_ACL_XATTR_ACCESS"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "__v9fs_get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "28-54",
          "snippet": "static struct posix_acl *__v9fs_get_acl(struct p9_fid *fid, char *name)\n{\n\tssize_t size;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl = NULL;\n\n\tsize = v9fs_fid_xattr_get(fid, name, NULL, 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = v9fs_fid_xattr_get(fid, name, value, size);\n\t\tif (size > 0) {\n\t\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\t\tif (IS_ERR(acl))\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else if (size == -ENODATA || size == 0 ||\n\t\t   size == -ENOSYS || size == -EOPNOTSUPP) {\n\t\tacl = NULL;\n\t} else\n\t\tacl = ERR_PTR(-EIO);\n\nerr_out:\n\tkfree(value);\n\treturn acl;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct posix_acl *__v9fs_get_acl(struct p9_fid *fid, char *name)\n{\n\tssize_t size;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl = NULL;\n\n\tsize = v9fs_fid_xattr_get(fid, name, NULL, 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = v9fs_fid_xattr_get(fid, name, value, size);\n\t\tif (size > 0) {\n\t\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\t\tif (IS_ERR(acl))\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else if (size == -ENODATA || size == 0 ||\n\t\t   size == -ENOSYS || size == -EOPNOTSUPP) {\n\t\tacl = NULL;\n\t} else\n\t\tacl = ERR_PTR(-EIO);\n\nerr_out:\n\tkfree(value);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "inode"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_get_acl(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *pacl, *dacl;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, NULL);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, NULL);\n\t\treturn 0;\n\t}\n\t/* get the default/access acl values and cache them */\n\tdacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_DEFAULT);\n\tpacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_ACCESS);\n\n\tif (!IS_ERR(dacl) && !IS_ERR(pacl)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, pacl);\n\t} else\n\t\tretval = -EIO;\n\n\tif (!IS_ERR(dacl))\n\t\tposix_acl_release(dacl);\n\n\tif (!IS_ERR(pacl))\n\t\tposix_acl_release(pacl);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "__v9fs_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
    "lines": "28-54",
    "snippet": "static struct posix_acl *__v9fs_get_acl(struct p9_fid *fid, char *name)\n{\n\tssize_t size;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl = NULL;\n\n\tsize = v9fs_fid_xattr_get(fid, name, NULL, 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = v9fs_fid_xattr_get(fid, name, value, size);\n\t\tif (size > 0) {\n\t\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\t\tif (IS_ERR(acl))\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else if (size == -ENODATA || size == 0 ||\n\t\t   size == -ENOSYS || size == -EOPNOTSUPP) {\n\t\tacl = NULL;\n\t} else\n\t\tacl = ERR_PTR(-EIO);\n\nerr_out:\n\tkfree(value);\n\treturn acl;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_from_xattr",
          "args": [
            "&init_user_ns",
            "value",
            "size"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_from_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "662-725",
          "snippet": "struct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_fid_xattr_get",
          "args": [
            "fid",
            "name",
            "value",
            "size"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/xattr.c",
          "lines": "24-72",
          "snippet": "ssize_t v9fs_fid_xattr_get(struct p9_fid *fid, const char *name,\n\t\t\t   void *buffer, size_t buffer_size)\n{\n\tssize_t retval;\n\tint msize, read_count;\n\tu64 offset = 0, attr_size;\n\tstruct p9_fid *attr_fid;\n\n\tattr_fid = p9_client_xattrwalk(fid, name, &attr_size);\n\tif (IS_ERR(attr_fid)) {\n\t\tretval = PTR_ERR(attr_fid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_attrwalk failed %zd\\n\",\n\t\t\t retval);\n\t\tattr_fid = NULL;\n\t\tgoto error;\n\t}\n\tif (!buffer_size) {\n\t\t/* request to get the attr_size */\n\t\tretval = attr_size;\n\t\tgoto error;\n\t}\n\tif (attr_size > buffer_size) {\n\t\tretval = -ERANGE;\n\t\tgoto error;\n\t}\n\tmsize = attr_fid->clnt->msize;\n\twhile (attr_size) {\n\t\tif (attr_size > (msize - P9_IOHDRSZ))\n\t\t\tread_count = msize - P9_IOHDRSZ;\n\t\telse\n\t\t\tread_count = attr_size;\n\t\tread_count = p9_client_read(attr_fid, ((char *)buffer)+offset,\n\t\t\t\t\tNULL, offset, read_count);\n\t\tif (read_count < 0) {\n\t\t\t/* error in xattr read */\n\t\t\tretval = read_count;\n\t\t\tgoto error;\n\t\t}\n\t\toffset += read_count;\n\t\tattr_size -= read_count;\n\t}\n\t/* Total read xattr bytes */\n\tretval = offset;\nerror:\n\tif (attr_fid)\n\t\tp9_client_clunk(attr_fid);\n\treturn retval;\n\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"fid.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"fid.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nssize_t v9fs_fid_xattr_get(struct p9_fid *fid, const char *name,\n\t\t\t   void *buffer, size_t buffer_size)\n{\n\tssize_t retval;\n\tint msize, read_count;\n\tu64 offset = 0, attr_size;\n\tstruct p9_fid *attr_fid;\n\n\tattr_fid = p9_client_xattrwalk(fid, name, &attr_size);\n\tif (IS_ERR(attr_fid)) {\n\t\tretval = PTR_ERR(attr_fid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_attrwalk failed %zd\\n\",\n\t\t\t retval);\n\t\tattr_fid = NULL;\n\t\tgoto error;\n\t}\n\tif (!buffer_size) {\n\t\t/* request to get the attr_size */\n\t\tretval = attr_size;\n\t\tgoto error;\n\t}\n\tif (attr_size > buffer_size) {\n\t\tretval = -ERANGE;\n\t\tgoto error;\n\t}\n\tmsize = attr_fid->clnt->msize;\n\twhile (attr_size) {\n\t\tif (attr_size > (msize - P9_IOHDRSZ))\n\t\t\tread_count = msize - P9_IOHDRSZ;\n\t\telse\n\t\t\tread_count = attr_size;\n\t\tread_count = p9_client_read(attr_fid, ((char *)buffer)+offset,\n\t\t\t\t\tNULL, offset, read_count);\n\t\tif (read_count < 0) {\n\t\t\t/* error in xattr read */\n\t\t\tretval = read_count;\n\t\t\tgoto error;\n\t\t}\n\t\toffset += read_count;\n\t\tattr_size -= read_count;\n\t}\n\t/* Total read xattr bytes */\n\tretval = offset;\nerror:\n\tif (attr_fid)\n\t\tp9_client_clunk(attr_fid);\n\treturn retval;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_NOFS"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct posix_acl *__v9fs_get_acl(struct p9_fid *fid, char *name)\n{\n\tssize_t size;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl = NULL;\n\n\tsize = v9fs_fid_xattr_get(fid, name, NULL, 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = v9fs_fid_xattr_get(fid, name, value, size);\n\t\tif (size > 0) {\n\t\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\t\tif (IS_ERR(acl))\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else if (size == -ENODATA || size == 0 ||\n\t\t   size == -ENOSYS || size == -EOPNOTSUPP) {\n\t\tacl = NULL;\n\t} else\n\t\tacl = ERR_PTR(-EIO);\n\nerr_out:\n\tkfree(value);\n\treturn acl;\n}"
  }
]