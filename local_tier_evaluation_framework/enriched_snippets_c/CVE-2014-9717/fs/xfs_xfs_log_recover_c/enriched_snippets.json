[
  {
    "function_name": "xlog_recover_check_summary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "4607-4650",
    "snippet": "void\nxlog_recover_check_summary(\n\tstruct xlog\t*log)\n{\n\txfs_mount_t\t*mp;\n\txfs_agf_t\t*agfp;\n\txfs_buf_t\t*agfbp;\n\txfs_buf_t\t*agibp;\n\txfs_agnumber_t\tagno;\n\t__uint64_t\tfreeblks;\n\t__uint64_t\titotal;\n\t__uint64_t\tifree;\n\tint\t\terror;\n\n\tmp = log->l_mp;\n\n\tfreeblks = 0LL;\n\titotal = 0LL;\n\tifree = 0LL;\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\terror = xfs_read_agf(mp, NULL, agno, 0, &agfbp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agf read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tagfp = XFS_BUF_TO_AGF(agfbp);\n\t\t\tfreeblks += be32_to_cpu(agfp->agf_freeblks) +\n\t\t\t\t    be32_to_cpu(agfp->agf_flcount);\n\t\t\txfs_buf_relse(agfbp);\n\t\t}\n\n\t\terror = xfs_read_agi(mp, NULL, agno, &agibp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agi read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(agibp);\n\n\t\t\titotal += be32_to_cpu(agi->agi_count);\n\t\t\tifree += be32_to_cpu(agi->agi_freecount);\n\t\t\txfs_buf_relse(agibp);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "agibp"
          ],
          "line": 4647
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_freecount"
          ],
          "line": 4646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_count"
          ],
          "line": 4645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agibp"
          ],
          "line": 4643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"%s agi read failed agno %d error %d\"",
            "__func__",
            "agno",
            "error"
          ],
          "line": 4640
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_read_agi",
          "args": [
            "mp",
            "NULL",
            "agno",
            "&agibp"
          ],
          "line": 4638
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_read_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2122-2142",
          "snippet": "int\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};\n\nint\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agfp->agf_flcount"
          ],
          "line": 4634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agfp->agf_freeblks"
          ],
          "line": 4633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "agfbp"
          ],
          "line": 4632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_read_agf",
          "args": [
            "mp",
            "NULL",
            "agno",
            "0",
            "&agfbp"
          ],
          "line": 4627
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_read_agf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2280-2305",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_BUF_ */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tint\t\terror;\n\n\ttrace_xfs_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGF_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), flags, bpp, &xfs_agf_buf_ops);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\n\tASSERT(!(*bpp)->b_error);\n\txfs_buf_set_ref(*bpp, XFS_AGF_REF);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_agf_buf_ops = {\n\t.verify_read = xfs_agf_read_verify,\n\t.verify_write = xfs_agf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agf_buf_ops = {\n\t.verify_read = xfs_agf_read_verify,\n\t.verify_write = xfs_agf_write_verify,\n};\n\nint\t\t\t\t\t/* error */\nxfs_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_BUF_ */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tint\t\terror;\n\n\ttrace_xfs_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGF_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), flags, bpp, &xfs_agf_buf_ops);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\n\tASSERT(!(*bpp)->b_error);\n\txfs_buf_set_ref(*bpp, XFS_AGF_REF);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxlog_recover_check_summary(\n\tstruct xlog\t*log)\n{\n\txfs_mount_t\t*mp;\n\txfs_agf_t\t*agfp;\n\txfs_buf_t\t*agfbp;\n\txfs_buf_t\t*agibp;\n\txfs_agnumber_t\tagno;\n\t__uint64_t\tfreeblks;\n\t__uint64_t\titotal;\n\t__uint64_t\tifree;\n\tint\t\terror;\n\n\tmp = log->l_mp;\n\n\tfreeblks = 0LL;\n\titotal = 0LL;\n\tifree = 0LL;\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\terror = xfs_read_agf(mp, NULL, agno, 0, &agfbp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agf read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tagfp = XFS_BUF_TO_AGF(agfbp);\n\t\t\tfreeblks += be32_to_cpu(agfp->agf_freeblks) +\n\t\t\t\t    be32_to_cpu(agfp->agf_flcount);\n\t\t\txfs_buf_relse(agfbp);\n\t\t}\n\n\t\terror = xfs_read_agi(mp, NULL, agno, &agibp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agi read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(agibp);\n\n\t\t\titotal += be32_to_cpu(agi->agi_count);\n\t\t\tifree += be32_to_cpu(agi->agi_freecount);\n\t\t\txfs_buf_relse(agibp);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xlog_recover_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "4560-4599",
    "snippet": "int\nxlog_recover_finish(\n\tstruct xlog\t*log)\n{\n\t/*\n\t * Now we're ready to do the transactions needed for the\n\t * rest of recovery.  Start with completing all the extent\n\t * free intent records and then process the unlinked inode\n\t * lists.  At this point, we essentially run in normal mode\n\t * except that we're still performing recovery actions\n\t * rather than accepting new requests.\n\t */\n\tif (log->l_flags & XLOG_RECOVERY_NEEDED) {\n\t\tint\terror;\n\t\terror = xlog_recover_process_efis(log);\n\t\tif (error) {\n\t\t\txfs_alert(log->l_mp, \"Failed to recover EFIs\");\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Sync the log to get all the EFIs out of the AIL.\n\t\t * This isn't absolutely necessary, but it helps in\n\t\t * case the unlink transactions would have problems\n\t\t * pushing the EFIs out of the way.\n\t\t */\n\t\txfs_log_force(log->l_mp, XFS_LOG_SYNC);\n\n\t\txlog_recover_process_iunlinks(log);\n\n\t\txlog_recover_check_summary(log);\n\n\t\txfs_notice(log->l_mp, \"Ending recovery (logdev: %s)\",\n\t\t\t\tlog->l_mp->m_logname ? log->l_mp->m_logname\n\t\t\t\t\t\t     : \"internal\");\n\t\tlog->l_flags &= ~XLOG_RECOVERY_NEEDED;\n\t} else {\n\t\txfs_info(log->l_mp, \"Ending clean mount\");\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_info",
          "args": [
            "log->l_mp",
            "\"Ending clean mount\""
          ],
          "line": 4596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "log->l_mp",
            "\"Ending recovery (logdev: %s)\"",
            "log->l_mp->m_logname ? log->l_mp->m_logname\n\t\t\t\t\t\t     : \"internal\""
          ],
          "line": 4591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_recover_check_summary",
          "args": [
            "log"
          ],
          "line": 4589
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_check_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "4607-4650",
          "snippet": "void\nxlog_recover_check_summary(\n\tstruct xlog\t*log)\n{\n\txfs_mount_t\t*mp;\n\txfs_agf_t\t*agfp;\n\txfs_buf_t\t*agfbp;\n\txfs_buf_t\t*agibp;\n\txfs_agnumber_t\tagno;\n\t__uint64_t\tfreeblks;\n\t__uint64_t\titotal;\n\t__uint64_t\tifree;\n\tint\t\terror;\n\n\tmp = log->l_mp;\n\n\tfreeblks = 0LL;\n\titotal = 0LL;\n\tifree = 0LL;\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\terror = xfs_read_agf(mp, NULL, agno, 0, &agfbp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agf read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tagfp = XFS_BUF_TO_AGF(agfbp);\n\t\t\tfreeblks += be32_to_cpu(agfp->agf_freeblks) +\n\t\t\t\t    be32_to_cpu(agfp->agf_flcount);\n\t\t\txfs_buf_relse(agfbp);\n\t\t}\n\n\t\terror = xfs_read_agi(mp, NULL, agno, &agibp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agi read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(agibp);\n\n\t\t\titotal += be32_to_cpu(agi->agi_count);\n\t\t\tifree += be32_to_cpu(agi->agi_freecount);\n\t\t\txfs_buf_relse(agibp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxlog_recover_check_summary(\n\tstruct xlog\t*log)\n{\n\txfs_mount_t\t*mp;\n\txfs_agf_t\t*agfp;\n\txfs_buf_t\t*agfbp;\n\txfs_buf_t\t*agibp;\n\txfs_agnumber_t\tagno;\n\t__uint64_t\tfreeblks;\n\t__uint64_t\titotal;\n\t__uint64_t\tifree;\n\tint\t\terror;\n\n\tmp = log->l_mp;\n\n\tfreeblks = 0LL;\n\titotal = 0LL;\n\tifree = 0LL;\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\terror = xfs_read_agf(mp, NULL, agno, 0, &agfbp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agf read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tagfp = XFS_BUF_TO_AGF(agfbp);\n\t\t\tfreeblks += be32_to_cpu(agfp->agf_freeblks) +\n\t\t\t\t    be32_to_cpu(agfp->agf_flcount);\n\t\t\txfs_buf_relse(agfbp);\n\t\t}\n\n\t\terror = xfs_read_agi(mp, NULL, agno, &agibp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agi read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(agibp);\n\n\t\t\titotal += be32_to_cpu(agi->agi_count);\n\t\t\tifree += be32_to_cpu(agi->agi_freecount);\n\t\t\txfs_buf_relse(agibp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_process_iunlinks",
          "args": [
            "log"
          ],
          "line": 4587
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_process_iunlinks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3940-3998",
          "snippet": "STATIC void\nxlog_recover_process_iunlinks(\n\tstruct xlog\t*log)\n{\n\txfs_mount_t\t*mp;\n\txfs_agnumber_t\tagno;\n\txfs_agi_t\t*agi;\n\txfs_buf_t\t*agibp;\n\txfs_agino_t\tagino;\n\tint\t\tbucket;\n\tint\t\terror;\n\tuint\t\tmp_dmevmask;\n\n\tmp = log->l_mp;\n\n\t/*\n\t * Prevent any DMAPI event from being sent while in this function.\n\t */\n\tmp_dmevmask = mp->m_dmevmask;\n\tmp->m_dmevmask = 0;\n\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\t/*\n\t\t * Find the agi for this ag.\n\t\t */\n\t\terror = xfs_read_agi(mp, NULL, agno, &agibp);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * AGI is b0rked. Don't process it.\n\t\t\t *\n\t\t\t * We should probably mark the filesystem as corrupt\n\t\t\t * after we've recovered all the ag's we can....\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Unlock the buffer so that it can be acquired in the normal\n\t\t * course of the transaction to truncate and free each inode.\n\t\t * Because we are not racing with anyone else here for the AGI\n\t\t * buffer, we don't even need to hold it locked to read the\n\t\t * initial unlinked bucket entries out of the buffer. We keep\n\t\t * buffer reference though, so that it stays pinned in memory\n\t\t * while we need the buffer.\n\t\t */\n\t\tagi = XFS_BUF_TO_AGI(agibp);\n\t\txfs_buf_unlock(agibp);\n\n\t\tfor (bucket = 0; bucket < XFS_AGI_UNLINKED_BUCKETS; bucket++) {\n\t\t\tagino = be32_to_cpu(agi->agi_unlinked[bucket]);\n\t\t\twhile (agino != NULLAGINO) {\n\t\t\t\tagino = xlog_recover_process_one_iunlink(mp,\n\t\t\t\t\t\t\tagno, agino, bucket);\n\t\t\t}\n\t\t}\n\t\txfs_buf_rele(agibp);\n\t}\n\n\tmp->m_dmevmask = mp_dmevmask;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_process_iunlinks(\n\tstruct xlog\t*log)\n{\n\txfs_mount_t\t*mp;\n\txfs_agnumber_t\tagno;\n\txfs_agi_t\t*agi;\n\txfs_buf_t\t*agibp;\n\txfs_agino_t\tagino;\n\tint\t\tbucket;\n\tint\t\terror;\n\tuint\t\tmp_dmevmask;\n\n\tmp = log->l_mp;\n\n\t/*\n\t * Prevent any DMAPI event from being sent while in this function.\n\t */\n\tmp_dmevmask = mp->m_dmevmask;\n\tmp->m_dmevmask = 0;\n\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\t/*\n\t\t * Find the agi for this ag.\n\t\t */\n\t\terror = xfs_read_agi(mp, NULL, agno, &agibp);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * AGI is b0rked. Don't process it.\n\t\t\t *\n\t\t\t * We should probably mark the filesystem as corrupt\n\t\t\t * after we've recovered all the ag's we can....\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Unlock the buffer so that it can be acquired in the normal\n\t\t * course of the transaction to truncate and free each inode.\n\t\t * Because we are not racing with anyone else here for the AGI\n\t\t * buffer, we don't even need to hold it locked to read the\n\t\t * initial unlinked bucket entries out of the buffer. We keep\n\t\t * buffer reference though, so that it stays pinned in memory\n\t\t * while we need the buffer.\n\t\t */\n\t\tagi = XFS_BUF_TO_AGI(agibp);\n\t\txfs_buf_unlock(agibp);\n\n\t\tfor (bucket = 0; bucket < XFS_AGI_UNLINKED_BUCKETS; bucket++) {\n\t\t\tagino = be32_to_cpu(agi->agi_unlinked[bucket]);\n\t\t\twhile (agino != NULLAGINO) {\n\t\t\t\tagino = xlog_recover_process_one_iunlink(mp,\n\t\t\t\t\t\t\tagno, agino, bucket);\n\t\t\t}\n\t\t}\n\t\txfs_buf_rele(agibp);\n\t}\n\n\tmp->m_dmevmask = mp_dmevmask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "log->l_mp",
            "XFS_LOG_SYNC"
          ],
          "line": 4585
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "log->l_mp",
            "\"Failed to recover EFIs\""
          ],
          "line": 4576
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_fsblock_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iomap.c",
          "lines": "95-110",
          "snippet": "STATIC int\nxfs_alert_fsblock_zero(\n\txfs_inode_t\t*ip,\n\txfs_bmbt_irec_t\t*imap)\n{\n\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\"blkcnt: %llx extent-state: %x\",\n\t\t(unsigned long long)ip->i_ino,\n\t\t(unsigned long long)imap->br_startblock,\n\t\t(unsigned long long)imap->br_startoff,\n\t\t(unsigned long long)imap->br_blockcount,\n\t\timap->br_state);\n\treturn -EFSCORRUPTED;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_alert_fsblock_zero(\n\txfs_inode_t\t*ip,\n\txfs_bmbt_irec_t\t*imap)\n{\n\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\"blkcnt: %llx extent-state: %x\",\n\t\t(unsigned long long)ip->i_ino,\n\t\t(unsigned long long)imap->br_startblock,\n\t\t(unsigned long long)imap->br_startoff,\n\t\t(unsigned long long)imap->br_blockcount,\n\t\timap->br_state);\n\treturn -EFSCORRUPTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_process_efis",
          "args": [
            "log"
          ],
          "line": 4574
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_process_efis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3780-3826",
          "snippet": "STATIC int\nxlog_recover_process_efis(\n\tstruct xlog\t*log)\n{\n\txfs_log_item_t\t\t*lip;\n\txfs_efi_log_item_t\t*efip;\n\tint\t\t\terror = 0;\n\tstruct xfs_ail_cursor\tcur;\n\tstruct xfs_ail\t\t*ailp;\n\n\tailp = log->l_ailp;\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, 0);\n\twhile (lip != NULL) {\n\t\t/*\n\t\t * We're done when we see something other than an EFI.\n\t\t * There should be no EFIs left in the AIL now.\n\t\t */\n\t\tif (lip->li_type != XFS_LI_EFI) {\n#ifdef DEBUG\n\t\t\tfor (; lip; lip = xfs_trans_ail_cursor_next(ailp, &cur))\n\t\t\t\tASSERT(lip->li_type != XFS_LI_EFI);\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Skip EFIs that we've already processed.\n\t\t */\n\t\tefip = (xfs_efi_log_item_t *)lip;\n\t\tif (test_bit(XFS_EFI_RECOVERED, &efip->efi_flags)) {\n\t\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_unlock(&ailp->xa_lock);\n\t\terror = xlog_recover_process_efi(log->l_mp, efip);\n\t\tspin_lock(&ailp->xa_lock);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t}\nout:\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_process_efis(\n\tstruct xlog\t*log)\n{\n\txfs_log_item_t\t\t*lip;\n\txfs_efi_log_item_t\t*efip;\n\tint\t\t\terror = 0;\n\tstruct xfs_ail_cursor\tcur;\n\tstruct xfs_ail\t\t*ailp;\n\n\tailp = log->l_ailp;\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, 0);\n\twhile (lip != NULL) {\n\t\t/*\n\t\t * We're done when we see something other than an EFI.\n\t\t * There should be no EFIs left in the AIL now.\n\t\t */\n\t\tif (lip->li_type != XFS_LI_EFI) {\n#ifdef DEBUG\n\t\t\tfor (; lip; lip = xfs_trans_ail_cursor_next(ailp, &cur))\n\t\t\t\tASSERT(lip->li_type != XFS_LI_EFI);\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Skip EFIs that we've already processed.\n\t\t */\n\t\tefip = (xfs_efi_log_item_t *)lip;\n\t\tif (test_bit(XFS_EFI_RECOVERED, &efip->efi_flags)) {\n\t\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_unlock(&ailp->xa_lock);\n\t\terror = xlog_recover_process_efi(log->l_mp, efip);\n\t\tspin_lock(&ailp->xa_lock);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t}\nout:\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxlog_recover_finish(\n\tstruct xlog\t*log)\n{\n\t/*\n\t * Now we're ready to do the transactions needed for the\n\t * rest of recovery.  Start with completing all the extent\n\t * free intent records and then process the unlinked inode\n\t * lists.  At this point, we essentially run in normal mode\n\t * except that we're still performing recovery actions\n\t * rather than accepting new requests.\n\t */\n\tif (log->l_flags & XLOG_RECOVERY_NEEDED) {\n\t\tint\terror;\n\t\terror = xlog_recover_process_efis(log);\n\t\tif (error) {\n\t\t\txfs_alert(log->l_mp, \"Failed to recover EFIs\");\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Sync the log to get all the EFIs out of the AIL.\n\t\t * This isn't absolutely necessary, but it helps in\n\t\t * case the unlink transactions would have problems\n\t\t * pushing the EFIs out of the way.\n\t\t */\n\t\txfs_log_force(log->l_mp, XFS_LOG_SYNC);\n\n\t\txlog_recover_process_iunlinks(log);\n\n\t\txlog_recover_check_summary(log);\n\n\t\txfs_notice(log->l_mp, \"Ending recovery (logdev: %s)\",\n\t\t\t\tlog->l_mp->m_logname ? log->l_mp->m_logname\n\t\t\t\t\t\t     : \"internal\");\n\t\tlog->l_flags &= ~XLOG_RECOVERY_NEEDED;\n\t} else {\n\t\txfs_info(log->l_mp, \"Ending clean mount\");\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "4483-4549",
    "snippet": "int\nxlog_recover(\n\tstruct xlog\t*log)\n{\n\txfs_daddr_t\thead_blk, tail_blk;\n\tint\t\terror;\n\n\t/* find the tail of the log */\n\tif ((error = xlog_find_tail(log, &head_blk, &tail_blk)))\n\t\treturn error;\n\n\tif (tail_blk != head_blk) {\n\t\t/* There used to be a comment here:\n\t\t *\n\t\t * disallow recovery on read-only mounts.  note -- mount\n\t\t * checks for ENOSPC and turns it into an intelligent\n\t\t * error message.\n\t\t * ...but this is no longer true.  Now, unless you specify\n\t\t * NORECOVERY (in which case this function would never be\n\t\t * called), we just go ahead and recover.  We do this all\n\t\t * under the vfs layer, so we can get away with it unless\n\t\t * the device itself is read-only, in which case we fail.\n\t\t */\n\t\tif ((error = xfs_dev_is_read_only(log->l_mp, \"recovery\"))) {\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Version 5 superblock log feature mask validation. We know the\n\t\t * log is dirty so check if there are any unknown log features\n\t\t * in what we need to recover. If there are unknown features\n\t\t * (e.g. unsupported transactions, then simply reject the\n\t\t * attempt at recovery before touching anything.\n\t\t */\n\t\tif (XFS_SB_VERSION_NUM(&log->l_mp->m_sb) == XFS_SB_VERSION_5 &&\n\t\t    xfs_sb_has_incompat_log_feature(&log->l_mp->m_sb,\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_LOG_UNKNOWN)) {\n\t\t\txfs_warn(log->l_mp,\n\"Superblock has unknown incompatible log features (0x%x) enabled.\\n\"\n\"The log can not be fully and/or safely recovered by this kernel.\\n\"\n\"Please recover the log on a kernel that supports the unknown features.\",\n\t\t\t\t(log->l_mp->m_sb.sb_features_log_incompat &\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_LOG_UNKNOWN));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * Delay log recovery if the debug hook is set. This is debug\n\t\t * instrumention to coordinate simulation of I/O failures with\n\t\t * log recovery.\n\t\t */\n\t\tif (xfs_globals.log_recovery_delay) {\n\t\t\txfs_notice(log->l_mp,\n\t\t\t\t\"Delaying log recovery for %d seconds.\",\n\t\t\t\txfs_globals.log_recovery_delay);\n\t\t\tmsleep(xfs_globals.log_recovery_delay * 1000);\n\t\t}\n\n\t\txfs_notice(log->l_mp, \"Starting recovery (logdev: %s)\",\n\t\t\t\tlog->l_mp->m_logname ? log->l_mp->m_logname\n\t\t\t\t\t\t     : \"internal\");\n\n\t\terror = xlog_do_recover(log, head_blk, tail_blk);\n\t\tlog->l_flags |= XLOG_RECOVERY_NEEDED;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_do_recover",
          "args": [
            "log",
            "head_blk",
            "tail_blk"
          ],
          "line": 4545
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_do_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "4405-4476",
          "snippet": "STATIC int\nxlog_do_recover(\n\tstruct xlog\t*log,\n\txfs_daddr_t\thead_blk,\n\txfs_daddr_t\ttail_blk)\n{\n\tint\t\terror;\n\txfs_buf_t\t*bp;\n\txfs_sb_t\t*sbp;\n\n\t/*\n\t * First replay the images in the log.\n\t */\n\terror = xlog_do_log_recovery(log, head_blk, tail_blk);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If IO errors happened during recovery, bail out.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(log->l_mp)) {\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * We now update the tail_lsn since much of the recovery has completed\n\t * and there may be space available to use.  If there were no extent\n\t * or iunlinks, we can free up the entire log and set the tail_lsn to\n\t * be the last_sync_lsn.  This was set in xlog_find_tail to be the\n\t * lsn of the last known good LR on disk.  If there are extent frees\n\t * or iunlinks they will have some entries in the AIL; so we look at\n\t * the AIL to determine how to set the tail_lsn.\n\t */\n\txlog_assign_tail_lsn(log->l_mp);\n\n\t/*\n\t * Now that we've finished replaying all buffer and inode\n\t * updates, re-read in the superblock and reverify it.\n\t */\n\tbp = xfs_getsb(log->l_mp, 0);\n\tXFS_BUF_UNDONE(bp);\n\tASSERT(!(XFS_BUF_ISWRITE(bp)));\n\tXFS_BUF_READ(bp);\n\tXFS_BUF_UNASYNC(bp);\n\tbp->b_ops = &xfs_sb_buf_ops;\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\tif (!XFS_FORCED_SHUTDOWN(log->l_mp)) {\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\t\tASSERT(0);\n\t\t}\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t/* Convert superblock from on-disk format */\n\tsbp = &log->l_mp->m_sb;\n\txfs_sb_from_disk(sbp, XFS_BUF_TO_SBP(bp));\n\tASSERT(sbp->sb_magicnum == XFS_SB_MAGIC);\n\tASSERT(xfs_sb_good_version(sbp));\n\txfs_buf_relse(bp);\n\n\t/* We've re-read the superblock so re-initialize per-cpu counters */\n\txfs_icsb_reinit_counters(log->l_mp);\n\n\txlog_recover_check_summary(log);\n\n\t/* Normal transactions can now occur */\n\tlog->l_flags &= ~XLOG_ACTIVE_RECOVERY;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_do_recover(\n\tstruct xlog\t*log,\n\txfs_daddr_t\thead_blk,\n\txfs_daddr_t\ttail_blk)\n{\n\tint\t\terror;\n\txfs_buf_t\t*bp;\n\txfs_sb_t\t*sbp;\n\n\t/*\n\t * First replay the images in the log.\n\t */\n\terror = xlog_do_log_recovery(log, head_blk, tail_blk);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If IO errors happened during recovery, bail out.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(log->l_mp)) {\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * We now update the tail_lsn since much of the recovery has completed\n\t * and there may be space available to use.  If there were no extent\n\t * or iunlinks, we can free up the entire log and set the tail_lsn to\n\t * be the last_sync_lsn.  This was set in xlog_find_tail to be the\n\t * lsn of the last known good LR on disk.  If there are extent frees\n\t * or iunlinks they will have some entries in the AIL; so we look at\n\t * the AIL to determine how to set the tail_lsn.\n\t */\n\txlog_assign_tail_lsn(log->l_mp);\n\n\t/*\n\t * Now that we've finished replaying all buffer and inode\n\t * updates, re-read in the superblock and reverify it.\n\t */\n\tbp = xfs_getsb(log->l_mp, 0);\n\tXFS_BUF_UNDONE(bp);\n\tASSERT(!(XFS_BUF_ISWRITE(bp)));\n\tXFS_BUF_READ(bp);\n\tXFS_BUF_UNASYNC(bp);\n\tbp->b_ops = &xfs_sb_buf_ops;\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\tif (!XFS_FORCED_SHUTDOWN(log->l_mp)) {\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\t\tASSERT(0);\n\t\t}\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t/* Convert superblock from on-disk format */\n\tsbp = &log->l_mp->m_sb;\n\txfs_sb_from_disk(sbp, XFS_BUF_TO_SBP(bp));\n\tASSERT(sbp->sb_magicnum == XFS_SB_MAGIC);\n\tASSERT(xfs_sb_good_version(sbp));\n\txfs_buf_relse(bp);\n\n\t/* We've re-read the superblock so re-initialize per-cpu counters */\n\txfs_icsb_reinit_counters(log->l_mp);\n\n\txlog_recover_check_summary(log);\n\n\t/* Normal transactions can now occur */\n\tlog->l_flags &= ~XLOG_ACTIVE_RECOVERY;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "log->l_mp",
            "\"Starting recovery (logdev: %s)\"",
            "log->l_mp->m_logname ? log->l_mp->m_logname\n\t\t\t\t\t\t     : \"internal\""
          ],
          "line": 4541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "xfs_globals.log_recovery_delay * 1000"
          ],
          "line": 4538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "log->l_mp",
            "\"Delaying log recovery for %d seconds.\"",
            "xfs_globals.log_recovery_delay"
          ],
          "line": 4535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"Superblock has unknown incompatible log features (0x%x) enabled.\\n\"\n\"The log can not be fully and/or safely recovered by this kernel.\\n\"\n\"Please recover the log on a kernel that supports the unknown features.\"",
            "(log->l_mp->m_sb.sb_features_log_incompat &\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_LOG_UNKNOWN)"
          ],
          "line": 4520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_has_incompat_log_feature",
          "args": [
            "&log->l_mp->m_sb",
            "XFS_SB_FEAT_INCOMPAT_LOG_UNKNOWN"
          ],
          "line": 4518
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_has_incompat_log_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "536-542",
          "snippet": "static inline bool\nxfs_sb_has_incompat_log_feature(\n\tstruct xfs_sb\t*sbp,\n\t__uint32_t\tfeature)\n{\n\treturn (sbp->sb_features_log_incompat & feature) != 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\nxfs_sb_has_incompat_log_feature(\n\tstruct xfs_sb\t*sbp,\n\t__uint32_t\tfeature)\n{\n\treturn (sbp->sb_features_log_incompat & feature) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_SB_VERSION_NUM",
          "args": [
            "&log->l_mp->m_sb"
          ],
          "line": 4517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dev_is_read_only",
          "args": [
            "log->l_mp",
            "\"recovery\""
          ],
          "line": 4506
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dev_is_read_only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1396-1409",
          "snippet": "int\nxfs_dev_is_read_only(\n\tstruct xfs_mount\t*mp,\n\tchar\t\t\t*message)\n{\n\tif (xfs_readonly_buftarg(mp->m_ddev_targp) ||\n\t    xfs_readonly_buftarg(mp->m_logdev_targp) ||\n\t    (mp->m_rtdev_targp && xfs_readonly_buftarg(mp->m_rtdev_targp))) {\n\t\txfs_notice(mp, \"%s required on read-only device.\", message);\n\t\txfs_notice(mp, \"write access unavailable, cannot proceed.\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dev_is_read_only(\n\tstruct xfs_mount\t*mp,\n\tchar\t\t\t*message)\n{\n\tif (xfs_readonly_buftarg(mp->m_ddev_targp) ||\n\t    xfs_readonly_buftarg(mp->m_logdev_targp) ||\n\t    (mp->m_rtdev_targp && xfs_readonly_buftarg(mp->m_rtdev_targp))) {\n\t\txfs_notice(mp, \"%s required on read-only device.\", message);\n\t\txfs_notice(mp, \"write access unavailable, cannot proceed.\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_find_tail",
          "args": [
            "log",
            "&head_blk",
            "&tail_blk"
          ],
          "line": 4491
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_find_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "886-1078",
          "snippet": "STATIC int\nxlog_find_tail(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\t*head_blk,\n\txfs_daddr_t\t\t*tail_blk)\n{\n\txlog_rec_header_t\t*rhead;\n\txlog_op_header_t\t*op_head;\n\txfs_caddr_t\t\toffset = NULL;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror, i, found;\n\txfs_daddr_t\t\tumount_data_blk;\n\txfs_daddr_t\t\tafter_umount_blk;\n\txfs_lsn_t\t\ttail_lsn;\n\tint\t\t\thblks;\n\n\tfound = 0;\n\n\t/*\n\t * Find previous log record\n\t */\n\tif ((error = xlog_find_head(log, head_blk)))\n\t\treturn error;\n\n\tbp = xlog_get_bp(log, 1);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\tif (*head_blk == 0) {\t\t\t\t/* special case */\n\t\terror = xlog_bread(log, 0, 1, bp, &offset);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\tif (xlog_get_cycle(offset) == 0) {\n\t\t\t*tail_blk = 0;\n\t\t\t/* leave all other log inited values alone */\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/*\n\t * Search backwards looking for log record header block\n\t */\n\tASSERT(*head_blk < INT_MAX);\n\tfor (i = (int)(*head_blk) - 1; i >= 0; i--) {\n\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\tif (*(__be32 *)offset == cpu_to_be32(XLOG_HEADER_MAGIC_NUM)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * If we haven't found the log record header block, start looking\n\t * again from the end of the physical log.  XXXmiken: There should be\n\t * a check here to make sure we didn't search more than N blocks in\n\t * the previous code.\n\t */\n\tif (!found) {\n\t\tfor (i = log->l_logBBsize - 1; i >= (int)(*head_blk); i--) {\n\t\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\n\t\t\tif (*(__be32 *)offset ==\n\t\t\t    cpu_to_be32(XLOG_HEADER_MAGIC_NUM)) {\n\t\t\t\tfound = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!found) {\n\t\txfs_warn(log->l_mp, \"%s: couldn't find sync record\", __func__);\n\t\txlog_put_bp(bp);\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n\n\t/* find blk_no of tail of log */\n\trhead = (xlog_rec_header_t *)offset;\n\t*tail_blk = BLOCK_LSN(be64_to_cpu(rhead->h_tail_lsn));\n\n\t/*\n\t * Reset log values according to the state of the log when we\n\t * crashed.  In the case where head_blk == 0, we bump curr_cycle\n\t * one because the next write starts a new cycle rather than\n\t * continuing the cycle of the last good log record.  At this\n\t * point we have guaranteed that all partial log records have been\n\t * accounted for.  Therefore, we know that the last good log record\n\t * written was complete and ended exactly on the end boundary\n\t * of the physical log.\n\t */\n\tlog->l_prev_block = i;\n\tlog->l_curr_block = (int)*head_blk;\n\tlog->l_curr_cycle = be32_to_cpu(rhead->h_cycle);\n\tif (found == 2)\n\t\tlog->l_curr_cycle++;\n\tatomic64_set(&log->l_tail_lsn, be64_to_cpu(rhead->h_tail_lsn));\n\tatomic64_set(&log->l_last_sync_lsn, be64_to_cpu(rhead->h_lsn));\n\txlog_assign_grant_head(&log->l_reserve_head.grant, log->l_curr_cycle,\n\t\t\t\t\tBBTOB(log->l_curr_block));\n\txlog_assign_grant_head(&log->l_write_head.grant, log->l_curr_cycle,\n\t\t\t\t\tBBTOB(log->l_curr_block));\n\n\t/*\n\t * Look for unmount record.  If we find it, then we know there\n\t * was a clean unmount.  Since 'i' could be the last block in\n\t * the physical log, we convert to a log block before comparing\n\t * to the head_blk.\n\t *\n\t * Save the current tail lsn to use to pass to\n\t * xlog_clear_stale_blocks() below.  We won't want to clear the\n\t * unmount record if there is one, so we pass the lsn of the\n\t * unmount record rather than the block after it.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tint\th_size = be32_to_cpu(rhead->h_size);\n\t\tint\th_version = be32_to_cpu(rhead->h_version);\n\n\t\tif ((h_version & XLOG_VERSION_2) &&\n\t\t    (h_size > XLOG_HEADER_CYCLE_SIZE)) {\n\t\t\thblks = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\t\thblks++;\n\t\t} else {\n\t\t\thblks = 1;\n\t\t}\n\t} else {\n\t\thblks = 1;\n\t}\n\tafter_umount_blk = (i + hblks + (int)\n\t\tBTOBB(be32_to_cpu(rhead->h_len))) % log->l_logBBsize;\n\ttail_lsn = atomic64_read(&log->l_tail_lsn);\n\tif (*head_blk == after_umount_blk &&\n\t    be32_to_cpu(rhead->h_num_logops) == 1) {\n\t\tumount_data_blk = (i + hblks) % log->l_logBBsize;\n\t\terror = xlog_bread(log, umount_data_blk, 1, bp, &offset);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\top_head = (xlog_op_header_t *)offset;\n\t\tif (op_head->oh_flags & XLOG_UNMOUNT_TRANS) {\n\t\t\t/*\n\t\t\t * Set tail and last sync so that newly written\n\t\t\t * log records will point recovery to after the\n\t\t\t * current unmount record.\n\t\t\t */\n\t\t\txlog_assign_atomic_lsn(&log->l_tail_lsn,\n\t\t\t\t\tlog->l_curr_cycle, after_umount_blk);\n\t\t\txlog_assign_atomic_lsn(&log->l_last_sync_lsn,\n\t\t\t\t\tlog->l_curr_cycle, after_umount_blk);\n\t\t\t*tail_blk = after_umount_blk;\n\n\t\t\t/*\n\t\t\t * Note that the unmount was clean. If the unmount\n\t\t\t * was not clean, we need to know this to rebuild the\n\t\t\t * superblock counters from the perag headers if we\n\t\t\t * have a filesystem using non-persistent counters.\n\t\t\t */\n\t\t\tlog->l_mp->m_flags |= XFS_MOUNT_WAS_CLEAN;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that there are no blocks in front of the head\n\t * with the same cycle number as the head.  This can happen\n\t * because we allow multiple outstanding log writes concurrently,\n\t * and the later writes might make it out before earlier ones.\n\t *\n\t * We use the lsn from before modifying it so that we'll never\n\t * overwrite the unmount record after a clean unmount.\n\t *\n\t * Do this only if we are going to recover the filesystem\n\t *\n\t * NOTE: This used to say \"if (!readonly)\"\n\t * However on Linux, we can & do recover a read-only filesystem.\n\t * We only skip recovery if NORECOVERY is specified on mount,\n\t * in which case we would not be here.\n\t *\n\t * But... if the -device- itself is readonly, just skip this.\n\t * We can't recover this device anyway, so it won't matter.\n\t */\n\tif (!xfs_readonly_buftarg(log->l_mp->m_logdev_targp))\n\t\terror = xlog_clear_stale_blocks(log, tail_lsn);\n\ndone:\n\txlog_put_bp(bp);\n\n\tif (error)\n\t\txfs_warn(log->l_mp, \"failed to locate log tail\");\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_tail(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\t*head_blk,\n\txfs_daddr_t\t\t*tail_blk)\n{\n\txlog_rec_header_t\t*rhead;\n\txlog_op_header_t\t*op_head;\n\txfs_caddr_t\t\toffset = NULL;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror, i, found;\n\txfs_daddr_t\t\tumount_data_blk;\n\txfs_daddr_t\t\tafter_umount_blk;\n\txfs_lsn_t\t\ttail_lsn;\n\tint\t\t\thblks;\n\n\tfound = 0;\n\n\t/*\n\t * Find previous log record\n\t */\n\tif ((error = xlog_find_head(log, head_blk)))\n\t\treturn error;\n\n\tbp = xlog_get_bp(log, 1);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\tif (*head_blk == 0) {\t\t\t\t/* special case */\n\t\terror = xlog_bread(log, 0, 1, bp, &offset);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\tif (xlog_get_cycle(offset) == 0) {\n\t\t\t*tail_blk = 0;\n\t\t\t/* leave all other log inited values alone */\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/*\n\t * Search backwards looking for log record header block\n\t */\n\tASSERT(*head_blk < INT_MAX);\n\tfor (i = (int)(*head_blk) - 1; i >= 0; i--) {\n\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\tif (*(__be32 *)offset == cpu_to_be32(XLOG_HEADER_MAGIC_NUM)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * If we haven't found the log record header block, start looking\n\t * again from the end of the physical log.  XXXmiken: There should be\n\t * a check here to make sure we didn't search more than N blocks in\n\t * the previous code.\n\t */\n\tif (!found) {\n\t\tfor (i = log->l_logBBsize - 1; i >= (int)(*head_blk); i--) {\n\t\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\n\t\t\tif (*(__be32 *)offset ==\n\t\t\t    cpu_to_be32(XLOG_HEADER_MAGIC_NUM)) {\n\t\t\t\tfound = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!found) {\n\t\txfs_warn(log->l_mp, \"%s: couldn't find sync record\", __func__);\n\t\txlog_put_bp(bp);\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n\n\t/* find blk_no of tail of log */\n\trhead = (xlog_rec_header_t *)offset;\n\t*tail_blk = BLOCK_LSN(be64_to_cpu(rhead->h_tail_lsn));\n\n\t/*\n\t * Reset log values according to the state of the log when we\n\t * crashed.  In the case where head_blk == 0, we bump curr_cycle\n\t * one because the next write starts a new cycle rather than\n\t * continuing the cycle of the last good log record.  At this\n\t * point we have guaranteed that all partial log records have been\n\t * accounted for.  Therefore, we know that the last good log record\n\t * written was complete and ended exactly on the end boundary\n\t * of the physical log.\n\t */\n\tlog->l_prev_block = i;\n\tlog->l_curr_block = (int)*head_blk;\n\tlog->l_curr_cycle = be32_to_cpu(rhead->h_cycle);\n\tif (found == 2)\n\t\tlog->l_curr_cycle++;\n\tatomic64_set(&log->l_tail_lsn, be64_to_cpu(rhead->h_tail_lsn));\n\tatomic64_set(&log->l_last_sync_lsn, be64_to_cpu(rhead->h_lsn));\n\txlog_assign_grant_head(&log->l_reserve_head.grant, log->l_curr_cycle,\n\t\t\t\t\tBBTOB(log->l_curr_block));\n\txlog_assign_grant_head(&log->l_write_head.grant, log->l_curr_cycle,\n\t\t\t\t\tBBTOB(log->l_curr_block));\n\n\t/*\n\t * Look for unmount record.  If we find it, then we know there\n\t * was a clean unmount.  Since 'i' could be the last block in\n\t * the physical log, we convert to a log block before comparing\n\t * to the head_blk.\n\t *\n\t * Save the current tail lsn to use to pass to\n\t * xlog_clear_stale_blocks() below.  We won't want to clear the\n\t * unmount record if there is one, so we pass the lsn of the\n\t * unmount record rather than the block after it.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tint\th_size = be32_to_cpu(rhead->h_size);\n\t\tint\th_version = be32_to_cpu(rhead->h_version);\n\n\t\tif ((h_version & XLOG_VERSION_2) &&\n\t\t    (h_size > XLOG_HEADER_CYCLE_SIZE)) {\n\t\t\thblks = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\t\thblks++;\n\t\t} else {\n\t\t\thblks = 1;\n\t\t}\n\t} else {\n\t\thblks = 1;\n\t}\n\tafter_umount_blk = (i + hblks + (int)\n\t\tBTOBB(be32_to_cpu(rhead->h_len))) % log->l_logBBsize;\n\ttail_lsn = atomic64_read(&log->l_tail_lsn);\n\tif (*head_blk == after_umount_blk &&\n\t    be32_to_cpu(rhead->h_num_logops) == 1) {\n\t\tumount_data_blk = (i + hblks) % log->l_logBBsize;\n\t\terror = xlog_bread(log, umount_data_blk, 1, bp, &offset);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\top_head = (xlog_op_header_t *)offset;\n\t\tif (op_head->oh_flags & XLOG_UNMOUNT_TRANS) {\n\t\t\t/*\n\t\t\t * Set tail and last sync so that newly written\n\t\t\t * log records will point recovery to after the\n\t\t\t * current unmount record.\n\t\t\t */\n\t\t\txlog_assign_atomic_lsn(&log->l_tail_lsn,\n\t\t\t\t\tlog->l_curr_cycle, after_umount_blk);\n\t\t\txlog_assign_atomic_lsn(&log->l_last_sync_lsn,\n\t\t\t\t\tlog->l_curr_cycle, after_umount_blk);\n\t\t\t*tail_blk = after_umount_blk;\n\n\t\t\t/*\n\t\t\t * Note that the unmount was clean. If the unmount\n\t\t\t * was not clean, we need to know this to rebuild the\n\t\t\t * superblock counters from the perag headers if we\n\t\t\t * have a filesystem using non-persistent counters.\n\t\t\t */\n\t\t\tlog->l_mp->m_flags |= XFS_MOUNT_WAS_CLEAN;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that there are no blocks in front of the head\n\t * with the same cycle number as the head.  This can happen\n\t * because we allow multiple outstanding log writes concurrently,\n\t * and the later writes might make it out before earlier ones.\n\t *\n\t * We use the lsn from before modifying it so that we'll never\n\t * overwrite the unmount record after a clean unmount.\n\t *\n\t * Do this only if we are going to recover the filesystem\n\t *\n\t * NOTE: This used to say \"if (!readonly)\"\n\t * However on Linux, we can & do recover a read-only filesystem.\n\t * We only skip recovery if NORECOVERY is specified on mount,\n\t * in which case we would not be here.\n\t *\n\t * But... if the -device- itself is readonly, just skip this.\n\t * We can't recover this device anyway, so it won't matter.\n\t */\n\tif (!xfs_readonly_buftarg(log->l_mp->m_logdev_targp))\n\t\terror = xlog_clear_stale_blocks(log, tail_lsn);\n\ndone:\n\txlog_put_bp(bp);\n\n\tif (error)\n\t\txfs_warn(log->l_mp, \"failed to locate log tail\");\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nint\nxlog_recover(\n\tstruct xlog\t*log)\n{\n\txfs_daddr_t\thead_blk, tail_blk;\n\tint\t\terror;\n\n\t/* find the tail of the log */\n\tif ((error = xlog_find_tail(log, &head_blk, &tail_blk)))\n\t\treturn error;\n\n\tif (tail_blk != head_blk) {\n\t\t/* There used to be a comment here:\n\t\t *\n\t\t * disallow recovery on read-only mounts.  note -- mount\n\t\t * checks for ENOSPC and turns it into an intelligent\n\t\t * error message.\n\t\t * ...but this is no longer true.  Now, unless you specify\n\t\t * NORECOVERY (in which case this function would never be\n\t\t * called), we just go ahead and recover.  We do this all\n\t\t * under the vfs layer, so we can get away with it unless\n\t\t * the device itself is read-only, in which case we fail.\n\t\t */\n\t\tif ((error = xfs_dev_is_read_only(log->l_mp, \"recovery\"))) {\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Version 5 superblock log feature mask validation. We know the\n\t\t * log is dirty so check if there are any unknown log features\n\t\t * in what we need to recover. If there are unknown features\n\t\t * (e.g. unsupported transactions, then simply reject the\n\t\t * attempt at recovery before touching anything.\n\t\t */\n\t\tif (XFS_SB_VERSION_NUM(&log->l_mp->m_sb) == XFS_SB_VERSION_5 &&\n\t\t    xfs_sb_has_incompat_log_feature(&log->l_mp->m_sb,\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_LOG_UNKNOWN)) {\n\t\t\txfs_warn(log->l_mp,\n\"Superblock has unknown incompatible log features (0x%x) enabled.\\n\"\n\"The log can not be fully and/or safely recovered by this kernel.\\n\"\n\"Please recover the log on a kernel that supports the unknown features.\",\n\t\t\t\t(log->l_mp->m_sb.sb_features_log_incompat &\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_LOG_UNKNOWN));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * Delay log recovery if the debug hook is set. This is debug\n\t\t * instrumention to coordinate simulation of I/O failures with\n\t\t * log recovery.\n\t\t */\n\t\tif (xfs_globals.log_recovery_delay) {\n\t\t\txfs_notice(log->l_mp,\n\t\t\t\t\"Delaying log recovery for %d seconds.\",\n\t\t\t\txfs_globals.log_recovery_delay);\n\t\t\tmsleep(xfs_globals.log_recovery_delay * 1000);\n\t\t}\n\n\t\txfs_notice(log->l_mp, \"Starting recovery (logdev: %s)\",\n\t\t\t\tlog->l_mp->m_logname ? log->l_mp->m_logname\n\t\t\t\t\t\t     : \"internal\");\n\n\t\terror = xlog_do_recover(log, head_blk, tail_blk);\n\t\tlog->l_flags |= XLOG_RECOVERY_NEEDED;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_do_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "4405-4476",
    "snippet": "STATIC int\nxlog_do_recover(\n\tstruct xlog\t*log,\n\txfs_daddr_t\thead_blk,\n\txfs_daddr_t\ttail_blk)\n{\n\tint\t\terror;\n\txfs_buf_t\t*bp;\n\txfs_sb_t\t*sbp;\n\n\t/*\n\t * First replay the images in the log.\n\t */\n\terror = xlog_do_log_recovery(log, head_blk, tail_blk);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If IO errors happened during recovery, bail out.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(log->l_mp)) {\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * We now update the tail_lsn since much of the recovery has completed\n\t * and there may be space available to use.  If there were no extent\n\t * or iunlinks, we can free up the entire log and set the tail_lsn to\n\t * be the last_sync_lsn.  This was set in xlog_find_tail to be the\n\t * lsn of the last known good LR on disk.  If there are extent frees\n\t * or iunlinks they will have some entries in the AIL; so we look at\n\t * the AIL to determine how to set the tail_lsn.\n\t */\n\txlog_assign_tail_lsn(log->l_mp);\n\n\t/*\n\t * Now that we've finished replaying all buffer and inode\n\t * updates, re-read in the superblock and reverify it.\n\t */\n\tbp = xfs_getsb(log->l_mp, 0);\n\tXFS_BUF_UNDONE(bp);\n\tASSERT(!(XFS_BUF_ISWRITE(bp)));\n\tXFS_BUF_READ(bp);\n\tXFS_BUF_UNASYNC(bp);\n\tbp->b_ops = &xfs_sb_buf_ops;\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\tif (!XFS_FORCED_SHUTDOWN(log->l_mp)) {\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\t\tASSERT(0);\n\t\t}\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t/* Convert superblock from on-disk format */\n\tsbp = &log->l_mp->m_sb;\n\txfs_sb_from_disk(sbp, XFS_BUF_TO_SBP(bp));\n\tASSERT(sbp->sb_magicnum == XFS_SB_MAGIC);\n\tASSERT(xfs_sb_good_version(sbp));\n\txfs_buf_relse(bp);\n\n\t/* We've re-read the superblock so re-initialize per-cpu counters */\n\txfs_icsb_reinit_counters(log->l_mp);\n\n\txlog_recover_check_summary(log);\n\n\t/* Normal transactions can now occur */\n\tlog->l_flags &= ~XLOG_ACTIVE_RECOVERY;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_recover_check_summary",
          "args": [
            "log"
          ],
          "line": 4471
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_check_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "4607-4650",
          "snippet": "void\nxlog_recover_check_summary(\n\tstruct xlog\t*log)\n{\n\txfs_mount_t\t*mp;\n\txfs_agf_t\t*agfp;\n\txfs_buf_t\t*agfbp;\n\txfs_buf_t\t*agibp;\n\txfs_agnumber_t\tagno;\n\t__uint64_t\tfreeblks;\n\t__uint64_t\titotal;\n\t__uint64_t\tifree;\n\tint\t\terror;\n\n\tmp = log->l_mp;\n\n\tfreeblks = 0LL;\n\titotal = 0LL;\n\tifree = 0LL;\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\terror = xfs_read_agf(mp, NULL, agno, 0, &agfbp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agf read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tagfp = XFS_BUF_TO_AGF(agfbp);\n\t\t\tfreeblks += be32_to_cpu(agfp->agf_freeblks) +\n\t\t\t\t    be32_to_cpu(agfp->agf_flcount);\n\t\t\txfs_buf_relse(agfbp);\n\t\t}\n\n\t\terror = xfs_read_agi(mp, NULL, agno, &agibp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agi read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(agibp);\n\n\t\t\titotal += be32_to_cpu(agi->agi_count);\n\t\t\tifree += be32_to_cpu(agi->agi_freecount);\n\t\t\txfs_buf_relse(agibp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxlog_recover_check_summary(\n\tstruct xlog\t*log)\n{\n\txfs_mount_t\t*mp;\n\txfs_agf_t\t*agfp;\n\txfs_buf_t\t*agfbp;\n\txfs_buf_t\t*agibp;\n\txfs_agnumber_t\tagno;\n\t__uint64_t\tfreeblks;\n\t__uint64_t\titotal;\n\t__uint64_t\tifree;\n\tint\t\terror;\n\n\tmp = log->l_mp;\n\n\tfreeblks = 0LL;\n\titotal = 0LL;\n\tifree = 0LL;\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\terror = xfs_read_agf(mp, NULL, agno, 0, &agfbp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agf read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tagfp = XFS_BUF_TO_AGF(agfbp);\n\t\t\tfreeblks += be32_to_cpu(agfp->agf_freeblks) +\n\t\t\t\t    be32_to_cpu(agfp->agf_flcount);\n\t\t\txfs_buf_relse(agfbp);\n\t\t}\n\n\t\terror = xfs_read_agi(mp, NULL, agno, &agibp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agi read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(agibp);\n\n\t\t\titotal += be32_to_cpu(agi->agi_count);\n\t\t\tifree += be32_to_cpu(agi->agi_freecount);\n\t\t\txfs_buf_relse(agibp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_reinit_counters",
          "args": [
            "log->l_mp"
          ],
          "line": 4469
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_reinit_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1562-1576",
          "snippet": "void\nxfs_icsb_reinit_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_lock(mp);\n\t/*\n\t * start with all counters disabled so that the\n\t * initial balance kicks us off correctly\n\t */\n\tmp->m_icsb_counters = -1;\n\txfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);\n\txfs_icsb_unlock(mp);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_reinit_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_lock(mp);\n\t/*\n\t * start with all counters disabled so that the\n\t * initial balance kicks us off correctly\n\t */\n\tmp->m_icsb_counters = -1;\n\txfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);\n\txfs_icsb_unlock(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 4466
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_sb_good_version(sbp)"
          ],
          "line": 4465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_good_version",
          "args": [
            "sbp"
          ],
          "line": 4465
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_good_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "361-368",
          "snippet": "static inline bool xfs_sb_good_version(struct xfs_sb *sbp)\n{\n\tif (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5)\n\t\treturn true;\n\tif (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_4)\n\t\treturn xfs_sb_good_v4_features(sbp);\n\treturn false;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */",
            "#define\tXFS_SB_VERSION_4\t4\t\t/* 6.2+ - bitmask version */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n#define\tXFS_SB_VERSION_4\t4\t\t/* 6.2+ - bitmask version */\n\nstatic inline bool xfs_sb_good_version(struct xfs_sb *sbp)\n{\n\tif (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5)\n\t\treturn true;\n\tif (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_4)\n\t\treturn xfs_sb_good_v4_features(sbp);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "sbp->sb_magicnum == XFS_SB_MAGIC"
          ],
          "line": 4464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_from_disk",
          "args": [
            "sbp",
            "XFS_BUF_TO_SBP(bp)"
          ],
          "line": 4463
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "393-399",
          "snippet": "void\nxfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\txfs_dsb_t\t*from)\n{\n\t__xfs_sb_from_disk(to, from, true);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\txfs_dsb_t\t*from)\n{\n\t__xfs_sb_from_disk(to, from, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_SBP",
          "args": [
            "bp"
          ],
          "line": 4463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 4455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror_alert",
          "args": [
            "bp",
            "__func__"
          ],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "log->l_mp"
          ],
          "line": 4453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_submit_wait",
          "args": [
            "bp"
          ],
          "line": 4451
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_submit_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1362-1420",
          "snippet": "int\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_UNASYNC",
          "args": [
            "bp"
          ],
          "line": 4448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_READ",
          "args": [
            "bp"
          ],
          "line": 4447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(XFS_BUF_ISWRITE(bp))"
          ],
          "line": 4446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ISWRITE",
          "args": [
            "bp"
          ],
          "line": 4446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_UNDONE",
          "args": [
            "bp"
          ],
          "line": 4445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_getsb",
          "args": [
            "log->l_mp",
            "0"
          ],
          "line": 4444
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_getsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1360-1376",
          "snippet": "struct xfs_buf *\nxfs_getsb(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK)\n\t\t\treturn NULL;\n\t\txfs_buf_lock(bp);\n\t}\n\n\txfs_buf_hold(bp);\n\tASSERT(XFS_BUF_ISDONE(bp));\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_buf *\nxfs_getsb(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK)\n\t\t\treturn NULL;\n\t\txfs_buf_lock(bp);\n\t}\n\n\txfs_buf_hold(bp);\n\tASSERT(XFS_BUF_ISDONE(bp));\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_assign_tail_lsn",
          "args": [
            "log->l_mp"
          ],
          "line": 4438
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_tail_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1094-1105",
          "snippet": "xfs_lsn_t\nxlog_assign_tail_lsn(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_lsn_t\t\ttail_lsn;\n\n\tspin_lock(&mp->m_ail->xa_lock);\n\ttail_lsn = xlog_assign_tail_lsn_locked(mp);\n\tspin_unlock(&mp->m_ail->xa_lock);\n\n\treturn tail_lsn;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_lsn_t\nxlog_assign_tail_lsn(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_lsn_t\t\ttail_lsn;\n\n\tspin_lock(&mp->m_ail->xa_lock);\n\ttail_lsn = xlog_assign_tail_lsn_locked(mp);\n\tspin_unlock(&mp->m_ail->xa_lock);\n\n\treturn tail_lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "log->l_mp"
          ],
          "line": 4425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_do_log_recovery",
          "args": [
            "log",
            "head_blk",
            "tail_blk"
          ],
          "line": 4418
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_do_log_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "4354-4400",
          "snippet": "STATIC int\nxlog_do_log_recovery(\n\tstruct xlog\t*log,\n\txfs_daddr_t\thead_blk,\n\txfs_daddr_t\ttail_blk)\n{\n\tint\t\terror, i;\n\n\tASSERT(head_blk != tail_blk);\n\n\t/*\n\t * First do a pass to find all of the cancelled buf log items.\n\t * Store them in the buf_cancel_table for use in the second pass.\n\t */\n\tlog->l_buf_cancel_table = kmem_zalloc(XLOG_BC_TABLE_SIZE *\n\t\t\t\t\t\t sizeof(struct list_head),\n\t\t\t\t\t\t KM_SLEEP);\n\tfor (i = 0; i < XLOG_BC_TABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(&log->l_buf_cancel_table[i]);\n\n\terror = xlog_do_recovery_pass(log, head_blk, tail_blk,\n\t\t\t\t      XLOG_RECOVER_PASS1);\n\tif (error != 0) {\n\t\tkmem_free(log->l_buf_cancel_table);\n\t\tlog->l_buf_cancel_table = NULL;\n\t\treturn error;\n\t}\n\t/*\n\t * Then do a second pass to actually recover the items in the log.\n\t * When it is complete free the table of buf cancel items.\n\t */\n\terror = xlog_do_recovery_pass(log, head_blk, tail_blk,\n\t\t\t\t      XLOG_RECOVER_PASS2);\n#ifdef DEBUG\n\tif (!error) {\n\t\tint\ti;\n\n\t\tfor (i = 0; i < XLOG_BC_TABLE_SIZE; i++)\n\t\t\tASSERT(list_empty(&log->l_buf_cancel_table[i]));\n\t}\n#endif\t/* DEBUG */\n\n\tkmem_free(log->l_buf_cancel_table);\n\tlog->l_buf_cancel_table = NULL;\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_do_log_recovery(\n\tstruct xlog\t*log,\n\txfs_daddr_t\thead_blk,\n\txfs_daddr_t\ttail_blk)\n{\n\tint\t\terror, i;\n\n\tASSERT(head_blk != tail_blk);\n\n\t/*\n\t * First do a pass to find all of the cancelled buf log items.\n\t * Store them in the buf_cancel_table for use in the second pass.\n\t */\n\tlog->l_buf_cancel_table = kmem_zalloc(XLOG_BC_TABLE_SIZE *\n\t\t\t\t\t\t sizeof(struct list_head),\n\t\t\t\t\t\t KM_SLEEP);\n\tfor (i = 0; i < XLOG_BC_TABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(&log->l_buf_cancel_table[i]);\n\n\terror = xlog_do_recovery_pass(log, head_blk, tail_blk,\n\t\t\t\t      XLOG_RECOVER_PASS1);\n\tif (error != 0) {\n\t\tkmem_free(log->l_buf_cancel_table);\n\t\tlog->l_buf_cancel_table = NULL;\n\t\treturn error;\n\t}\n\t/*\n\t * Then do a second pass to actually recover the items in the log.\n\t * When it is complete free the table of buf cancel items.\n\t */\n\terror = xlog_do_recovery_pass(log, head_blk, tail_blk,\n\t\t\t\t      XLOG_RECOVER_PASS2);\n#ifdef DEBUG\n\tif (!error) {\n\t\tint\ti;\n\n\t\tfor (i = 0; i < XLOG_BC_TABLE_SIZE; i++)\n\t\t\tASSERT(list_empty(&log->l_buf_cancel_table[i]));\n\t}\n#endif\t/* DEBUG */\n\n\tkmem_free(log->l_buf_cancel_table);\n\tlog->l_buf_cancel_table = NULL;\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_do_recover(\n\tstruct xlog\t*log,\n\txfs_daddr_t\thead_blk,\n\txfs_daddr_t\ttail_blk)\n{\n\tint\t\terror;\n\txfs_buf_t\t*bp;\n\txfs_sb_t\t*sbp;\n\n\t/*\n\t * First replay the images in the log.\n\t */\n\terror = xlog_do_log_recovery(log, head_blk, tail_blk);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If IO errors happened during recovery, bail out.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(log->l_mp)) {\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * We now update the tail_lsn since much of the recovery has completed\n\t * and there may be space available to use.  If there were no extent\n\t * or iunlinks, we can free up the entire log and set the tail_lsn to\n\t * be the last_sync_lsn.  This was set in xlog_find_tail to be the\n\t * lsn of the last known good LR on disk.  If there are extent frees\n\t * or iunlinks they will have some entries in the AIL; so we look at\n\t * the AIL to determine how to set the tail_lsn.\n\t */\n\txlog_assign_tail_lsn(log->l_mp);\n\n\t/*\n\t * Now that we've finished replaying all buffer and inode\n\t * updates, re-read in the superblock and reverify it.\n\t */\n\tbp = xfs_getsb(log->l_mp, 0);\n\tXFS_BUF_UNDONE(bp);\n\tASSERT(!(XFS_BUF_ISWRITE(bp)));\n\tXFS_BUF_READ(bp);\n\tXFS_BUF_UNASYNC(bp);\n\tbp->b_ops = &xfs_sb_buf_ops;\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\tif (!XFS_FORCED_SHUTDOWN(log->l_mp)) {\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\t\tASSERT(0);\n\t\t}\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t/* Convert superblock from on-disk format */\n\tsbp = &log->l_mp->m_sb;\n\txfs_sb_from_disk(sbp, XFS_BUF_TO_SBP(bp));\n\tASSERT(sbp->sb_magicnum == XFS_SB_MAGIC);\n\tASSERT(xfs_sb_good_version(sbp));\n\txfs_buf_relse(bp);\n\n\t/* We've re-read the superblock so re-initialize per-cpu counters */\n\txfs_icsb_reinit_counters(log->l_mp);\n\n\txlog_recover_check_summary(log);\n\n\t/* Normal transactions can now occur */\n\tlog->l_flags &= ~XLOG_ACTIVE_RECOVERY;\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_do_log_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "4354-4400",
    "snippet": "STATIC int\nxlog_do_log_recovery(\n\tstruct xlog\t*log,\n\txfs_daddr_t\thead_blk,\n\txfs_daddr_t\ttail_blk)\n{\n\tint\t\terror, i;\n\n\tASSERT(head_blk != tail_blk);\n\n\t/*\n\t * First do a pass to find all of the cancelled buf log items.\n\t * Store them in the buf_cancel_table for use in the second pass.\n\t */\n\tlog->l_buf_cancel_table = kmem_zalloc(XLOG_BC_TABLE_SIZE *\n\t\t\t\t\t\t sizeof(struct list_head),\n\t\t\t\t\t\t KM_SLEEP);\n\tfor (i = 0; i < XLOG_BC_TABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(&log->l_buf_cancel_table[i]);\n\n\terror = xlog_do_recovery_pass(log, head_blk, tail_blk,\n\t\t\t\t      XLOG_RECOVER_PASS1);\n\tif (error != 0) {\n\t\tkmem_free(log->l_buf_cancel_table);\n\t\tlog->l_buf_cancel_table = NULL;\n\t\treturn error;\n\t}\n\t/*\n\t * Then do a second pass to actually recover the items in the log.\n\t * When it is complete free the table of buf cancel items.\n\t */\n\terror = xlog_do_recovery_pass(log, head_blk, tail_blk,\n\t\t\t\t      XLOG_RECOVER_PASS2);\n#ifdef DEBUG\n\tif (!error) {\n\t\tint\ti;\n\n\t\tfor (i = 0; i < XLOG_BC_TABLE_SIZE; i++)\n\t\t\tASSERT(list_empty(&log->l_buf_cancel_table[i]));\n\t}\n#endif\t/* DEBUG */\n\n\tkmem_free(log->l_buf_cancel_table);\n\tlog->l_buf_cancel_table = NULL;\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "log->l_buf_cancel_table"
          ],
          "line": 4396
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&log->l_buf_cancel_table[i])"
          ],
          "line": 4392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&log->l_buf_cancel_table[i]"
          ],
          "line": 4392
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_do_recovery_pass",
          "args": [
            "log",
            "head_blk",
            "tail_blk",
            "XLOG_RECOVER_PASS2"
          ],
          "line": 4385
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_do_recovery_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "4116-4339",
          "snippet": "STATIC int\nxlog_do_recovery_pass(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\thead_blk,\n\txfs_daddr_t\t\ttail_blk,\n\tint\t\t\tpass)\n{\n\txlog_rec_header_t\t*rhead;\n\txfs_daddr_t\t\tblk_no;\n\txfs_caddr_t\t\toffset;\n\txfs_buf_t\t\t*hbp, *dbp;\n\tint\t\t\terror = 0, h_size;\n\tint\t\t\tbblks, split_bblks;\n\tint\t\t\thblks, split_hblks, wrapped_hblks;\n\tstruct hlist_head\trhash[XLOG_RHASH_SIZE];\n\n\tASSERT(head_blk != tail_blk);\n\n\t/*\n\t * Read the header of the tail block and get the iclog buffer size from\n\t * h_size.  Use this to tell how many sectors make up the log header.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\t/*\n\t\t * When using variable length iclogs, read first sector of\n\t\t * iclog header and extract the header size from it.  Get a\n\t\t * new hbp that is the correct size.\n\t\t */\n\t\thbp = xlog_get_bp(log, 1);\n\t\tif (!hbp)\n\t\t\treturn -ENOMEM;\n\n\t\terror = xlog_bread(log, tail_blk, 1, hbp, &offset);\n\t\tif (error)\n\t\t\tgoto bread_err1;\n\n\t\trhead = (xlog_rec_header_t *)offset;\n\t\terror = xlog_valid_rec_header(log, rhead, tail_blk);\n\t\tif (error)\n\t\t\tgoto bread_err1;\n\t\th_size = be32_to_cpu(rhead->h_size);\n\t\tif ((be32_to_cpu(rhead->h_version) & XLOG_VERSION_2) &&\n\t\t    (h_size > XLOG_HEADER_CYCLE_SIZE)) {\n\t\t\thblks = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\t\thblks++;\n\t\t\txlog_put_bp(hbp);\n\t\t\thbp = xlog_get_bp(log, hblks);\n\t\t} else {\n\t\t\thblks = 1;\n\t\t}\n\t} else {\n\t\tASSERT(log->l_sectBBsize == 1);\n\t\thblks = 1;\n\t\thbp = xlog_get_bp(log, 1);\n\t\th_size = XLOG_BIG_RECORD_BSIZE;\n\t}\n\n\tif (!hbp)\n\t\treturn -ENOMEM;\n\tdbp = xlog_get_bp(log, BTOBB(h_size));\n\tif (!dbp) {\n\t\txlog_put_bp(hbp);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(rhash, 0, sizeof(rhash));\n\tblk_no = tail_blk;\n\tif (tail_blk > head_blk) {\n\t\t/*\n\t\t * Perform recovery around the end of the physical log.\n\t\t * When the head is not on the same cycle number as the tail,\n\t\t * we can't do a sequential recovery.\n\t\t */\n\t\twhile (blk_no < log->l_logBBsize) {\n\t\t\t/*\n\t\t\t * Check for header wrapping around physical end-of-log\n\t\t\t */\n\t\t\toffset = hbp->b_addr;\n\t\t\tsplit_hblks = 0;\n\t\t\twrapped_hblks = 0;\n\t\t\tif (blk_no + hblks <= log->l_logBBsize) {\n\t\t\t\t/* Read header in one read */\n\t\t\t\terror = xlog_bread(log, blk_no, hblks, hbp,\n\t\t\t\t\t\t   &offset);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t} else {\n\t\t\t\t/* This LR is split across physical log end */\n\t\t\t\tif (blk_no != log->l_logBBsize) {\n\t\t\t\t\t/* some data before physical log end */\n\t\t\t\t\tASSERT(blk_no <= INT_MAX);\n\t\t\t\t\tsplit_hblks = log->l_logBBsize - (int)blk_no;\n\t\t\t\t\tASSERT(split_hblks > 0);\n\t\t\t\t\terror = xlog_bread(log, blk_no,\n\t\t\t\t\t\t\t   split_hblks, hbp,\n\t\t\t\t\t\t\t   &offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\tgoto bread_err2;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note: this black magic still works with\n\t\t\t\t * large sector sizes (non-512) only because:\n\t\t\t\t * - we increased the buffer size originally\n\t\t\t\t *   by 1 sector giving us enough extra space\n\t\t\t\t *   for the second read;\n\t\t\t\t * - the log start is guaranteed to be sector\n\t\t\t\t *   aligned;\n\t\t\t\t * - we read the log end (LR header start)\n\t\t\t\t *   _first_, then the log start (LR header end)\n\t\t\t\t *   - order is important.\n\t\t\t\t */\n\t\t\t\twrapped_hblks = hblks - split_hblks;\n\t\t\t\terror = xlog_bread_offset(log, 0,\n\t\t\t\t\t\twrapped_hblks, hbp,\n\t\t\t\t\t\toffset + BBTOB(split_hblks));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t}\n\t\t\trhead = (xlog_rec_header_t *)offset;\n\t\t\terror = xlog_valid_rec_header(log, rhead,\n\t\t\t\t\t\tsplit_hblks ? blk_no : 0);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\n\t\t\tbblks = (int)BTOBB(be32_to_cpu(rhead->h_len));\n\t\t\tblk_no += hblks;\n\n\t\t\t/* Read in data for log record */\n\t\t\tif (blk_no + bblks <= log->l_logBBsize) {\n\t\t\t\terror = xlog_bread(log, blk_no, bblks, dbp,\n\t\t\t\t\t\t   &offset);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t} else {\n\t\t\t\t/* This log record is split across the\n\t\t\t\t * physical end of log */\n\t\t\t\toffset = dbp->b_addr;\n\t\t\t\tsplit_bblks = 0;\n\t\t\t\tif (blk_no != log->l_logBBsize) {\n\t\t\t\t\t/* some data is before the physical\n\t\t\t\t\t * end of log */\n\t\t\t\t\tASSERT(!wrapped_hblks);\n\t\t\t\t\tASSERT(blk_no <= INT_MAX);\n\t\t\t\t\tsplit_bblks =\n\t\t\t\t\t\tlog->l_logBBsize - (int)blk_no;\n\t\t\t\t\tASSERT(split_bblks > 0);\n\t\t\t\t\terror = xlog_bread(log, blk_no,\n\t\t\t\t\t\t\tsplit_bblks, dbp,\n\t\t\t\t\t\t\t&offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\tgoto bread_err2;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note: this black magic still works with\n\t\t\t\t * large sector sizes (non-512) only because:\n\t\t\t\t * - we increased the buffer size originally\n\t\t\t\t *   by 1 sector giving us enough extra space\n\t\t\t\t *   for the second read;\n\t\t\t\t * - the log start is guaranteed to be sector\n\t\t\t\t *   aligned;\n\t\t\t\t * - we read the log end (LR header start)\n\t\t\t\t *   _first_, then the log start (LR header end)\n\t\t\t\t *   - order is important.\n\t\t\t\t */\n\t\t\t\terror = xlog_bread_offset(log, 0,\n\t\t\t\t\t\tbblks - split_bblks, dbp,\n\t\t\t\t\t\toffset + BBTOB(split_bblks));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t}\n\n\t\t\terror = xlog_unpack_data(rhead, offset, log);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\n\t\t\terror = xlog_recover_process_data(log, rhash,\n\t\t\t\t\t\t\trhead, offset, pass);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\t\t\tblk_no += bblks;\n\t\t}\n\n\t\tASSERT(blk_no >= log->l_logBBsize);\n\t\tblk_no -= log->l_logBBsize;\n\t}\n\n\t/* read first part of physical log */\n\twhile (blk_no < head_blk) {\n\t\terror = xlog_bread(log, blk_no, hblks, hbp, &offset);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\trhead = (xlog_rec_header_t *)offset;\n\t\terror = xlog_valid_rec_header(log, rhead, blk_no);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\t/* blocks in data section */\n\t\tbblks = (int)BTOBB(be32_to_cpu(rhead->h_len));\n\t\terror = xlog_bread(log, blk_no+hblks, bblks, dbp,\n\t\t\t\t   &offset);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\terror = xlog_unpack_data(rhead, offset, log);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\terror = xlog_recover_process_data(log, rhash,\n\t\t\t\t\t\trhead, offset, pass);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\t\tblk_no += bblks + hblks;\n\t}\n\n bread_err2:\n\txlog_put_bp(dbp);\n bread_err1:\n\txlog_put_bp(hbp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_do_recovery_pass(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\thead_blk,\n\txfs_daddr_t\t\ttail_blk,\n\tint\t\t\tpass)\n{\n\txlog_rec_header_t\t*rhead;\n\txfs_daddr_t\t\tblk_no;\n\txfs_caddr_t\t\toffset;\n\txfs_buf_t\t\t*hbp, *dbp;\n\tint\t\t\terror = 0, h_size;\n\tint\t\t\tbblks, split_bblks;\n\tint\t\t\thblks, split_hblks, wrapped_hblks;\n\tstruct hlist_head\trhash[XLOG_RHASH_SIZE];\n\n\tASSERT(head_blk != tail_blk);\n\n\t/*\n\t * Read the header of the tail block and get the iclog buffer size from\n\t * h_size.  Use this to tell how many sectors make up the log header.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\t/*\n\t\t * When using variable length iclogs, read first sector of\n\t\t * iclog header and extract the header size from it.  Get a\n\t\t * new hbp that is the correct size.\n\t\t */\n\t\thbp = xlog_get_bp(log, 1);\n\t\tif (!hbp)\n\t\t\treturn -ENOMEM;\n\n\t\terror = xlog_bread(log, tail_blk, 1, hbp, &offset);\n\t\tif (error)\n\t\t\tgoto bread_err1;\n\n\t\trhead = (xlog_rec_header_t *)offset;\n\t\terror = xlog_valid_rec_header(log, rhead, tail_blk);\n\t\tif (error)\n\t\t\tgoto bread_err1;\n\t\th_size = be32_to_cpu(rhead->h_size);\n\t\tif ((be32_to_cpu(rhead->h_version) & XLOG_VERSION_2) &&\n\t\t    (h_size > XLOG_HEADER_CYCLE_SIZE)) {\n\t\t\thblks = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\t\thblks++;\n\t\t\txlog_put_bp(hbp);\n\t\t\thbp = xlog_get_bp(log, hblks);\n\t\t} else {\n\t\t\thblks = 1;\n\t\t}\n\t} else {\n\t\tASSERT(log->l_sectBBsize == 1);\n\t\thblks = 1;\n\t\thbp = xlog_get_bp(log, 1);\n\t\th_size = XLOG_BIG_RECORD_BSIZE;\n\t}\n\n\tif (!hbp)\n\t\treturn -ENOMEM;\n\tdbp = xlog_get_bp(log, BTOBB(h_size));\n\tif (!dbp) {\n\t\txlog_put_bp(hbp);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(rhash, 0, sizeof(rhash));\n\tblk_no = tail_blk;\n\tif (tail_blk > head_blk) {\n\t\t/*\n\t\t * Perform recovery around the end of the physical log.\n\t\t * When the head is not on the same cycle number as the tail,\n\t\t * we can't do a sequential recovery.\n\t\t */\n\t\twhile (blk_no < log->l_logBBsize) {\n\t\t\t/*\n\t\t\t * Check for header wrapping around physical end-of-log\n\t\t\t */\n\t\t\toffset = hbp->b_addr;\n\t\t\tsplit_hblks = 0;\n\t\t\twrapped_hblks = 0;\n\t\t\tif (blk_no + hblks <= log->l_logBBsize) {\n\t\t\t\t/* Read header in one read */\n\t\t\t\terror = xlog_bread(log, blk_no, hblks, hbp,\n\t\t\t\t\t\t   &offset);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t} else {\n\t\t\t\t/* This LR is split across physical log end */\n\t\t\t\tif (blk_no != log->l_logBBsize) {\n\t\t\t\t\t/* some data before physical log end */\n\t\t\t\t\tASSERT(blk_no <= INT_MAX);\n\t\t\t\t\tsplit_hblks = log->l_logBBsize - (int)blk_no;\n\t\t\t\t\tASSERT(split_hblks > 0);\n\t\t\t\t\terror = xlog_bread(log, blk_no,\n\t\t\t\t\t\t\t   split_hblks, hbp,\n\t\t\t\t\t\t\t   &offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\tgoto bread_err2;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note: this black magic still works with\n\t\t\t\t * large sector sizes (non-512) only because:\n\t\t\t\t * - we increased the buffer size originally\n\t\t\t\t *   by 1 sector giving us enough extra space\n\t\t\t\t *   for the second read;\n\t\t\t\t * - the log start is guaranteed to be sector\n\t\t\t\t *   aligned;\n\t\t\t\t * - we read the log end (LR header start)\n\t\t\t\t *   _first_, then the log start (LR header end)\n\t\t\t\t *   - order is important.\n\t\t\t\t */\n\t\t\t\twrapped_hblks = hblks - split_hblks;\n\t\t\t\terror = xlog_bread_offset(log, 0,\n\t\t\t\t\t\twrapped_hblks, hbp,\n\t\t\t\t\t\toffset + BBTOB(split_hblks));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t}\n\t\t\trhead = (xlog_rec_header_t *)offset;\n\t\t\terror = xlog_valid_rec_header(log, rhead,\n\t\t\t\t\t\tsplit_hblks ? blk_no : 0);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\n\t\t\tbblks = (int)BTOBB(be32_to_cpu(rhead->h_len));\n\t\t\tblk_no += hblks;\n\n\t\t\t/* Read in data for log record */\n\t\t\tif (blk_no + bblks <= log->l_logBBsize) {\n\t\t\t\terror = xlog_bread(log, blk_no, bblks, dbp,\n\t\t\t\t\t\t   &offset);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t} else {\n\t\t\t\t/* This log record is split across the\n\t\t\t\t * physical end of log */\n\t\t\t\toffset = dbp->b_addr;\n\t\t\t\tsplit_bblks = 0;\n\t\t\t\tif (blk_no != log->l_logBBsize) {\n\t\t\t\t\t/* some data is before the physical\n\t\t\t\t\t * end of log */\n\t\t\t\t\tASSERT(!wrapped_hblks);\n\t\t\t\t\tASSERT(blk_no <= INT_MAX);\n\t\t\t\t\tsplit_bblks =\n\t\t\t\t\t\tlog->l_logBBsize - (int)blk_no;\n\t\t\t\t\tASSERT(split_bblks > 0);\n\t\t\t\t\terror = xlog_bread(log, blk_no,\n\t\t\t\t\t\t\tsplit_bblks, dbp,\n\t\t\t\t\t\t\t&offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\tgoto bread_err2;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note: this black magic still works with\n\t\t\t\t * large sector sizes (non-512) only because:\n\t\t\t\t * - we increased the buffer size originally\n\t\t\t\t *   by 1 sector giving us enough extra space\n\t\t\t\t *   for the second read;\n\t\t\t\t * - the log start is guaranteed to be sector\n\t\t\t\t *   aligned;\n\t\t\t\t * - we read the log end (LR header start)\n\t\t\t\t *   _first_, then the log start (LR header end)\n\t\t\t\t *   - order is important.\n\t\t\t\t */\n\t\t\t\terror = xlog_bread_offset(log, 0,\n\t\t\t\t\t\tbblks - split_bblks, dbp,\n\t\t\t\t\t\toffset + BBTOB(split_bblks));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t}\n\n\t\t\terror = xlog_unpack_data(rhead, offset, log);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\n\t\t\terror = xlog_recover_process_data(log, rhash,\n\t\t\t\t\t\t\trhead, offset, pass);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\t\t\tblk_no += bblks;\n\t\t}\n\n\t\tASSERT(blk_no >= log->l_logBBsize);\n\t\tblk_no -= log->l_logBBsize;\n\t}\n\n\t/* read first part of physical log */\n\twhile (blk_no < head_blk) {\n\t\terror = xlog_bread(log, blk_no, hblks, hbp, &offset);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\trhead = (xlog_rec_header_t *)offset;\n\t\terror = xlog_valid_rec_header(log, rhead, blk_no);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\t/* blocks in data section */\n\t\tbblks = (int)BTOBB(be32_to_cpu(rhead->h_len));\n\t\terror = xlog_bread(log, blk_no+hblks, bblks, dbp,\n\t\t\t\t   &offset);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\terror = xlog_unpack_data(rhead, offset, log);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\terror = xlog_recover_process_data(log, rhash,\n\t\t\t\t\t\trhead, offset, pass);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\t\tblk_no += bblks + hblks;\n\t}\n\n bread_err2:\n\txlog_put_bp(dbp);\n bread_err1:\n\txlog_put_bp(hbp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&log->l_buf_cancel_table[i]"
          ],
          "line": 4372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "XLOG_BC_TABLE_SIZE *\n\t\t\t\t\t\t sizeof(struct list_head)",
            "KM_SLEEP"
          ],
          "line": 4368
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "head_blk != tail_blk"
          ],
          "line": 4362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_do_log_recovery(\n\tstruct xlog\t*log,\n\txfs_daddr_t\thead_blk,\n\txfs_daddr_t\ttail_blk)\n{\n\tint\t\terror, i;\n\n\tASSERT(head_blk != tail_blk);\n\n\t/*\n\t * First do a pass to find all of the cancelled buf log items.\n\t * Store them in the buf_cancel_table for use in the second pass.\n\t */\n\tlog->l_buf_cancel_table = kmem_zalloc(XLOG_BC_TABLE_SIZE *\n\t\t\t\t\t\t sizeof(struct list_head),\n\t\t\t\t\t\t KM_SLEEP);\n\tfor (i = 0; i < XLOG_BC_TABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(&log->l_buf_cancel_table[i]);\n\n\terror = xlog_do_recovery_pass(log, head_blk, tail_blk,\n\t\t\t\t      XLOG_RECOVER_PASS1);\n\tif (error != 0) {\n\t\tkmem_free(log->l_buf_cancel_table);\n\t\tlog->l_buf_cancel_table = NULL;\n\t\treturn error;\n\t}\n\t/*\n\t * Then do a second pass to actually recover the items in the log.\n\t * When it is complete free the table of buf cancel items.\n\t */\n\terror = xlog_do_recovery_pass(log, head_blk, tail_blk,\n\t\t\t\t      XLOG_RECOVER_PASS2);\n#ifdef DEBUG\n\tif (!error) {\n\t\tint\ti;\n\n\t\tfor (i = 0; i < XLOG_BC_TABLE_SIZE; i++)\n\t\t\tASSERT(list_empty(&log->l_buf_cancel_table[i]));\n\t}\n#endif\t/* DEBUG */\n\n\tkmem_free(log->l_buf_cancel_table);\n\tlog->l_buf_cancel_table = NULL;\n\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_do_recovery_pass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "4116-4339",
    "snippet": "STATIC int\nxlog_do_recovery_pass(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\thead_blk,\n\txfs_daddr_t\t\ttail_blk,\n\tint\t\t\tpass)\n{\n\txlog_rec_header_t\t*rhead;\n\txfs_daddr_t\t\tblk_no;\n\txfs_caddr_t\t\toffset;\n\txfs_buf_t\t\t*hbp, *dbp;\n\tint\t\t\terror = 0, h_size;\n\tint\t\t\tbblks, split_bblks;\n\tint\t\t\thblks, split_hblks, wrapped_hblks;\n\tstruct hlist_head\trhash[XLOG_RHASH_SIZE];\n\n\tASSERT(head_blk != tail_blk);\n\n\t/*\n\t * Read the header of the tail block and get the iclog buffer size from\n\t * h_size.  Use this to tell how many sectors make up the log header.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\t/*\n\t\t * When using variable length iclogs, read first sector of\n\t\t * iclog header and extract the header size from it.  Get a\n\t\t * new hbp that is the correct size.\n\t\t */\n\t\thbp = xlog_get_bp(log, 1);\n\t\tif (!hbp)\n\t\t\treturn -ENOMEM;\n\n\t\terror = xlog_bread(log, tail_blk, 1, hbp, &offset);\n\t\tif (error)\n\t\t\tgoto bread_err1;\n\n\t\trhead = (xlog_rec_header_t *)offset;\n\t\terror = xlog_valid_rec_header(log, rhead, tail_blk);\n\t\tif (error)\n\t\t\tgoto bread_err1;\n\t\th_size = be32_to_cpu(rhead->h_size);\n\t\tif ((be32_to_cpu(rhead->h_version) & XLOG_VERSION_2) &&\n\t\t    (h_size > XLOG_HEADER_CYCLE_SIZE)) {\n\t\t\thblks = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\t\thblks++;\n\t\t\txlog_put_bp(hbp);\n\t\t\thbp = xlog_get_bp(log, hblks);\n\t\t} else {\n\t\t\thblks = 1;\n\t\t}\n\t} else {\n\t\tASSERT(log->l_sectBBsize == 1);\n\t\thblks = 1;\n\t\thbp = xlog_get_bp(log, 1);\n\t\th_size = XLOG_BIG_RECORD_BSIZE;\n\t}\n\n\tif (!hbp)\n\t\treturn -ENOMEM;\n\tdbp = xlog_get_bp(log, BTOBB(h_size));\n\tif (!dbp) {\n\t\txlog_put_bp(hbp);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(rhash, 0, sizeof(rhash));\n\tblk_no = tail_blk;\n\tif (tail_blk > head_blk) {\n\t\t/*\n\t\t * Perform recovery around the end of the physical log.\n\t\t * When the head is not on the same cycle number as the tail,\n\t\t * we can't do a sequential recovery.\n\t\t */\n\t\twhile (blk_no < log->l_logBBsize) {\n\t\t\t/*\n\t\t\t * Check for header wrapping around physical end-of-log\n\t\t\t */\n\t\t\toffset = hbp->b_addr;\n\t\t\tsplit_hblks = 0;\n\t\t\twrapped_hblks = 0;\n\t\t\tif (blk_no + hblks <= log->l_logBBsize) {\n\t\t\t\t/* Read header in one read */\n\t\t\t\terror = xlog_bread(log, blk_no, hblks, hbp,\n\t\t\t\t\t\t   &offset);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t} else {\n\t\t\t\t/* This LR is split across physical log end */\n\t\t\t\tif (blk_no != log->l_logBBsize) {\n\t\t\t\t\t/* some data before physical log end */\n\t\t\t\t\tASSERT(blk_no <= INT_MAX);\n\t\t\t\t\tsplit_hblks = log->l_logBBsize - (int)blk_no;\n\t\t\t\t\tASSERT(split_hblks > 0);\n\t\t\t\t\terror = xlog_bread(log, blk_no,\n\t\t\t\t\t\t\t   split_hblks, hbp,\n\t\t\t\t\t\t\t   &offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\tgoto bread_err2;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note: this black magic still works with\n\t\t\t\t * large sector sizes (non-512) only because:\n\t\t\t\t * - we increased the buffer size originally\n\t\t\t\t *   by 1 sector giving us enough extra space\n\t\t\t\t *   for the second read;\n\t\t\t\t * - the log start is guaranteed to be sector\n\t\t\t\t *   aligned;\n\t\t\t\t * - we read the log end (LR header start)\n\t\t\t\t *   _first_, then the log start (LR header end)\n\t\t\t\t *   - order is important.\n\t\t\t\t */\n\t\t\t\twrapped_hblks = hblks - split_hblks;\n\t\t\t\terror = xlog_bread_offset(log, 0,\n\t\t\t\t\t\twrapped_hblks, hbp,\n\t\t\t\t\t\toffset + BBTOB(split_hblks));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t}\n\t\t\trhead = (xlog_rec_header_t *)offset;\n\t\t\terror = xlog_valid_rec_header(log, rhead,\n\t\t\t\t\t\tsplit_hblks ? blk_no : 0);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\n\t\t\tbblks = (int)BTOBB(be32_to_cpu(rhead->h_len));\n\t\t\tblk_no += hblks;\n\n\t\t\t/* Read in data for log record */\n\t\t\tif (blk_no + bblks <= log->l_logBBsize) {\n\t\t\t\terror = xlog_bread(log, blk_no, bblks, dbp,\n\t\t\t\t\t\t   &offset);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t} else {\n\t\t\t\t/* This log record is split across the\n\t\t\t\t * physical end of log */\n\t\t\t\toffset = dbp->b_addr;\n\t\t\t\tsplit_bblks = 0;\n\t\t\t\tif (blk_no != log->l_logBBsize) {\n\t\t\t\t\t/* some data is before the physical\n\t\t\t\t\t * end of log */\n\t\t\t\t\tASSERT(!wrapped_hblks);\n\t\t\t\t\tASSERT(blk_no <= INT_MAX);\n\t\t\t\t\tsplit_bblks =\n\t\t\t\t\t\tlog->l_logBBsize - (int)blk_no;\n\t\t\t\t\tASSERT(split_bblks > 0);\n\t\t\t\t\terror = xlog_bread(log, blk_no,\n\t\t\t\t\t\t\tsplit_bblks, dbp,\n\t\t\t\t\t\t\t&offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\tgoto bread_err2;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note: this black magic still works with\n\t\t\t\t * large sector sizes (non-512) only because:\n\t\t\t\t * - we increased the buffer size originally\n\t\t\t\t *   by 1 sector giving us enough extra space\n\t\t\t\t *   for the second read;\n\t\t\t\t * - the log start is guaranteed to be sector\n\t\t\t\t *   aligned;\n\t\t\t\t * - we read the log end (LR header start)\n\t\t\t\t *   _first_, then the log start (LR header end)\n\t\t\t\t *   - order is important.\n\t\t\t\t */\n\t\t\t\terror = xlog_bread_offset(log, 0,\n\t\t\t\t\t\tbblks - split_bblks, dbp,\n\t\t\t\t\t\toffset + BBTOB(split_bblks));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t}\n\n\t\t\terror = xlog_unpack_data(rhead, offset, log);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\n\t\t\terror = xlog_recover_process_data(log, rhash,\n\t\t\t\t\t\t\trhead, offset, pass);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\t\t\tblk_no += bblks;\n\t\t}\n\n\t\tASSERT(blk_no >= log->l_logBBsize);\n\t\tblk_no -= log->l_logBBsize;\n\t}\n\n\t/* read first part of physical log */\n\twhile (blk_no < head_blk) {\n\t\terror = xlog_bread(log, blk_no, hblks, hbp, &offset);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\trhead = (xlog_rec_header_t *)offset;\n\t\terror = xlog_valid_rec_header(log, rhead, blk_no);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\t/* blocks in data section */\n\t\tbblks = (int)BTOBB(be32_to_cpu(rhead->h_len));\n\t\terror = xlog_bread(log, blk_no+hblks, bblks, dbp,\n\t\t\t\t   &offset);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\terror = xlog_unpack_data(rhead, offset, log);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\terror = xlog_recover_process_data(log, rhash,\n\t\t\t\t\t\trhead, offset, pass);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\t\tblk_no += bblks + hblks;\n\t}\n\n bread_err2:\n\txlog_put_bp(dbp);\n bread_err1:\n\txlog_put_bp(hbp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_put_bp",
          "args": [
            "hbp"
          ],
          "line": 4337
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_put_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "139-144",
          "snippet": "STATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_process_data",
          "args": [
            "log",
            "rhash",
            "rhead",
            "offset",
            "pass"
          ],
          "line": 4327
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_process_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3659-3695",
          "snippet": "STATIC int\nxlog_recover_process_data(\n\tstruct xlog\t\t*log,\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\txfs_caddr_t\t\tdp,\n\tint\t\t\tpass)\n{\n\tstruct xlog_op_header\t*ohead;\n\txfs_caddr_t\t\tend;\n\tint\t\t\tnum_logops;\n\tint\t\t\terror;\n\n\tend = dp + be32_to_cpu(rhead->h_len);\n\tnum_logops = be32_to_cpu(rhead->h_num_logops);\n\n\t/* check the log format matches our own - else we can't recover */\n\tif (xlog_header_check_recover(log->l_mp, rhead))\n\t\treturn -EIO;\n\n\twhile ((dp < end) && num_logops) {\n\n\t\tohead = (struct xlog_op_header *)dp;\n\t\tdp += sizeof(*ohead);\n\t\tASSERT(dp <= end);\n\n\t\t/* errors will abort recovery */\n\t\terror = xlog_recover_process_ophdr(log, rhash, rhead, ohead,\n\t\t\t\t\t\t    dp, end, pass);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdp += be32_to_cpu(ohead->oh_len);\n\t\tnum_logops--;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_process_data(\n\tstruct xlog\t\t*log,\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\txfs_caddr_t\t\tdp,\n\tint\t\t\tpass)\n{\n\tstruct xlog_op_header\t*ohead;\n\txfs_caddr_t\t\tend;\n\tint\t\t\tnum_logops;\n\tint\t\t\terror;\n\n\tend = dp + be32_to_cpu(rhead->h_len);\n\tnum_logops = be32_to_cpu(rhead->h_num_logops);\n\n\t/* check the log format matches our own - else we can't recover */\n\tif (xlog_header_check_recover(log->l_mp, rhead))\n\t\treturn -EIO;\n\n\twhile ((dp < end) && num_logops) {\n\n\t\tohead = (struct xlog_op_header *)dp;\n\t\tdp += sizeof(*ohead);\n\t\tASSERT(dp <= end);\n\n\t\t/* errors will abort recovery */\n\t\terror = xlog_recover_process_ophdr(log, rhash, rhead, ohead,\n\t\t\t\t\t\t    dp, end, pass);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdp += be32_to_cpu(ohead->oh_len);\n\t\tnum_logops--;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_unpack_data",
          "args": [
            "rhead",
            "offset",
            "log"
          ],
          "line": 4323
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_unpack_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "4040-4070",
          "snippet": "STATIC int\nxlog_unpack_data(\n\tstruct xlog_rec_header\t*rhead,\n\txfs_caddr_t\t\tdp,\n\tstruct xlog\t\t*log)\n{\n\tint\t\t\ti, j, k;\n\tint\t\t\terror;\n\n\terror = xlog_unpack_data_crc(rhead, dp, log);\n\tif (error)\n\t\treturn error;\n\n\tfor (i = 0; i < BTOBB(be32_to_cpu(rhead->h_len)) &&\n\t\t  i < (XLOG_HEADER_CYCLE_SIZE / BBSIZE); i++) {\n\t\t*(__be32 *)dp = *(__be32 *)&rhead->h_cycle_data[i];\n\t\tdp += BBSIZE;\n\t}\n\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\txlog_in_core_2_t *xhdr = (xlog_in_core_2_t *)rhead;\n\t\tfor ( ; i < BTOBB(be32_to_cpu(rhead->h_len)); i++) {\n\t\t\tj = i / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\tk = i % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t*(__be32 *)dp = xhdr[j].hic_xheader.xh_cycle_data[k];\n\t\t\tdp += BBSIZE;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_unpack_data(\n\tstruct xlog_rec_header\t*rhead,\n\txfs_caddr_t\t\tdp,\n\tstruct xlog\t\t*log)\n{\n\tint\t\t\ti, j, k;\n\tint\t\t\terror;\n\n\terror = xlog_unpack_data_crc(rhead, dp, log);\n\tif (error)\n\t\treturn error;\n\n\tfor (i = 0; i < BTOBB(be32_to_cpu(rhead->h_len)) &&\n\t\t  i < (XLOG_HEADER_CYCLE_SIZE / BBSIZE); i++) {\n\t\t*(__be32 *)dp = *(__be32 *)&rhead->h_cycle_data[i];\n\t\tdp += BBSIZE;\n\t}\n\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\txlog_in_core_2_t *xhdr = (xlog_in_core_2_t *)rhead;\n\t\tfor ( ; i < BTOBB(be32_to_cpu(rhead->h_len)); i++) {\n\t\t\tj = i / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\tk = i % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t*(__be32 *)dp = xhdr[j].hic_xheader.xh_cycle_data[k];\n\t\t\tdp += BBSIZE;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_bread",
          "args": [
            "log",
            "blk_no+hblks",
            "bblks",
            "dbp",
            "&offset"
          ],
          "line": 4318
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_bread_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "222-245",
          "snippet": "STATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "be32_to_cpu(rhead->h_len)"
          ],
          "line": 4317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_len"
          ],
          "line": 4317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_valid_rec_header",
          "args": [
            "log",
            "rhead",
            "blk_no"
          ],
          "line": 4312
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_valid_rec_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "4072-4106",
          "snippet": "STATIC int\nxlog_valid_rec_header(\n\tstruct xlog\t\t*log,\n\tstruct xlog_rec_header\t*rhead,\n\txfs_daddr_t\t\tblkno)\n{\n\tint\t\t\thlen;\n\n\tif (unlikely(rhead->h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM))) {\n\t\tXFS_ERROR_REPORT(\"xlog_valid_rec_header(1)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (unlikely(\n\t    (!rhead->h_version ||\n\t    (be32_to_cpu(rhead->h_version) & (~XLOG_VERSION_OKBITS))))) {\n\t\txfs_warn(log->l_mp, \"%s: unrecognised log version (%d).\",\n\t\t\t__func__, be32_to_cpu(rhead->h_version));\n\t\treturn -EIO;\n\t}\n\n\t/* LR body must have data or it wouldn't have been written */\n\thlen = be32_to_cpu(rhead->h_len);\n\tif (unlikely( hlen <= 0 || hlen > INT_MAX )) {\n\t\tXFS_ERROR_REPORT(\"xlog_valid_rec_header(2)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (unlikely( blkno > log->l_logBBsize || blkno > INT_MAX )) {\n\t\tXFS_ERROR_REPORT(\"xlog_valid_rec_header(3)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_valid_rec_header(\n\tstruct xlog\t\t*log,\n\tstruct xlog_rec_header\t*rhead,\n\txfs_daddr_t\t\tblkno)\n{\n\tint\t\t\thlen;\n\n\tif (unlikely(rhead->h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM))) {\n\t\tXFS_ERROR_REPORT(\"xlog_valid_rec_header(1)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (unlikely(\n\t    (!rhead->h_version ||\n\t    (be32_to_cpu(rhead->h_version) & (~XLOG_VERSION_OKBITS))))) {\n\t\txfs_warn(log->l_mp, \"%s: unrecognised log version (%d).\",\n\t\t\t__func__, be32_to_cpu(rhead->h_version));\n\t\treturn -EIO;\n\t}\n\n\t/* LR body must have data or it wouldn't have been written */\n\thlen = be32_to_cpu(rhead->h_len);\n\tif (unlikely( hlen <= 0 || hlen > INT_MAX )) {\n\t\tXFS_ERROR_REPORT(\"xlog_valid_rec_header(2)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (unlikely( blkno > log->l_logBBsize || blkno > INT_MAX )) {\n\t\tXFS_ERROR_REPORT(\"xlog_valid_rec_header(3)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk_no >= log->l_logBBsize"
          ],
          "line": 4301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "split_bblks"
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "split_bblks > 0"
          ],
          "line": 4263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk_no <= INT_MAX"
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!wrapped_hblks"
          ],
          "line": 4259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "be32_to_cpu(rhead->h_len)"
          ],
          "line": 4242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_len"
          ],
          "line": 4242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "split_hblks"
          ],
          "line": 4232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "split_hblks > 0"
          ],
          "line": 4209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk_no <= INT_MAX"
          ],
          "line": 4207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rhash",
            "0",
            "sizeof(rhash)"
          ],
          "line": 4182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_get_bp",
          "args": [
            "log",
            "BTOBB(h_size)"
          ],
          "line": 4176
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "99-137",
          "snippet": "STATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "h_size"
          ],
          "line": 4176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "log->l_sectBBsize == 1"
          ],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_version"
          ],
          "line": 4157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_size"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&log->l_mp->m_sb"
          ],
          "line": 4138
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "head_blk != tail_blk"
          ],
          "line": 4132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_do_recovery_pass(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\thead_blk,\n\txfs_daddr_t\t\ttail_blk,\n\tint\t\t\tpass)\n{\n\txlog_rec_header_t\t*rhead;\n\txfs_daddr_t\t\tblk_no;\n\txfs_caddr_t\t\toffset;\n\txfs_buf_t\t\t*hbp, *dbp;\n\tint\t\t\terror = 0, h_size;\n\tint\t\t\tbblks, split_bblks;\n\tint\t\t\thblks, split_hblks, wrapped_hblks;\n\tstruct hlist_head\trhash[XLOG_RHASH_SIZE];\n\n\tASSERT(head_blk != tail_blk);\n\n\t/*\n\t * Read the header of the tail block and get the iclog buffer size from\n\t * h_size.  Use this to tell how many sectors make up the log header.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\t/*\n\t\t * When using variable length iclogs, read first sector of\n\t\t * iclog header and extract the header size from it.  Get a\n\t\t * new hbp that is the correct size.\n\t\t */\n\t\thbp = xlog_get_bp(log, 1);\n\t\tif (!hbp)\n\t\t\treturn -ENOMEM;\n\n\t\terror = xlog_bread(log, tail_blk, 1, hbp, &offset);\n\t\tif (error)\n\t\t\tgoto bread_err1;\n\n\t\trhead = (xlog_rec_header_t *)offset;\n\t\terror = xlog_valid_rec_header(log, rhead, tail_blk);\n\t\tif (error)\n\t\t\tgoto bread_err1;\n\t\th_size = be32_to_cpu(rhead->h_size);\n\t\tif ((be32_to_cpu(rhead->h_version) & XLOG_VERSION_2) &&\n\t\t    (h_size > XLOG_HEADER_CYCLE_SIZE)) {\n\t\t\thblks = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\t\thblks++;\n\t\t\txlog_put_bp(hbp);\n\t\t\thbp = xlog_get_bp(log, hblks);\n\t\t} else {\n\t\t\thblks = 1;\n\t\t}\n\t} else {\n\t\tASSERT(log->l_sectBBsize == 1);\n\t\thblks = 1;\n\t\thbp = xlog_get_bp(log, 1);\n\t\th_size = XLOG_BIG_RECORD_BSIZE;\n\t}\n\n\tif (!hbp)\n\t\treturn -ENOMEM;\n\tdbp = xlog_get_bp(log, BTOBB(h_size));\n\tif (!dbp) {\n\t\txlog_put_bp(hbp);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(rhash, 0, sizeof(rhash));\n\tblk_no = tail_blk;\n\tif (tail_blk > head_blk) {\n\t\t/*\n\t\t * Perform recovery around the end of the physical log.\n\t\t * When the head is not on the same cycle number as the tail,\n\t\t * we can't do a sequential recovery.\n\t\t */\n\t\twhile (blk_no < log->l_logBBsize) {\n\t\t\t/*\n\t\t\t * Check for header wrapping around physical end-of-log\n\t\t\t */\n\t\t\toffset = hbp->b_addr;\n\t\t\tsplit_hblks = 0;\n\t\t\twrapped_hblks = 0;\n\t\t\tif (blk_no + hblks <= log->l_logBBsize) {\n\t\t\t\t/* Read header in one read */\n\t\t\t\terror = xlog_bread(log, blk_no, hblks, hbp,\n\t\t\t\t\t\t   &offset);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t} else {\n\t\t\t\t/* This LR is split across physical log end */\n\t\t\t\tif (blk_no != log->l_logBBsize) {\n\t\t\t\t\t/* some data before physical log end */\n\t\t\t\t\tASSERT(blk_no <= INT_MAX);\n\t\t\t\t\tsplit_hblks = log->l_logBBsize - (int)blk_no;\n\t\t\t\t\tASSERT(split_hblks > 0);\n\t\t\t\t\terror = xlog_bread(log, blk_no,\n\t\t\t\t\t\t\t   split_hblks, hbp,\n\t\t\t\t\t\t\t   &offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\tgoto bread_err2;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note: this black magic still works with\n\t\t\t\t * large sector sizes (non-512) only because:\n\t\t\t\t * - we increased the buffer size originally\n\t\t\t\t *   by 1 sector giving us enough extra space\n\t\t\t\t *   for the second read;\n\t\t\t\t * - the log start is guaranteed to be sector\n\t\t\t\t *   aligned;\n\t\t\t\t * - we read the log end (LR header start)\n\t\t\t\t *   _first_, then the log start (LR header end)\n\t\t\t\t *   - order is important.\n\t\t\t\t */\n\t\t\t\twrapped_hblks = hblks - split_hblks;\n\t\t\t\terror = xlog_bread_offset(log, 0,\n\t\t\t\t\t\twrapped_hblks, hbp,\n\t\t\t\t\t\toffset + BBTOB(split_hblks));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t}\n\t\t\trhead = (xlog_rec_header_t *)offset;\n\t\t\terror = xlog_valid_rec_header(log, rhead,\n\t\t\t\t\t\tsplit_hblks ? blk_no : 0);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\n\t\t\tbblks = (int)BTOBB(be32_to_cpu(rhead->h_len));\n\t\t\tblk_no += hblks;\n\n\t\t\t/* Read in data for log record */\n\t\t\tif (blk_no + bblks <= log->l_logBBsize) {\n\t\t\t\terror = xlog_bread(log, blk_no, bblks, dbp,\n\t\t\t\t\t\t   &offset);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t} else {\n\t\t\t\t/* This log record is split across the\n\t\t\t\t * physical end of log */\n\t\t\t\toffset = dbp->b_addr;\n\t\t\t\tsplit_bblks = 0;\n\t\t\t\tif (blk_no != log->l_logBBsize) {\n\t\t\t\t\t/* some data is before the physical\n\t\t\t\t\t * end of log */\n\t\t\t\t\tASSERT(!wrapped_hblks);\n\t\t\t\t\tASSERT(blk_no <= INT_MAX);\n\t\t\t\t\tsplit_bblks =\n\t\t\t\t\t\tlog->l_logBBsize - (int)blk_no;\n\t\t\t\t\tASSERT(split_bblks > 0);\n\t\t\t\t\terror = xlog_bread(log, blk_no,\n\t\t\t\t\t\t\tsplit_bblks, dbp,\n\t\t\t\t\t\t\t&offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\tgoto bread_err2;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note: this black magic still works with\n\t\t\t\t * large sector sizes (non-512) only because:\n\t\t\t\t * - we increased the buffer size originally\n\t\t\t\t *   by 1 sector giving us enough extra space\n\t\t\t\t *   for the second read;\n\t\t\t\t * - the log start is guaranteed to be sector\n\t\t\t\t *   aligned;\n\t\t\t\t * - we read the log end (LR header start)\n\t\t\t\t *   _first_, then the log start (LR header end)\n\t\t\t\t *   - order is important.\n\t\t\t\t */\n\t\t\t\terror = xlog_bread_offset(log, 0,\n\t\t\t\t\t\tbblks - split_bblks, dbp,\n\t\t\t\t\t\toffset + BBTOB(split_bblks));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t}\n\n\t\t\terror = xlog_unpack_data(rhead, offset, log);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\n\t\t\terror = xlog_recover_process_data(log, rhash,\n\t\t\t\t\t\t\trhead, offset, pass);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\t\t\tblk_no += bblks;\n\t\t}\n\n\t\tASSERT(blk_no >= log->l_logBBsize);\n\t\tblk_no -= log->l_logBBsize;\n\t}\n\n\t/* read first part of physical log */\n\twhile (blk_no < head_blk) {\n\t\terror = xlog_bread(log, blk_no, hblks, hbp, &offset);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\trhead = (xlog_rec_header_t *)offset;\n\t\terror = xlog_valid_rec_header(log, rhead, blk_no);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\t/* blocks in data section */\n\t\tbblks = (int)BTOBB(be32_to_cpu(rhead->h_len));\n\t\terror = xlog_bread(log, blk_no+hblks, bblks, dbp,\n\t\t\t\t   &offset);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\terror = xlog_unpack_data(rhead, offset, log);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\terror = xlog_recover_process_data(log, rhash,\n\t\t\t\t\t\trhead, offset, pass);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\t\tblk_no += bblks + hblks;\n\t}\n\n bread_err2:\n\txlog_put_bp(dbp);\n bread_err1:\n\txlog_put_bp(hbp);\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_valid_rec_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "4072-4106",
    "snippet": "STATIC int\nxlog_valid_rec_header(\n\tstruct xlog\t\t*log,\n\tstruct xlog_rec_header\t*rhead,\n\txfs_daddr_t\t\tblkno)\n{\n\tint\t\t\thlen;\n\n\tif (unlikely(rhead->h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM))) {\n\t\tXFS_ERROR_REPORT(\"xlog_valid_rec_header(1)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (unlikely(\n\t    (!rhead->h_version ||\n\t    (be32_to_cpu(rhead->h_version) & (~XLOG_VERSION_OKBITS))))) {\n\t\txfs_warn(log->l_mp, \"%s: unrecognised log version (%d).\",\n\t\t\t__func__, be32_to_cpu(rhead->h_version));\n\t\treturn -EIO;\n\t}\n\n\t/* LR body must have data or it wouldn't have been written */\n\thlen = be32_to_cpu(rhead->h_len);\n\tif (unlikely( hlen <= 0 || hlen > INT_MAX )) {\n\t\tXFS_ERROR_REPORT(\"xlog_valid_rec_header(2)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (unlikely( blkno > log->l_logBBsize || blkno > INT_MAX )) {\n\t\tXFS_ERROR_REPORT(\"xlog_valid_rec_header(3)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xlog_valid_rec_header(3)\"",
            "XFS_ERRLEVEL_LOW",
            "log->l_mp"
          ],
          "line": 4101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "blkno > log->l_logBBsize || blkno > INT_MAX"
          ],
          "line": 4100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xlog_valid_rec_header(2)\"",
            "XFS_ERRLEVEL_LOW",
            "log->l_mp"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "hlen <= 0 || hlen > INT_MAX"
          ],
          "line": 4095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_len"
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"%s: unrecognised log version (%d).\"",
            "__func__",
            "be32_to_cpu(rhead->h_version)"
          ],
          "line": 4088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_version"
          ],
          "line": 4089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(!rhead->h_version ||\n\t    (be32_to_cpu(rhead->h_version) & (~XLOG_VERSION_OKBITS)))"
          ],
          "line": 4085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_version"
          ],
          "line": 4087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xlog_valid_rec_header(1)\"",
            "XFS_ERRLEVEL_LOW",
            "log->l_mp"
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rhead->h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM)"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XLOG_HEADER_MAGIC_NUM"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_valid_rec_header(\n\tstruct xlog\t\t*log,\n\tstruct xlog_rec_header\t*rhead,\n\txfs_daddr_t\t\tblkno)\n{\n\tint\t\t\thlen;\n\n\tif (unlikely(rhead->h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM))) {\n\t\tXFS_ERROR_REPORT(\"xlog_valid_rec_header(1)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (unlikely(\n\t    (!rhead->h_version ||\n\t    (be32_to_cpu(rhead->h_version) & (~XLOG_VERSION_OKBITS))))) {\n\t\txfs_warn(log->l_mp, \"%s: unrecognised log version (%d).\",\n\t\t\t__func__, be32_to_cpu(rhead->h_version));\n\t\treturn -EIO;\n\t}\n\n\t/* LR body must have data or it wouldn't have been written */\n\thlen = be32_to_cpu(rhead->h_len);\n\tif (unlikely( hlen <= 0 || hlen > INT_MAX )) {\n\t\tXFS_ERROR_REPORT(\"xlog_valid_rec_header(2)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (unlikely( blkno > log->l_logBBsize || blkno > INT_MAX )) {\n\t\tXFS_ERROR_REPORT(\"xlog_valid_rec_header(3)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_unpack_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "4040-4070",
    "snippet": "STATIC int\nxlog_unpack_data(\n\tstruct xlog_rec_header\t*rhead,\n\txfs_caddr_t\t\tdp,\n\tstruct xlog\t\t*log)\n{\n\tint\t\t\ti, j, k;\n\tint\t\t\terror;\n\n\terror = xlog_unpack_data_crc(rhead, dp, log);\n\tif (error)\n\t\treturn error;\n\n\tfor (i = 0; i < BTOBB(be32_to_cpu(rhead->h_len)) &&\n\t\t  i < (XLOG_HEADER_CYCLE_SIZE / BBSIZE); i++) {\n\t\t*(__be32 *)dp = *(__be32 *)&rhead->h_cycle_data[i];\n\t\tdp += BBSIZE;\n\t}\n\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\txlog_in_core_2_t *xhdr = (xlog_in_core_2_t *)rhead;\n\t\tfor ( ; i < BTOBB(be32_to_cpu(rhead->h_len)); i++) {\n\t\t\tj = i / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\tk = i % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t*(__be32 *)dp = xhdr[j].hic_xheader.xh_cycle_data[k];\n\t\t\tdp += BBSIZE;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "be32_to_cpu(rhead->h_len)"
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_len"
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&log->l_mp->m_sb"
          ],
          "line": 4059
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "be32_to_cpu(rhead->h_len)"
          ],
          "line": 4053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_len"
          ],
          "line": 4053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_unpack_data_crc",
          "args": [
            "rhead",
            "dp",
            "log"
          ],
          "line": 4049
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_unpack_data_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "4010-4038",
          "snippet": "STATIC int\nxlog_unpack_data_crc(\n\tstruct xlog_rec_header\t*rhead,\n\txfs_caddr_t\t\tdp,\n\tstruct xlog\t\t*log)\n{\n\t__le32\t\t\tcrc;\n\n\tcrc = xlog_cksum(log, rhead, dp, be32_to_cpu(rhead->h_len));\n\tif (crc != rhead->h_crc) {\n\t\tif (rhead->h_crc || xfs_sb_version_hascrc(&log->l_mp->m_sb)) {\n\t\t\txfs_alert(log->l_mp,\n\t\t\"log record CRC mismatch: found 0x%x, expected 0x%x.\",\n\t\t\t\t\tle32_to_cpu(rhead->h_crc),\n\t\t\t\t\tle32_to_cpu(crc));\n\t\t\txfs_hex_dump(dp, 32);\n\t\t}\n\n\t\t/*\n\t\t * If we've detected a log record corruption, then we can't\n\t\t * recover past this point. Abort recovery if we are enforcing\n\t\t * CRC protection by punting an error back up the stack.\n\t\t */\n\t\tif (xfs_sb_version_hascrc(&log->l_mp->m_sb))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_unpack_data_crc(\n\tstruct xlog_rec_header\t*rhead,\n\txfs_caddr_t\t\tdp,\n\tstruct xlog\t\t*log)\n{\n\t__le32\t\t\tcrc;\n\n\tcrc = xlog_cksum(log, rhead, dp, be32_to_cpu(rhead->h_len));\n\tif (crc != rhead->h_crc) {\n\t\tif (rhead->h_crc || xfs_sb_version_hascrc(&log->l_mp->m_sb)) {\n\t\t\txfs_alert(log->l_mp,\n\t\t\"log record CRC mismatch: found 0x%x, expected 0x%x.\",\n\t\t\t\t\tle32_to_cpu(rhead->h_crc),\n\t\t\t\t\tle32_to_cpu(crc));\n\t\t\txfs_hex_dump(dp, 32);\n\t\t}\n\n\t\t/*\n\t\t * If we've detected a log record corruption, then we can't\n\t\t * recover past this point. Abort recovery if we are enforcing\n\t\t * CRC protection by punting an error back up the stack.\n\t\t */\n\t\tif (xfs_sb_version_hascrc(&log->l_mp->m_sb))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_unpack_data(\n\tstruct xlog_rec_header\t*rhead,\n\txfs_caddr_t\t\tdp,\n\tstruct xlog\t\t*log)\n{\n\tint\t\t\ti, j, k;\n\tint\t\t\terror;\n\n\terror = xlog_unpack_data_crc(rhead, dp, log);\n\tif (error)\n\t\treturn error;\n\n\tfor (i = 0; i < BTOBB(be32_to_cpu(rhead->h_len)) &&\n\t\t  i < (XLOG_HEADER_CYCLE_SIZE / BBSIZE); i++) {\n\t\t*(__be32 *)dp = *(__be32 *)&rhead->h_cycle_data[i];\n\t\tdp += BBSIZE;\n\t}\n\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\txlog_in_core_2_t *xhdr = (xlog_in_core_2_t *)rhead;\n\t\tfor ( ; i < BTOBB(be32_to_cpu(rhead->h_len)); i++) {\n\t\t\tj = i / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\tk = i % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t*(__be32 *)dp = xhdr[j].hic_xheader.xh_cycle_data[k];\n\t\t\tdp += BBSIZE;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_unpack_data_crc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "4010-4038",
    "snippet": "STATIC int\nxlog_unpack_data_crc(\n\tstruct xlog_rec_header\t*rhead,\n\txfs_caddr_t\t\tdp,\n\tstruct xlog\t\t*log)\n{\n\t__le32\t\t\tcrc;\n\n\tcrc = xlog_cksum(log, rhead, dp, be32_to_cpu(rhead->h_len));\n\tif (crc != rhead->h_crc) {\n\t\tif (rhead->h_crc || xfs_sb_version_hascrc(&log->l_mp->m_sb)) {\n\t\t\txfs_alert(log->l_mp,\n\t\t\"log record CRC mismatch: found 0x%x, expected 0x%x.\",\n\t\t\t\t\tle32_to_cpu(rhead->h_crc),\n\t\t\t\t\tle32_to_cpu(crc));\n\t\t\txfs_hex_dump(dp, 32);\n\t\t}\n\n\t\t/*\n\t\t * If we've detected a log record corruption, then we can't\n\t\t * recover past this point. Abort recovery if we are enforcing\n\t\t * CRC protection by punting an error back up the stack.\n\t\t */\n\t\tif (xfs_sb_version_hascrc(&log->l_mp->m_sb))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&log->l_mp->m_sb"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_hex_dump",
          "args": [
            "dp",
            "32"
          ],
          "line": 4025
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_hex_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "109-113",
          "snippet": "void\nxfs_hex_dump(void *p, int length)\n{\n\tprint_hex_dump(KERN_ALERT, \"\", DUMP_PREFIX_ADDRESS, 16, 1, p, length, 1);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_hex_dump(void *p, int length)\n{\n\tprint_hex_dump(KERN_ALERT, \"\", DUMP_PREFIX_ADDRESS, 16, 1, p, length, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "log->l_mp",
            "\"log record CRC mismatch: found 0x%x, expected 0x%x.\"",
            "le32_to_cpu(rhead->h_crc)",
            "le32_to_cpu(crc)"
          ],
          "line": 4021
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "crc"
          ],
          "line": 4024
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_cksum",
          "args": [
            "log",
            "rhead",
            "dp",
            "be32_to_cpu(rhead->h_len)"
          ],
          "line": 4018
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1640-1669",
          "snippet": "__le32\nxlog_cksum(\n\tstruct xlog\t\t*log,\n\tstruct xlog_rec_header\t*rhead,\n\tchar\t\t\t*dp,\n\tint\t\t\tsize)\n{\n\t__uint32_t\t\tcrc;\n\n\t/* first generate the crc for the record header ... */\n\tcrc = xfs_start_cksum((char *)rhead,\n\t\t\t      sizeof(struct xlog_rec_header),\n\t\t\t      offsetof(struct xlog_rec_header, h_crc));\n\n\t/* ... then for additional cycle data for v2 logs ... */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tunion xlog_in_core2 *xhdr = (union xlog_in_core2 *)rhead;\n\t\tint\t\ti;\n\n\t\tfor (i = 1; i < log->l_iclog_heads; i++) {\n\t\t\tcrc = crc32c(crc, &xhdr[i].hic_xheader,\n\t\t\t\t     sizeof(struct xlog_rec_ext_header));\n\t\t}\n\t}\n\n\t/* ... and finally for the payload */\n\tcrc = crc32c(crc, dp, size);\n\n\treturn xfs_end_cksum(crc);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\n__le32\nxlog_cksum(\n\tstruct xlog\t\t*log,\n\tstruct xlog_rec_header\t*rhead,\n\tchar\t\t\t*dp,\n\tint\t\t\tsize)\n{\n\t__uint32_t\t\tcrc;\n\n\t/* first generate the crc for the record header ... */\n\tcrc = xfs_start_cksum((char *)rhead,\n\t\t\t      sizeof(struct xlog_rec_header),\n\t\t\t      offsetof(struct xlog_rec_header, h_crc));\n\n\t/* ... then for additional cycle data for v2 logs ... */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tunion xlog_in_core2 *xhdr = (union xlog_in_core2 *)rhead;\n\t\tint\t\ti;\n\n\t\tfor (i = 1; i < log->l_iclog_heads; i++) {\n\t\t\tcrc = crc32c(crc, &xhdr[i].hic_xheader,\n\t\t\t\t     sizeof(struct xlog_rec_ext_header));\n\t\t}\n\t}\n\n\t/* ... and finally for the payload */\n\tcrc = crc32c(crc, dp, size);\n\n\treturn xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_len"
          ],
          "line": 4018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_unpack_data_crc(\n\tstruct xlog_rec_header\t*rhead,\n\txfs_caddr_t\t\tdp,\n\tstruct xlog\t\t*log)\n{\n\t__le32\t\t\tcrc;\n\n\tcrc = xlog_cksum(log, rhead, dp, be32_to_cpu(rhead->h_len));\n\tif (crc != rhead->h_crc) {\n\t\tif (rhead->h_crc || xfs_sb_version_hascrc(&log->l_mp->m_sb)) {\n\t\t\txfs_alert(log->l_mp,\n\t\t\"log record CRC mismatch: found 0x%x, expected 0x%x.\",\n\t\t\t\t\tle32_to_cpu(rhead->h_crc),\n\t\t\t\t\tle32_to_cpu(crc));\n\t\t\txfs_hex_dump(dp, 32);\n\t\t}\n\n\t\t/*\n\t\t * If we've detected a log record corruption, then we can't\n\t\t * recover past this point. Abort recovery if we are enforcing\n\t\t * CRC protection by punting an error back up the stack.\n\t\t */\n\t\tif (xfs_sb_version_hascrc(&log->l_mp->m_sb))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_recover_process_iunlinks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3940-3998",
    "snippet": "STATIC void\nxlog_recover_process_iunlinks(\n\tstruct xlog\t*log)\n{\n\txfs_mount_t\t*mp;\n\txfs_agnumber_t\tagno;\n\txfs_agi_t\t*agi;\n\txfs_buf_t\t*agibp;\n\txfs_agino_t\tagino;\n\tint\t\tbucket;\n\tint\t\terror;\n\tuint\t\tmp_dmevmask;\n\n\tmp = log->l_mp;\n\n\t/*\n\t * Prevent any DMAPI event from being sent while in this function.\n\t */\n\tmp_dmevmask = mp->m_dmevmask;\n\tmp->m_dmevmask = 0;\n\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\t/*\n\t\t * Find the agi for this ag.\n\t\t */\n\t\terror = xfs_read_agi(mp, NULL, agno, &agibp);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * AGI is b0rked. Don't process it.\n\t\t\t *\n\t\t\t * We should probably mark the filesystem as corrupt\n\t\t\t * after we've recovered all the ag's we can....\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Unlock the buffer so that it can be acquired in the normal\n\t\t * course of the transaction to truncate and free each inode.\n\t\t * Because we are not racing with anyone else here for the AGI\n\t\t * buffer, we don't even need to hold it locked to read the\n\t\t * initial unlinked bucket entries out of the buffer. We keep\n\t\t * buffer reference though, so that it stays pinned in memory\n\t\t * while we need the buffer.\n\t\t */\n\t\tagi = XFS_BUF_TO_AGI(agibp);\n\t\txfs_buf_unlock(agibp);\n\n\t\tfor (bucket = 0; bucket < XFS_AGI_UNLINKED_BUCKETS; bucket++) {\n\t\t\tagino = be32_to_cpu(agi->agi_unlinked[bucket]);\n\t\t\twhile (agino != NULLAGINO) {\n\t\t\t\tagino = xlog_recover_process_one_iunlink(mp,\n\t\t\t\t\t\t\tagno, agino, bucket);\n\t\t\t}\n\t\t}\n\t\txfs_buf_rele(agibp);\n\t}\n\n\tmp->m_dmevmask = mp_dmevmask;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_rele",
          "args": [
            "agibp"
          ],
          "line": 3994
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_rele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "866-920",
          "snippet": "void\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_process_one_iunlink",
          "args": [
            "mp",
            "agno",
            "agino",
            "bucket"
          ],
          "line": 3990
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_process_one_iunlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3872-3926",
          "snippet": "STATIC xfs_agino_t\nxlog_recover_process_one_iunlink(\n\tstruct xfs_mount\t\t*mp,\n\txfs_agnumber_t\t\t\tagno,\n\txfs_agino_t\t\t\tagino,\n\tint\t\t\t\tbucket)\n{\n\tstruct xfs_buf\t\t\t*ibp;\n\tstruct xfs_dinode\t\t*dip;\n\tstruct xfs_inode\t\t*ip;\n\txfs_ino_t\t\t\tino;\n\tint\t\t\t\terror;\n\n\tino = XFS_AGINO_TO_INO(mp, agno, agino);\n\terror = xfs_iget(mp, NULL, ino, 0, 0, &ip);\n\tif (error)\n\t\tgoto fail;\n\n\t/*\n\t * Get the on disk inode to find the next inode in the bucket.\n\t */\n\terror = xfs_imap_to_bp(mp, NULL, &ip->i_imap, &dip, &ibp, 0, 0);\n\tif (error)\n\t\tgoto fail_iput;\n\n\tASSERT(ip->i_d.di_nlink == 0);\n\tASSERT(ip->i_d.di_mode != 0);\n\n\t/* setup for the next pass */\n\tagino = be32_to_cpu(dip->di_next_unlinked);\n\txfs_buf_relse(ibp);\n\n\t/*\n\t * Prevent any DMAPI event from being sent when the reference on\n\t * the inode is dropped.\n\t */\n\tip->i_d.di_dmevmask = 0;\n\n\tIRELE(ip);\n\treturn agino;\n\n fail_iput:\n\tIRELE(ip);\n fail:\n\t/*\n\t * We can't read in the inode this bucket points to, or this inode\n\t * is messed up.  Just ditch this bucket of inodes.  We will lose\n\t * some inodes and space, but at least we won't hang.\n\t *\n\t * Call xlog_recover_clear_agi_bucket() to perform a transaction to\n\t * clear the inode pointer in the bucket.\n\t */\n\txlog_recover_clear_agi_bucket(mp, agno, bucket);\n\treturn NULLAGINO;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_agino_t\nxlog_recover_process_one_iunlink(\n\tstruct xfs_mount\t\t*mp,\n\txfs_agnumber_t\t\t\tagno,\n\txfs_agino_t\t\t\tagino,\n\tint\t\t\t\tbucket)\n{\n\tstruct xfs_buf\t\t\t*ibp;\n\tstruct xfs_dinode\t\t*dip;\n\tstruct xfs_inode\t\t*ip;\n\txfs_ino_t\t\t\tino;\n\tint\t\t\t\terror;\n\n\tino = XFS_AGINO_TO_INO(mp, agno, agino);\n\terror = xfs_iget(mp, NULL, ino, 0, 0, &ip);\n\tif (error)\n\t\tgoto fail;\n\n\t/*\n\t * Get the on disk inode to find the next inode in the bucket.\n\t */\n\terror = xfs_imap_to_bp(mp, NULL, &ip->i_imap, &dip, &ibp, 0, 0);\n\tif (error)\n\t\tgoto fail_iput;\n\n\tASSERT(ip->i_d.di_nlink == 0);\n\tASSERT(ip->i_d.di_mode != 0);\n\n\t/* setup for the next pass */\n\tagino = be32_to_cpu(dip->di_next_unlinked);\n\txfs_buf_relse(ibp);\n\n\t/*\n\t * Prevent any DMAPI event from being sent when the reference on\n\t * the inode is dropped.\n\t */\n\tip->i_d.di_dmevmask = 0;\n\n\tIRELE(ip);\n\treturn agino;\n\n fail_iput:\n\tIRELE(ip);\n fail:\n\t/*\n\t * We can't read in the inode this bucket points to, or this inode\n\t * is messed up.  Just ditch this bucket of inodes.  We will lose\n\t * some inodes and space, but at least we won't hang.\n\t *\n\t * Call xlog_recover_clear_agi_bucket() to perform a transaction to\n\t * clear the inode pointer in the bucket.\n\t */\n\txlog_recover_clear_agi_bucket(mp, agno, bucket);\n\treturn NULLAGINO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_unlinked[bucket]"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_unlock",
          "args": [
            "agibp"
          ],
          "line": 3985
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "971-979",
          "snippet": "void\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agibp"
          ],
          "line": 3984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_read_agi",
          "args": [
            "mp",
            "NULL",
            "agno",
            "&agibp"
          ],
          "line": 3965
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_read_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2122-2142",
          "snippet": "int\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};\n\nint\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_process_iunlinks(\n\tstruct xlog\t*log)\n{\n\txfs_mount_t\t*mp;\n\txfs_agnumber_t\tagno;\n\txfs_agi_t\t*agi;\n\txfs_buf_t\t*agibp;\n\txfs_agino_t\tagino;\n\tint\t\tbucket;\n\tint\t\terror;\n\tuint\t\tmp_dmevmask;\n\n\tmp = log->l_mp;\n\n\t/*\n\t * Prevent any DMAPI event from being sent while in this function.\n\t */\n\tmp_dmevmask = mp->m_dmevmask;\n\tmp->m_dmevmask = 0;\n\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\t/*\n\t\t * Find the agi for this ag.\n\t\t */\n\t\terror = xfs_read_agi(mp, NULL, agno, &agibp);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * AGI is b0rked. Don't process it.\n\t\t\t *\n\t\t\t * We should probably mark the filesystem as corrupt\n\t\t\t * after we've recovered all the ag's we can....\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Unlock the buffer so that it can be acquired in the normal\n\t\t * course of the transaction to truncate and free each inode.\n\t\t * Because we are not racing with anyone else here for the AGI\n\t\t * buffer, we don't even need to hold it locked to read the\n\t\t * initial unlinked bucket entries out of the buffer. We keep\n\t\t * buffer reference though, so that it stays pinned in memory\n\t\t * while we need the buffer.\n\t\t */\n\t\tagi = XFS_BUF_TO_AGI(agibp);\n\t\txfs_buf_unlock(agibp);\n\n\t\tfor (bucket = 0; bucket < XFS_AGI_UNLINKED_BUCKETS; bucket++) {\n\t\t\tagino = be32_to_cpu(agi->agi_unlinked[bucket]);\n\t\t\twhile (agino != NULLAGINO) {\n\t\t\t\tagino = xlog_recover_process_one_iunlink(mp,\n\t\t\t\t\t\t\tagno, agino, bucket);\n\t\t\t}\n\t\t}\n\t\txfs_buf_rele(agibp);\n\t}\n\n\tmp->m_dmevmask = mp_dmevmask;\n}"
  },
  {
    "function_name": "xlog_recover_process_one_iunlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3872-3926",
    "snippet": "STATIC xfs_agino_t\nxlog_recover_process_one_iunlink(\n\tstruct xfs_mount\t\t*mp,\n\txfs_agnumber_t\t\t\tagno,\n\txfs_agino_t\t\t\tagino,\n\tint\t\t\t\tbucket)\n{\n\tstruct xfs_buf\t\t\t*ibp;\n\tstruct xfs_dinode\t\t*dip;\n\tstruct xfs_inode\t\t*ip;\n\txfs_ino_t\t\t\tino;\n\tint\t\t\t\terror;\n\n\tino = XFS_AGINO_TO_INO(mp, agno, agino);\n\terror = xfs_iget(mp, NULL, ino, 0, 0, &ip);\n\tif (error)\n\t\tgoto fail;\n\n\t/*\n\t * Get the on disk inode to find the next inode in the bucket.\n\t */\n\terror = xfs_imap_to_bp(mp, NULL, &ip->i_imap, &dip, &ibp, 0, 0);\n\tif (error)\n\t\tgoto fail_iput;\n\n\tASSERT(ip->i_d.di_nlink == 0);\n\tASSERT(ip->i_d.di_mode != 0);\n\n\t/* setup for the next pass */\n\tagino = be32_to_cpu(dip->di_next_unlinked);\n\txfs_buf_relse(ibp);\n\n\t/*\n\t * Prevent any DMAPI event from being sent when the reference on\n\t * the inode is dropped.\n\t */\n\tip->i_d.di_dmevmask = 0;\n\n\tIRELE(ip);\n\treturn agino;\n\n fail_iput:\n\tIRELE(ip);\n fail:\n\t/*\n\t * We can't read in the inode this bucket points to, or this inode\n\t * is messed up.  Just ditch this bucket of inodes.  We will lose\n\t * some inodes and space, but at least we won't hang.\n\t *\n\t * Call xlog_recover_clear_agi_bucket() to perform a transaction to\n\t * clear the inode pointer in the bucket.\n\t */\n\txlog_recover_clear_agi_bucket(mp, agno, bucket);\n\treturn NULLAGINO;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_recover_clear_agi_bucket",
          "args": [
            "mp",
            "agno",
            "bucket"
          ],
          "line": 3924
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_clear_agi_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3832-3870",
          "snippet": "STATIC void\nxlog_recover_clear_agi_bucket(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno,\n\tint\t\tbucket)\n{\n\txfs_trans_t\t*tp;\n\txfs_agi_t\t*agi;\n\txfs_buf_t\t*agibp;\n\tint\t\toffset;\n\tint\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_CLEAR_AGI_BUCKET);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_clearagi, 0, 0);\n\tif (error)\n\t\tgoto out_abort;\n\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\tgoto out_abort;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\tagi->agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);\n\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t (sizeof(xfs_agino_t) * bucket);\n\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\n\terror = xfs_trans_commit(tp, 0);\n\tif (error)\n\t\tgoto out_error;\n\treturn;\n\nout_abort:\n\txfs_trans_cancel(tp, XFS_TRANS_ABORT);\nout_error:\n\txfs_warn(mp, \"%s: failed to clear agi %d. Continuing.\", __func__, agno);\n\treturn;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_recover_clear_agi_bucket(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno,\n\tint\t\tbucket)\n{\n\txfs_trans_t\t*tp;\n\txfs_agi_t\t*agi;\n\txfs_buf_t\t*agibp;\n\tint\t\toffset;\n\tint\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_CLEAR_AGI_BUCKET);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_clearagi, 0, 0);\n\tif (error)\n\t\tgoto out_abort;\n\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\tgoto out_abort;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\tagi->agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);\n\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t (sizeof(xfs_agino_t) * bucket);\n\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\n\terror = xfs_trans_commit(tp, 0);\n\tif (error)\n\t\tgoto out_error;\n\treturn;\n\nout_abort:\n\txfs_trans_cancel(tp, XFS_TRANS_ABORT);\nout_error:\n\txfs_warn(mp, \"%s: failed to clear agi %d. Continuing.\", __func__, agno);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "ip"
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "ip"
          ],
          "line": 3910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "ibp"
          ],
          "line": 3902
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dip->di_next_unlinked"
          ],
          "line": 3901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_mode != 0"
          ],
          "line": 3898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_nlink == 0"
          ],
          "line": 3897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_imap_to_bp",
          "args": [
            "mp",
            "NULL",
            "&ip->i_imap",
            "&dip",
            "&ibp",
            "0",
            "0"
          ],
          "line": 3893
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_imap_to_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "156-191",
          "snippet": "int\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (error == -EFSCORRUPTED &&\n\t\t    (iget_flags & XFS_IGET_UNTRUSTED))\n\t\t\treturn -EINVAL;\n\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = (struct xfs_dinode *)xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};\n\nint\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (error == -EFSCORRUPTED &&\n\t\t    (iget_flags & XFS_IGET_UNTRUSTED))\n\t\t\treturn -EINVAL;\n\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = (struct xfs_dinode *)xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iget",
          "args": [
            "mp",
            "NULL",
            "ino",
            "0",
            "0",
            "&ip"
          ],
          "line": 3886
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "388-456",
          "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "agino"
          ],
          "line": 3885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_agino_t\nxlog_recover_process_one_iunlink(\n\tstruct xfs_mount\t\t*mp,\n\txfs_agnumber_t\t\t\tagno,\n\txfs_agino_t\t\t\tagino,\n\tint\t\t\t\tbucket)\n{\n\tstruct xfs_buf\t\t\t*ibp;\n\tstruct xfs_dinode\t\t*dip;\n\tstruct xfs_inode\t\t*ip;\n\txfs_ino_t\t\t\tino;\n\tint\t\t\t\terror;\n\n\tino = XFS_AGINO_TO_INO(mp, agno, agino);\n\terror = xfs_iget(mp, NULL, ino, 0, 0, &ip);\n\tif (error)\n\t\tgoto fail;\n\n\t/*\n\t * Get the on disk inode to find the next inode in the bucket.\n\t */\n\terror = xfs_imap_to_bp(mp, NULL, &ip->i_imap, &dip, &ibp, 0, 0);\n\tif (error)\n\t\tgoto fail_iput;\n\n\tASSERT(ip->i_d.di_nlink == 0);\n\tASSERT(ip->i_d.di_mode != 0);\n\n\t/* setup for the next pass */\n\tagino = be32_to_cpu(dip->di_next_unlinked);\n\txfs_buf_relse(ibp);\n\n\t/*\n\t * Prevent any DMAPI event from being sent when the reference on\n\t * the inode is dropped.\n\t */\n\tip->i_d.di_dmevmask = 0;\n\n\tIRELE(ip);\n\treturn agino;\n\n fail_iput:\n\tIRELE(ip);\n fail:\n\t/*\n\t * We can't read in the inode this bucket points to, or this inode\n\t * is messed up.  Just ditch this bucket of inodes.  We will lose\n\t * some inodes and space, but at least we won't hang.\n\t *\n\t * Call xlog_recover_clear_agi_bucket() to perform a transaction to\n\t * clear the inode pointer in the bucket.\n\t */\n\txlog_recover_clear_agi_bucket(mp, agno, bucket);\n\treturn NULLAGINO;\n}"
  },
  {
    "function_name": "xlog_recover_clear_agi_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3832-3870",
    "snippet": "STATIC void\nxlog_recover_clear_agi_bucket(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno,\n\tint\t\tbucket)\n{\n\txfs_trans_t\t*tp;\n\txfs_agi_t\t*agi;\n\txfs_buf_t\t*agibp;\n\tint\t\toffset;\n\tint\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_CLEAR_AGI_BUCKET);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_clearagi, 0, 0);\n\tif (error)\n\t\tgoto out_abort;\n\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\tgoto out_abort;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\tagi->agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);\n\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t (sizeof(xfs_agino_t) * bucket);\n\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\n\terror = xfs_trans_commit(tp, 0);\n\tif (error)\n\t\tgoto out_error;\n\treturn;\n\nout_abort:\n\txfs_trans_cancel(tp, XFS_TRANS_ABORT);\nout_error:\n\txfs_warn(mp, \"%s: failed to clear agi %d. Continuing.\", __func__, agno);\n\treturn;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: failed to clear agi %d. Continuing.\"",
            "__func__",
            "agno"
          ],
          "line": 3868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "XFS_TRANS_ABORT"
          ],
          "line": 3866
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 3860
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "agibp",
            "offset",
            "(offset + sizeof(xfs_agino_t) - 1)"
          ],
          "line": 3857
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGINO"
          ],
          "line": 3854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agibp"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_read_agi",
          "args": [
            "mp",
            "tp",
            "agno",
            "&agibp"
          ],
          "line": 3849
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_read_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2122-2142",
          "snippet": "int\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n};\n\nint\nxfs_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, bpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*bpp, XFS_AGI_REF);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_clearagi",
            "0",
            "0"
          ],
          "line": 3845
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_CLEAR_AGI_BUCKET"
          ],
          "line": 3844
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_recover_clear_agi_bucket(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno,\n\tint\t\tbucket)\n{\n\txfs_trans_t\t*tp;\n\txfs_agi_t\t*agi;\n\txfs_buf_t\t*agibp;\n\tint\t\toffset;\n\tint\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_CLEAR_AGI_BUCKET);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_clearagi, 0, 0);\n\tif (error)\n\t\tgoto out_abort;\n\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\tgoto out_abort;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\tagi->agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);\n\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t (sizeof(xfs_agino_t) * bucket);\n\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\n\terror = xfs_trans_commit(tp, 0);\n\tif (error)\n\t\tgoto out_error;\n\treturn;\n\nout_abort:\n\txfs_trans_cancel(tp, XFS_TRANS_ABORT);\nout_error:\n\txfs_warn(mp, \"%s: failed to clear agi %d. Continuing.\", __func__, agno);\n\treturn;\n}"
  },
  {
    "function_name": "xlog_recover_process_efis",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3780-3826",
    "snippet": "STATIC int\nxlog_recover_process_efis(\n\tstruct xlog\t*log)\n{\n\txfs_log_item_t\t\t*lip;\n\txfs_efi_log_item_t\t*efip;\n\tint\t\t\terror = 0;\n\tstruct xfs_ail_cursor\tcur;\n\tstruct xfs_ail\t\t*ailp;\n\n\tailp = log->l_ailp;\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, 0);\n\twhile (lip != NULL) {\n\t\t/*\n\t\t * We're done when we see something other than an EFI.\n\t\t * There should be no EFIs left in the AIL now.\n\t\t */\n\t\tif (lip->li_type != XFS_LI_EFI) {\n#ifdef DEBUG\n\t\t\tfor (; lip; lip = xfs_trans_ail_cursor_next(ailp, &cur))\n\t\t\t\tASSERT(lip->li_type != XFS_LI_EFI);\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Skip EFIs that we've already processed.\n\t\t */\n\t\tefip = (xfs_efi_log_item_t *)lip;\n\t\tif (test_bit(XFS_EFI_RECOVERED, &efip->efi_flags)) {\n\t\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_unlock(&ailp->xa_lock);\n\t\terror = xlog_recover_process_efi(log->l_mp, efip);\n\t\tspin_lock(&ailp->xa_lock);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t}\nout:\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 3824
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_done",
          "args": [
            "&cur"
          ],
          "line": 3823
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "173-179",
          "snippet": "void\nxfs_trans_ail_cursor_done(\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_del_init(&cur->list);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ail_cursor_done(\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_del_init(&cur->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_next",
          "args": [
            "ailp",
            "&cur"
          ],
          "line": 3820
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "155-167",
          "snippet": "struct xfs_log_item *\nxfs_trans_ail_cursor_next(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tstruct xfs_log_item\t*lip = cur->item;\n\n\tif ((__psint_t)lip & 1)\n\t\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_log_item *\nxfs_trans_ail_cursor_next(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tstruct xfs_log_item\t*lip = cur->item;\n\n\tif ((__psint_t)lip & 1)\n\t\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 3817
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_process_efi",
          "args": [
            "log->l_mp",
            "efip"
          ],
          "line": 3816
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_process_efi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3701-3760",
          "snippet": "STATIC int\nxlog_recover_process_efi(\n\txfs_mount_t\t\t*mp,\n\txfs_efi_log_item_t\t*efip)\n{\n\txfs_efd_log_item_t\t*efdp;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\ti;\n\tint\t\t\terror = 0;\n\txfs_extent_t\t\t*extp;\n\txfs_fsblock_t\t\tstartblock_fsb;\n\n\tASSERT(!test_bit(XFS_EFI_RECOVERED, &efip->efi_flags));\n\n\t/*\n\t * First check the validity of the extents described by the\n\t * EFI.  If any are bad, then assume that all are bad and\n\t * just toss the EFI.\n\t */\n\tfor (i = 0; i < efip->efi_format.efi_nextents; i++) {\n\t\textp = &(efip->efi_format.efi_extents[i]);\n\t\tstartblock_fsb = XFS_BB_TO_FSB(mp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, extp->ext_start));\n\t\tif ((startblock_fsb == 0) ||\n\t\t    (extp->ext_len == 0) ||\n\t\t    (startblock_fsb >= mp->m_sb.sb_dblocks) ||\n\t\t    (extp->ext_len >= mp->m_sb.sb_agblocks)) {\n\t\t\t/*\n\t\t\t * This will pull the EFI from the AIL and\n\t\t\t * free the memory associated with it.\n\t\t\t */\n\t\t\tset_bit(XFS_EFI_RECOVERED, &efip->efi_flags);\n\t\t\txfs_efi_release(efip, efip->efi_format.efi_nextents);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\ttp = xfs_trans_alloc(mp, 0);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto abort_error;\n\tefdp = xfs_trans_get_efd(tp, efip, efip->efi_format.efi_nextents);\n\n\tfor (i = 0; i < efip->efi_format.efi_nextents; i++) {\n\t\textp = &(efip->efi_format.efi_extents[i]);\n\t\terror = xfs_free_extent(tp, extp->ext_start, extp->ext_len);\n\t\tif (error)\n\t\t\tgoto abort_error;\n\t\txfs_trans_log_efd_extent(tp, efdp, extp->ext_start,\n\t\t\t\t\t extp->ext_len);\n\t}\n\n\tset_bit(XFS_EFI_RECOVERED, &efip->efi_flags);\n\terror = xfs_trans_commit(tp, 0);\n\treturn error;\n\nabort_error:\n\txfs_trans_cancel(tp, XFS_TRANS_ABORT);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_recover_process_efi(\n\txfs_mount_t\t\t*mp,\n\txfs_efi_log_item_t\t*efip)\n{\n\txfs_efd_log_item_t\t*efdp;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\ti;\n\tint\t\t\terror = 0;\n\txfs_extent_t\t\t*extp;\n\txfs_fsblock_t\t\tstartblock_fsb;\n\n\tASSERT(!test_bit(XFS_EFI_RECOVERED, &efip->efi_flags));\n\n\t/*\n\t * First check the validity of the extents described by the\n\t * EFI.  If any are bad, then assume that all are bad and\n\t * just toss the EFI.\n\t */\n\tfor (i = 0; i < efip->efi_format.efi_nextents; i++) {\n\t\textp = &(efip->efi_format.efi_extents[i]);\n\t\tstartblock_fsb = XFS_BB_TO_FSB(mp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, extp->ext_start));\n\t\tif ((startblock_fsb == 0) ||\n\t\t    (extp->ext_len == 0) ||\n\t\t    (startblock_fsb >= mp->m_sb.sb_dblocks) ||\n\t\t    (extp->ext_len >= mp->m_sb.sb_agblocks)) {\n\t\t\t/*\n\t\t\t * This will pull the EFI from the AIL and\n\t\t\t * free the memory associated with it.\n\t\t\t */\n\t\t\tset_bit(XFS_EFI_RECOVERED, &efip->efi_flags);\n\t\t\txfs_efi_release(efip, efip->efi_format.efi_nextents);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\ttp = xfs_trans_alloc(mp, 0);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto abort_error;\n\tefdp = xfs_trans_get_efd(tp, efip, efip->efi_format.efi_nextents);\n\n\tfor (i = 0; i < efip->efi_format.efi_nextents; i++) {\n\t\textp = &(efip->efi_format.efi_extents[i]);\n\t\terror = xfs_free_extent(tp, extp->ext_start, extp->ext_len);\n\t\tif (error)\n\t\t\tgoto abort_error;\n\t\txfs_trans_log_efd_extent(tp, efdp, extp->ext_start,\n\t\t\t\t\t extp->ext_len);\n\t}\n\n\tset_bit(XFS_EFI_RECOVERED, &efip->efi_flags);\n\terror = xfs_trans_commit(tp, 0);\n\treturn error;\n\nabort_error:\n\txfs_trans_cancel(tp, XFS_TRANS_ABORT);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "XFS_EFI_RECOVERED",
            "&efip->efi_flags"
          ],
          "line": 3810
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lip->li_type != XFS_LI_EFI"
          ],
          "line": 3801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_first",
          "args": [
            "ailp",
            "&cur",
            "0"
          ],
          "line": 3792
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "209-234",
          "snippet": "xfs_log_item_t *\nxfs_trans_ail_cursor_first(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\txfs_trans_ail_cursor_init(ailp, cur);\n\n\tif (lsn == 0) {\n\t\tlip = xfs_ail_min(ailp);\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) >= 0)\n\t\t\tgoto out;\n\t}\n\treturn NULL;\n\nout:\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_log_item_t *\nxfs_trans_ail_cursor_first(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\txfs_trans_ail_cursor_init(ailp, cur);\n\n\tif (lsn == 0) {\n\t\tlip = xfs_ail_min(ailp);\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) >= 0)\n\t\t\tgoto out;\n\t}\n\treturn NULL;\n\nout:\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_process_efis(\n\tstruct xlog\t*log)\n{\n\txfs_log_item_t\t\t*lip;\n\txfs_efi_log_item_t\t*efip;\n\tint\t\t\terror = 0;\n\tstruct xfs_ail_cursor\tcur;\n\tstruct xfs_ail\t\t*ailp;\n\n\tailp = log->l_ailp;\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, 0);\n\twhile (lip != NULL) {\n\t\t/*\n\t\t * We're done when we see something other than an EFI.\n\t\t * There should be no EFIs left in the AIL now.\n\t\t */\n\t\tif (lip->li_type != XFS_LI_EFI) {\n#ifdef DEBUG\n\t\t\tfor (; lip; lip = xfs_trans_ail_cursor_next(ailp, &cur))\n\t\t\t\tASSERT(lip->li_type != XFS_LI_EFI);\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Skip EFIs that we've already processed.\n\t\t */\n\t\tefip = (xfs_efi_log_item_t *)lip;\n\t\tif (test_bit(XFS_EFI_RECOVERED, &efip->efi_flags)) {\n\t\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_unlock(&ailp->xa_lock);\n\t\terror = xlog_recover_process_efi(log->l_mp, efip);\n\t\tspin_lock(&ailp->xa_lock);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t}\nout:\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_recover_process_efi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3701-3760",
    "snippet": "STATIC int\nxlog_recover_process_efi(\n\txfs_mount_t\t\t*mp,\n\txfs_efi_log_item_t\t*efip)\n{\n\txfs_efd_log_item_t\t*efdp;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\ti;\n\tint\t\t\terror = 0;\n\txfs_extent_t\t\t*extp;\n\txfs_fsblock_t\t\tstartblock_fsb;\n\n\tASSERT(!test_bit(XFS_EFI_RECOVERED, &efip->efi_flags));\n\n\t/*\n\t * First check the validity of the extents described by the\n\t * EFI.  If any are bad, then assume that all are bad and\n\t * just toss the EFI.\n\t */\n\tfor (i = 0; i < efip->efi_format.efi_nextents; i++) {\n\t\textp = &(efip->efi_format.efi_extents[i]);\n\t\tstartblock_fsb = XFS_BB_TO_FSB(mp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, extp->ext_start));\n\t\tif ((startblock_fsb == 0) ||\n\t\t    (extp->ext_len == 0) ||\n\t\t    (startblock_fsb >= mp->m_sb.sb_dblocks) ||\n\t\t    (extp->ext_len >= mp->m_sb.sb_agblocks)) {\n\t\t\t/*\n\t\t\t * This will pull the EFI from the AIL and\n\t\t\t * free the memory associated with it.\n\t\t\t */\n\t\t\tset_bit(XFS_EFI_RECOVERED, &efip->efi_flags);\n\t\t\txfs_efi_release(efip, efip->efi_format.efi_nextents);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\ttp = xfs_trans_alloc(mp, 0);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto abort_error;\n\tefdp = xfs_trans_get_efd(tp, efip, efip->efi_format.efi_nextents);\n\n\tfor (i = 0; i < efip->efi_format.efi_nextents; i++) {\n\t\textp = &(efip->efi_format.efi_extents[i]);\n\t\terror = xfs_free_extent(tp, extp->ext_start, extp->ext_len);\n\t\tif (error)\n\t\t\tgoto abort_error;\n\t\txfs_trans_log_efd_extent(tp, efdp, extp->ext_start,\n\t\t\t\t\t extp->ext_len);\n\t}\n\n\tset_bit(XFS_EFI_RECOVERED, &efip->efi_flags);\n\terror = xfs_trans_commit(tp, 0);\n\treturn error;\n\nabort_error:\n\txfs_trans_cancel(tp, XFS_TRANS_ABORT);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "XFS_TRANS_ABORT"
          ],
          "line": 3758
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 3754
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "XFS_EFI_RECOVERED",
            "&efip->efi_flags"
          ],
          "line": 3753
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_efd_extent",
          "args": [
            "tp",
            "efdp",
            "extp->ext_start",
            "extp->ext_len"
          ],
          "line": 3749
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_efd_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_extfree.c",
          "lines": "115-133",
          "snippet": "void\nxfs_trans_log_efd_extent(xfs_trans_t\t\t*tp,\n\t\t\t xfs_efd_log_item_t\t*efdp,\n\t\t\t xfs_fsblock_t\t\tstart_block,\n\t\t\t xfs_extlen_t\t\text_len)\n{\n\tuint\t\t\tnext_extent;\n\txfs_extent_t\t\t*extp;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tefdp->efd_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\tnext_extent = efdp->efd_next_extent;\n\tASSERT(next_extent < efdp->efd_format.efd_nextents);\n\textp = &(efdp->efd_format.efd_extents[next_extent]);\n\textp->ext_start = start_block;\n\textp->ext_len = ext_len;\n\tefdp->efd_next_extent++;\n}",
          "includes": [
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_extfree_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_efd_extent(xfs_trans_t\t\t*tp,\n\t\t\t xfs_efd_log_item_t\t*efdp,\n\t\t\t xfs_fsblock_t\t\tstart_block,\n\t\t\t xfs_extlen_t\t\text_len)\n{\n\tuint\t\t\tnext_extent;\n\txfs_extent_t\t\t*extp;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tefdp->efd_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\tnext_extent = efdp->efd_next_extent;\n\tASSERT(next_extent < efdp->efd_format.efd_nextents);\n\textp = &(efdp->efd_format.efd_extents[next_extent]);\n\textp->ext_start = start_block;\n\textp->ext_len = ext_len;\n\tefdp->efd_next_extent++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_free_extent",
          "args": [
            "tp",
            "extp->ext_start",
            "extp->ext_len"
          ],
          "line": 3746
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2587-2633",
          "snippet": "int\t\t\t\t/* error */\nxfs_free_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_fsblock_t\tbno,\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t/* length of extent */\n{\n\txfs_alloc_arg_t\targs;\n\tint\t\terror;\n\n\tASSERT(len != 0);\n\tmemset(&args, 0, sizeof(xfs_alloc_arg_t));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * validate that the block number is legal - the enables us to detect\n\t * and handle a silent filesystem corruption rather than crashing.\n\t */\n\targs.agno = XFS_FSB_TO_AGNO(args.mp, bno);\n\tif (args.agno >= args.mp->m_sb.sb_agcount)\n\t\treturn -EFSCORRUPTED;\n\n\targs.agbno = XFS_FSB_TO_AGBNO(args.mp, bno);\n\tif (args.agbno >= args.mp->m_sb.sb_agblocks)\n\t\treturn -EFSCORRUPTED;\n\n\targs.pag = xfs_perag_get(args.mp, args.agno);\n\tASSERT(args.pag);\n\n\terror = xfs_alloc_fix_freelist(&args, XFS_ALLOC_FLAG_FREEING);\n\tif (error)\n\t\tgoto error0;\n\n\t/* validate the extent size is legal now we have the agf locked */\n\tif (args.agbno + len >\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args.agbp)->agf_length)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\n\terror = xfs_free_ag_extent(tp, args.agbp, args.agno, args.agbno, len, 0);\n\tif (!error)\n\t\txfs_extent_busy_insert(tp, args.agno, args.agbno, len, 0);\nerror0:\n\txfs_perag_put(args.pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_free_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_fsblock_t\tbno,\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t/* length of extent */\n{\n\txfs_alloc_arg_t\targs;\n\tint\t\terror;\n\n\tASSERT(len != 0);\n\tmemset(&args, 0, sizeof(xfs_alloc_arg_t));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * validate that the block number is legal - the enables us to detect\n\t * and handle a silent filesystem corruption rather than crashing.\n\t */\n\targs.agno = XFS_FSB_TO_AGNO(args.mp, bno);\n\tif (args.agno >= args.mp->m_sb.sb_agcount)\n\t\treturn -EFSCORRUPTED;\n\n\targs.agbno = XFS_FSB_TO_AGBNO(args.mp, bno);\n\tif (args.agbno >= args.mp->m_sb.sb_agblocks)\n\t\treturn -EFSCORRUPTED;\n\n\targs.pag = xfs_perag_get(args.mp, args.agno);\n\tASSERT(args.pag);\n\n\terror = xfs_alloc_fix_freelist(&args, XFS_ALLOC_FLAG_FREEING);\n\tif (error)\n\t\tgoto error0;\n\n\t/* validate the extent size is legal now we have the agf locked */\n\tif (args.agbno + len >\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args.agbp)->agf_length)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\n\terror = xfs_free_ag_extent(tp, args.agbp, args.agno, args.agbno, len, 0);\n\tif (!error)\n\t\txfs_extent_busy_insert(tp, args.agno, args.agbno, len, 0);\nerror0:\n\txfs_perag_put(args.pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_efd",
          "args": [
            "tp",
            "efip",
            "efip->efi_format.efi_nextents"
          ],
          "line": 3742
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_efd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_extfree.c",
          "lines": "90-108",
          "snippet": "xfs_efd_log_item_t *\nxfs_trans_get_efd(xfs_trans_t\t\t*tp,\n\t\t  xfs_efi_log_item_t\t*efip,\n\t\t  uint\t\t\tnextents)\n{\n\txfs_efd_log_item_t\t*efdp;\n\n\tASSERT(tp != NULL);\n\tASSERT(nextents > 0);\n\n\tefdp = xfs_efd_init(tp->t_mountp, efip, nextents);\n\tASSERT(efdp != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &efdp->efd_item);\n\treturn efdp;\n}",
          "includes": [
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_extfree_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_efd_log_item_t *\nxfs_trans_get_efd(xfs_trans_t\t\t*tp,\n\t\t  xfs_efi_log_item_t\t*efip,\n\t\t  uint\t\t\tnextents)\n{\n\txfs_efd_log_item_t\t*efdp;\n\n\tASSERT(tp != NULL);\n\tASSERT(nextents > 0);\n\n\tefdp = xfs_efd_init(tp->t_mountp, efip, nextents);\n\tASSERT(efdp != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &efdp->efd_item);\n\treturn efdp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_itruncate",
            "0",
            "0"
          ],
          "line": 3739
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "0"
          ],
          "line": 3738
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_efi_release",
          "args": [
            "efip",
            "efip->efi_format.efi_nextents"
          ],
          "line": 3733
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_efi_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extfree_item.c",
          "lines": "309-322",
          "snippet": "void\nxfs_efi_release(xfs_efi_log_item_t\t*efip,\n\t\tuint\t\t\tnextents)\n{\n\tASSERT(atomic_read(&efip->efi_next_extent) >= nextents);\n\tif (atomic_sub_and_test(nextents, &efip->efi_next_extent)) {\n\t\t/* recovery needs us to drop the EFI reference, too */\n\t\tif (test_bit(XFS_EFI_RECOVERED, &efip->efi_flags))\n\t\t\t__xfs_efi_release(efip);\n\n\t\t__xfs_efi_release(efip);\n\t\t/* efip may now have been freed, do not reference it again. */\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_efi_release(xfs_efi_log_item_t\t*efip,\n\t\tuint\t\t\tnextents)\n{\n\tASSERT(atomic_read(&efip->efi_next_extent) >= nextents);\n\tif (atomic_sub_and_test(nextents, &efip->efi_next_extent)) {\n\t\t/* recovery needs us to drop the EFI reference, too */\n\t\tif (test_bit(XFS_EFI_RECOVERED, &efip->efi_flags))\n\t\t\t__xfs_efi_release(efip);\n\n\t\t__xfs_efi_release(efip);\n\t\t/* efip may now have been freed, do not reference it again. */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BB_TO_FSB",
          "args": [
            "mp",
            "XFS_FSB_TO_DADDR(mp, extp->ext_start)"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "extp->ext_start"
          ],
          "line": 3723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!test_bit(XFS_EFI_RECOVERED, &efip->efi_flags)"
          ],
          "line": 3713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "XFS_EFI_RECOVERED",
            "&efip->efi_flags"
          ],
          "line": 3713
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_recover_process_efi(\n\txfs_mount_t\t\t*mp,\n\txfs_efi_log_item_t\t*efip)\n{\n\txfs_efd_log_item_t\t*efdp;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\ti;\n\tint\t\t\terror = 0;\n\txfs_extent_t\t\t*extp;\n\txfs_fsblock_t\t\tstartblock_fsb;\n\n\tASSERT(!test_bit(XFS_EFI_RECOVERED, &efip->efi_flags));\n\n\t/*\n\t * First check the validity of the extents described by the\n\t * EFI.  If any are bad, then assume that all are bad and\n\t * just toss the EFI.\n\t */\n\tfor (i = 0; i < efip->efi_format.efi_nextents; i++) {\n\t\textp = &(efip->efi_format.efi_extents[i]);\n\t\tstartblock_fsb = XFS_BB_TO_FSB(mp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, extp->ext_start));\n\t\tif ((startblock_fsb == 0) ||\n\t\t    (extp->ext_len == 0) ||\n\t\t    (startblock_fsb >= mp->m_sb.sb_dblocks) ||\n\t\t    (extp->ext_len >= mp->m_sb.sb_agblocks)) {\n\t\t\t/*\n\t\t\t * This will pull the EFI from the AIL and\n\t\t\t * free the memory associated with it.\n\t\t\t */\n\t\t\tset_bit(XFS_EFI_RECOVERED, &efip->efi_flags);\n\t\t\txfs_efi_release(efip, efip->efi_format.efi_nextents);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\ttp = xfs_trans_alloc(mp, 0);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto abort_error;\n\tefdp = xfs_trans_get_efd(tp, efip, efip->efi_format.efi_nextents);\n\n\tfor (i = 0; i < efip->efi_format.efi_nextents; i++) {\n\t\textp = &(efip->efi_format.efi_extents[i]);\n\t\terror = xfs_free_extent(tp, extp->ext_start, extp->ext_len);\n\t\tif (error)\n\t\t\tgoto abort_error;\n\t\txfs_trans_log_efd_extent(tp, efdp, extp->ext_start,\n\t\t\t\t\t extp->ext_len);\n\t}\n\n\tset_bit(XFS_EFI_RECOVERED, &efip->efi_flags);\n\terror = xfs_trans_commit(tp, 0);\n\treturn error;\n\nabort_error:\n\txfs_trans_cancel(tp, XFS_TRANS_ABORT);\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_recover_process_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3659-3695",
    "snippet": "STATIC int\nxlog_recover_process_data(\n\tstruct xlog\t\t*log,\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\txfs_caddr_t\t\tdp,\n\tint\t\t\tpass)\n{\n\tstruct xlog_op_header\t*ohead;\n\txfs_caddr_t\t\tend;\n\tint\t\t\tnum_logops;\n\tint\t\t\terror;\n\n\tend = dp + be32_to_cpu(rhead->h_len);\n\tnum_logops = be32_to_cpu(rhead->h_num_logops);\n\n\t/* check the log format matches our own - else we can't recover */\n\tif (xlog_header_check_recover(log->l_mp, rhead))\n\t\treturn -EIO;\n\n\twhile ((dp < end) && num_logops) {\n\n\t\tohead = (struct xlog_op_header *)dp;\n\t\tdp += sizeof(*ohead);\n\t\tASSERT(dp <= end);\n\n\t\t/* errors will abort recovery */\n\t\terror = xlog_recover_process_ophdr(log, rhash, rhead, ohead,\n\t\t\t\t\t\t    dp, end, pass);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdp += be32_to_cpu(ohead->oh_len);\n\t\tnum_logops--;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ohead->oh_len"
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_recover_process_ophdr",
          "args": [
            "log",
            "rhash",
            "rhead",
            "ohead",
            "dp",
            "end",
            "pass"
          ],
          "line": 3686
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_process_ophdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3608-3648",
          "snippet": "STATIC int\nxlog_recover_process_ophdr(\n\tstruct xlog\t\t*log,\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\tstruct xlog_op_header\t*ohead,\n\txfs_caddr_t\t\tdp,\n\txfs_caddr_t\t\tend,\n\tint\t\t\tpass)\n{\n\tstruct xlog_recover\t*trans;\n\tunsigned int\t\tlen;\n\n\t/* Do we understand who wrote this op? */\n\tif (ohead->oh_clientid != XFS_TRANSACTION &&\n\t    ohead->oh_clientid != XFS_LOG) {\n\t\txfs_warn(log->l_mp, \"%s: bad clientid 0x%x\",\n\t\t\t__func__, ohead->oh_clientid);\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Check the ophdr contains all the data it is supposed to contain.\n\t */\n\tlen = be32_to_cpu(ohead->oh_len);\n\tif (dp + len > end) {\n\t\txfs_warn(log->l_mp, \"%s: bad length 0x%x\", __func__, len);\n\t\tWARN_ON(1);\n\t\treturn -EIO;\n\t}\n\n\ttrans = xlog_recover_ophdr_to_trans(rhash, rhead, ohead);\n\tif (!trans) {\n\t\t/* nothing to do, so skip over this ophdr */\n\t\treturn 0;\n\t}\n\n\treturn xlog_recovery_process_trans(log, trans, dp, len,\n\t\t\t\t\t   ohead->oh_flags, pass);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_process_ophdr(\n\tstruct xlog\t\t*log,\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\tstruct xlog_op_header\t*ohead,\n\txfs_caddr_t\t\tdp,\n\txfs_caddr_t\t\tend,\n\tint\t\t\tpass)\n{\n\tstruct xlog_recover\t*trans;\n\tunsigned int\t\tlen;\n\n\t/* Do we understand who wrote this op? */\n\tif (ohead->oh_clientid != XFS_TRANSACTION &&\n\t    ohead->oh_clientid != XFS_LOG) {\n\t\txfs_warn(log->l_mp, \"%s: bad clientid 0x%x\",\n\t\t\t__func__, ohead->oh_clientid);\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Check the ophdr contains all the data it is supposed to contain.\n\t */\n\tlen = be32_to_cpu(ohead->oh_len);\n\tif (dp + len > end) {\n\t\txfs_warn(log->l_mp, \"%s: bad length 0x%x\", __func__, len);\n\t\tWARN_ON(1);\n\t\treturn -EIO;\n\t}\n\n\ttrans = xlog_recover_ophdr_to_trans(rhash, rhead, ohead);\n\tif (!trans) {\n\t\t/* nothing to do, so skip over this ophdr */\n\t\treturn 0;\n\t}\n\n\treturn xlog_recovery_process_trans(log, trans, dp, len,\n\t\t\t\t\t   ohead->oh_flags, pass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp <= end"
          ],
          "line": 3683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_header_check_recover",
          "args": [
            "log->l_mp",
            "rhead"
          ],
          "line": 3676
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_header_check_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "309-337",
          "snippet": "STATIC int\nxlog_header_check_recover(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\tASSERT(head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM));\n\n\t/*\n\t * IRIX doesn't write the h_fmt field and leaves it zeroed\n\t * (XLOG_FMT_UNKNOWN). This stops us from trying to recover\n\t * a dirty log created in IRIX.\n\t */\n\tif (unlikely(head->h_fmt != cpu_to_be32(XLOG_FMT))) {\n\t\txfs_warn(mp,\n\t\"dirty log written in incompatible format - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\tXFS_ERROR_REPORT(\"xlog_header_check_recover(1)\",\n\t\t\t\t XFS_ERRLEVEL_HIGH, mp);\n\t\treturn -EFSCORRUPTED;\n\t} else if (unlikely(!uuid_equal(&mp->m_sb.sb_uuid, &head->h_fs_uuid))) {\n\t\txfs_warn(mp,\n\t\"dirty log entry has mismatched uuid - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\tXFS_ERROR_REPORT(\"xlog_header_check_recover(2)\",\n\t\t\t\t XFS_ERRLEVEL_HIGH, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_header_check_recover(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\tASSERT(head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM));\n\n\t/*\n\t * IRIX doesn't write the h_fmt field and leaves it zeroed\n\t * (XLOG_FMT_UNKNOWN). This stops us from trying to recover\n\t * a dirty log created in IRIX.\n\t */\n\tif (unlikely(head->h_fmt != cpu_to_be32(XLOG_FMT))) {\n\t\txfs_warn(mp,\n\t\"dirty log written in incompatible format - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\tXFS_ERROR_REPORT(\"xlog_header_check_recover(1)\",\n\t\t\t\t XFS_ERRLEVEL_HIGH, mp);\n\t\treturn -EFSCORRUPTED;\n\t} else if (unlikely(!uuid_equal(&mp->m_sb.sb_uuid, &head->h_fs_uuid))) {\n\t\txfs_warn(mp,\n\t\"dirty log entry has mismatched uuid - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\tXFS_ERROR_REPORT(\"xlog_header_check_recover(2)\",\n\t\t\t\t XFS_ERRLEVEL_HIGH, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_num_logops"
          ],
          "line": 3673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_len"
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_process_data(\n\tstruct xlog\t\t*log,\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\txfs_caddr_t\t\tdp,\n\tint\t\t\tpass)\n{\n\tstruct xlog_op_header\t*ohead;\n\txfs_caddr_t\t\tend;\n\tint\t\t\tnum_logops;\n\tint\t\t\terror;\n\n\tend = dp + be32_to_cpu(rhead->h_len);\n\tnum_logops = be32_to_cpu(rhead->h_num_logops);\n\n\t/* check the log format matches our own - else we can't recover */\n\tif (xlog_header_check_recover(log->l_mp, rhead))\n\t\treturn -EIO;\n\n\twhile ((dp < end) && num_logops) {\n\n\t\tohead = (struct xlog_op_header *)dp;\n\t\tdp += sizeof(*ohead);\n\t\tASSERT(dp <= end);\n\n\t\t/* errors will abort recovery */\n\t\terror = xlog_recover_process_ophdr(log, rhash, rhead, ohead,\n\t\t\t\t\t\t    dp, end, pass);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdp += be32_to_cpu(ohead->oh_len);\n\t\tnum_logops--;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_recover_process_ophdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3608-3648",
    "snippet": "STATIC int\nxlog_recover_process_ophdr(\n\tstruct xlog\t\t*log,\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\tstruct xlog_op_header\t*ohead,\n\txfs_caddr_t\t\tdp,\n\txfs_caddr_t\t\tend,\n\tint\t\t\tpass)\n{\n\tstruct xlog_recover\t*trans;\n\tunsigned int\t\tlen;\n\n\t/* Do we understand who wrote this op? */\n\tif (ohead->oh_clientid != XFS_TRANSACTION &&\n\t    ohead->oh_clientid != XFS_LOG) {\n\t\txfs_warn(log->l_mp, \"%s: bad clientid 0x%x\",\n\t\t\t__func__, ohead->oh_clientid);\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Check the ophdr contains all the data it is supposed to contain.\n\t */\n\tlen = be32_to_cpu(ohead->oh_len);\n\tif (dp + len > end) {\n\t\txfs_warn(log->l_mp, \"%s: bad length 0x%x\", __func__, len);\n\t\tWARN_ON(1);\n\t\treturn -EIO;\n\t}\n\n\ttrans = xlog_recover_ophdr_to_trans(rhash, rhead, ohead);\n\tif (!trans) {\n\t\t/* nothing to do, so skip over this ophdr */\n\t\treturn 0;\n\t}\n\n\treturn xlog_recovery_process_trans(log, trans, dp, len,\n\t\t\t\t\t   ohead->oh_flags, pass);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_recovery_process_trans",
          "args": [
            "log",
            "trans",
            "dp",
            "len",
            "ohead->oh_flags",
            "pass"
          ],
          "line": 3646
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recovery_process_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3503-3555",
          "snippet": "STATIC int\nxlog_recovery_process_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\txfs_caddr_t\t\tdp,\n\tunsigned int\t\tlen,\n\tunsigned int\t\tflags,\n\tint\t\t\tpass)\n{\n\tint\t\t\terror = 0;\n\tbool\t\t\tfreeit = false;\n\n\t/* mask off ophdr transaction container flags */\n\tflags &= ~XLOG_END_TRANS;\n\tif (flags & XLOG_WAS_CONT_TRANS)\n\t\tflags &= ~XLOG_CONTINUE_TRANS;\n\n\t/*\n\t * Callees must not free the trans structure. We'll decide if we need to\n\t * free it or not based on the operation being done and it's result.\n\t */\n\tswitch (flags) {\n\t/* expected flag values */\n\tcase 0:\n\tcase XLOG_CONTINUE_TRANS:\n\t\terror = xlog_recover_add_to_trans(log, trans, dp, len);\n\t\tbreak;\n\tcase XLOG_WAS_CONT_TRANS:\n\t\terror = xlog_recover_add_to_cont_trans(log, trans, dp, len);\n\t\tbreak;\n\tcase XLOG_COMMIT_TRANS:\n\t\terror = xlog_recover_commit_trans(log, trans, pass);\n\t\t/* success or fail, we are now done with this transaction. */\n\t\tfreeit = true;\n\t\tbreak;\n\n\t/* unexpected flag values */\n\tcase XLOG_UNMOUNT_TRANS:\n\t\t/* just skip trans */\n\t\txfs_warn(log->l_mp, \"%s: Unmount LR\", __func__);\n\t\tfreeit = true;\n\t\tbreak;\n\tcase XLOG_START_TRANS:\n\tdefault:\n\t\txfs_warn(log->l_mp, \"%s: bad flag 0x%x\", __func__, flags);\n\t\tASSERT(0);\n\t\terror = -EIO;\n\t\tbreak;\n\t}\n\tif (error || freeit)\n\t\txlog_recover_free_trans(trans);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recovery_process_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\txfs_caddr_t\t\tdp,\n\tunsigned int\t\tlen,\n\tunsigned int\t\tflags,\n\tint\t\t\tpass)\n{\n\tint\t\t\terror = 0;\n\tbool\t\t\tfreeit = false;\n\n\t/* mask off ophdr transaction container flags */\n\tflags &= ~XLOG_END_TRANS;\n\tif (flags & XLOG_WAS_CONT_TRANS)\n\t\tflags &= ~XLOG_CONTINUE_TRANS;\n\n\t/*\n\t * Callees must not free the trans structure. We'll decide if we need to\n\t * free it or not based on the operation being done and it's result.\n\t */\n\tswitch (flags) {\n\t/* expected flag values */\n\tcase 0:\n\tcase XLOG_CONTINUE_TRANS:\n\t\terror = xlog_recover_add_to_trans(log, trans, dp, len);\n\t\tbreak;\n\tcase XLOG_WAS_CONT_TRANS:\n\t\terror = xlog_recover_add_to_cont_trans(log, trans, dp, len);\n\t\tbreak;\n\tcase XLOG_COMMIT_TRANS:\n\t\terror = xlog_recover_commit_trans(log, trans, pass);\n\t\t/* success or fail, we are now done with this transaction. */\n\t\tfreeit = true;\n\t\tbreak;\n\n\t/* unexpected flag values */\n\tcase XLOG_UNMOUNT_TRANS:\n\t\t/* just skip trans */\n\t\txfs_warn(log->l_mp, \"%s: Unmount LR\", __func__);\n\t\tfreeit = true;\n\t\tbreak;\n\tcase XLOG_START_TRANS:\n\tdefault:\n\t\txfs_warn(log->l_mp, \"%s: bad flag 0x%x\", __func__, flags);\n\t\tASSERT(0);\n\t\terror = -EIO;\n\t\tbreak;\n\t}\n\tif (error || freeit)\n\t\txlog_recover_free_trans(trans);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_ophdr_to_trans",
          "args": [
            "rhash",
            "rhead",
            "ohead"
          ],
          "line": 3640
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_ophdr_to_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3564-3606",
          "snippet": "xlog_recover *\nxlog_recover_ophdr_to_trans(\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\tstruct xlog_op_header\t*ohead)\n{\n\tstruct xlog_recover\t*trans;\n\txlog_tid_t\t\ttid;\n\tstruct hlist_head\t*rhp;\n\n\ttid = be32_to_cpu(ohead->oh_tid);\n\trhp = &rhash[XLOG_RHASH(tid)];\n\thlist_for_each_entry(trans, rhp, r_list) {\n\t\tif (trans->r_log_tid == tid)\n\t\t\treturn trans;\n\t}\n\n\t/*\n\t * skip over non-start transaction headers - we could be\n\t * processing slack space before the next transaction starts\n\t */\n\tif (!(ohead->oh_flags & XLOG_START_TRANS))\n\t\treturn NULL;\n\n\tASSERT(be32_to_cpu(ohead->oh_len) == 0);\n\n\t/*\n\t * This is a new transaction so allocate a new recovery container to\n\t * hold the recovery ops that will follow.\n\t */\n\ttrans = kmem_zalloc(sizeof(struct xlog_recover), KM_SLEEP);\n\ttrans->r_log_tid = tid;\n\ttrans->r_lsn = be64_to_cpu(rhead->h_lsn);\n\tINIT_LIST_HEAD(&trans->r_itemq);\n\tINIT_HLIST_NODE(&trans->r_list);\n\thlist_add_head(&trans->r_list, rhp);\n\n\t/*\n\t * Nothing more to do for this ophdr. Items to be added to this new\n\t * transaction will be in subsequent ophdr containers.\n\t */\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxlog_recover *\nxlog_recover_ophdr_to_trans(\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\tstruct xlog_op_header\t*ohead)\n{\n\tstruct xlog_recover\t*trans;\n\txlog_tid_t\t\ttid;\n\tstruct hlist_head\t*rhp;\n\n\ttid = be32_to_cpu(ohead->oh_tid);\n\trhp = &rhash[XLOG_RHASH(tid)];\n\thlist_for_each_entry(trans, rhp, r_list) {\n\t\tif (trans->r_log_tid == tid)\n\t\t\treturn trans;\n\t}\n\n\t/*\n\t * skip over non-start transaction headers - we could be\n\t * processing slack space before the next transaction starts\n\t */\n\tif (!(ohead->oh_flags & XLOG_START_TRANS))\n\t\treturn NULL;\n\n\tASSERT(be32_to_cpu(ohead->oh_len) == 0);\n\n\t/*\n\t * This is a new transaction so allocate a new recovery container to\n\t * hold the recovery ops that will follow.\n\t */\n\ttrans = kmem_zalloc(sizeof(struct xlog_recover), KM_SLEEP);\n\ttrans->r_log_tid = tid;\n\ttrans->r_lsn = be64_to_cpu(rhead->h_lsn);\n\tINIT_LIST_HEAD(&trans->r_itemq);\n\tINIT_HLIST_NODE(&trans->r_list);\n\thlist_add_head(&trans->r_list, rhp);\n\n\t/*\n\t * Nothing more to do for this ophdr. Items to be added to this new\n\t * transaction will be in subsequent ophdr containers.\n\t */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"%s: bad length 0x%x\"",
            "__func__",
            "len"
          ],
          "line": 3635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ohead->oh_len"
          ],
          "line": 3633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"%s: bad clientid 0x%x\"",
            "__func__",
            "ohead->oh_clientid"
          ],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_process_ophdr(\n\tstruct xlog\t\t*log,\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\tstruct xlog_op_header\t*ohead,\n\txfs_caddr_t\t\tdp,\n\txfs_caddr_t\t\tend,\n\tint\t\t\tpass)\n{\n\tstruct xlog_recover\t*trans;\n\tunsigned int\t\tlen;\n\n\t/* Do we understand who wrote this op? */\n\tif (ohead->oh_clientid != XFS_TRANSACTION &&\n\t    ohead->oh_clientid != XFS_LOG) {\n\t\txfs_warn(log->l_mp, \"%s: bad clientid 0x%x\",\n\t\t\t__func__, ohead->oh_clientid);\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Check the ophdr contains all the data it is supposed to contain.\n\t */\n\tlen = be32_to_cpu(ohead->oh_len);\n\tif (dp + len > end) {\n\t\txfs_warn(log->l_mp, \"%s: bad length 0x%x\", __func__, len);\n\t\tWARN_ON(1);\n\t\treturn -EIO;\n\t}\n\n\ttrans = xlog_recover_ophdr_to_trans(rhash, rhead, ohead);\n\tif (!trans) {\n\t\t/* nothing to do, so skip over this ophdr */\n\t\treturn 0;\n\t}\n\n\treturn xlog_recovery_process_trans(log, trans, dp, len,\n\t\t\t\t\t   ohead->oh_flags, pass);\n}"
  },
  {
    "function_name": "xlog_recover_ophdr_to_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3564-3606",
    "snippet": "xlog_recover *\nxlog_recover_ophdr_to_trans(\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\tstruct xlog_op_header\t*ohead)\n{\n\tstruct xlog_recover\t*trans;\n\txlog_tid_t\t\ttid;\n\tstruct hlist_head\t*rhp;\n\n\ttid = be32_to_cpu(ohead->oh_tid);\n\trhp = &rhash[XLOG_RHASH(tid)];\n\thlist_for_each_entry(trans, rhp, r_list) {\n\t\tif (trans->r_log_tid == tid)\n\t\t\treturn trans;\n\t}\n\n\t/*\n\t * skip over non-start transaction headers - we could be\n\t * processing slack space before the next transaction starts\n\t */\n\tif (!(ohead->oh_flags & XLOG_START_TRANS))\n\t\treturn NULL;\n\n\tASSERT(be32_to_cpu(ohead->oh_len) == 0);\n\n\t/*\n\t * This is a new transaction so allocate a new recovery container to\n\t * hold the recovery ops that will follow.\n\t */\n\ttrans = kmem_zalloc(sizeof(struct xlog_recover), KM_SLEEP);\n\ttrans->r_log_tid = tid;\n\ttrans->r_lsn = be64_to_cpu(rhead->h_lsn);\n\tINIT_LIST_HEAD(&trans->r_itemq);\n\tINIT_HLIST_NODE(&trans->r_list);\n\thlist_add_head(&trans->r_list, rhp);\n\n\t/*\n\t * Nothing more to do for this ophdr. Items to be added to this new\n\t * transaction will be in subsequent ophdr containers.\n\t */\n\treturn NULL;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&trans->r_list",
            "rhp"
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&trans->r_list"
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&trans->r_itemq"
          ],
          "line": 3597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "rhead->h_lsn"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(struct xlog_recover)",
            "KM_SLEEP"
          ],
          "line": 3594
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be32_to_cpu(ohead->oh_len) == 0"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ohead->oh_len"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "trans",
            "rhp",
            "r_list"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_RHASH",
          "args": [
            "tid"
          ],
          "line": 3575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ohead->oh_tid"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxlog_recover *\nxlog_recover_ophdr_to_trans(\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\tstruct xlog_op_header\t*ohead)\n{\n\tstruct xlog_recover\t*trans;\n\txlog_tid_t\t\ttid;\n\tstruct hlist_head\t*rhp;\n\n\ttid = be32_to_cpu(ohead->oh_tid);\n\trhp = &rhash[XLOG_RHASH(tid)];\n\thlist_for_each_entry(trans, rhp, r_list) {\n\t\tif (trans->r_log_tid == tid)\n\t\t\treturn trans;\n\t}\n\n\t/*\n\t * skip over non-start transaction headers - we could be\n\t * processing slack space before the next transaction starts\n\t */\n\tif (!(ohead->oh_flags & XLOG_START_TRANS))\n\t\treturn NULL;\n\n\tASSERT(be32_to_cpu(ohead->oh_len) == 0);\n\n\t/*\n\t * This is a new transaction so allocate a new recovery container to\n\t * hold the recovery ops that will follow.\n\t */\n\ttrans = kmem_zalloc(sizeof(struct xlog_recover), KM_SLEEP);\n\ttrans->r_log_tid = tid;\n\ttrans->r_lsn = be64_to_cpu(rhead->h_lsn);\n\tINIT_LIST_HEAD(&trans->r_itemq);\n\tINIT_HLIST_NODE(&trans->r_list);\n\thlist_add_head(&trans->r_list, rhp);\n\n\t/*\n\t * Nothing more to do for this ophdr. Items to be added to this new\n\t * transaction will be in subsequent ophdr containers.\n\t */\n\treturn NULL;\n}"
  },
  {
    "function_name": "xlog_recovery_process_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3503-3555",
    "snippet": "STATIC int\nxlog_recovery_process_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\txfs_caddr_t\t\tdp,\n\tunsigned int\t\tlen,\n\tunsigned int\t\tflags,\n\tint\t\t\tpass)\n{\n\tint\t\t\terror = 0;\n\tbool\t\t\tfreeit = false;\n\n\t/* mask off ophdr transaction container flags */\n\tflags &= ~XLOG_END_TRANS;\n\tif (flags & XLOG_WAS_CONT_TRANS)\n\t\tflags &= ~XLOG_CONTINUE_TRANS;\n\n\t/*\n\t * Callees must not free the trans structure. We'll decide if we need to\n\t * free it or not based on the operation being done and it's result.\n\t */\n\tswitch (flags) {\n\t/* expected flag values */\n\tcase 0:\n\tcase XLOG_CONTINUE_TRANS:\n\t\terror = xlog_recover_add_to_trans(log, trans, dp, len);\n\t\tbreak;\n\tcase XLOG_WAS_CONT_TRANS:\n\t\terror = xlog_recover_add_to_cont_trans(log, trans, dp, len);\n\t\tbreak;\n\tcase XLOG_COMMIT_TRANS:\n\t\terror = xlog_recover_commit_trans(log, trans, pass);\n\t\t/* success or fail, we are now done with this transaction. */\n\t\tfreeit = true;\n\t\tbreak;\n\n\t/* unexpected flag values */\n\tcase XLOG_UNMOUNT_TRANS:\n\t\t/* just skip trans */\n\t\txfs_warn(log->l_mp, \"%s: Unmount LR\", __func__);\n\t\tfreeit = true;\n\t\tbreak;\n\tcase XLOG_START_TRANS:\n\tdefault:\n\t\txfs_warn(log->l_mp, \"%s: bad flag 0x%x\", __func__, flags);\n\t\tASSERT(0);\n\t\terror = -EIO;\n\t\tbreak;\n\t}\n\tif (error || freeit)\n\t\txlog_recover_free_trans(trans);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_recover_free_trans",
          "args": [
            "trans"
          ],
          "line": 3553
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_free_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3480-3498",
          "snippet": "STATIC void\nxlog_recover_free_trans(\n\tstruct xlog_recover\t*trans)\n{\n\txlog_recover_item_t\t*item, *n;\n\tint\t\t\ti;\n\n\tlist_for_each_entry_safe(item, n, &trans->r_itemq, ri_list) {\n\t\t/* Free the regions in the item. */\n\t\tlist_del(&item->ri_list);\n\t\tfor (i = 0; i < item->ri_cnt; i++)\n\t\t\tkmem_free(item->ri_buf[i].i_addr);\n\t\t/* Free the item itself */\n\t\tkmem_free(item->ri_buf);\n\t\tkmem_free(item);\n\t}\n\t/* Free the transaction recover structure */\n\tkmem_free(trans);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_free_trans(\n\tstruct xlog_recover\t*trans)\n{\n\txlog_recover_item_t\t*item, *n;\n\tint\t\t\ti;\n\n\tlist_for_each_entry_safe(item, n, &trans->r_itemq, ri_list) {\n\t\t/* Free the regions in the item. */\n\t\tlist_del(&item->ri_list);\n\t\tfor (i = 0; i < item->ri_cnt; i++)\n\t\t\tkmem_free(item->ri_buf[i].i_addr);\n\t\t/* Free the item itself */\n\t\tkmem_free(item->ri_buf);\n\t\tkmem_free(item);\n\t}\n\t/* Free the transaction recover structure */\n\tkmem_free(trans);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"%s: bad flag 0x%x\"",
            "__func__",
            "flags"
          ],
          "line": 3547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"%s: Unmount LR\"",
            "__func__"
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_recover_commit_trans",
          "args": [
            "log",
            "trans",
            "pass"
          ],
          "line": 3534
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3289-3350",
          "snippet": "STATIC int\nxlog_recover_commit_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\tint\t\t\tpass)\n{\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\terror2;\n\tint\t\t\t\titems_queued = 0;\n\tstruct xlog_recover_item\t*item;\n\tstruct xlog_recover_item\t*next;\n\tLIST_HEAD\t\t\t(buffer_list);\n\tLIST_HEAD\t\t\t(ra_list);\n\tLIST_HEAD\t\t\t(done_list);\n\n\t#define XLOG_RECOVER_COMMIT_QUEUE_MAX 100\n\n\thlist_del(&trans->r_list);\n\n\terror = xlog_recover_reorder_trans(log, trans, pass);\n\tif (error)\n\t\treturn error;\n\n\tlist_for_each_entry_safe(item, next, &trans->r_itemq, ri_list) {\n\t\tswitch (pass) {\n\t\tcase XLOG_RECOVER_PASS1:\n\t\t\terror = xlog_recover_commit_pass1(log, trans, item);\n\t\t\tbreak;\n\t\tcase XLOG_RECOVER_PASS2:\n\t\t\txlog_recover_ra_pass2(log, item);\n\t\t\tlist_move_tail(&item->ri_list, &ra_list);\n\t\t\titems_queued++;\n\t\t\tif (items_queued >= XLOG_RECOVER_COMMIT_QUEUE_MAX) {\n\t\t\t\terror = xlog_recover_items_pass2(log, trans,\n\t\t\t\t\t\t&buffer_list, &ra_list);\n\t\t\t\tlist_splice_tail_init(&ra_list, &done_list);\n\t\t\t\titems_queued = 0;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (!list_empty(&ra_list)) {\n\t\tif (!error)\n\t\t\terror = xlog_recover_items_pass2(log, trans,\n\t\t\t\t\t&buffer_list, &ra_list);\n\t\tlist_splice_tail_init(&ra_list, &done_list);\n\t}\n\n\tif (!list_empty(&done_list))\n\t\tlist_splice_init(&done_list, &trans->r_itemq);\n\n\terror2 = xfs_buf_delwri_submit(&buffer_list);\n\treturn error ? error : error2;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define XLOG_RECOVER_COMMIT_QUEUE_MAX 100"
          ],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XLOG_RECOVER_COMMIT_QUEUE_MAX 100\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_commit_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\tint\t\t\tpass)\n{\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\terror2;\n\tint\t\t\t\titems_queued = 0;\n\tstruct xlog_recover_item\t*item;\n\tstruct xlog_recover_item\t*next;\n\tLIST_HEAD\t\t\t(buffer_list);\n\tLIST_HEAD\t\t\t(ra_list);\n\tLIST_HEAD\t\t\t(done_list);\n\n\t#define XLOG_RECOVER_COMMIT_QUEUE_MAX 100\n\n\thlist_del(&trans->r_list);\n\n\terror = xlog_recover_reorder_trans(log, trans, pass);\n\tif (error)\n\t\treturn error;\n\n\tlist_for_each_entry_safe(item, next, &trans->r_itemq, ri_list) {\n\t\tswitch (pass) {\n\t\tcase XLOG_RECOVER_PASS1:\n\t\t\terror = xlog_recover_commit_pass1(log, trans, item);\n\t\t\tbreak;\n\t\tcase XLOG_RECOVER_PASS2:\n\t\t\txlog_recover_ra_pass2(log, item);\n\t\t\tlist_move_tail(&item->ri_list, &ra_list);\n\t\t\titems_queued++;\n\t\t\tif (items_queued >= XLOG_RECOVER_COMMIT_QUEUE_MAX) {\n\t\t\t\terror = xlog_recover_items_pass2(log, trans,\n\t\t\t\t\t\t&buffer_list, &ra_list);\n\t\t\t\tlist_splice_tail_init(&ra_list, &done_list);\n\t\t\t\titems_queued = 0;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (!list_empty(&ra_list)) {\n\t\tif (!error)\n\t\t\terror = xlog_recover_items_pass2(log, trans,\n\t\t\t\t\t&buffer_list, &ra_list);\n\t\tlist_splice_tail_init(&ra_list, &done_list);\n\t}\n\n\tif (!list_empty(&done_list))\n\t\tlist_splice_init(&done_list, &trans->r_itemq);\n\n\terror2 = xfs_buf_delwri_submit(&buffer_list);\n\treturn error ? error : error2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_add_to_cont_trans",
          "args": [
            "log",
            "trans",
            "dp",
            "len"
          ],
          "line": 3531
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_add_to_cont_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3363-3394",
          "snippet": "STATIC int\nxlog_recover_add_to_cont_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\txfs_caddr_t\t\tdp,\n\tint\t\t\tlen)\n{\n\txlog_recover_item_t\t*item;\n\txfs_caddr_t\t\tptr, old_ptr;\n\tint\t\t\told_len;\n\n\tif (list_empty(&trans->r_itemq)) {\n\t\t/* finish copying rest of trans header */\n\t\txlog_recover_add_item(&trans->r_itemq);\n\t\tptr = (xfs_caddr_t) &trans->r_theader +\n\t\t\t\tsizeof(xfs_trans_header_t) - len;\n\t\tmemcpy(ptr, dp, len);\n\t\treturn 0;\n\t}\n\t/* take the tail entry */\n\titem = list_entry(trans->r_itemq.prev, xlog_recover_item_t, ri_list);\n\n\told_ptr = item->ri_buf[item->ri_cnt-1].i_addr;\n\told_len = item->ri_buf[item->ri_cnt-1].i_len;\n\n\tptr = kmem_realloc(old_ptr, len+old_len, old_len, KM_SLEEP);\n\tmemcpy(&ptr[old_len], dp, len);\n\titem->ri_buf[item->ri_cnt-1].i_len += len;\n\titem->ri_buf[item->ri_cnt-1].i_addr = ptr;\n\ttrace_xfs_log_recover_item_add_cont(log, trans, item, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_add_to_cont_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\txfs_caddr_t\t\tdp,\n\tint\t\t\tlen)\n{\n\txlog_recover_item_t\t*item;\n\txfs_caddr_t\t\tptr, old_ptr;\n\tint\t\t\told_len;\n\n\tif (list_empty(&trans->r_itemq)) {\n\t\t/* finish copying rest of trans header */\n\t\txlog_recover_add_item(&trans->r_itemq);\n\t\tptr = (xfs_caddr_t) &trans->r_theader +\n\t\t\t\tsizeof(xfs_trans_header_t) - len;\n\t\tmemcpy(ptr, dp, len);\n\t\treturn 0;\n\t}\n\t/* take the tail entry */\n\titem = list_entry(trans->r_itemq.prev, xlog_recover_item_t, ri_list);\n\n\told_ptr = item->ri_buf[item->ri_cnt-1].i_addr;\n\told_len = item->ri_buf[item->ri_cnt-1].i_len;\n\n\tptr = kmem_realloc(old_ptr, len+old_len, old_len, KM_SLEEP);\n\tmemcpy(&ptr[old_len], dp, len);\n\titem->ri_buf[item->ri_cnt-1].i_len += len;\n\titem->ri_buf[item->ri_cnt-1].i_addr = ptr;\n\ttrace_xfs_log_recover_item_add_cont(log, trans, item, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_add_to_trans",
          "args": [
            "log",
            "trans",
            "dp",
            "len"
          ],
          "line": 3528
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_add_to_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3409-3473",
          "snippet": "STATIC int\nxlog_recover_add_to_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\txfs_caddr_t\t\tdp,\n\tint\t\t\tlen)\n{\n\txfs_inode_log_format_t\t*in_f;\t\t\t/* any will do */\n\txlog_recover_item_t\t*item;\n\txfs_caddr_t\t\tptr;\n\n\tif (!len)\n\t\treturn 0;\n\tif (list_empty(&trans->r_itemq)) {\n\t\t/* we need to catch log corruptions here */\n\t\tif (*(uint *)dp != XFS_TRANS_HEADER_MAGIC) {\n\t\t\txfs_warn(log->l_mp, \"%s: bad header magic number\",\n\t\t\t\t__func__);\n\t\t\tASSERT(0);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (len == sizeof(xfs_trans_header_t))\n\t\t\txlog_recover_add_item(&trans->r_itemq);\n\t\tmemcpy(&trans->r_theader, dp, len);\n\t\treturn 0;\n\t}\n\n\tptr = kmem_alloc(len, KM_SLEEP);\n\tmemcpy(ptr, dp, len);\n\tin_f = (xfs_inode_log_format_t *)ptr;\n\n\t/* take the tail entry */\n\titem = list_entry(trans->r_itemq.prev, xlog_recover_item_t, ri_list);\n\tif (item->ri_total != 0 &&\n\t     item->ri_total == item->ri_cnt) {\n\t\t/* tail item is in use, get a new one */\n\t\txlog_recover_add_item(&trans->r_itemq);\n\t\titem = list_entry(trans->r_itemq.prev,\n\t\t\t\t\txlog_recover_item_t, ri_list);\n\t}\n\n\tif (item->ri_total == 0) {\t\t/* first region to be added */\n\t\tif (in_f->ilf_size == 0 ||\n\t\t    in_f->ilf_size > XLOG_MAX_REGIONS_IN_ITEM) {\n\t\t\txfs_warn(log->l_mp,\n\t\t\"bad number of regions (%d) in inode log format\",\n\t\t\t\t  in_f->ilf_size);\n\t\t\tASSERT(0);\n\t\t\tkmem_free(ptr);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\titem->ri_total = in_f->ilf_size;\n\t\titem->ri_buf =\n\t\t\tkmem_zalloc(item->ri_total * sizeof(xfs_log_iovec_t),\n\t\t\t\t    KM_SLEEP);\n\t}\n\tASSERT(item->ri_total > item->ri_cnt);\n\t/* Description region is ri_buf[0] */\n\titem->ri_buf[item->ri_cnt].i_addr = ptr;\n\titem->ri_buf[item->ri_cnt].i_len  = len;\n\titem->ri_cnt++;\n\ttrace_xfs_log_recover_item_add(log, trans, item, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_add_to_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\txfs_caddr_t\t\tdp,\n\tint\t\t\tlen)\n{\n\txfs_inode_log_format_t\t*in_f;\t\t\t/* any will do */\n\txlog_recover_item_t\t*item;\n\txfs_caddr_t\t\tptr;\n\n\tif (!len)\n\t\treturn 0;\n\tif (list_empty(&trans->r_itemq)) {\n\t\t/* we need to catch log corruptions here */\n\t\tif (*(uint *)dp != XFS_TRANS_HEADER_MAGIC) {\n\t\t\txfs_warn(log->l_mp, \"%s: bad header magic number\",\n\t\t\t\t__func__);\n\t\t\tASSERT(0);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (len == sizeof(xfs_trans_header_t))\n\t\t\txlog_recover_add_item(&trans->r_itemq);\n\t\tmemcpy(&trans->r_theader, dp, len);\n\t\treturn 0;\n\t}\n\n\tptr = kmem_alloc(len, KM_SLEEP);\n\tmemcpy(ptr, dp, len);\n\tin_f = (xfs_inode_log_format_t *)ptr;\n\n\t/* take the tail entry */\n\titem = list_entry(trans->r_itemq.prev, xlog_recover_item_t, ri_list);\n\tif (item->ri_total != 0 &&\n\t     item->ri_total == item->ri_cnt) {\n\t\t/* tail item is in use, get a new one */\n\t\txlog_recover_add_item(&trans->r_itemq);\n\t\titem = list_entry(trans->r_itemq.prev,\n\t\t\t\t\txlog_recover_item_t, ri_list);\n\t}\n\n\tif (item->ri_total == 0) {\t\t/* first region to be added */\n\t\tif (in_f->ilf_size == 0 ||\n\t\t    in_f->ilf_size > XLOG_MAX_REGIONS_IN_ITEM) {\n\t\t\txfs_warn(log->l_mp,\n\t\t\"bad number of regions (%d) in inode log format\",\n\t\t\t\t  in_f->ilf_size);\n\t\t\tASSERT(0);\n\t\t\tkmem_free(ptr);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\titem->ri_total = in_f->ilf_size;\n\t\titem->ri_buf =\n\t\t\tkmem_zalloc(item->ri_total * sizeof(xfs_log_iovec_t),\n\t\t\t\t    KM_SLEEP);\n\t}\n\tASSERT(item->ri_total > item->ri_cnt);\n\t/* Description region is ri_buf[0] */\n\titem->ri_buf[item->ri_cnt].i_addr = ptr;\n\titem->ri_buf[item->ri_cnt].i_len  = len;\n\titem->ri_cnt++;\n\ttrace_xfs_log_recover_item_add(log, trans, item, 0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recovery_process_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\txfs_caddr_t\t\tdp,\n\tunsigned int\t\tlen,\n\tunsigned int\t\tflags,\n\tint\t\t\tpass)\n{\n\tint\t\t\terror = 0;\n\tbool\t\t\tfreeit = false;\n\n\t/* mask off ophdr transaction container flags */\n\tflags &= ~XLOG_END_TRANS;\n\tif (flags & XLOG_WAS_CONT_TRANS)\n\t\tflags &= ~XLOG_CONTINUE_TRANS;\n\n\t/*\n\t * Callees must not free the trans structure. We'll decide if we need to\n\t * free it or not based on the operation being done and it's result.\n\t */\n\tswitch (flags) {\n\t/* expected flag values */\n\tcase 0:\n\tcase XLOG_CONTINUE_TRANS:\n\t\terror = xlog_recover_add_to_trans(log, trans, dp, len);\n\t\tbreak;\n\tcase XLOG_WAS_CONT_TRANS:\n\t\terror = xlog_recover_add_to_cont_trans(log, trans, dp, len);\n\t\tbreak;\n\tcase XLOG_COMMIT_TRANS:\n\t\terror = xlog_recover_commit_trans(log, trans, pass);\n\t\t/* success or fail, we are now done with this transaction. */\n\t\tfreeit = true;\n\t\tbreak;\n\n\t/* unexpected flag values */\n\tcase XLOG_UNMOUNT_TRANS:\n\t\t/* just skip trans */\n\t\txfs_warn(log->l_mp, \"%s: Unmount LR\", __func__);\n\t\tfreeit = true;\n\t\tbreak;\n\tcase XLOG_START_TRANS:\n\tdefault:\n\t\txfs_warn(log->l_mp, \"%s: bad flag 0x%x\", __func__, flags);\n\t\tASSERT(0);\n\t\terror = -EIO;\n\t\tbreak;\n\t}\n\tif (error || freeit)\n\t\txlog_recover_free_trans(trans);\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_recover_free_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3480-3498",
    "snippet": "STATIC void\nxlog_recover_free_trans(\n\tstruct xlog_recover\t*trans)\n{\n\txlog_recover_item_t\t*item, *n;\n\tint\t\t\ti;\n\n\tlist_for_each_entry_safe(item, n, &trans->r_itemq, ri_list) {\n\t\t/* Free the regions in the item. */\n\t\tlist_del(&item->ri_list);\n\t\tfor (i = 0; i < item->ri_cnt; i++)\n\t\t\tkmem_free(item->ri_buf[i].i_addr);\n\t\t/* Free the item itself */\n\t\tkmem_free(item->ri_buf);\n\t\tkmem_free(item);\n\t}\n\t/* Free the transaction recover structure */\n\tkmem_free(trans);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "trans"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&item->ri_list"
          ],
          "line": 3489
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "item",
            "n",
            "&trans->r_itemq",
            "ri_list"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_free_trans(\n\tstruct xlog_recover\t*trans)\n{\n\txlog_recover_item_t\t*item, *n;\n\tint\t\t\ti;\n\n\tlist_for_each_entry_safe(item, n, &trans->r_itemq, ri_list) {\n\t\t/* Free the regions in the item. */\n\t\tlist_del(&item->ri_list);\n\t\tfor (i = 0; i < item->ri_cnt; i++)\n\t\t\tkmem_free(item->ri_buf[i].i_addr);\n\t\t/* Free the item itself */\n\t\tkmem_free(item->ri_buf);\n\t\tkmem_free(item);\n\t}\n\t/* Free the transaction recover structure */\n\tkmem_free(trans);\n}"
  },
  {
    "function_name": "xlog_recover_add_to_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3409-3473",
    "snippet": "STATIC int\nxlog_recover_add_to_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\txfs_caddr_t\t\tdp,\n\tint\t\t\tlen)\n{\n\txfs_inode_log_format_t\t*in_f;\t\t\t/* any will do */\n\txlog_recover_item_t\t*item;\n\txfs_caddr_t\t\tptr;\n\n\tif (!len)\n\t\treturn 0;\n\tif (list_empty(&trans->r_itemq)) {\n\t\t/* we need to catch log corruptions here */\n\t\tif (*(uint *)dp != XFS_TRANS_HEADER_MAGIC) {\n\t\t\txfs_warn(log->l_mp, \"%s: bad header magic number\",\n\t\t\t\t__func__);\n\t\t\tASSERT(0);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (len == sizeof(xfs_trans_header_t))\n\t\t\txlog_recover_add_item(&trans->r_itemq);\n\t\tmemcpy(&trans->r_theader, dp, len);\n\t\treturn 0;\n\t}\n\n\tptr = kmem_alloc(len, KM_SLEEP);\n\tmemcpy(ptr, dp, len);\n\tin_f = (xfs_inode_log_format_t *)ptr;\n\n\t/* take the tail entry */\n\titem = list_entry(trans->r_itemq.prev, xlog_recover_item_t, ri_list);\n\tif (item->ri_total != 0 &&\n\t     item->ri_total == item->ri_cnt) {\n\t\t/* tail item is in use, get a new one */\n\t\txlog_recover_add_item(&trans->r_itemq);\n\t\titem = list_entry(trans->r_itemq.prev,\n\t\t\t\t\txlog_recover_item_t, ri_list);\n\t}\n\n\tif (item->ri_total == 0) {\t\t/* first region to be added */\n\t\tif (in_f->ilf_size == 0 ||\n\t\t    in_f->ilf_size > XLOG_MAX_REGIONS_IN_ITEM) {\n\t\t\txfs_warn(log->l_mp,\n\t\t\"bad number of regions (%d) in inode log format\",\n\t\t\t\t  in_f->ilf_size);\n\t\t\tASSERT(0);\n\t\t\tkmem_free(ptr);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\titem->ri_total = in_f->ilf_size;\n\t\titem->ri_buf =\n\t\t\tkmem_zalloc(item->ri_total * sizeof(xfs_log_iovec_t),\n\t\t\t\t    KM_SLEEP);\n\t}\n\tASSERT(item->ri_total > item->ri_cnt);\n\t/* Description region is ri_buf[0] */\n\titem->ri_buf[item->ri_cnt].i_addr = ptr;\n\titem->ri_buf[item->ri_cnt].i_len  = len;\n\titem->ri_cnt++;\n\ttrace_xfs_log_recover_item_add(log, trans, item, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_item_add",
          "args": [
            "log",
            "trans",
            "item",
            "0"
          ],
          "line": 3471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "item->ri_total > item->ri_cnt"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "item->ri_total * sizeof(xfs_log_iovec_t)",
            "KM_SLEEP"
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ptr"
          ],
          "line": 3457
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"bad number of regions (%d) in inode log format\"",
            "in_f->ilf_size"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "trans->r_itemq.prev",
            "xlog_recover_item_t",
            "ri_list"
          ],
          "line": 3446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_recover_add_item",
          "args": [
            "&trans->r_itemq"
          ],
          "line": 3445
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_add_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3352-3361",
          "snippet": "STATIC void\nxlog_recover_add_item(\n\tstruct list_head\t*head)\n{\n\txlog_recover_item_t\t*item;\n\n\titem = kmem_zalloc(sizeof(xlog_recover_item_t), KM_SLEEP);\n\tINIT_LIST_HEAD(&item->ri_list);\n\tlist_add_tail(&item->ri_list, head);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_add_item(\n\tstruct list_head\t*head)\n{\n\txlog_recover_item_t\t*item;\n\n\titem = kmem_zalloc(sizeof(xlog_recover_item_t), KM_SLEEP);\n\tINIT_LIST_HEAD(&item->ri_list);\n\tlist_add_tail(&item->ri_list, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "trans->r_itemq.prev",
            "xlog_recover_item_t",
            "ri_list"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "dp",
            "len"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "len",
            "KM_SLEEP"
          ],
          "line": 3436
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&trans->r_theader",
            "dp",
            "len"
          ],
          "line": 3432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"%s: bad header magic number\"",
            "__func__"
          ],
          "line": 3425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&trans->r_itemq"
          ],
          "line": 3422
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_add_to_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\txfs_caddr_t\t\tdp,\n\tint\t\t\tlen)\n{\n\txfs_inode_log_format_t\t*in_f;\t\t\t/* any will do */\n\txlog_recover_item_t\t*item;\n\txfs_caddr_t\t\tptr;\n\n\tif (!len)\n\t\treturn 0;\n\tif (list_empty(&trans->r_itemq)) {\n\t\t/* we need to catch log corruptions here */\n\t\tif (*(uint *)dp != XFS_TRANS_HEADER_MAGIC) {\n\t\t\txfs_warn(log->l_mp, \"%s: bad header magic number\",\n\t\t\t\t__func__);\n\t\t\tASSERT(0);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (len == sizeof(xfs_trans_header_t))\n\t\t\txlog_recover_add_item(&trans->r_itemq);\n\t\tmemcpy(&trans->r_theader, dp, len);\n\t\treturn 0;\n\t}\n\n\tptr = kmem_alloc(len, KM_SLEEP);\n\tmemcpy(ptr, dp, len);\n\tin_f = (xfs_inode_log_format_t *)ptr;\n\n\t/* take the tail entry */\n\titem = list_entry(trans->r_itemq.prev, xlog_recover_item_t, ri_list);\n\tif (item->ri_total != 0 &&\n\t     item->ri_total == item->ri_cnt) {\n\t\t/* tail item is in use, get a new one */\n\t\txlog_recover_add_item(&trans->r_itemq);\n\t\titem = list_entry(trans->r_itemq.prev,\n\t\t\t\t\txlog_recover_item_t, ri_list);\n\t}\n\n\tif (item->ri_total == 0) {\t\t/* first region to be added */\n\t\tif (in_f->ilf_size == 0 ||\n\t\t    in_f->ilf_size > XLOG_MAX_REGIONS_IN_ITEM) {\n\t\t\txfs_warn(log->l_mp,\n\t\t\"bad number of regions (%d) in inode log format\",\n\t\t\t\t  in_f->ilf_size);\n\t\t\tASSERT(0);\n\t\t\tkmem_free(ptr);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\titem->ri_total = in_f->ilf_size;\n\t\titem->ri_buf =\n\t\t\tkmem_zalloc(item->ri_total * sizeof(xfs_log_iovec_t),\n\t\t\t\t    KM_SLEEP);\n\t}\n\tASSERT(item->ri_total > item->ri_cnt);\n\t/* Description region is ri_buf[0] */\n\titem->ri_buf[item->ri_cnt].i_addr = ptr;\n\titem->ri_buf[item->ri_cnt].i_len  = len;\n\titem->ri_cnt++;\n\ttrace_xfs_log_recover_item_add(log, trans, item, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_recover_add_to_cont_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3363-3394",
    "snippet": "STATIC int\nxlog_recover_add_to_cont_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\txfs_caddr_t\t\tdp,\n\tint\t\t\tlen)\n{\n\txlog_recover_item_t\t*item;\n\txfs_caddr_t\t\tptr, old_ptr;\n\tint\t\t\told_len;\n\n\tif (list_empty(&trans->r_itemq)) {\n\t\t/* finish copying rest of trans header */\n\t\txlog_recover_add_item(&trans->r_itemq);\n\t\tptr = (xfs_caddr_t) &trans->r_theader +\n\t\t\t\tsizeof(xfs_trans_header_t) - len;\n\t\tmemcpy(ptr, dp, len);\n\t\treturn 0;\n\t}\n\t/* take the tail entry */\n\titem = list_entry(trans->r_itemq.prev, xlog_recover_item_t, ri_list);\n\n\told_ptr = item->ri_buf[item->ri_cnt-1].i_addr;\n\told_len = item->ri_buf[item->ri_cnt-1].i_len;\n\n\tptr = kmem_realloc(old_ptr, len+old_len, old_len, KM_SLEEP);\n\tmemcpy(&ptr[old_len], dp, len);\n\titem->ri_buf[item->ri_cnt-1].i_len += len;\n\titem->ri_buf[item->ri_cnt-1].i_addr = ptr;\n\ttrace_xfs_log_recover_item_add_cont(log, trans, item, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_item_add_cont",
          "args": [
            "log",
            "trans",
            "item",
            "0"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ptr[old_len]",
            "dp",
            "len"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_realloc",
          "args": [
            "old_ptr",
            "len+old_len",
            "old_len",
            "KM_SLEEP"
          ],
          "line": 3388
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "94-108",
          "snippet": "void *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "trans->r_itemq.prev",
            "xlog_recover_item_t",
            "ri_list"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "dp",
            "len"
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_recover_add_item",
          "args": [
            "&trans->r_itemq"
          ],
          "line": 3376
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_add_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3352-3361",
          "snippet": "STATIC void\nxlog_recover_add_item(\n\tstruct list_head\t*head)\n{\n\txlog_recover_item_t\t*item;\n\n\titem = kmem_zalloc(sizeof(xlog_recover_item_t), KM_SLEEP);\n\tINIT_LIST_HEAD(&item->ri_list);\n\tlist_add_tail(&item->ri_list, head);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_add_item(\n\tstruct list_head\t*head)\n{\n\txlog_recover_item_t\t*item;\n\n\titem = kmem_zalloc(sizeof(xlog_recover_item_t), KM_SLEEP);\n\tINIT_LIST_HEAD(&item->ri_list);\n\tlist_add_tail(&item->ri_list, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&trans->r_itemq"
          ],
          "line": 3374
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_add_to_cont_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\txfs_caddr_t\t\tdp,\n\tint\t\t\tlen)\n{\n\txlog_recover_item_t\t*item;\n\txfs_caddr_t\t\tptr, old_ptr;\n\tint\t\t\told_len;\n\n\tif (list_empty(&trans->r_itemq)) {\n\t\t/* finish copying rest of trans header */\n\t\txlog_recover_add_item(&trans->r_itemq);\n\t\tptr = (xfs_caddr_t) &trans->r_theader +\n\t\t\t\tsizeof(xfs_trans_header_t) - len;\n\t\tmemcpy(ptr, dp, len);\n\t\treturn 0;\n\t}\n\t/* take the tail entry */\n\titem = list_entry(trans->r_itemq.prev, xlog_recover_item_t, ri_list);\n\n\told_ptr = item->ri_buf[item->ri_cnt-1].i_addr;\n\told_len = item->ri_buf[item->ri_cnt-1].i_len;\n\n\tptr = kmem_realloc(old_ptr, len+old_len, old_len, KM_SLEEP);\n\tmemcpy(&ptr[old_len], dp, len);\n\titem->ri_buf[item->ri_cnt-1].i_len += len;\n\titem->ri_buf[item->ri_cnt-1].i_addr = ptr;\n\ttrace_xfs_log_recover_item_add_cont(log, trans, item, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_recover_add_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3352-3361",
    "snippet": "STATIC void\nxlog_recover_add_item(\n\tstruct list_head\t*head)\n{\n\txlog_recover_item_t\t*item;\n\n\titem = kmem_zalloc(sizeof(xlog_recover_item_t), KM_SLEEP);\n\tINIT_LIST_HEAD(&item->ri_list);\n\tlist_add_tail(&item->ri_list, head);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&item->ri_list",
            "head"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&item->ri_list"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(xlog_recover_item_t)",
            "KM_SLEEP"
          ],
          "line": 3358
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_add_item(\n\tstruct list_head\t*head)\n{\n\txlog_recover_item_t\t*item;\n\n\titem = kmem_zalloc(sizeof(xlog_recover_item_t), KM_SLEEP);\n\tINIT_LIST_HEAD(&item->ri_list);\n\tlist_add_tail(&item->ri_list, head);\n}"
  },
  {
    "function_name": "xlog_recover_commit_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3289-3350",
    "snippet": "STATIC int\nxlog_recover_commit_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\tint\t\t\tpass)\n{\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\terror2;\n\tint\t\t\t\titems_queued = 0;\n\tstruct xlog_recover_item\t*item;\n\tstruct xlog_recover_item\t*next;\n\tLIST_HEAD\t\t\t(buffer_list);\n\tLIST_HEAD\t\t\t(ra_list);\n\tLIST_HEAD\t\t\t(done_list);\n\n\t#define XLOG_RECOVER_COMMIT_QUEUE_MAX 100\n\n\thlist_del(&trans->r_list);\n\n\terror = xlog_recover_reorder_trans(log, trans, pass);\n\tif (error)\n\t\treturn error;\n\n\tlist_for_each_entry_safe(item, next, &trans->r_itemq, ri_list) {\n\t\tswitch (pass) {\n\t\tcase XLOG_RECOVER_PASS1:\n\t\t\terror = xlog_recover_commit_pass1(log, trans, item);\n\t\t\tbreak;\n\t\tcase XLOG_RECOVER_PASS2:\n\t\t\txlog_recover_ra_pass2(log, item);\n\t\t\tlist_move_tail(&item->ri_list, &ra_list);\n\t\t\titems_queued++;\n\t\t\tif (items_queued >= XLOG_RECOVER_COMMIT_QUEUE_MAX) {\n\t\t\t\terror = xlog_recover_items_pass2(log, trans,\n\t\t\t\t\t\t&buffer_list, &ra_list);\n\t\t\t\tlist_splice_tail_init(&ra_list, &done_list);\n\t\t\t\titems_queued = 0;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (!list_empty(&ra_list)) {\n\t\tif (!error)\n\t\t\terror = xlog_recover_items_pass2(log, trans,\n\t\t\t\t\t&buffer_list, &ra_list);\n\t\tlist_splice_tail_init(&ra_list, &done_list);\n\t}\n\n\tif (!list_empty(&done_list))\n\t\tlist_splice_init(&done_list, &trans->r_itemq);\n\n\terror2 = xfs_buf_delwri_submit(&buffer_list);\n\treturn error ? error : error2;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define XLOG_RECOVER_COMMIT_QUEUE_MAX 100"
    ],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_delwri_submit",
          "args": [
            "&buffer_list"
          ],
          "line": 3348
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1856-1881",
          "snippet": "int\nxfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list)\n{\n\tLIST_HEAD\t\t(io_list);\n\tint\t\t\terror = 0, error2;\n\tstruct xfs_buf\t\t*bp;\n\n\t__xfs_buf_delwri_submit(buffer_list, &io_list, true);\n\n\t/* Wait for IO to complete. */\n\twhile (!list_empty(&io_list)) {\n\t\tbp = list_first_entry(&io_list, struct xfs_buf, b_list);\n\n\t\tlist_del_init(&bp->b_list);\n\n\t\t/* locking the buffer will wait for async IO completion. */\n\t\txfs_buf_lock(bp);\n\t\terror2 = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list)\n{\n\tLIST_HEAD\t\t(io_list);\n\tint\t\t\terror = 0, error2;\n\tstruct xfs_buf\t\t*bp;\n\n\t__xfs_buf_delwri_submit(buffer_list, &io_list, true);\n\n\t/* Wait for IO to complete. */\n\twhile (!list_empty(&io_list)) {\n\t\tbp = list_first_entry(&io_list, struct xfs_buf, b_list);\n\n\t\tlist_del_init(&bp->b_list);\n\n\t\t/* locking the buffer will wait for async IO completion. */\n\t\txfs_buf_lock(bp);\n\t\terror2 = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&done_list",
            "&trans->r_itemq"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&done_list"
          ],
          "line": 3345
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&ra_list",
            "&done_list"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_recover_items_pass2",
          "args": [
            "log",
            "trans",
            "&buffer_list",
            "&ra_list"
          ],
          "line": 3340
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_items_pass2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3263-3281",
          "snippet": "STATIC int\nxlog_recover_items_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover             *trans,\n\tstruct list_head                *buffer_list,\n\tstruct list_head                *item_list)\n{\n\tstruct xlog_recover_item\t*item;\n\tint\t\t\t\terror = 0;\n\n\tlist_for_each_entry(item, item_list, ri_list) {\n\t\terror = xlog_recover_commit_pass2(log, trans,\n\t\t\t\t\t  buffer_list, item);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_items_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover             *trans,\n\tstruct list_head                *buffer_list,\n\tstruct list_head                *item_list)\n{\n\tstruct xlog_recover_item\t*item;\n\tint\t\t\t\terror = 0;\n\n\tlist_for_each_entry(item, item_list, ri_list) {\n\t\terror = xlog_recover_commit_pass2(log, trans,\n\t\t\t\t\t  buffer_list, item);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&ra_list",
            "&done_list"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&item->ri_list",
            "&ra_list"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_recover_ra_pass2",
          "args": [
            "log",
            "item"
          ],
          "line": 3318
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_ra_pass2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3176-3197",
          "snippet": "STATIC void\nxlog_recover_ra_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\tswitch (ITEM_TYPE(item)) {\n\tcase XFS_LI_BUF:\n\t\txlog_recover_buffer_ra_pass2(log, item);\n\t\tbreak;\n\tcase XFS_LI_INODE:\n\t\txlog_recover_inode_ra_pass2(log, item);\n\t\tbreak;\n\tcase XFS_LI_DQUOT:\n\t\txlog_recover_dquot_ra_pass2(log, item);\n\t\tbreak;\n\tcase XFS_LI_EFI:\n\tcase XFS_LI_EFD:\n\tcase XFS_LI_QUOTAOFF:\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_ra_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\tswitch (ITEM_TYPE(item)) {\n\tcase XFS_LI_BUF:\n\t\txlog_recover_buffer_ra_pass2(log, item);\n\t\tbreak;\n\tcase XFS_LI_INODE:\n\t\txlog_recover_inode_ra_pass2(log, item);\n\t\tbreak;\n\tcase XFS_LI_DQUOT:\n\t\txlog_recover_dquot_ra_pass2(log, item);\n\t\tbreak;\n\tcase XFS_LI_EFI:\n\tcase XFS_LI_EFD:\n\tcase XFS_LI_QUOTAOFF:\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_commit_pass1",
          "args": [
            "log",
            "trans",
            "item"
          ],
          "line": 3315
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_commit_pass1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3199-3225",
          "snippet": "STATIC int\nxlog_recover_commit_pass1(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover\t\t*trans,\n\tstruct xlog_recover_item\t*item)\n{\n\ttrace_xfs_log_recover_item_recover(log, trans, item, XLOG_RECOVER_PASS1);\n\n\tswitch (ITEM_TYPE(item)) {\n\tcase XFS_LI_BUF:\n\t\treturn xlog_recover_buffer_pass1(log, item);\n\tcase XFS_LI_QUOTAOFF:\n\t\treturn xlog_recover_quotaoff_pass1(log, item);\n\tcase XFS_LI_INODE:\n\tcase XFS_LI_EFI:\n\tcase XFS_LI_EFD:\n\tcase XFS_LI_DQUOT:\n\tcase XFS_LI_ICREATE:\n\t\t/* nothing to do in pass 1 */\n\t\treturn 0;\n\tdefault:\n\t\txfs_warn(log->l_mp, \"%s: invalid item type (%d)\",\n\t\t\t__func__, ITEM_TYPE(item));\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_commit_pass1(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover\t\t*trans,\n\tstruct xlog_recover_item\t*item)\n{\n\ttrace_xfs_log_recover_item_recover(log, trans, item, XLOG_RECOVER_PASS1);\n\n\tswitch (ITEM_TYPE(item)) {\n\tcase XFS_LI_BUF:\n\t\treturn xlog_recover_buffer_pass1(log, item);\n\tcase XFS_LI_QUOTAOFF:\n\t\treturn xlog_recover_quotaoff_pass1(log, item);\n\tcase XFS_LI_INODE:\n\tcase XFS_LI_EFI:\n\tcase XFS_LI_EFD:\n\tcase XFS_LI_DQUOT:\n\tcase XFS_LI_ICREATE:\n\t\t/* nothing to do in pass 1 */\n\t\treturn 0;\n\tdefault:\n\t\txfs_warn(log->l_mp, \"%s: invalid item type (%d)\",\n\t\t\t__func__, ITEM_TYPE(item));\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "item",
            "next",
            "&trans->r_itemq",
            "ri_list"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_recover_reorder_trans",
          "args": [
            "log",
            "trans",
            "pass"
          ],
          "line": 3308
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_reorder_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1493-1563",
          "snippet": "STATIC int\nxlog_recover_reorder_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\tint\t\t\tpass)\n{\n\txlog_recover_item_t\t*item, *n;\n\tint\t\t\terror = 0;\n\tLIST_HEAD(sort_list);\n\tLIST_HEAD(cancel_list);\n\tLIST_HEAD(buffer_list);\n\tLIST_HEAD(inode_buffer_list);\n\tLIST_HEAD(inode_list);\n\n\tlist_splice_init(&trans->r_itemq, &sort_list);\n\tlist_for_each_entry_safe(item, n, &sort_list, ri_list) {\n\t\txfs_buf_log_format_t\t*buf_f = item->ri_buf[0].i_addr;\n\n\t\tswitch (ITEM_TYPE(item)) {\n\t\tcase XFS_LI_ICREATE:\n\t\t\tlist_move_tail(&item->ri_list, &buffer_list);\n\t\t\tbreak;\n\t\tcase XFS_LI_BUF:\n\t\t\tif (buf_f->blf_flags & XFS_BLF_CANCEL) {\n\t\t\t\ttrace_xfs_log_recover_item_reorder_head(log,\n\t\t\t\t\t\t\ttrans, item, pass);\n\t\t\t\tlist_move(&item->ri_list, &cancel_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF) {\n\t\t\t\tlist_move(&item->ri_list, &inode_buffer_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_move_tail(&item->ri_list, &buffer_list);\n\t\t\tbreak;\n\t\tcase XFS_LI_INODE:\n\t\tcase XFS_LI_DQUOT:\n\t\tcase XFS_LI_QUOTAOFF:\n\t\tcase XFS_LI_EFD:\n\t\tcase XFS_LI_EFI:\n\t\t\ttrace_xfs_log_recover_item_reorder_tail(log,\n\t\t\t\t\t\t\ttrans, item, pass);\n\t\t\tlist_move_tail(&item->ri_list, &inode_list);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: unrecognized type of log operation\",\n\t\t\t\t__func__);\n\t\t\tASSERT(0);\n\t\t\t/*\n\t\t\t * return the remaining items back to the transaction\n\t\t\t * item list so they can be freed in caller.\n\t\t\t */\n\t\t\tif (!list_empty(&sort_list))\n\t\t\t\tlist_splice_init(&sort_list, &trans->r_itemq);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tASSERT(list_empty(&sort_list));\n\tif (!list_empty(&buffer_list))\n\t\tlist_splice(&buffer_list, &trans->r_itemq);\n\tif (!list_empty(&inode_list))\n\t\tlist_splice_tail(&inode_list, &trans->r_itemq);\n\tif (!list_empty(&inode_buffer_list))\n\t\tlist_splice_tail(&inode_buffer_list, &trans->r_itemq);\n\tif (!list_empty(&cancel_list))\n\t\tlist_splice_tail(&cancel_list, &trans->r_itemq);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_reorder_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\tint\t\t\tpass)\n{\n\txlog_recover_item_t\t*item, *n;\n\tint\t\t\terror = 0;\n\tLIST_HEAD(sort_list);\n\tLIST_HEAD(cancel_list);\n\tLIST_HEAD(buffer_list);\n\tLIST_HEAD(inode_buffer_list);\n\tLIST_HEAD(inode_list);\n\n\tlist_splice_init(&trans->r_itemq, &sort_list);\n\tlist_for_each_entry_safe(item, n, &sort_list, ri_list) {\n\t\txfs_buf_log_format_t\t*buf_f = item->ri_buf[0].i_addr;\n\n\t\tswitch (ITEM_TYPE(item)) {\n\t\tcase XFS_LI_ICREATE:\n\t\t\tlist_move_tail(&item->ri_list, &buffer_list);\n\t\t\tbreak;\n\t\tcase XFS_LI_BUF:\n\t\t\tif (buf_f->blf_flags & XFS_BLF_CANCEL) {\n\t\t\t\ttrace_xfs_log_recover_item_reorder_head(log,\n\t\t\t\t\t\t\ttrans, item, pass);\n\t\t\t\tlist_move(&item->ri_list, &cancel_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF) {\n\t\t\t\tlist_move(&item->ri_list, &inode_buffer_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_move_tail(&item->ri_list, &buffer_list);\n\t\t\tbreak;\n\t\tcase XFS_LI_INODE:\n\t\tcase XFS_LI_DQUOT:\n\t\tcase XFS_LI_QUOTAOFF:\n\t\tcase XFS_LI_EFD:\n\t\tcase XFS_LI_EFI:\n\t\t\ttrace_xfs_log_recover_item_reorder_tail(log,\n\t\t\t\t\t\t\ttrans, item, pass);\n\t\t\tlist_move_tail(&item->ri_list, &inode_list);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: unrecognized type of log operation\",\n\t\t\t\t__func__);\n\t\t\tASSERT(0);\n\t\t\t/*\n\t\t\t * return the remaining items back to the transaction\n\t\t\t * item list so they can be freed in caller.\n\t\t\t */\n\t\t\tif (!list_empty(&sort_list))\n\t\t\t\tlist_splice_init(&sort_list, &trans->r_itemq);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tASSERT(list_empty(&sort_list));\n\tif (!list_empty(&buffer_list))\n\t\tlist_splice(&buffer_list, &trans->r_itemq);\n\tif (!list_empty(&inode_list))\n\t\tlist_splice_tail(&inode_list, &trans->r_itemq);\n\tif (!list_empty(&inode_buffer_list))\n\t\tlist_splice_tail(&inode_buffer_list, &trans->r_itemq);\n\tif (!list_empty(&cancel_list))\n\t\tlist_splice_tail(&cancel_list, &trans->r_itemq);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&trans->r_list"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "done_list"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "ra_list"
          ],
          "line": 3301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "buffer_list"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XLOG_RECOVER_COMMIT_QUEUE_MAX 100\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_commit_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\tint\t\t\tpass)\n{\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\terror2;\n\tint\t\t\t\titems_queued = 0;\n\tstruct xlog_recover_item\t*item;\n\tstruct xlog_recover_item\t*next;\n\tLIST_HEAD\t\t\t(buffer_list);\n\tLIST_HEAD\t\t\t(ra_list);\n\tLIST_HEAD\t\t\t(done_list);\n\n\t#define XLOG_RECOVER_COMMIT_QUEUE_MAX 100\n\n\thlist_del(&trans->r_list);\n\n\terror = xlog_recover_reorder_trans(log, trans, pass);\n\tif (error)\n\t\treturn error;\n\n\tlist_for_each_entry_safe(item, next, &trans->r_itemq, ri_list) {\n\t\tswitch (pass) {\n\t\tcase XLOG_RECOVER_PASS1:\n\t\t\terror = xlog_recover_commit_pass1(log, trans, item);\n\t\t\tbreak;\n\t\tcase XLOG_RECOVER_PASS2:\n\t\t\txlog_recover_ra_pass2(log, item);\n\t\t\tlist_move_tail(&item->ri_list, &ra_list);\n\t\t\titems_queued++;\n\t\t\tif (items_queued >= XLOG_RECOVER_COMMIT_QUEUE_MAX) {\n\t\t\t\terror = xlog_recover_items_pass2(log, trans,\n\t\t\t\t\t\t&buffer_list, &ra_list);\n\t\t\t\tlist_splice_tail_init(&ra_list, &done_list);\n\t\t\t\titems_queued = 0;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (!list_empty(&ra_list)) {\n\t\tif (!error)\n\t\t\terror = xlog_recover_items_pass2(log, trans,\n\t\t\t\t\t&buffer_list, &ra_list);\n\t\tlist_splice_tail_init(&ra_list, &done_list);\n\t}\n\n\tif (!list_empty(&done_list))\n\t\tlist_splice_init(&done_list, &trans->r_itemq);\n\n\terror2 = xfs_buf_delwri_submit(&buffer_list);\n\treturn error ? error : error2;\n}"
  },
  {
    "function_name": "xlog_recover_items_pass2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3263-3281",
    "snippet": "STATIC int\nxlog_recover_items_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover             *trans,\n\tstruct list_head                *buffer_list,\n\tstruct list_head                *item_list)\n{\n\tstruct xlog_recover_item\t*item;\n\tint\t\t\t\terror = 0;\n\n\tlist_for_each_entry(item, item_list, ri_list) {\n\t\terror = xlog_recover_commit_pass2(log, trans,\n\t\t\t\t\t  buffer_list, item);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_recover_commit_pass2",
          "args": [
            "log",
            "trans",
            "buffer_list",
            "item"
          ],
          "line": 3274
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_commit_pass2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3227-3261",
          "snippet": "STATIC int\nxlog_recover_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover\t\t*trans,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item)\n{\n\ttrace_xfs_log_recover_item_recover(log, trans, item, XLOG_RECOVER_PASS2);\n\n\tswitch (ITEM_TYPE(item)) {\n\tcase XFS_LI_BUF:\n\t\treturn xlog_recover_buffer_pass2(log, buffer_list, item,\n\t\t\t\t\t\t trans->r_lsn);\n\tcase XFS_LI_INODE:\n\t\treturn xlog_recover_inode_pass2(log, buffer_list, item,\n\t\t\t\t\t\t trans->r_lsn);\n\tcase XFS_LI_EFI:\n\t\treturn xlog_recover_efi_pass2(log, item, trans->r_lsn);\n\tcase XFS_LI_EFD:\n\t\treturn xlog_recover_efd_pass2(log, item);\n\tcase XFS_LI_DQUOT:\n\t\treturn xlog_recover_dquot_pass2(log, buffer_list, item,\n\t\t\t\t\t\ttrans->r_lsn);\n\tcase XFS_LI_ICREATE:\n\t\treturn xlog_recover_do_icreate_pass2(log, buffer_list, item);\n\tcase XFS_LI_QUOTAOFF:\n\t\t/* nothing to do in pass2 */\n\t\treturn 0;\n\tdefault:\n\t\txfs_warn(log->l_mp, \"%s: invalid item type (%d)\",\n\t\t\t__func__, ITEM_TYPE(item));\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover\t\t*trans,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item)\n{\n\ttrace_xfs_log_recover_item_recover(log, trans, item, XLOG_RECOVER_PASS2);\n\n\tswitch (ITEM_TYPE(item)) {\n\tcase XFS_LI_BUF:\n\t\treturn xlog_recover_buffer_pass2(log, buffer_list, item,\n\t\t\t\t\t\t trans->r_lsn);\n\tcase XFS_LI_INODE:\n\t\treturn xlog_recover_inode_pass2(log, buffer_list, item,\n\t\t\t\t\t\t trans->r_lsn);\n\tcase XFS_LI_EFI:\n\t\treturn xlog_recover_efi_pass2(log, item, trans->r_lsn);\n\tcase XFS_LI_EFD:\n\t\treturn xlog_recover_efd_pass2(log, item);\n\tcase XFS_LI_DQUOT:\n\t\treturn xlog_recover_dquot_pass2(log, buffer_list, item,\n\t\t\t\t\t\ttrans->r_lsn);\n\tcase XFS_LI_ICREATE:\n\t\treturn xlog_recover_do_icreate_pass2(log, buffer_list, item);\n\tcase XFS_LI_QUOTAOFF:\n\t\t/* nothing to do in pass2 */\n\t\treturn 0;\n\tdefault:\n\t\txfs_warn(log->l_mp, \"%s: invalid item type (%d)\",\n\t\t\t__func__, ITEM_TYPE(item));\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "item",
            "item_list",
            "ri_list"
          ],
          "line": 3273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_items_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover             *trans,\n\tstruct list_head                *buffer_list,\n\tstruct list_head                *item_list)\n{\n\tstruct xlog_recover_item\t*item;\n\tint\t\t\t\terror = 0;\n\n\tlist_for_each_entry(item, item_list, ri_list) {\n\t\terror = xlog_recover_commit_pass2(log, trans,\n\t\t\t\t\t  buffer_list, item);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_recover_commit_pass2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3227-3261",
    "snippet": "STATIC int\nxlog_recover_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover\t\t*trans,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item)\n{\n\ttrace_xfs_log_recover_item_recover(log, trans, item, XLOG_RECOVER_PASS2);\n\n\tswitch (ITEM_TYPE(item)) {\n\tcase XFS_LI_BUF:\n\t\treturn xlog_recover_buffer_pass2(log, buffer_list, item,\n\t\t\t\t\t\t trans->r_lsn);\n\tcase XFS_LI_INODE:\n\t\treturn xlog_recover_inode_pass2(log, buffer_list, item,\n\t\t\t\t\t\t trans->r_lsn);\n\tcase XFS_LI_EFI:\n\t\treturn xlog_recover_efi_pass2(log, item, trans->r_lsn);\n\tcase XFS_LI_EFD:\n\t\treturn xlog_recover_efd_pass2(log, item);\n\tcase XFS_LI_DQUOT:\n\t\treturn xlog_recover_dquot_pass2(log, buffer_list, item,\n\t\t\t\t\t\ttrans->r_lsn);\n\tcase XFS_LI_ICREATE:\n\t\treturn xlog_recover_do_icreate_pass2(log, buffer_list, item);\n\tcase XFS_LI_QUOTAOFF:\n\t\t/* nothing to do in pass2 */\n\t\treturn 0;\n\tdefault:\n\t\txfs_warn(log->l_mp, \"%s: invalid item type (%d)\",\n\t\t\t__func__, ITEM_TYPE(item));\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"%s: invalid item type (%d)\"",
            "__func__",
            "ITEM_TYPE(item)"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ITEM_TYPE",
          "args": [
            "item"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_recover_do_icreate_pass2",
          "args": [
            "log",
            "buffer_list",
            "item"
          ],
          "line": 3251
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_do_icreate_pass2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3020-3097",
          "snippet": "STATIC int\nxlog_recover_do_icreate_pass2(\n\tstruct xlog\t\t*log,\n\tstruct list_head\t*buffer_list,\n\txlog_recover_item_t\t*item)\n{\n\tstruct xfs_mount\t*mp = log->l_mp;\n\tstruct xfs_icreate_log\t*icl;\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\tunsigned int\t\tcount;\n\tunsigned int\t\tisize;\n\txfs_agblock_t\t\tlength;\n\n\ticl = (struct xfs_icreate_log *)item->ri_buf[0].i_addr;\n\tif (icl->icl_type != XFS_LI_ICREATE) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad type\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (icl->icl_size != 1) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad icl size\");\n\t\treturn -EINVAL;\n\t}\n\n\tagno = be32_to_cpu(icl->icl_ag);\n\tif (agno >= mp->m_sb.sb_agcount) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad agno\");\n\t\treturn -EINVAL;\n\t}\n\tagbno = be32_to_cpu(icl->icl_agbno);\n\tif (!agbno || agbno == NULLAGBLOCK || agbno >= mp->m_sb.sb_agblocks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad agbno\");\n\t\treturn -EINVAL;\n\t}\n\tisize = be32_to_cpu(icl->icl_isize);\n\tif (isize != mp->m_sb.sb_inodesize) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad isize\");\n\t\treturn -EINVAL;\n\t}\n\tcount = be32_to_cpu(icl->icl_count);\n\tif (!count) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad count\");\n\t\treturn -EINVAL;\n\t}\n\tlength = be32_to_cpu(icl->icl_length);\n\tif (!length || length >= mp->m_sb.sb_agblocks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad length\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* existing allocation is fixed value */\n\tASSERT(count == mp->m_ialloc_inos);\n\tASSERT(length == mp->m_ialloc_blks);\n\tif (count != mp->m_ialloc_inos ||\n\t     length != mp->m_ialloc_blks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad count 2\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Inode buffers can be freed. Do not replay the inode initialisation as\n\t * we could be overwriting something written after this inode buffer was\n\t * cancelled.\n\t *\n\t * XXX: we need to iterate all buffers and only init those that are not\n\t * cancelled. I think that a more fine grained factoring of\n\t * xfs_ialloc_inode_init may be appropriate here to enable this to be\n\t * done easily.\n\t */\n\tif (xlog_check_buffer_cancelled(log,\n\t\t\tXFS_AGB_TO_DADDR(mp, agno, agbno), length, 0))\n\t\treturn 0;\n\n\txfs_ialloc_inode_init(mp, NULL, buffer_list, agno, agbno, length,\n\t\t\t\t\tbe32_to_cpu(icl->icl_gen));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_do_icreate_pass2(\n\tstruct xlog\t\t*log,\n\tstruct list_head\t*buffer_list,\n\txlog_recover_item_t\t*item)\n{\n\tstruct xfs_mount\t*mp = log->l_mp;\n\tstruct xfs_icreate_log\t*icl;\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\tunsigned int\t\tcount;\n\tunsigned int\t\tisize;\n\txfs_agblock_t\t\tlength;\n\n\ticl = (struct xfs_icreate_log *)item->ri_buf[0].i_addr;\n\tif (icl->icl_type != XFS_LI_ICREATE) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad type\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (icl->icl_size != 1) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad icl size\");\n\t\treturn -EINVAL;\n\t}\n\n\tagno = be32_to_cpu(icl->icl_ag);\n\tif (agno >= mp->m_sb.sb_agcount) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad agno\");\n\t\treturn -EINVAL;\n\t}\n\tagbno = be32_to_cpu(icl->icl_agbno);\n\tif (!agbno || agbno == NULLAGBLOCK || agbno >= mp->m_sb.sb_agblocks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad agbno\");\n\t\treturn -EINVAL;\n\t}\n\tisize = be32_to_cpu(icl->icl_isize);\n\tif (isize != mp->m_sb.sb_inodesize) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad isize\");\n\t\treturn -EINVAL;\n\t}\n\tcount = be32_to_cpu(icl->icl_count);\n\tif (!count) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad count\");\n\t\treturn -EINVAL;\n\t}\n\tlength = be32_to_cpu(icl->icl_length);\n\tif (!length || length >= mp->m_sb.sb_agblocks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad length\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* existing allocation is fixed value */\n\tASSERT(count == mp->m_ialloc_inos);\n\tASSERT(length == mp->m_ialloc_blks);\n\tif (count != mp->m_ialloc_inos ||\n\t     length != mp->m_ialloc_blks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad count 2\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Inode buffers can be freed. Do not replay the inode initialisation as\n\t * we could be overwriting something written after this inode buffer was\n\t * cancelled.\n\t *\n\t * XXX: we need to iterate all buffers and only init those that are not\n\t * cancelled. I think that a more fine grained factoring of\n\t * xfs_ialloc_inode_init may be appropriate here to enable this to be\n\t * done easily.\n\t */\n\tif (xlog_check_buffer_cancelled(log,\n\t\t\tXFS_AGB_TO_DADDR(mp, agno, agbno), length, 0))\n\t\treturn 0;\n\n\txfs_ialloc_inode_init(mp, NULL, buffer_list, agno, agbno, length,\n\t\t\t\t\tbe32_to_cpu(icl->icl_gen));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_dquot_pass2",
          "args": [
            "log",
            "buffer_list",
            "item",
            "trans->r_lsn"
          ],
          "line": 3248
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_dquot_pass2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "2816-2917",
          "snippet": "STATIC int\nxlog_recover_dquot_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_buf_t\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddq, *recddq;\n\tint\t\t\terror;\n\txfs_dq_logformat_t\t*dq_f;\n\tuint\t\t\ttype;\n\n\n\t/*\n\t * Filesystems are required to send in quota flags at mount time.\n\t */\n\tif (mp->m_qflags == 0)\n\t\treturn 0;\n\n\trecddq = item->ri_buf[1].i_addr;\n\tif (recddq == NULL) {\n\t\txfs_alert(log->l_mp, \"NULL dquot in %s.\", __func__);\n\t\treturn -EIO;\n\t}\n\tif (item->ri_buf[1].i_len < sizeof(xfs_disk_dquot_t)) {\n\t\txfs_alert(log->l_mp, \"dquot too small (%d) in %s.\",\n\t\t\titem->ri_buf[1].i_len, __func__);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * This type of quotas was turned off, so ignore this record.\n\t */\n\ttype = recddq->d_flags & (XFS_DQ_USER | XFS_DQ_PROJ | XFS_DQ_GROUP);\n\tASSERT(type);\n\tif (log->l_quotaoffs_flag & type)\n\t\treturn 0;\n\n\t/*\n\t * At this point we know that quota was _not_ turned off.\n\t * Since the mount flags are not indicating to us otherwise, this\n\t * must mean that quota is on, and the dquot needs to be replayed.\n\t * Remember that we may not have fully recovered the superblock yet,\n\t * so we can't do the usual trick of looking at the SB quota bits.\n\t *\n\t * The other possibility, of course, is that the quota subsystem was\n\t * removed since the last mount - ENOSYS.\n\t */\n\tdq_f = item->ri_buf[0].i_addr;\n\tASSERT(dq_f);\n\terror = xfs_dqcheck(mp, recddq, dq_f->qlf_id, 0, XFS_QMOPT_DOWARN,\n\t\t\t   \"xlog_recover_dquot_pass2 (log copy)\");\n\tif (error)\n\t\treturn -EIO;\n\tASSERT(dq_f->qlf_len == 1);\n\n\t/*\n\t * At this point we are assuming that the dquots have been allocated\n\t * and hence the buffer has valid dquots stamped in it. It should,\n\t * therefore, pass verifier validation. If the dquot is bad, then the\n\t * we'll return an error here, so we don't need to specifically check\n\t * the dquot in the buffer after the verifier has run.\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dq_f->qlf_blkno,\n\t\t\t\t   XFS_FSB_TO_BB(mp, dq_f->qlf_len), 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(bp);\n\tddq = (xfs_disk_dquot_t *)xfs_buf_offset(bp, dq_f->qlf_boffset);\n\n\t/*\n\t * If the dquot has an LSN in it, recover the dquot only if it's less\n\t * than the lsn of the transaction we are replaying.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddq;\n\t\txfs_lsn_t\tlsn = be64_to_cpu(dqb->dd_lsn);\n\n\t\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) >= 0) {\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\tmemcpy(ddq, recddq, item->ri_buf[1].i_len);\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\txfs_update_cksum((char *)ddq, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\tASSERT(dq_f->qlf_size == 2);\n\tASSERT(bp->b_target->bt_mount == mp);\n\tbp->b_iodone = xlog_recover_iodone;\n\txfs_buf_delwri_queue(bp, buffer_list);\n\nout_release:\n\txfs_buf_relse(bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_dquot_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_buf_t\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddq, *recddq;\n\tint\t\t\terror;\n\txfs_dq_logformat_t\t*dq_f;\n\tuint\t\t\ttype;\n\n\n\t/*\n\t * Filesystems are required to send in quota flags at mount time.\n\t */\n\tif (mp->m_qflags == 0)\n\t\treturn 0;\n\n\trecddq = item->ri_buf[1].i_addr;\n\tif (recddq == NULL) {\n\t\txfs_alert(log->l_mp, \"NULL dquot in %s.\", __func__);\n\t\treturn -EIO;\n\t}\n\tif (item->ri_buf[1].i_len < sizeof(xfs_disk_dquot_t)) {\n\t\txfs_alert(log->l_mp, \"dquot too small (%d) in %s.\",\n\t\t\titem->ri_buf[1].i_len, __func__);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * This type of quotas was turned off, so ignore this record.\n\t */\n\ttype = recddq->d_flags & (XFS_DQ_USER | XFS_DQ_PROJ | XFS_DQ_GROUP);\n\tASSERT(type);\n\tif (log->l_quotaoffs_flag & type)\n\t\treturn 0;\n\n\t/*\n\t * At this point we know that quota was _not_ turned off.\n\t * Since the mount flags are not indicating to us otherwise, this\n\t * must mean that quota is on, and the dquot needs to be replayed.\n\t * Remember that we may not have fully recovered the superblock yet,\n\t * so we can't do the usual trick of looking at the SB quota bits.\n\t *\n\t * The other possibility, of course, is that the quota subsystem was\n\t * removed since the last mount - ENOSYS.\n\t */\n\tdq_f = item->ri_buf[0].i_addr;\n\tASSERT(dq_f);\n\terror = xfs_dqcheck(mp, recddq, dq_f->qlf_id, 0, XFS_QMOPT_DOWARN,\n\t\t\t   \"xlog_recover_dquot_pass2 (log copy)\");\n\tif (error)\n\t\treturn -EIO;\n\tASSERT(dq_f->qlf_len == 1);\n\n\t/*\n\t * At this point we are assuming that the dquots have been allocated\n\t * and hence the buffer has valid dquots stamped in it. It should,\n\t * therefore, pass verifier validation. If the dquot is bad, then the\n\t * we'll return an error here, so we don't need to specifically check\n\t * the dquot in the buffer after the verifier has run.\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dq_f->qlf_blkno,\n\t\t\t\t   XFS_FSB_TO_BB(mp, dq_f->qlf_len), 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(bp);\n\tddq = (xfs_disk_dquot_t *)xfs_buf_offset(bp, dq_f->qlf_boffset);\n\n\t/*\n\t * If the dquot has an LSN in it, recover the dquot only if it's less\n\t * than the lsn of the transaction we are replaying.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddq;\n\t\txfs_lsn_t\tlsn = be64_to_cpu(dqb->dd_lsn);\n\n\t\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) >= 0) {\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\tmemcpy(ddq, recddq, item->ri_buf[1].i_len);\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\txfs_update_cksum((char *)ddq, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\tASSERT(dq_f->qlf_size == 2);\n\tASSERT(bp->b_target->bt_mount == mp);\n\tbp->b_iodone = xlog_recover_iodone;\n\txfs_buf_delwri_queue(bp, buffer_list);\n\nout_release:\n\txfs_buf_relse(bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_efd_pass2",
          "args": [
            "log",
            "item"
          ],
          "line": 3246
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_efd_pass2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "2964-3010",
          "snippet": "STATIC int\nxlog_recover_efd_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\txfs_efd_log_format_t\t*efd_formatp;\n\txfs_efi_log_item_t\t*efip = NULL;\n\txfs_log_item_t\t\t*lip;\n\t__uint64_t\t\tefi_id;\n\tstruct xfs_ail_cursor\tcur;\n\tstruct xfs_ail\t\t*ailp = log->l_ailp;\n\n\tefd_formatp = item->ri_buf[0].i_addr;\n\tASSERT((item->ri_buf[0].i_len == (sizeof(xfs_efd_log_format_32_t) +\n\t\t((efd_formatp->efd_nextents - 1) * sizeof(xfs_extent_32_t)))) ||\n\t       (item->ri_buf[0].i_len == (sizeof(xfs_efd_log_format_64_t) +\n\t\t((efd_formatp->efd_nextents - 1) * sizeof(xfs_extent_64_t)))));\n\tefi_id = efd_formatp->efd_efi_id;\n\n\t/*\n\t * Search for the efi with the id in the efd format structure\n\t * in the AIL.\n\t */\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, 0);\n\twhile (lip != NULL) {\n\t\tif (lip->li_type == XFS_LI_EFI) {\n\t\t\tefip = (xfs_efi_log_item_t *)lip;\n\t\t\tif (efip->efi_format.efi_id == efi_id) {\n\t\t\t\t/*\n\t\t\t\t * xfs_trans_ail_delete() drops the\n\t\t\t\t * AIL lock.\n\t\t\t\t */\n\t\t\t\txfs_trans_ail_delete(ailp, lip,\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t\txfs_efi_item_free(efip);\n\t\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t}\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_efd_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\txfs_efd_log_format_t\t*efd_formatp;\n\txfs_efi_log_item_t\t*efip = NULL;\n\txfs_log_item_t\t\t*lip;\n\t__uint64_t\t\tefi_id;\n\tstruct xfs_ail_cursor\tcur;\n\tstruct xfs_ail\t\t*ailp = log->l_ailp;\n\n\tefd_formatp = item->ri_buf[0].i_addr;\n\tASSERT((item->ri_buf[0].i_len == (sizeof(xfs_efd_log_format_32_t) +\n\t\t((efd_formatp->efd_nextents - 1) * sizeof(xfs_extent_32_t)))) ||\n\t       (item->ri_buf[0].i_len == (sizeof(xfs_efd_log_format_64_t) +\n\t\t((efd_formatp->efd_nextents - 1) * sizeof(xfs_extent_64_t)))));\n\tefi_id = efd_formatp->efd_efi_id;\n\n\t/*\n\t * Search for the efi with the id in the efd format structure\n\t * in the AIL.\n\t */\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, 0);\n\twhile (lip != NULL) {\n\t\tif (lip->li_type == XFS_LI_EFI) {\n\t\t\tefip = (xfs_efi_log_item_t *)lip;\n\t\t\tif (efip->efi_format.efi_id == efi_id) {\n\t\t\t\t/*\n\t\t\t\t * xfs_trans_ail_delete() drops the\n\t\t\t\t * AIL lock.\n\t\t\t\t */\n\t\t\t\txfs_trans_ail_delete(ailp, lip,\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t\txfs_efi_item_free(efip);\n\t\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t}\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_efi_pass2",
          "args": [
            "log",
            "item",
            "trans->r_lsn"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_efi_pass2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "2926-2953",
          "snippet": "STATIC int\nxlog_recover_efi_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tint\t\t\terror;\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_efi_log_item_t\t*efip;\n\txfs_efi_log_format_t\t*efi_formatp;\n\n\tefi_formatp = item->ri_buf[0].i_addr;\n\n\tefip = xfs_efi_init(mp, efi_formatp->efi_nextents);\n\tif ((error = xfs_efi_copy_format(&(item->ri_buf[0]),\n\t\t\t\t\t &(efip->efi_format)))) {\n\t\txfs_efi_item_free(efip);\n\t\treturn error;\n\t}\n\tatomic_set(&efip->efi_next_extent, efi_formatp->efi_nextents);\n\n\tspin_lock(&log->l_ailp->xa_lock);\n\t/*\n\t * xfs_trans_ail_update() drops the AIL lock.\n\t */\n\txfs_trans_ail_update(log->l_ailp, &efip->efi_item, lsn);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_efi_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tint\t\t\terror;\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_efi_log_item_t\t*efip;\n\txfs_efi_log_format_t\t*efi_formatp;\n\n\tefi_formatp = item->ri_buf[0].i_addr;\n\n\tefip = xfs_efi_init(mp, efi_formatp->efi_nextents);\n\tif ((error = xfs_efi_copy_format(&(item->ri_buf[0]),\n\t\t\t\t\t &(efip->efi_format)))) {\n\t\txfs_efi_item_free(efip);\n\t\treturn error;\n\t}\n\tatomic_set(&efip->efi_next_extent, efi_formatp->efi_nextents);\n\n\tspin_lock(&log->l_ailp->xa_lock);\n\t/*\n\t * xfs_trans_ail_update() drops the AIL lock.\n\t */\n\txfs_trans_ail_update(log->l_ailp, &efip->efi_item, lsn);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_inode_pass2",
          "args": [
            "log",
            "buffer_list",
            "item",
            "trans->r_lsn"
          ],
          "line": 3241
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_inode_pass2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "2494-2784",
          "snippet": "STATIC int\nxlog_recover_inode_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\txfs_inode_log_format_t\t*in_f;\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_buf_t\t\t*bp;\n\txfs_dinode_t\t\t*dip;\n\tint\t\t\tlen;\n\txfs_caddr_t\t\tsrc;\n\txfs_caddr_t\t\tdest;\n\tint\t\t\terror;\n\tint\t\t\tattr_index;\n\tuint\t\t\tfields;\n\txfs_icdinode_t\t\t*dicp;\n\tuint\t\t\tisize;\n\tint\t\t\tneed_free = 0;\n\n\tif (item->ri_buf[0].i_len == sizeof(xfs_inode_log_format_t)) {\n\t\tin_f = item->ri_buf[0].i_addr;\n\t} else {\n\t\tin_f = kmem_alloc(sizeof(xfs_inode_log_format_t), KM_SLEEP);\n\t\tneed_free = 1;\n\t\terror = xfs_inode_item_format_convert(&item->ri_buf[0], in_f);\n\t\tif (error)\n\t\t\tgoto error;\n\t}\n\n\t/*\n\t * Inode buffers can be freed, look out for it,\n\t * and do not replay the inode.\n\t */\n\tif (xlog_check_buffer_cancelled(log, in_f->ilf_blkno,\n\t\t\t\t\tin_f->ilf_len, 0)) {\n\t\terror = 0;\n\t\ttrace_xfs_log_recover_inode_cancel(log, in_f);\n\t\tgoto error;\n\t}\n\ttrace_xfs_log_recover_inode_recover(log, in_f);\n\n\tbp = xfs_buf_read(mp->m_ddev_targp, in_f->ilf_blkno, in_f->ilf_len, 0,\n\t\t\t  &xfs_inode_buf_ops);\n\tif (!bp) {\n\t\terror = -ENOMEM;\n\t\tgoto error;\n\t}\n\terror = bp->b_error;\n\tif (error) {\n\t\txfs_buf_ioerror_alert(bp, \"xlog_recover_do..(read#2)\");\n\t\tgoto out_release;\n\t}\n\tASSERT(in_f->ilf_fields & XFS_ILOG_CORE);\n\tdip = (xfs_dinode_t *)xfs_buf_offset(bp, in_f->ilf_boffset);\n\n\t/*\n\t * Make sure the place we're flushing out to really looks\n\t * like an inode!\n\t */\n\tif (unlikely(dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))) {\n\t\txfs_alert(mp,\n\t\"%s: Bad inode magic number, dip = 0x%p, dino bp = 0x%p, ino = %Ld\",\n\t\t\t__func__, dip, bp, in_f->ilf_ino);\n\t\tXFS_ERROR_REPORT(\"xlog_recover_inode_pass2(1)\",\n\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tdicp = item->ri_buf[1].i_addr;\n\tif (unlikely(dicp->di_magic != XFS_DINODE_MAGIC)) {\n\t\txfs_alert(mp,\n\t\t\t\"%s: Bad inode log record, rec ptr 0x%p, ino %Ld\",\n\t\t\t__func__, item, in_f->ilf_ino);\n\t\tXFS_ERROR_REPORT(\"xlog_recover_inode_pass2(2)\",\n\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * If the inode has an LSN in it, recover the inode only if it's less\n\t * than the lsn of the transaction we are replaying. Note: we still\n\t * need to replay an owner change even though the inode is more recent\n\t * than the transaction as there is no guarantee that all the btree\n\t * blocks are more recent than this transaction, too.\n\t */\n\tif (dip->di_version >= 3) {\n\t\txfs_lsn_t\tlsn = be64_to_cpu(dip->di_lsn);\n\n\t\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) >= 0) {\n\t\t\ttrace_xfs_log_recover_inode_skip(log, in_f);\n\t\t\terror = 0;\n\t\t\tgoto out_owner_change;\n\t\t}\n\t}\n\n\t/*\n\t * di_flushiter is only valid for v1/2 inodes. All changes for v3 inodes\n\t * are transactional and if ordering is necessary we can determine that\n\t * more accurately by the LSN field in the V3 inode core. Don't trust\n\t * the inode versions we might be changing them here - use the\n\t * superblock flag to determine whether we need to look at di_flushiter\n\t * to skip replay when the on disk inode is newer than the log one\n\t */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    dicp->di_flushiter < be16_to_cpu(dip->di_flushiter)) {\n\t\t/*\n\t\t * Deal with the wrap case, DI_MAX_FLUSH is less\n\t\t * than smaller numbers\n\t\t */\n\t\tif (be16_to_cpu(dip->di_flushiter) == DI_MAX_FLUSH &&\n\t\t    dicp->di_flushiter < (DI_MAX_FLUSH >> 1)) {\n\t\t\t/* do nothing */\n\t\t} else {\n\t\t\ttrace_xfs_log_recover_inode_skip(log, in_f);\n\t\t\terror = 0;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\t/* Take the opportunity to reset the flush iteration count */\n\tdicp->di_flushiter = 0;\n\n\tif (unlikely(S_ISREG(dicp->di_mode))) {\n\t\tif ((dicp->di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (dicp->di_format != XFS_DINODE_FMT_BTREE)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(3)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp, dicp);\n\t\t\txfs_alert(mp,\n\t\t\"%s: Bad regular inode log record, rec ptr 0x%p, \"\n\t\t\"ino ptr = 0x%p, ino bp = 0x%p, ino %Ld\",\n\t\t\t\t__func__, item, dip, bp, in_f->ilf_ino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_release;\n\t\t}\n\t} else if (unlikely(S_ISDIR(dicp->di_mode))) {\n\t\tif ((dicp->di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (dicp->di_format != XFS_DINODE_FMT_BTREE) &&\n\t\t    (dicp->di_format != XFS_DINODE_FMT_LOCAL)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(4)\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\t\txfs_alert(mp,\n\t\t\"%s: Bad dir inode log record, rec ptr 0x%p, \"\n\t\t\"ino ptr = 0x%p, ino bp = 0x%p, ino %Ld\",\n\t\t\t\t__func__, item, dip, bp, in_f->ilf_ino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\tif (unlikely(dicp->di_nextents + dicp->di_anextents > dicp->di_nblocks)){\n\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(5)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\txfs_alert(mp,\n\t\"%s: Bad inode log record, rec ptr 0x%p, dino ptr 0x%p, \"\n\t\"dino bp 0x%p, ino %Ld, total extents = %d, nblocks = %Ld\",\n\t\t\t__func__, item, dip, bp, in_f->ilf_ino,\n\t\t\tdicp->di_nextents + dicp->di_anextents,\n\t\t\tdicp->di_nblocks);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tif (unlikely(dicp->di_forkoff > mp->m_sb.sb_inodesize)) {\n\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(6)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\txfs_alert(mp,\n\t\"%s: Bad inode log record, rec ptr 0x%p, dino ptr 0x%p, \"\n\t\"dino bp 0x%p, ino %Ld, forkoff 0x%x\", __func__,\n\t\t\titem, dip, bp, in_f->ilf_ino, dicp->di_forkoff);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tisize = xfs_icdinode_size(dicp->di_version);\n\tif (unlikely(item->ri_buf[1].i_len > isize)) {\n\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(7)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\txfs_alert(mp,\n\t\t\t\"%s: Bad inode log record length %d, rec ptr 0x%p\",\n\t\t\t__func__, item->ri_buf[1].i_len, item);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\n\t/* The core is in in-core format */\n\txfs_dinode_to_disk(dip, dicp);\n\n\t/* the rest is in on-disk format */\n\tif (item->ri_buf[1].i_len > isize) {\n\t\tmemcpy((char *)dip + isize,\n\t\t\titem->ri_buf[1].i_addr + isize,\n\t\t\titem->ri_buf[1].i_len - isize);\n\t}\n\n\tfields = in_f->ilf_fields;\n\tswitch (fields & (XFS_ILOG_DEV | XFS_ILOG_UUID)) {\n\tcase XFS_ILOG_DEV:\n\t\txfs_dinode_put_rdev(dip, in_f->ilf_u.ilfu_rdev);\n\t\tbreak;\n\tcase XFS_ILOG_UUID:\n\t\tmemcpy(XFS_DFORK_DPTR(dip),\n\t\t       &in_f->ilf_u.ilfu_uuid,\n\t\t       sizeof(uuid_t));\n\t\tbreak;\n\t}\n\n\tif (in_f->ilf_size == 2)\n\t\tgoto out_owner_change;\n\tlen = item->ri_buf[2].i_len;\n\tsrc = item->ri_buf[2].i_addr;\n\tASSERT(in_f->ilf_size <= 4);\n\tASSERT((in_f->ilf_size == 3) || (fields & XFS_ILOG_AFORK));\n\tASSERT(!(fields & XFS_ILOG_DFORK) ||\n\t       (len == in_f->ilf_dsize));\n\n\tswitch (fields & XFS_ILOG_DFORK) {\n\tcase XFS_ILOG_DDATA:\n\tcase XFS_ILOG_DEXT:\n\t\tmemcpy(XFS_DFORK_DPTR(dip), src, len);\n\t\tbreak;\n\n\tcase XFS_ILOG_DBROOT:\n\t\txfs_bmbt_to_bmdr(mp, (struct xfs_btree_block *)src, len,\n\t\t\t\t (xfs_bmdr_block_t *)XFS_DFORK_DPTR(dip),\n\t\t\t\t XFS_DFORK_DSIZE(dip, mp));\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * There are no data fork flags set.\n\t\t */\n\t\tASSERT((fields & XFS_ILOG_DFORK) == 0);\n\t\tbreak;\n\t}\n\n\t/*\n\t * If we logged any attribute data, recover it.  There may or\n\t * may not have been any other non-core data logged in this\n\t * transaction.\n\t */\n\tif (in_f->ilf_fields & XFS_ILOG_AFORK) {\n\t\tif (in_f->ilf_fields & XFS_ILOG_DFORK) {\n\t\t\tattr_index = 3;\n\t\t} else {\n\t\t\tattr_index = 2;\n\t\t}\n\t\tlen = item->ri_buf[attr_index].i_len;\n\t\tsrc = item->ri_buf[attr_index].i_addr;\n\t\tASSERT(len == in_f->ilf_asize);\n\n\t\tswitch (in_f->ilf_fields & XFS_ILOG_AFORK) {\n\t\tcase XFS_ILOG_ADATA:\n\t\tcase XFS_ILOG_AEXT:\n\t\t\tdest = XFS_DFORK_APTR(dip);\n\t\t\tASSERT(len <= XFS_DFORK_ASIZE(dip, mp));\n\t\t\tmemcpy(dest, src, len);\n\t\t\tbreak;\n\n\t\tcase XFS_ILOG_ABROOT:\n\t\t\tdest = XFS_DFORK_APTR(dip);\n\t\t\txfs_bmbt_to_bmdr(mp, (struct xfs_btree_block *)src,\n\t\t\t\t\t len, (xfs_bmdr_block_t*)dest,\n\t\t\t\t\t XFS_DFORK_ASIZE(dip, mp));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\txfs_warn(log->l_mp, \"%s: Invalid flag\", __func__);\n\t\t\tASSERT(0);\n\t\t\terror = -EIO;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\nout_owner_change:\n\tif (in_f->ilf_fields & (XFS_ILOG_DOWNER|XFS_ILOG_AOWNER))\n\t\terror = xfs_recover_inode_owner_change(mp, dip, in_f,\n\t\t\t\t\t\t       buffer_list);\n\t/* re-generate the checksum. */\n\txfs_dinode_calc_crc(log->l_mp, dip);\n\n\tASSERT(bp->b_target->bt_mount == mp);\n\tbp->b_iodone = xlog_recover_iodone;\n\txfs_buf_delwri_queue(bp, buffer_list);\n\nout_release:\n\txfs_buf_relse(bp);\nerror:\n\tif (need_free)\n\t\tkmem_free(in_f);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_inode_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\txfs_inode_log_format_t\t*in_f;\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_buf_t\t\t*bp;\n\txfs_dinode_t\t\t*dip;\n\tint\t\t\tlen;\n\txfs_caddr_t\t\tsrc;\n\txfs_caddr_t\t\tdest;\n\tint\t\t\terror;\n\tint\t\t\tattr_index;\n\tuint\t\t\tfields;\n\txfs_icdinode_t\t\t*dicp;\n\tuint\t\t\tisize;\n\tint\t\t\tneed_free = 0;\n\n\tif (item->ri_buf[0].i_len == sizeof(xfs_inode_log_format_t)) {\n\t\tin_f = item->ri_buf[0].i_addr;\n\t} else {\n\t\tin_f = kmem_alloc(sizeof(xfs_inode_log_format_t), KM_SLEEP);\n\t\tneed_free = 1;\n\t\terror = xfs_inode_item_format_convert(&item->ri_buf[0], in_f);\n\t\tif (error)\n\t\t\tgoto error;\n\t}\n\n\t/*\n\t * Inode buffers can be freed, look out for it,\n\t * and do not replay the inode.\n\t */\n\tif (xlog_check_buffer_cancelled(log, in_f->ilf_blkno,\n\t\t\t\t\tin_f->ilf_len, 0)) {\n\t\terror = 0;\n\t\ttrace_xfs_log_recover_inode_cancel(log, in_f);\n\t\tgoto error;\n\t}\n\ttrace_xfs_log_recover_inode_recover(log, in_f);\n\n\tbp = xfs_buf_read(mp->m_ddev_targp, in_f->ilf_blkno, in_f->ilf_len, 0,\n\t\t\t  &xfs_inode_buf_ops);\n\tif (!bp) {\n\t\terror = -ENOMEM;\n\t\tgoto error;\n\t}\n\terror = bp->b_error;\n\tif (error) {\n\t\txfs_buf_ioerror_alert(bp, \"xlog_recover_do..(read#2)\");\n\t\tgoto out_release;\n\t}\n\tASSERT(in_f->ilf_fields & XFS_ILOG_CORE);\n\tdip = (xfs_dinode_t *)xfs_buf_offset(bp, in_f->ilf_boffset);\n\n\t/*\n\t * Make sure the place we're flushing out to really looks\n\t * like an inode!\n\t */\n\tif (unlikely(dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))) {\n\t\txfs_alert(mp,\n\t\"%s: Bad inode magic number, dip = 0x%p, dino bp = 0x%p, ino = %Ld\",\n\t\t\t__func__, dip, bp, in_f->ilf_ino);\n\t\tXFS_ERROR_REPORT(\"xlog_recover_inode_pass2(1)\",\n\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tdicp = item->ri_buf[1].i_addr;\n\tif (unlikely(dicp->di_magic != XFS_DINODE_MAGIC)) {\n\t\txfs_alert(mp,\n\t\t\t\"%s: Bad inode log record, rec ptr 0x%p, ino %Ld\",\n\t\t\t__func__, item, in_f->ilf_ino);\n\t\tXFS_ERROR_REPORT(\"xlog_recover_inode_pass2(2)\",\n\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * If the inode has an LSN in it, recover the inode only if it's less\n\t * than the lsn of the transaction we are replaying. Note: we still\n\t * need to replay an owner change even though the inode is more recent\n\t * than the transaction as there is no guarantee that all the btree\n\t * blocks are more recent than this transaction, too.\n\t */\n\tif (dip->di_version >= 3) {\n\t\txfs_lsn_t\tlsn = be64_to_cpu(dip->di_lsn);\n\n\t\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) >= 0) {\n\t\t\ttrace_xfs_log_recover_inode_skip(log, in_f);\n\t\t\terror = 0;\n\t\t\tgoto out_owner_change;\n\t\t}\n\t}\n\n\t/*\n\t * di_flushiter is only valid for v1/2 inodes. All changes for v3 inodes\n\t * are transactional and if ordering is necessary we can determine that\n\t * more accurately by the LSN field in the V3 inode core. Don't trust\n\t * the inode versions we might be changing them here - use the\n\t * superblock flag to determine whether we need to look at di_flushiter\n\t * to skip replay when the on disk inode is newer than the log one\n\t */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    dicp->di_flushiter < be16_to_cpu(dip->di_flushiter)) {\n\t\t/*\n\t\t * Deal with the wrap case, DI_MAX_FLUSH is less\n\t\t * than smaller numbers\n\t\t */\n\t\tif (be16_to_cpu(dip->di_flushiter) == DI_MAX_FLUSH &&\n\t\t    dicp->di_flushiter < (DI_MAX_FLUSH >> 1)) {\n\t\t\t/* do nothing */\n\t\t} else {\n\t\t\ttrace_xfs_log_recover_inode_skip(log, in_f);\n\t\t\terror = 0;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\t/* Take the opportunity to reset the flush iteration count */\n\tdicp->di_flushiter = 0;\n\n\tif (unlikely(S_ISREG(dicp->di_mode))) {\n\t\tif ((dicp->di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (dicp->di_format != XFS_DINODE_FMT_BTREE)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(3)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp, dicp);\n\t\t\txfs_alert(mp,\n\t\t\"%s: Bad regular inode log record, rec ptr 0x%p, \"\n\t\t\"ino ptr = 0x%p, ino bp = 0x%p, ino %Ld\",\n\t\t\t\t__func__, item, dip, bp, in_f->ilf_ino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_release;\n\t\t}\n\t} else if (unlikely(S_ISDIR(dicp->di_mode))) {\n\t\tif ((dicp->di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (dicp->di_format != XFS_DINODE_FMT_BTREE) &&\n\t\t    (dicp->di_format != XFS_DINODE_FMT_LOCAL)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(4)\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\t\txfs_alert(mp,\n\t\t\"%s: Bad dir inode log record, rec ptr 0x%p, \"\n\t\t\"ino ptr = 0x%p, ino bp = 0x%p, ino %Ld\",\n\t\t\t\t__func__, item, dip, bp, in_f->ilf_ino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\tif (unlikely(dicp->di_nextents + dicp->di_anextents > dicp->di_nblocks)){\n\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(5)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\txfs_alert(mp,\n\t\"%s: Bad inode log record, rec ptr 0x%p, dino ptr 0x%p, \"\n\t\"dino bp 0x%p, ino %Ld, total extents = %d, nblocks = %Ld\",\n\t\t\t__func__, item, dip, bp, in_f->ilf_ino,\n\t\t\tdicp->di_nextents + dicp->di_anextents,\n\t\t\tdicp->di_nblocks);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tif (unlikely(dicp->di_forkoff > mp->m_sb.sb_inodesize)) {\n\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(6)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\txfs_alert(mp,\n\t\"%s: Bad inode log record, rec ptr 0x%p, dino ptr 0x%p, \"\n\t\"dino bp 0x%p, ino %Ld, forkoff 0x%x\", __func__,\n\t\t\titem, dip, bp, in_f->ilf_ino, dicp->di_forkoff);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tisize = xfs_icdinode_size(dicp->di_version);\n\tif (unlikely(item->ri_buf[1].i_len > isize)) {\n\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(7)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\txfs_alert(mp,\n\t\t\t\"%s: Bad inode log record length %d, rec ptr 0x%p\",\n\t\t\t__func__, item->ri_buf[1].i_len, item);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\n\t/* The core is in in-core format */\n\txfs_dinode_to_disk(dip, dicp);\n\n\t/* the rest is in on-disk format */\n\tif (item->ri_buf[1].i_len > isize) {\n\t\tmemcpy((char *)dip + isize,\n\t\t\titem->ri_buf[1].i_addr + isize,\n\t\t\titem->ri_buf[1].i_len - isize);\n\t}\n\n\tfields = in_f->ilf_fields;\n\tswitch (fields & (XFS_ILOG_DEV | XFS_ILOG_UUID)) {\n\tcase XFS_ILOG_DEV:\n\t\txfs_dinode_put_rdev(dip, in_f->ilf_u.ilfu_rdev);\n\t\tbreak;\n\tcase XFS_ILOG_UUID:\n\t\tmemcpy(XFS_DFORK_DPTR(dip),\n\t\t       &in_f->ilf_u.ilfu_uuid,\n\t\t       sizeof(uuid_t));\n\t\tbreak;\n\t}\n\n\tif (in_f->ilf_size == 2)\n\t\tgoto out_owner_change;\n\tlen = item->ri_buf[2].i_len;\n\tsrc = item->ri_buf[2].i_addr;\n\tASSERT(in_f->ilf_size <= 4);\n\tASSERT((in_f->ilf_size == 3) || (fields & XFS_ILOG_AFORK));\n\tASSERT(!(fields & XFS_ILOG_DFORK) ||\n\t       (len == in_f->ilf_dsize));\n\n\tswitch (fields & XFS_ILOG_DFORK) {\n\tcase XFS_ILOG_DDATA:\n\tcase XFS_ILOG_DEXT:\n\t\tmemcpy(XFS_DFORK_DPTR(dip), src, len);\n\t\tbreak;\n\n\tcase XFS_ILOG_DBROOT:\n\t\txfs_bmbt_to_bmdr(mp, (struct xfs_btree_block *)src, len,\n\t\t\t\t (xfs_bmdr_block_t *)XFS_DFORK_DPTR(dip),\n\t\t\t\t XFS_DFORK_DSIZE(dip, mp));\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * There are no data fork flags set.\n\t\t */\n\t\tASSERT((fields & XFS_ILOG_DFORK) == 0);\n\t\tbreak;\n\t}\n\n\t/*\n\t * If we logged any attribute data, recover it.  There may or\n\t * may not have been any other non-core data logged in this\n\t * transaction.\n\t */\n\tif (in_f->ilf_fields & XFS_ILOG_AFORK) {\n\t\tif (in_f->ilf_fields & XFS_ILOG_DFORK) {\n\t\t\tattr_index = 3;\n\t\t} else {\n\t\t\tattr_index = 2;\n\t\t}\n\t\tlen = item->ri_buf[attr_index].i_len;\n\t\tsrc = item->ri_buf[attr_index].i_addr;\n\t\tASSERT(len == in_f->ilf_asize);\n\n\t\tswitch (in_f->ilf_fields & XFS_ILOG_AFORK) {\n\t\tcase XFS_ILOG_ADATA:\n\t\tcase XFS_ILOG_AEXT:\n\t\t\tdest = XFS_DFORK_APTR(dip);\n\t\t\tASSERT(len <= XFS_DFORK_ASIZE(dip, mp));\n\t\t\tmemcpy(dest, src, len);\n\t\t\tbreak;\n\n\t\tcase XFS_ILOG_ABROOT:\n\t\t\tdest = XFS_DFORK_APTR(dip);\n\t\t\txfs_bmbt_to_bmdr(mp, (struct xfs_btree_block *)src,\n\t\t\t\t\t len, (xfs_bmdr_block_t*)dest,\n\t\t\t\t\t XFS_DFORK_ASIZE(dip, mp));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\txfs_warn(log->l_mp, \"%s: Invalid flag\", __func__);\n\t\t\tASSERT(0);\n\t\t\terror = -EIO;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\nout_owner_change:\n\tif (in_f->ilf_fields & (XFS_ILOG_DOWNER|XFS_ILOG_AOWNER))\n\t\terror = xfs_recover_inode_owner_change(mp, dip, in_f,\n\t\t\t\t\t\t       buffer_list);\n\t/* re-generate the checksum. */\n\txfs_dinode_calc_crc(log->l_mp, dip);\n\n\tASSERT(bp->b_target->bt_mount == mp);\n\tbp->b_iodone = xlog_recover_iodone;\n\txfs_buf_delwri_queue(bp, buffer_list);\n\nout_release:\n\txfs_buf_relse(bp);\nerror:\n\tif (need_free)\n\t\tkmem_free(in_f);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_buffer_pass2",
          "args": [
            "log",
            "buffer_list",
            "item",
            "trans->r_lsn"
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_buffer_pass2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "2306-2416",
          "snippet": "STATIC int\nxlog_recover_buffer_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\txfs_buf_log_format_t\t*buf_f = item->ri_buf[0].i_addr;\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\tuint\t\t\tbuf_flags;\n\txfs_lsn_t\t\tlsn;\n\n\t/*\n\t * In this pass we only want to recover all the buffers which have\n\t * not been cancelled and are not cancellation buffers themselves.\n\t */\n\tif (xlog_check_buffer_cancelled(log, buf_f->blf_blkno,\n\t\t\tbuf_f->blf_len, buf_f->blf_flags)) {\n\t\ttrace_xfs_log_recover_buf_cancel(log, buf_f);\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_log_recover_buf_recover(log, buf_f);\n\n\tbuf_flags = 0;\n\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF)\n\t\tbuf_flags |= XBF_UNMAPPED;\n\n\tbp = xfs_buf_read(mp->m_ddev_targp, buf_f->blf_blkno, buf_f->blf_len,\n\t\t\t  buf_flags, NULL);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\terror = bp->b_error;\n\tif (error) {\n\t\txfs_buf_ioerror_alert(bp, \"xlog_recover_do..(read#1)\");\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * Recover the buffer only if we get an LSN from it and it's less than\n\t * the lsn of the transaction we are replaying.\n\t *\n\t * Note that we have to be extremely careful of readahead here.\n\t * Readahead does not attach verfiers to the buffers so if we don't\n\t * actually do any replay after readahead because of the LSN we found\n\t * in the buffer if more recent than that current transaction then we\n\t * need to attach the verifier directly. Failure to do so can lead to\n\t * future recovery actions (e.g. EFI and unlinked list recovery) can\n\t * operate on the buffers and they won't get the verifier attached. This\n\t * can lead to blocks on disk having the correct content but a stale\n\t * CRC.\n\t *\n\t * It is safe to assume these clean buffers are currently up to date.\n\t * If the buffer is dirtied by a later transaction being replayed, then\n\t * the verifier will be reset to match whatever recover turns that\n\t * buffer into.\n\t */\n\tlsn = xlog_recover_get_buf_lsn(mp, bp);\n\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) >= 0) {\n\t\txlog_recover_validate_buf_type(mp, bp, buf_f);\n\t\tgoto out_release;\n\t}\n\n\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF) {\n\t\terror = xlog_recover_do_inode_buffer(mp, item, bp, buf_f);\n\t\tif (error)\n\t\t\tgoto out_release;\n\t} else if (buf_f->blf_flags &\n\t\t  (XFS_BLF_UDQUOT_BUF|XFS_BLF_PDQUOT_BUF|XFS_BLF_GDQUOT_BUF)) {\n\t\tbool\tdirty;\n\n\t\tdirty = xlog_recover_do_dquot_buffer(mp, log, item, bp, buf_f);\n\t\tif (!dirty)\n\t\t\tgoto out_release;\n\t} else {\n\t\txlog_recover_do_reg_buffer(mp, item, bp, buf_f);\n\t}\n\n\t/*\n\t * Perform delayed write on the buffer.  Asynchronous writes will be\n\t * slower when taking into account all the buffers to be flushed.\n\t *\n\t * Also make sure that only inode buffers with good sizes stay in\n\t * the buffer cache.  The kernel moves inodes in buffers of 1 block\n\t * or mp->m_inode_cluster_size bytes, whichever is bigger.  The inode\n\t * buffers in the log can be a different size if the log was generated\n\t * by an older kernel using unclustered inode buffers or a newer kernel\n\t * running with a different inode cluster size.  Regardless, if the\n\t * the inode buffer size isn't MAX(blocksize, mp->m_inode_cluster_size)\n\t * for *our* value of mp->m_inode_cluster_size, then we need to keep\n\t * the buffer out of the buffer cache so that the buffer won't\n\t * overlap with future reads of those inodes.\n\t */\n\tif (XFS_DINODE_MAGIC ==\n\t    be16_to_cpu(*((__be16 *)xfs_buf_offset(bp, 0))) &&\n\t    (BBTOB(bp->b_io_length) != MAX(log->l_mp->m_sb.sb_blocksize,\n\t\t\t(__uint32_t)log->l_mp->m_inode_cluster_size))) {\n\t\txfs_buf_stale(bp);\n\t\terror = xfs_bwrite(bp);\n\t} else {\n\t\tASSERT(bp->b_target->bt_mount == mp);\n\t\tbp->b_iodone = xlog_recover_iodone;\n\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t}\n\nout_release:\n\txfs_buf_relse(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_buffer_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\txfs_buf_log_format_t\t*buf_f = item->ri_buf[0].i_addr;\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\tuint\t\t\tbuf_flags;\n\txfs_lsn_t\t\tlsn;\n\n\t/*\n\t * In this pass we only want to recover all the buffers which have\n\t * not been cancelled and are not cancellation buffers themselves.\n\t */\n\tif (xlog_check_buffer_cancelled(log, buf_f->blf_blkno,\n\t\t\tbuf_f->blf_len, buf_f->blf_flags)) {\n\t\ttrace_xfs_log_recover_buf_cancel(log, buf_f);\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_log_recover_buf_recover(log, buf_f);\n\n\tbuf_flags = 0;\n\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF)\n\t\tbuf_flags |= XBF_UNMAPPED;\n\n\tbp = xfs_buf_read(mp->m_ddev_targp, buf_f->blf_blkno, buf_f->blf_len,\n\t\t\t  buf_flags, NULL);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\terror = bp->b_error;\n\tif (error) {\n\t\txfs_buf_ioerror_alert(bp, \"xlog_recover_do..(read#1)\");\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * Recover the buffer only if we get an LSN from it and it's less than\n\t * the lsn of the transaction we are replaying.\n\t *\n\t * Note that we have to be extremely careful of readahead here.\n\t * Readahead does not attach verfiers to the buffers so if we don't\n\t * actually do any replay after readahead because of the LSN we found\n\t * in the buffer if more recent than that current transaction then we\n\t * need to attach the verifier directly. Failure to do so can lead to\n\t * future recovery actions (e.g. EFI and unlinked list recovery) can\n\t * operate on the buffers and they won't get the verifier attached. This\n\t * can lead to blocks on disk having the correct content but a stale\n\t * CRC.\n\t *\n\t * It is safe to assume these clean buffers are currently up to date.\n\t * If the buffer is dirtied by a later transaction being replayed, then\n\t * the verifier will be reset to match whatever recover turns that\n\t * buffer into.\n\t */\n\tlsn = xlog_recover_get_buf_lsn(mp, bp);\n\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) >= 0) {\n\t\txlog_recover_validate_buf_type(mp, bp, buf_f);\n\t\tgoto out_release;\n\t}\n\n\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF) {\n\t\terror = xlog_recover_do_inode_buffer(mp, item, bp, buf_f);\n\t\tif (error)\n\t\t\tgoto out_release;\n\t} else if (buf_f->blf_flags &\n\t\t  (XFS_BLF_UDQUOT_BUF|XFS_BLF_PDQUOT_BUF|XFS_BLF_GDQUOT_BUF)) {\n\t\tbool\tdirty;\n\n\t\tdirty = xlog_recover_do_dquot_buffer(mp, log, item, bp, buf_f);\n\t\tif (!dirty)\n\t\t\tgoto out_release;\n\t} else {\n\t\txlog_recover_do_reg_buffer(mp, item, bp, buf_f);\n\t}\n\n\t/*\n\t * Perform delayed write on the buffer.  Asynchronous writes will be\n\t * slower when taking into account all the buffers to be flushed.\n\t *\n\t * Also make sure that only inode buffers with good sizes stay in\n\t * the buffer cache.  The kernel moves inodes in buffers of 1 block\n\t * or mp->m_inode_cluster_size bytes, whichever is bigger.  The inode\n\t * buffers in the log can be a different size if the log was generated\n\t * by an older kernel using unclustered inode buffers or a newer kernel\n\t * running with a different inode cluster size.  Regardless, if the\n\t * the inode buffer size isn't MAX(blocksize, mp->m_inode_cluster_size)\n\t * for *our* value of mp->m_inode_cluster_size, then we need to keep\n\t * the buffer out of the buffer cache so that the buffer won't\n\t * overlap with future reads of those inodes.\n\t */\n\tif (XFS_DINODE_MAGIC ==\n\t    be16_to_cpu(*((__be16 *)xfs_buf_offset(bp, 0))) &&\n\t    (BBTOB(bp->b_io_length) != MAX(log->l_mp->m_sb.sb_blocksize,\n\t\t\t(__uint32_t)log->l_mp->m_inode_cluster_size))) {\n\t\txfs_buf_stale(bp);\n\t\terror = xfs_bwrite(bp);\n\t} else {\n\t\tASSERT(bp->b_target->bt_mount == mp);\n\t\tbp->b_iodone = xlog_recover_iodone;\n\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t}\n\nout_release:\n\txfs_buf_relse(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITEM_TYPE",
          "args": [
            "item"
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_item_recover",
          "args": [
            "log",
            "trans",
            "item",
            "XLOG_RECOVER_PASS2"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover\t\t*trans,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item)\n{\n\ttrace_xfs_log_recover_item_recover(log, trans, item, XLOG_RECOVER_PASS2);\n\n\tswitch (ITEM_TYPE(item)) {\n\tcase XFS_LI_BUF:\n\t\treturn xlog_recover_buffer_pass2(log, buffer_list, item,\n\t\t\t\t\t\t trans->r_lsn);\n\tcase XFS_LI_INODE:\n\t\treturn xlog_recover_inode_pass2(log, buffer_list, item,\n\t\t\t\t\t\t trans->r_lsn);\n\tcase XFS_LI_EFI:\n\t\treturn xlog_recover_efi_pass2(log, item, trans->r_lsn);\n\tcase XFS_LI_EFD:\n\t\treturn xlog_recover_efd_pass2(log, item);\n\tcase XFS_LI_DQUOT:\n\t\treturn xlog_recover_dquot_pass2(log, buffer_list, item,\n\t\t\t\t\t\ttrans->r_lsn);\n\tcase XFS_LI_ICREATE:\n\t\treturn xlog_recover_do_icreate_pass2(log, buffer_list, item);\n\tcase XFS_LI_QUOTAOFF:\n\t\t/* nothing to do in pass2 */\n\t\treturn 0;\n\tdefault:\n\t\txfs_warn(log->l_mp, \"%s: invalid item type (%d)\",\n\t\t\t__func__, ITEM_TYPE(item));\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n}"
  },
  {
    "function_name": "xlog_recover_commit_pass1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3199-3225",
    "snippet": "STATIC int\nxlog_recover_commit_pass1(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover\t\t*trans,\n\tstruct xlog_recover_item\t*item)\n{\n\ttrace_xfs_log_recover_item_recover(log, trans, item, XLOG_RECOVER_PASS1);\n\n\tswitch (ITEM_TYPE(item)) {\n\tcase XFS_LI_BUF:\n\t\treturn xlog_recover_buffer_pass1(log, item);\n\tcase XFS_LI_QUOTAOFF:\n\t\treturn xlog_recover_quotaoff_pass1(log, item);\n\tcase XFS_LI_INODE:\n\tcase XFS_LI_EFI:\n\tcase XFS_LI_EFD:\n\tcase XFS_LI_DQUOT:\n\tcase XFS_LI_ICREATE:\n\t\t/* nothing to do in pass 1 */\n\t\treturn 0;\n\tdefault:\n\t\txfs_warn(log->l_mp, \"%s: invalid item type (%d)\",\n\t\t\t__func__, ITEM_TYPE(item));\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 3222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"%s: invalid item type (%d)\"",
            "__func__",
            "ITEM_TYPE(item)"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ITEM_TYPE",
          "args": [
            "item"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_recover_quotaoff_pass1",
          "args": [
            "log",
            "item"
          ],
          "line": 3211
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_quotaoff_pass1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "2791-2811",
          "snippet": "STATIC int\nxlog_recover_quotaoff_pass1(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\txfs_qoff_logformat_t\t*qoff_f = item->ri_buf[0].i_addr;\n\tASSERT(qoff_f);\n\n\t/*\n\t * The logitem format's flag tells us if this was user quotaoff,\n\t * group/project quotaoff or both.\n\t */\n\tif (qoff_f->qf_flags & XFS_UQUOTA_ACCT)\n\t\tlog->l_quotaoffs_flag |= XFS_DQ_USER;\n\tif (qoff_f->qf_flags & XFS_PQUOTA_ACCT)\n\t\tlog->l_quotaoffs_flag |= XFS_DQ_PROJ;\n\tif (qoff_f->qf_flags & XFS_GQUOTA_ACCT)\n\t\tlog->l_quotaoffs_flag |= XFS_DQ_GROUP;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_quotaoff_pass1(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\txfs_qoff_logformat_t\t*qoff_f = item->ri_buf[0].i_addr;\n\tASSERT(qoff_f);\n\n\t/*\n\t * The logitem format's flag tells us if this was user quotaoff,\n\t * group/project quotaoff or both.\n\t */\n\tif (qoff_f->qf_flags & XFS_UQUOTA_ACCT)\n\t\tlog->l_quotaoffs_flag |= XFS_DQ_USER;\n\tif (qoff_f->qf_flags & XFS_PQUOTA_ACCT)\n\t\tlog->l_quotaoffs_flag |= XFS_DQ_PROJ;\n\tif (qoff_f->qf_flags & XFS_GQUOTA_ACCT)\n\t\tlog->l_quotaoffs_flag |= XFS_DQ_GROUP;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_buffer_pass1",
          "args": [
            "log",
            "item"
          ],
          "line": 3209
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_buffer_pass1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1577-1616",
          "snippet": "STATIC int\nxlog_recover_buffer_pass1(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\txfs_buf_log_format_t\t*buf_f = item->ri_buf[0].i_addr;\n\tstruct list_head\t*bucket;\n\tstruct xfs_buf_cancel\t*bcp;\n\n\t/*\n\t * If this isn't a cancel buffer item, then just return.\n\t */\n\tif (!(buf_f->blf_flags & XFS_BLF_CANCEL)) {\n\t\ttrace_xfs_log_recover_buf_not_cancel(log, buf_f);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Insert an xfs_buf_cancel record into the hash table of them.\n\t * If there is already an identical record, bump its reference count.\n\t */\n\tbucket = XLOG_BUF_CANCEL_BUCKET(log, buf_f->blf_blkno);\n\tlist_for_each_entry(bcp, bucket, bc_list) {\n\t\tif (bcp->bc_blkno == buf_f->blf_blkno &&\n\t\t    bcp->bc_len == buf_f->blf_len) {\n\t\t\tbcp->bc_refcount++;\n\t\t\ttrace_xfs_log_recover_buf_cancel_ref_inc(log, buf_f);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tbcp = kmem_alloc(sizeof(struct xfs_buf_cancel), KM_SLEEP);\n\tbcp->bc_blkno = buf_f->blf_blkno;\n\tbcp->bc_len = buf_f->blf_len;\n\tbcp->bc_refcount = 1;\n\tlist_add_tail(&bcp->bc_list, bucket);\n\n\ttrace_xfs_log_recover_buf_cancel_add(log, buf_f);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_buffer_pass1(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\txfs_buf_log_format_t\t*buf_f = item->ri_buf[0].i_addr;\n\tstruct list_head\t*bucket;\n\tstruct xfs_buf_cancel\t*bcp;\n\n\t/*\n\t * If this isn't a cancel buffer item, then just return.\n\t */\n\tif (!(buf_f->blf_flags & XFS_BLF_CANCEL)) {\n\t\ttrace_xfs_log_recover_buf_not_cancel(log, buf_f);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Insert an xfs_buf_cancel record into the hash table of them.\n\t * If there is already an identical record, bump its reference count.\n\t */\n\tbucket = XLOG_BUF_CANCEL_BUCKET(log, buf_f->blf_blkno);\n\tlist_for_each_entry(bcp, bucket, bc_list) {\n\t\tif (bcp->bc_blkno == buf_f->blf_blkno &&\n\t\t    bcp->bc_len == buf_f->blf_len) {\n\t\t\tbcp->bc_refcount++;\n\t\t\ttrace_xfs_log_recover_buf_cancel_ref_inc(log, buf_f);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tbcp = kmem_alloc(sizeof(struct xfs_buf_cancel), KM_SLEEP);\n\tbcp->bc_blkno = buf_f->blf_blkno;\n\tbcp->bc_len = buf_f->blf_len;\n\tbcp->bc_refcount = 1;\n\tlist_add_tail(&bcp->bc_list, bucket);\n\n\ttrace_xfs_log_recover_buf_cancel_add(log, buf_f);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITEM_TYPE",
          "args": [
            "item"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_item_recover",
          "args": [
            "log",
            "trans",
            "item",
            "XLOG_RECOVER_PASS1"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_commit_pass1(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover\t\t*trans,\n\tstruct xlog_recover_item\t*item)\n{\n\ttrace_xfs_log_recover_item_recover(log, trans, item, XLOG_RECOVER_PASS1);\n\n\tswitch (ITEM_TYPE(item)) {\n\tcase XFS_LI_BUF:\n\t\treturn xlog_recover_buffer_pass1(log, item);\n\tcase XFS_LI_QUOTAOFF:\n\t\treturn xlog_recover_quotaoff_pass1(log, item);\n\tcase XFS_LI_INODE:\n\tcase XFS_LI_EFI:\n\tcase XFS_LI_EFD:\n\tcase XFS_LI_DQUOT:\n\tcase XFS_LI_ICREATE:\n\t\t/* nothing to do in pass 1 */\n\t\treturn 0;\n\tdefault:\n\t\txfs_warn(log->l_mp, \"%s: invalid item type (%d)\",\n\t\t\t__func__, ITEM_TYPE(item));\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n}"
  },
  {
    "function_name": "xlog_recover_ra_pass2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3176-3197",
    "snippet": "STATIC void\nxlog_recover_ra_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\tswitch (ITEM_TYPE(item)) {\n\tcase XFS_LI_BUF:\n\t\txlog_recover_buffer_ra_pass2(log, item);\n\t\tbreak;\n\tcase XFS_LI_INODE:\n\t\txlog_recover_inode_ra_pass2(log, item);\n\t\tbreak;\n\tcase XFS_LI_DQUOT:\n\t\txlog_recover_dquot_ra_pass2(log, item);\n\t\tbreak;\n\tcase XFS_LI_EFI:\n\tcase XFS_LI_EFD:\n\tcase XFS_LI_QUOTAOFF:\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_recover_dquot_ra_pass2",
          "args": [
            "log",
            "item"
          ],
          "line": 3189
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_dquot_ra_pass2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3143-3174",
          "snippet": "STATIC void\nxlog_recover_dquot_ra_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\tstruct xfs_mount\t*mp = log->l_mp;\n\tstruct xfs_disk_dquot\t*recddq;\n\tstruct xfs_dq_logformat\t*dq_f;\n\tuint\t\t\ttype;\n\n\n\tif (mp->m_qflags == 0)\n\t\treturn;\n\n\trecddq = item->ri_buf[1].i_addr;\n\tif (recddq == NULL)\n\t\treturn;\n\tif (item->ri_buf[1].i_len < sizeof(struct xfs_disk_dquot))\n\t\treturn;\n\n\ttype = recddq->d_flags & (XFS_DQ_USER | XFS_DQ_PROJ | XFS_DQ_GROUP);\n\tASSERT(type);\n\tif (log->l_quotaoffs_flag & type)\n\t\treturn;\n\n\tdq_f = item->ri_buf[0].i_addr;\n\tASSERT(dq_f);\n\tASSERT(dq_f->qlf_len == 1);\n\n\txfs_buf_readahead(mp->m_ddev_targp, dq_f->qlf_blkno,\n\t\t\t  XFS_FSB_TO_BB(mp, dq_f->qlf_len), NULL);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_dquot_ra_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\tstruct xfs_mount\t*mp = log->l_mp;\n\tstruct xfs_disk_dquot\t*recddq;\n\tstruct xfs_dq_logformat\t*dq_f;\n\tuint\t\t\ttype;\n\n\n\tif (mp->m_qflags == 0)\n\t\treturn;\n\n\trecddq = item->ri_buf[1].i_addr;\n\tif (recddq == NULL)\n\t\treturn;\n\tif (item->ri_buf[1].i_len < sizeof(struct xfs_disk_dquot))\n\t\treturn;\n\n\ttype = recddq->d_flags & (XFS_DQ_USER | XFS_DQ_PROJ | XFS_DQ_GROUP);\n\tASSERT(type);\n\tif (log->l_quotaoffs_flag & type)\n\t\treturn;\n\n\tdq_f = item->ri_buf[0].i_addr;\n\tASSERT(dq_f);\n\tASSERT(dq_f->qlf_len == 1);\n\n\txfs_buf_readahead(mp->m_ddev_targp, dq_f->qlf_blkno,\n\t\t\t  XFS_FSB_TO_BB(mp, dq_f->qlf_len), NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_inode_ra_pass2",
          "args": [
            "log",
            "item"
          ],
          "line": 3186
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_inode_ra_pass2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3116-3141",
          "snippet": "STATIC void\nxlog_recover_inode_ra_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover_item        *item)\n{\n\tstruct xfs_inode_log_format\tilf_buf;\n\tstruct xfs_inode_log_format\t*ilfp;\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\tint\t\t\terror;\n\n\tif (item->ri_buf[0].i_len == sizeof(struct xfs_inode_log_format)) {\n\t\tilfp = item->ri_buf[0].i_addr;\n\t} else {\n\t\tilfp = &ilf_buf;\n\t\tmemset(ilfp, 0, sizeof(*ilfp));\n\t\terror = xfs_inode_item_format_convert(&item->ri_buf[0], ilfp);\n\t\tif (error)\n\t\t\treturn;\n\t}\n\n\tif (xlog_peek_buffer_cancelled(log, ilfp->ilf_blkno, ilfp->ilf_len, 0))\n\t\treturn;\n\n\txfs_buf_readahead(mp->m_ddev_targp, ilfp->ilf_blkno,\n\t\t\t\tilfp->ilf_len, &xfs_inode_buf_ra_ops);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_inode_ra_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover_item        *item)\n{\n\tstruct xfs_inode_log_format\tilf_buf;\n\tstruct xfs_inode_log_format\t*ilfp;\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\tint\t\t\terror;\n\n\tif (item->ri_buf[0].i_len == sizeof(struct xfs_inode_log_format)) {\n\t\tilfp = item->ri_buf[0].i_addr;\n\t} else {\n\t\tilfp = &ilf_buf;\n\t\tmemset(ilfp, 0, sizeof(*ilfp));\n\t\terror = xfs_inode_item_format_convert(&item->ri_buf[0], ilfp);\n\t\tif (error)\n\t\t\treturn;\n\t}\n\n\tif (xlog_peek_buffer_cancelled(log, ilfp->ilf_blkno, ilfp->ilf_len, 0))\n\t\treturn;\n\n\txfs_buf_readahead(mp->m_ddev_targp, ilfp->ilf_blkno,\n\t\t\t\tilfp->ilf_len, &xfs_inode_buf_ra_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_buffer_ra_pass2",
          "args": [
            "log",
            "item"
          ],
          "line": 3183
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_buffer_ra_pass2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "3099-3114",
          "snippet": "STATIC void\nxlog_recover_buffer_ra_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover_item        *item)\n{\n\tstruct xfs_buf_log_format\t*buf_f = item->ri_buf[0].i_addr;\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\n\tif (xlog_peek_buffer_cancelled(log, buf_f->blf_blkno,\n\t\t\tbuf_f->blf_len, buf_f->blf_flags)) {\n\t\treturn;\n\t}\n\n\txfs_buf_readahead(mp->m_ddev_targp, buf_f->blf_blkno,\n\t\t\t\tbuf_f->blf_len, NULL);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_buffer_ra_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover_item        *item)\n{\n\tstruct xfs_buf_log_format\t*buf_f = item->ri_buf[0].i_addr;\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\n\tif (xlog_peek_buffer_cancelled(log, buf_f->blf_blkno,\n\t\t\tbuf_f->blf_len, buf_f->blf_flags)) {\n\t\treturn;\n\t}\n\n\txfs_buf_readahead(mp->m_ddev_targp, buf_f->blf_blkno,\n\t\t\t\tbuf_f->blf_len, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITEM_TYPE",
          "args": [
            "item"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_ra_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\tswitch (ITEM_TYPE(item)) {\n\tcase XFS_LI_BUF:\n\t\txlog_recover_buffer_ra_pass2(log, item);\n\t\tbreak;\n\tcase XFS_LI_INODE:\n\t\txlog_recover_inode_ra_pass2(log, item);\n\t\tbreak;\n\tcase XFS_LI_DQUOT:\n\t\txlog_recover_dquot_ra_pass2(log, item);\n\t\tbreak;\n\tcase XFS_LI_EFI:\n\tcase XFS_LI_EFD:\n\tcase XFS_LI_QUOTAOFF:\n\tdefault:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "xlog_recover_dquot_ra_pass2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3143-3174",
    "snippet": "STATIC void\nxlog_recover_dquot_ra_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\tstruct xfs_mount\t*mp = log->l_mp;\n\tstruct xfs_disk_dquot\t*recddq;\n\tstruct xfs_dq_logformat\t*dq_f;\n\tuint\t\t\ttype;\n\n\n\tif (mp->m_qflags == 0)\n\t\treturn;\n\n\trecddq = item->ri_buf[1].i_addr;\n\tif (recddq == NULL)\n\t\treturn;\n\tif (item->ri_buf[1].i_len < sizeof(struct xfs_disk_dquot))\n\t\treturn;\n\n\ttype = recddq->d_flags & (XFS_DQ_USER | XFS_DQ_PROJ | XFS_DQ_GROUP);\n\tASSERT(type);\n\tif (log->l_quotaoffs_flag & type)\n\t\treturn;\n\n\tdq_f = item->ri_buf[0].i_addr;\n\tASSERT(dq_f);\n\tASSERT(dq_f->qlf_len == 1);\n\n\txfs_buf_readahead(mp->m_ddev_targp, dq_f->qlf_blkno,\n\t\t\t  XFS_FSB_TO_BB(mp, dq_f->qlf_len), NULL);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_readahead",
          "args": [
            "mp->m_ddev_targp",
            "dq_f->qlf_blkno",
            "XFS_FSB_TO_BB(mp, dq_f->qlf_len)",
            "NULL"
          ],
          "line": 3172
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "256-265",
          "snippet": "static inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "dq_f->qlf_len"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dq_f->qlf_len == 1"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dq_f"
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "type"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_dquot_ra_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\tstruct xfs_mount\t*mp = log->l_mp;\n\tstruct xfs_disk_dquot\t*recddq;\n\tstruct xfs_dq_logformat\t*dq_f;\n\tuint\t\t\ttype;\n\n\n\tif (mp->m_qflags == 0)\n\t\treturn;\n\n\trecddq = item->ri_buf[1].i_addr;\n\tif (recddq == NULL)\n\t\treturn;\n\tif (item->ri_buf[1].i_len < sizeof(struct xfs_disk_dquot))\n\t\treturn;\n\n\ttype = recddq->d_flags & (XFS_DQ_USER | XFS_DQ_PROJ | XFS_DQ_GROUP);\n\tASSERT(type);\n\tif (log->l_quotaoffs_flag & type)\n\t\treturn;\n\n\tdq_f = item->ri_buf[0].i_addr;\n\tASSERT(dq_f);\n\tASSERT(dq_f->qlf_len == 1);\n\n\txfs_buf_readahead(mp->m_ddev_targp, dq_f->qlf_blkno,\n\t\t\t  XFS_FSB_TO_BB(mp, dq_f->qlf_len), NULL);\n}"
  },
  {
    "function_name": "xlog_recover_inode_ra_pass2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3116-3141",
    "snippet": "STATIC void\nxlog_recover_inode_ra_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover_item        *item)\n{\n\tstruct xfs_inode_log_format\tilf_buf;\n\tstruct xfs_inode_log_format\t*ilfp;\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\tint\t\t\terror;\n\n\tif (item->ri_buf[0].i_len == sizeof(struct xfs_inode_log_format)) {\n\t\tilfp = item->ri_buf[0].i_addr;\n\t} else {\n\t\tilfp = &ilf_buf;\n\t\tmemset(ilfp, 0, sizeof(*ilfp));\n\t\terror = xfs_inode_item_format_convert(&item->ri_buf[0], ilfp);\n\t\tif (error)\n\t\t\treturn;\n\t}\n\n\tif (xlog_peek_buffer_cancelled(log, ilfp->ilf_blkno, ilfp->ilf_len, 0))\n\t\treturn;\n\n\txfs_buf_readahead(mp->m_ddev_targp, ilfp->ilf_blkno,\n\t\t\t\tilfp->ilf_len, &xfs_inode_buf_ra_ops);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_readahead",
          "args": [
            "mp->m_ddev_targp",
            "ilfp->ilf_blkno",
            "ilfp->ilf_len",
            "&xfs_inode_buf_ra_ops"
          ],
          "line": 3139
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "256-265",
          "snippet": "static inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_peek_buffer_cancelled",
          "args": [
            "log",
            "ilfp->ilf_blkno",
            "ilfp->ilf_len",
            "0"
          ],
          "line": 3136
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_peek_buffer_cancelled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1623-1651",
          "snippet": "xfs_buf_cancel *\nxlog_peek_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct list_head\t*bucket;\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tif (!log->l_buf_cancel_table) {\n\t\t/* empty table means no cancelled buffers in the log */\n\t\tASSERT(!(flags & XFS_BLF_CANCEL));\n\t\treturn NULL;\n\t}\n\n\tbucket = XLOG_BUF_CANCEL_BUCKET(log, blkno);\n\tlist_for_each_entry(bcp, bucket, bc_list) {\n\t\tif (bcp->bc_blkno == blkno && bcp->bc_len == len)\n\t\t\treturn bcp;\n\t}\n\n\t/*\n\t * We didn't find a corresponding entry in the table, so return 0 so\n\t * that the buffer is NOT cancelled.\n\t */\n\tASSERT(!(flags & XFS_BLF_CANCEL));\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nxfs_buf_cancel *\nxlog_peek_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct list_head\t*bucket;\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tif (!log->l_buf_cancel_table) {\n\t\t/* empty table means no cancelled buffers in the log */\n\t\tASSERT(!(flags & XFS_BLF_CANCEL));\n\t\treturn NULL;\n\t}\n\n\tbucket = XLOG_BUF_CANCEL_BUCKET(log, blkno);\n\tlist_for_each_entry(bcp, bucket, bc_list) {\n\t\tif (bcp->bc_blkno == blkno && bcp->bc_len == len)\n\t\t\treturn bcp;\n\t}\n\n\t/*\n\t * We didn't find a corresponding entry in the table, so return 0 so\n\t * that the buffer is NOT cancelled.\n\t */\n\tASSERT(!(flags & XFS_BLF_CANCEL));\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_item_format_convert",
          "args": [
            "&item->ri_buf[0]",
            "ilfp"
          ],
          "line": 3131
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_item_format_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "748-789",
          "snippet": "int\nxfs_inode_item_format_convert(\n\txfs_log_iovec_t\t\t*buf,\n\txfs_inode_log_format_t\t*in_f)\n{\n\tif (buf->i_len == sizeof(xfs_inode_log_format_32_t)) {\n\t\txfs_inode_log_format_32_t *in_f32 = buf->i_addr;\n\n\t\tin_f->ilf_type = in_f32->ilf_type;\n\t\tin_f->ilf_size = in_f32->ilf_size;\n\t\tin_f->ilf_fields = in_f32->ilf_fields;\n\t\tin_f->ilf_asize = in_f32->ilf_asize;\n\t\tin_f->ilf_dsize = in_f32->ilf_dsize;\n\t\tin_f->ilf_ino = in_f32->ilf_ino;\n\t\t/* copy biggest field of ilf_u */\n\t\tmemcpy(in_f->ilf_u.ilfu_uuid.__u_bits,\n\t\t       in_f32->ilf_u.ilfu_uuid.__u_bits,\n\t\t       sizeof(uuid_t));\n\t\tin_f->ilf_blkno = in_f32->ilf_blkno;\n\t\tin_f->ilf_len = in_f32->ilf_len;\n\t\tin_f->ilf_boffset = in_f32->ilf_boffset;\n\t\treturn 0;\n\t} else if (buf->i_len == sizeof(xfs_inode_log_format_64_t)){\n\t\txfs_inode_log_format_64_t *in_f64 = buf->i_addr;\n\n\t\tin_f->ilf_type = in_f64->ilf_type;\n\t\tin_f->ilf_size = in_f64->ilf_size;\n\t\tin_f->ilf_fields = in_f64->ilf_fields;\n\t\tin_f->ilf_asize = in_f64->ilf_asize;\n\t\tin_f->ilf_dsize = in_f64->ilf_dsize;\n\t\tin_f->ilf_ino = in_f64->ilf_ino;\n\t\t/* copy biggest field of ilf_u */\n\t\tmemcpy(in_f->ilf_u.ilfu_uuid.__u_bits,\n\t\t       in_f64->ilf_u.ilfu_uuid.__u_bits,\n\t\t       sizeof(uuid_t));\n\t\tin_f->ilf_blkno = in_f64->ilf_blkno;\n\t\tin_f->ilf_len = in_f64->ilf_len;\n\t\tin_f->ilf_boffset = in_f64->ilf_boffset;\n\t\treturn 0;\n\t}\n\treturn -EFSCORRUPTED;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_inode_item_format_convert(\n\txfs_log_iovec_t\t\t*buf,\n\txfs_inode_log_format_t\t*in_f)\n{\n\tif (buf->i_len == sizeof(xfs_inode_log_format_32_t)) {\n\t\txfs_inode_log_format_32_t *in_f32 = buf->i_addr;\n\n\t\tin_f->ilf_type = in_f32->ilf_type;\n\t\tin_f->ilf_size = in_f32->ilf_size;\n\t\tin_f->ilf_fields = in_f32->ilf_fields;\n\t\tin_f->ilf_asize = in_f32->ilf_asize;\n\t\tin_f->ilf_dsize = in_f32->ilf_dsize;\n\t\tin_f->ilf_ino = in_f32->ilf_ino;\n\t\t/* copy biggest field of ilf_u */\n\t\tmemcpy(in_f->ilf_u.ilfu_uuid.__u_bits,\n\t\t       in_f32->ilf_u.ilfu_uuid.__u_bits,\n\t\t       sizeof(uuid_t));\n\t\tin_f->ilf_blkno = in_f32->ilf_blkno;\n\t\tin_f->ilf_len = in_f32->ilf_len;\n\t\tin_f->ilf_boffset = in_f32->ilf_boffset;\n\t\treturn 0;\n\t} else if (buf->i_len == sizeof(xfs_inode_log_format_64_t)){\n\t\txfs_inode_log_format_64_t *in_f64 = buf->i_addr;\n\n\t\tin_f->ilf_type = in_f64->ilf_type;\n\t\tin_f->ilf_size = in_f64->ilf_size;\n\t\tin_f->ilf_fields = in_f64->ilf_fields;\n\t\tin_f->ilf_asize = in_f64->ilf_asize;\n\t\tin_f->ilf_dsize = in_f64->ilf_dsize;\n\t\tin_f->ilf_ino = in_f64->ilf_ino;\n\t\t/* copy biggest field of ilf_u */\n\t\tmemcpy(in_f->ilf_u.ilfu_uuid.__u_bits,\n\t\t       in_f64->ilf_u.ilfu_uuid.__u_bits,\n\t\t       sizeof(uuid_t));\n\t\tin_f->ilf_blkno = in_f64->ilf_blkno;\n\t\tin_f->ilf_len = in_f64->ilf_len;\n\t\tin_f->ilf_boffset = in_f64->ilf_boffset;\n\t\treturn 0;\n\t}\n\treturn -EFSCORRUPTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ilfp",
            "0",
            "sizeof(*ilfp)"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_inode_ra_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover_item        *item)\n{\n\tstruct xfs_inode_log_format\tilf_buf;\n\tstruct xfs_inode_log_format\t*ilfp;\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\tint\t\t\terror;\n\n\tif (item->ri_buf[0].i_len == sizeof(struct xfs_inode_log_format)) {\n\t\tilfp = item->ri_buf[0].i_addr;\n\t} else {\n\t\tilfp = &ilf_buf;\n\t\tmemset(ilfp, 0, sizeof(*ilfp));\n\t\terror = xfs_inode_item_format_convert(&item->ri_buf[0], ilfp);\n\t\tif (error)\n\t\t\treturn;\n\t}\n\n\tif (xlog_peek_buffer_cancelled(log, ilfp->ilf_blkno, ilfp->ilf_len, 0))\n\t\treturn;\n\n\txfs_buf_readahead(mp->m_ddev_targp, ilfp->ilf_blkno,\n\t\t\t\tilfp->ilf_len, &xfs_inode_buf_ra_ops);\n}"
  },
  {
    "function_name": "xlog_recover_buffer_ra_pass2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3099-3114",
    "snippet": "STATIC void\nxlog_recover_buffer_ra_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover_item        *item)\n{\n\tstruct xfs_buf_log_format\t*buf_f = item->ri_buf[0].i_addr;\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\n\tif (xlog_peek_buffer_cancelled(log, buf_f->blf_blkno,\n\t\t\tbuf_f->blf_len, buf_f->blf_flags)) {\n\t\treturn;\n\t}\n\n\txfs_buf_readahead(mp->m_ddev_targp, buf_f->blf_blkno,\n\t\t\t\tbuf_f->blf_len, NULL);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_readahead",
          "args": [
            "mp->m_ddev_targp",
            "buf_f->blf_blkno",
            "buf_f->blf_len",
            "NULL"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "256-265",
          "snippet": "static inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_peek_buffer_cancelled",
          "args": [
            "log",
            "buf_f->blf_blkno",
            "buf_f->blf_len",
            "buf_f->blf_flags"
          ],
          "line": 3107
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_peek_buffer_cancelled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1623-1651",
          "snippet": "xfs_buf_cancel *\nxlog_peek_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct list_head\t*bucket;\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tif (!log->l_buf_cancel_table) {\n\t\t/* empty table means no cancelled buffers in the log */\n\t\tASSERT(!(flags & XFS_BLF_CANCEL));\n\t\treturn NULL;\n\t}\n\n\tbucket = XLOG_BUF_CANCEL_BUCKET(log, blkno);\n\tlist_for_each_entry(bcp, bucket, bc_list) {\n\t\tif (bcp->bc_blkno == blkno && bcp->bc_len == len)\n\t\t\treturn bcp;\n\t}\n\n\t/*\n\t * We didn't find a corresponding entry in the table, so return 0 so\n\t * that the buffer is NOT cancelled.\n\t */\n\tASSERT(!(flags & XFS_BLF_CANCEL));\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nxfs_buf_cancel *\nxlog_peek_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct list_head\t*bucket;\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tif (!log->l_buf_cancel_table) {\n\t\t/* empty table means no cancelled buffers in the log */\n\t\tASSERT(!(flags & XFS_BLF_CANCEL));\n\t\treturn NULL;\n\t}\n\n\tbucket = XLOG_BUF_CANCEL_BUCKET(log, blkno);\n\tlist_for_each_entry(bcp, bucket, bc_list) {\n\t\tif (bcp->bc_blkno == blkno && bcp->bc_len == len)\n\t\t\treturn bcp;\n\t}\n\n\t/*\n\t * We didn't find a corresponding entry in the table, so return 0 so\n\t * that the buffer is NOT cancelled.\n\t */\n\tASSERT(!(flags & XFS_BLF_CANCEL));\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_buffer_ra_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover_item        *item)\n{\n\tstruct xfs_buf_log_format\t*buf_f = item->ri_buf[0].i_addr;\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\n\tif (xlog_peek_buffer_cancelled(log, buf_f->blf_blkno,\n\t\t\tbuf_f->blf_len, buf_f->blf_flags)) {\n\t\treturn;\n\t}\n\n\txfs_buf_readahead(mp->m_ddev_targp, buf_f->blf_blkno,\n\t\t\t\tbuf_f->blf_len, NULL);\n}"
  },
  {
    "function_name": "xlog_recover_do_icreate_pass2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "3020-3097",
    "snippet": "STATIC int\nxlog_recover_do_icreate_pass2(\n\tstruct xlog\t\t*log,\n\tstruct list_head\t*buffer_list,\n\txlog_recover_item_t\t*item)\n{\n\tstruct xfs_mount\t*mp = log->l_mp;\n\tstruct xfs_icreate_log\t*icl;\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\tunsigned int\t\tcount;\n\tunsigned int\t\tisize;\n\txfs_agblock_t\t\tlength;\n\n\ticl = (struct xfs_icreate_log *)item->ri_buf[0].i_addr;\n\tif (icl->icl_type != XFS_LI_ICREATE) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad type\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (icl->icl_size != 1) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad icl size\");\n\t\treturn -EINVAL;\n\t}\n\n\tagno = be32_to_cpu(icl->icl_ag);\n\tif (agno >= mp->m_sb.sb_agcount) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad agno\");\n\t\treturn -EINVAL;\n\t}\n\tagbno = be32_to_cpu(icl->icl_agbno);\n\tif (!agbno || agbno == NULLAGBLOCK || agbno >= mp->m_sb.sb_agblocks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad agbno\");\n\t\treturn -EINVAL;\n\t}\n\tisize = be32_to_cpu(icl->icl_isize);\n\tif (isize != mp->m_sb.sb_inodesize) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad isize\");\n\t\treturn -EINVAL;\n\t}\n\tcount = be32_to_cpu(icl->icl_count);\n\tif (!count) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad count\");\n\t\treturn -EINVAL;\n\t}\n\tlength = be32_to_cpu(icl->icl_length);\n\tif (!length || length >= mp->m_sb.sb_agblocks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad length\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* existing allocation is fixed value */\n\tASSERT(count == mp->m_ialloc_inos);\n\tASSERT(length == mp->m_ialloc_blks);\n\tif (count != mp->m_ialloc_inos ||\n\t     length != mp->m_ialloc_blks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad count 2\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Inode buffers can be freed. Do not replay the inode initialisation as\n\t * we could be overwriting something written after this inode buffer was\n\t * cancelled.\n\t *\n\t * XXX: we need to iterate all buffers and only init those that are not\n\t * cancelled. I think that a more fine grained factoring of\n\t * xfs_ialloc_inode_init may be appropriate here to enable this to be\n\t * done easily.\n\t */\n\tif (xlog_check_buffer_cancelled(log,\n\t\t\tXFS_AGB_TO_DADDR(mp, agno, agbno), length, 0))\n\t\treturn 0;\n\n\txfs_ialloc_inode_init(mp, NULL, buffer_list, agno, agbno, length,\n\t\t\t\t\tbe32_to_cpu(icl->icl_gen));\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ialloc_inode_init",
          "args": [
            "mp",
            "NULL",
            "buffer_list",
            "agno",
            "agbno",
            "length",
            "be32_to_cpu(icl->icl_gen)"
          ],
          "line": 3094
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_inode_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "218-347",
          "snippet": "int\nxfs_ialloc_inode_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct list_head\t*buffer_list,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tagbno,\n\txfs_agblock_t\t\tlength,\n\tunsigned int\t\tgen)\n{\n\tstruct xfs_buf\t\t*fbuf;\n\tstruct xfs_dinode\t*free;\n\tint\t\t\tnbufs, blks_per_cluster, inodes_per_cluster;\n\tint\t\t\tversion;\n\tint\t\t\ti, j;\n\txfs_daddr_t\t\td;\n\txfs_ino_t\t\tino = 0;\n\n\t/*\n\t * Loop over the new block(s), filling in the inodes.  For small block\n\t * sizes, manipulate the inodes in buffers  which are multiples of the\n\t * blocks size.\n\t */\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\tnbufs = length / blks_per_cluster;\n\n\t/*\n\t * Figure out what version number to use in the inodes we create.  If\n\t * the superblock version has caught up to the one that supports the new\n\t * inode format, then use the new inode version.  Otherwise use the old\n\t * version so that old kernels will continue to be able to use the file\n\t * system.\n\t *\n\t * For v3 inodes, we also need to write the inode number into the inode,\n\t * so calculate the first inode number of the chunk here as\n\t * XFS_OFFBNO_TO_AGINO() only works within a filesystem block, not\n\t * across multiple filesystem blocks (such as a cluster) and so cannot\n\t * be used in the cluster buffer loop below.\n\t *\n\t * Further, because we are writing the inode directly into the buffer\n\t * and calculating a CRC on the entire inode, we have ot log the entire\n\t * inode so that the entire range the CRC covers is present in the log.\n\t * That means for v3 inode we log the entire buffer rather than just the\n\t * inode cores.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tversion = 3;\n\t\tino = XFS_AGINO_TO_INO(mp, agno,\n\t\t\t\t       XFS_OFFBNO_TO_AGINO(mp, agbno, 0));\n\n\t\t/*\n\t\t * log the initialisation that is about to take place as an\n\t\t * logical operation. This means the transaction does not\n\t\t * need to log the physical changes to the inode buffers as log\n\t\t * recovery will know what initialisation is actually needed.\n\t\t * Hence we only need to log the buffers as \"ordered\" buffers so\n\t\t * they track in the AIL as if they were physically logged.\n\t\t */\n\t\tif (tp)\n\t\t\txfs_icreate_log(tp, agno, agbno, mp->m_ialloc_inos,\n\t\t\t\t\tmp->m_sb.sb_inodesize, length, gen);\n\t} else\n\t\tversion = 2;\n\n\tfor (j = 0; j < nbufs; j++) {\n\t\t/*\n\t\t * Get the block.\n\t\t */\n\t\td = XFS_AGB_TO_DADDR(mp, agno, agbno + (j * blks_per_cluster));\n\t\tfbuf = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\t\t mp->m_bsize * blks_per_cluster,\n\t\t\t\t\t XBF_UNMAPPED);\n\t\tif (!fbuf)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Initialize the inode buffers and log them appropriately. */\n\t\tfbuf->b_ops = &xfs_inode_buf_ops;\n\t\txfs_buf_zero(fbuf, 0, BBTOB(fbuf->b_length));\n\t\tfor (i = 0; i < inodes_per_cluster; i++) {\n\t\t\tint\tioffset = i << mp->m_sb.sb_inodelog;\n\t\t\tuint\tisize = xfs_dinode_size(version);\n\n\t\t\tfree = xfs_make_iptr(mp, fbuf, i);\n\t\t\tfree->di_magic = cpu_to_be16(XFS_DINODE_MAGIC);\n\t\t\tfree->di_version = version;\n\t\t\tfree->di_gen = cpu_to_be32(gen);\n\t\t\tfree->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\n\t\t\tif (version == 3) {\n\t\t\t\tfree->di_ino = cpu_to_be64(ino);\n\t\t\t\tino++;\n\t\t\t\tuuid_copy(&free->di_uuid, &mp->m_sb.sb_uuid);\n\t\t\t\txfs_dinode_calc_crc(mp, free);\n\t\t\t} else if (tp) {\n\t\t\t\t/* just log the inode core */\n\t\t\t\txfs_trans_log_buf(tp, fbuf, ioffset,\n\t\t\t\t\t\t  ioffset + isize - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (tp) {\n\t\t\t/*\n\t\t\t * Mark the buffer as an inode allocation buffer so it\n\t\t\t * sticks in AIL at the point of this allocation\n\t\t\t * transaction. This ensures the they are on disk before\n\t\t\t * the tail of the log can be moved past this\n\t\t\t * transaction (i.e. by preventing relogging from moving\n\t\t\t * it forward in the log).\n\t\t\t */\n\t\t\txfs_trans_inode_alloc_buf(tp, fbuf);\n\t\t\tif (version == 3) {\n\t\t\t\t/*\n\t\t\t\t * Mark the buffer as ordered so that they are\n\t\t\t\t * not physically logged in the transaction but\n\t\t\t\t * still tracked in the AIL as part of the\n\t\t\t\t * transaction and pin the log appropriately.\n\t\t\t\t */\n\t\t\t\txfs_trans_ordered_buf(tp, fbuf);\n\t\t\t\txfs_trans_log_buf(tp, fbuf, 0,\n\t\t\t\t\t\t  BBTOB(fbuf->b_length) - 1);\n\t\t\t}\n\t\t} else {\n\t\t\tfbuf->b_flags |= XBF_DONE;\n\t\t\txfs_buf_delwri_queue(fbuf, buffer_list);\n\t\t\txfs_buf_relse(fbuf);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_inode_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct list_head\t*buffer_list,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tagbno,\n\txfs_agblock_t\t\tlength,\n\tunsigned int\t\tgen)\n{\n\tstruct xfs_buf\t\t*fbuf;\n\tstruct xfs_dinode\t*free;\n\tint\t\t\tnbufs, blks_per_cluster, inodes_per_cluster;\n\tint\t\t\tversion;\n\tint\t\t\ti, j;\n\txfs_daddr_t\t\td;\n\txfs_ino_t\t\tino = 0;\n\n\t/*\n\t * Loop over the new block(s), filling in the inodes.  For small block\n\t * sizes, manipulate the inodes in buffers  which are multiples of the\n\t * blocks size.\n\t */\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\tnbufs = length / blks_per_cluster;\n\n\t/*\n\t * Figure out what version number to use in the inodes we create.  If\n\t * the superblock version has caught up to the one that supports the new\n\t * inode format, then use the new inode version.  Otherwise use the old\n\t * version so that old kernels will continue to be able to use the file\n\t * system.\n\t *\n\t * For v3 inodes, we also need to write the inode number into the inode,\n\t * so calculate the first inode number of the chunk here as\n\t * XFS_OFFBNO_TO_AGINO() only works within a filesystem block, not\n\t * across multiple filesystem blocks (such as a cluster) and so cannot\n\t * be used in the cluster buffer loop below.\n\t *\n\t * Further, because we are writing the inode directly into the buffer\n\t * and calculating a CRC on the entire inode, we have ot log the entire\n\t * inode so that the entire range the CRC covers is present in the log.\n\t * That means for v3 inode we log the entire buffer rather than just the\n\t * inode cores.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tversion = 3;\n\t\tino = XFS_AGINO_TO_INO(mp, agno,\n\t\t\t\t       XFS_OFFBNO_TO_AGINO(mp, agbno, 0));\n\n\t\t/*\n\t\t * log the initialisation that is about to take place as an\n\t\t * logical operation. This means the transaction does not\n\t\t * need to log the physical changes to the inode buffers as log\n\t\t * recovery will know what initialisation is actually needed.\n\t\t * Hence we only need to log the buffers as \"ordered\" buffers so\n\t\t * they track in the AIL as if they were physically logged.\n\t\t */\n\t\tif (tp)\n\t\t\txfs_icreate_log(tp, agno, agbno, mp->m_ialloc_inos,\n\t\t\t\t\tmp->m_sb.sb_inodesize, length, gen);\n\t} else\n\t\tversion = 2;\n\n\tfor (j = 0; j < nbufs; j++) {\n\t\t/*\n\t\t * Get the block.\n\t\t */\n\t\td = XFS_AGB_TO_DADDR(mp, agno, agbno + (j * blks_per_cluster));\n\t\tfbuf = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\t\t mp->m_bsize * blks_per_cluster,\n\t\t\t\t\t XBF_UNMAPPED);\n\t\tif (!fbuf)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Initialize the inode buffers and log them appropriately. */\n\t\tfbuf->b_ops = &xfs_inode_buf_ops;\n\t\txfs_buf_zero(fbuf, 0, BBTOB(fbuf->b_length));\n\t\tfor (i = 0; i < inodes_per_cluster; i++) {\n\t\t\tint\tioffset = i << mp->m_sb.sb_inodelog;\n\t\t\tuint\tisize = xfs_dinode_size(version);\n\n\t\t\tfree = xfs_make_iptr(mp, fbuf, i);\n\t\t\tfree->di_magic = cpu_to_be16(XFS_DINODE_MAGIC);\n\t\t\tfree->di_version = version;\n\t\t\tfree->di_gen = cpu_to_be32(gen);\n\t\t\tfree->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\n\t\t\tif (version == 3) {\n\t\t\t\tfree->di_ino = cpu_to_be64(ino);\n\t\t\t\tino++;\n\t\t\t\tuuid_copy(&free->di_uuid, &mp->m_sb.sb_uuid);\n\t\t\t\txfs_dinode_calc_crc(mp, free);\n\t\t\t} else if (tp) {\n\t\t\t\t/* just log the inode core */\n\t\t\t\txfs_trans_log_buf(tp, fbuf, ioffset,\n\t\t\t\t\t\t  ioffset + isize - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (tp) {\n\t\t\t/*\n\t\t\t * Mark the buffer as an inode allocation buffer so it\n\t\t\t * sticks in AIL at the point of this allocation\n\t\t\t * transaction. This ensures the they are on disk before\n\t\t\t * the tail of the log can be moved past this\n\t\t\t * transaction (i.e. by preventing relogging from moving\n\t\t\t * it forward in the log).\n\t\t\t */\n\t\t\txfs_trans_inode_alloc_buf(tp, fbuf);\n\t\t\tif (version == 3) {\n\t\t\t\t/*\n\t\t\t\t * Mark the buffer as ordered so that they are\n\t\t\t\t * not physically logged in the transaction but\n\t\t\t\t * still tracked in the AIL as part of the\n\t\t\t\t * transaction and pin the log appropriately.\n\t\t\t\t */\n\t\t\t\txfs_trans_ordered_buf(tp, fbuf);\n\t\t\t\txfs_trans_log_buf(tp, fbuf, 0,\n\t\t\t\t\t\t  BBTOB(fbuf->b_length) - 1);\n\t\t\t}\n\t\t} else {\n\t\t\tfbuf->b_flags |= XBF_DONE;\n\t\t\txfs_buf_delwri_queue(fbuf, buffer_list);\n\t\t\txfs_buf_relse(fbuf);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "icl->icl_gen"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_check_buffer_cancelled",
          "args": [
            "log",
            "XFS_AGB_TO_DADDR(mp, agno, agbno)",
            "length",
            "0"
          ],
          "line": 3090
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_check_buffer_cancelled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1663-1689",
          "snippet": "STATIC int\nxlog_check_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tbcp = xlog_peek_buffer_cancelled(log, blkno, len, flags);\n\tif (!bcp)\n\t\treturn 0;\n\n\t/*\n\t * We've go a match, so return 1 so that the recovery of this buffer\n\t * is cancelled.  If this buffer is actually a buffer cancel log\n\t * item, then decrement the refcount on the one in the table and\n\t * remove it if this is the last reference.\n\t */\n\tif (flags & XFS_BLF_CANCEL) {\n\t\tif (--bcp->bc_refcount == 0) {\n\t\t\tlist_del(&bcp->bc_list);\n\t\t\tkmem_free(bcp);\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_check_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tbcp = xlog_peek_buffer_cancelled(log, blkno, len, flags);\n\tif (!bcp)\n\t\treturn 0;\n\n\t/*\n\t * We've go a match, so return 1 so that the recovery of this buffer\n\t * is cancelled.  If this buffer is actually a buffer cancel log\n\t * item, then decrement the refcount on the one in the table and\n\t * remove it if this is the last reference.\n\t */\n\tif (flags & XFS_BLF_CANCEL) {\n\t\tif (--bcp->bc_refcount == 0) {\n\t\t\tlist_del(&bcp->bc_list);\n\t\t\tkmem_free(bcp);\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "agno",
            "agbno"
          ],
          "line": 3091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"xlog_recover_do_icreate_trans: bad count 2\""
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "length == mp->m_ialloc_blks"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "count == mp->m_ialloc_inos"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"xlog_recover_do_icreate_trans: bad length\""
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "icl->icl_length"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"xlog_recover_do_icreate_trans: bad count\""
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "icl->icl_count"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"xlog_recover_do_icreate_trans: bad isize\""
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "icl->icl_isize"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"xlog_recover_do_icreate_trans: bad agbno\""
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "icl->icl_agbno"
          ],
          "line": 3050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"xlog_recover_do_icreate_trans: bad agno\""
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "icl->icl_ag"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"xlog_recover_do_icreate_trans: bad icl size\""
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"xlog_recover_do_icreate_trans: bad type\""
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_do_icreate_pass2(\n\tstruct xlog\t\t*log,\n\tstruct list_head\t*buffer_list,\n\txlog_recover_item_t\t*item)\n{\n\tstruct xfs_mount\t*mp = log->l_mp;\n\tstruct xfs_icreate_log\t*icl;\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\tunsigned int\t\tcount;\n\tunsigned int\t\tisize;\n\txfs_agblock_t\t\tlength;\n\n\ticl = (struct xfs_icreate_log *)item->ri_buf[0].i_addr;\n\tif (icl->icl_type != XFS_LI_ICREATE) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad type\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (icl->icl_size != 1) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad icl size\");\n\t\treturn -EINVAL;\n\t}\n\n\tagno = be32_to_cpu(icl->icl_ag);\n\tif (agno >= mp->m_sb.sb_agcount) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad agno\");\n\t\treturn -EINVAL;\n\t}\n\tagbno = be32_to_cpu(icl->icl_agbno);\n\tif (!agbno || agbno == NULLAGBLOCK || agbno >= mp->m_sb.sb_agblocks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad agbno\");\n\t\treturn -EINVAL;\n\t}\n\tisize = be32_to_cpu(icl->icl_isize);\n\tif (isize != mp->m_sb.sb_inodesize) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad isize\");\n\t\treturn -EINVAL;\n\t}\n\tcount = be32_to_cpu(icl->icl_count);\n\tif (!count) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad count\");\n\t\treturn -EINVAL;\n\t}\n\tlength = be32_to_cpu(icl->icl_length);\n\tif (!length || length >= mp->m_sb.sb_agblocks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad length\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* existing allocation is fixed value */\n\tASSERT(count == mp->m_ialloc_inos);\n\tASSERT(length == mp->m_ialloc_blks);\n\tif (count != mp->m_ialloc_inos ||\n\t     length != mp->m_ialloc_blks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad count 2\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Inode buffers can be freed. Do not replay the inode initialisation as\n\t * we could be overwriting something written after this inode buffer was\n\t * cancelled.\n\t *\n\t * XXX: we need to iterate all buffers and only init those that are not\n\t * cancelled. I think that a more fine grained factoring of\n\t * xfs_ialloc_inode_init may be appropriate here to enable this to be\n\t * done easily.\n\t */\n\tif (xlog_check_buffer_cancelled(log,\n\t\t\tXFS_AGB_TO_DADDR(mp, agno, agbno), length, 0))\n\t\treturn 0;\n\n\txfs_ialloc_inode_init(mp, NULL, buffer_list, agno, agbno, length,\n\t\t\t\t\tbe32_to_cpu(icl->icl_gen));\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_recover_efd_pass2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "2964-3010",
    "snippet": "STATIC int\nxlog_recover_efd_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\txfs_efd_log_format_t\t*efd_formatp;\n\txfs_efi_log_item_t\t*efip = NULL;\n\txfs_log_item_t\t\t*lip;\n\t__uint64_t\t\tefi_id;\n\tstruct xfs_ail_cursor\tcur;\n\tstruct xfs_ail\t\t*ailp = log->l_ailp;\n\n\tefd_formatp = item->ri_buf[0].i_addr;\n\tASSERT((item->ri_buf[0].i_len == (sizeof(xfs_efd_log_format_32_t) +\n\t\t((efd_formatp->efd_nextents - 1) * sizeof(xfs_extent_32_t)))) ||\n\t       (item->ri_buf[0].i_len == (sizeof(xfs_efd_log_format_64_t) +\n\t\t((efd_formatp->efd_nextents - 1) * sizeof(xfs_extent_64_t)))));\n\tefi_id = efd_formatp->efd_efi_id;\n\n\t/*\n\t * Search for the efi with the id in the efd format structure\n\t * in the AIL.\n\t */\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, 0);\n\twhile (lip != NULL) {\n\t\tif (lip->li_type == XFS_LI_EFI) {\n\t\t\tefip = (xfs_efi_log_item_t *)lip;\n\t\t\tif (efip->efi_format.efi_id == efi_id) {\n\t\t\t\t/*\n\t\t\t\t * xfs_trans_ail_delete() drops the\n\t\t\t\t * AIL lock.\n\t\t\t\t */\n\t\t\t\txfs_trans_ail_delete(ailp, lip,\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t\txfs_efi_item_free(efip);\n\t\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t}\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_done",
          "args": [
            "&cur"
          ],
          "line": 3006
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "173-179",
          "snippet": "void\nxfs_trans_ail_cursor_done(\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_del_init(&cur->list);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ail_cursor_done(\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_del_init(&cur->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_next",
          "args": [
            "ailp",
            "&cur"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "155-167",
          "snippet": "struct xfs_log_item *\nxfs_trans_ail_cursor_next(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tstruct xfs_log_item\t*lip = cur->item;\n\n\tif ((__psint_t)lip & 1)\n\t\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_log_item *\nxfs_trans_ail_cursor_next(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tstruct xfs_log_item\t*lip = cur->item;\n\n\tif ((__psint_t)lip & 1)\n\t\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_efi_item_free",
          "args": [
            "efip"
          ],
          "line": 2999
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_efi_item_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extfree_item.c",
          "lines": "39-47",
          "snippet": "void\nxfs_efi_item_free(\n\tstruct xfs_efi_log_item\t*efip)\n{\n\tif (efip->efi_format.efi_nextents > XFS_EFI_MAX_FAST_EXTENTS)\n\t\tkmem_free(efip);\n\telse\n\t\tkmem_zone_free(xfs_efi_zone, efip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_efi_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_efi_zone;\n\nvoid\nxfs_efi_item_free(\n\tstruct xfs_efi_log_item\t*efip)\n{\n\tif (efip->efi_format.efi_nextents > XFS_EFI_MAX_FAST_EXTENTS)\n\t\tkmem_free(efip);\n\telse\n\t\tkmem_zone_free(xfs_efi_zone, efip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_delete",
          "args": [
            "ailp",
            "lip",
            "SHUTDOWN_CORRUPT_INCORE"
          ],
          "line": 2997
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "113-120",
          "snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_first",
          "args": [
            "ailp",
            "&cur",
            "0"
          ],
          "line": 2988
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "209-234",
          "snippet": "xfs_log_item_t *\nxfs_trans_ail_cursor_first(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\txfs_trans_ail_cursor_init(ailp, cur);\n\n\tif (lsn == 0) {\n\t\tlip = xfs_ail_min(ailp);\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) >= 0)\n\t\t\tgoto out;\n\t}\n\treturn NULL;\n\nout:\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_log_item_t *\nxfs_trans_ail_cursor_first(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\txfs_trans_ail_cursor_init(ailp, cur);\n\n\tif (lsn == 0) {\n\t\tlip = xfs_ail_min(ailp);\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) >= 0)\n\t\t\tgoto out;\n\t}\n\treturn NULL;\n\nout:\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(item->ri_buf[0].i_len == (sizeof(xfs_efd_log_format_32_t) +\n\t\t((efd_formatp->efd_nextents - 1) * sizeof(xfs_extent_32_t)))) ||\n\t       (item->ri_buf[0].i_len == (sizeof(xfs_efd_log_format_64_t) +\n\t\t((efd_formatp->efd_nextents - 1) * sizeof(xfs_extent_64_t))))"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_efd_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\txfs_efd_log_format_t\t*efd_formatp;\n\txfs_efi_log_item_t\t*efip = NULL;\n\txfs_log_item_t\t\t*lip;\n\t__uint64_t\t\tefi_id;\n\tstruct xfs_ail_cursor\tcur;\n\tstruct xfs_ail\t\t*ailp = log->l_ailp;\n\n\tefd_formatp = item->ri_buf[0].i_addr;\n\tASSERT((item->ri_buf[0].i_len == (sizeof(xfs_efd_log_format_32_t) +\n\t\t((efd_formatp->efd_nextents - 1) * sizeof(xfs_extent_32_t)))) ||\n\t       (item->ri_buf[0].i_len == (sizeof(xfs_efd_log_format_64_t) +\n\t\t((efd_formatp->efd_nextents - 1) * sizeof(xfs_extent_64_t)))));\n\tefi_id = efd_formatp->efd_efi_id;\n\n\t/*\n\t * Search for the efi with the id in the efd format structure\n\t * in the AIL.\n\t */\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, 0);\n\twhile (lip != NULL) {\n\t\tif (lip->li_type == XFS_LI_EFI) {\n\t\t\tefip = (xfs_efi_log_item_t *)lip;\n\t\t\tif (efip->efi_format.efi_id == efi_id) {\n\t\t\t\t/*\n\t\t\t\t * xfs_trans_ail_delete() drops the\n\t\t\t\t * AIL lock.\n\t\t\t\t */\n\t\t\t\txfs_trans_ail_delete(ailp, lip,\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t\txfs_efi_item_free(efip);\n\t\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t}\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_recover_efi_pass2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "2926-2953",
    "snippet": "STATIC int\nxlog_recover_efi_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tint\t\t\terror;\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_efi_log_item_t\t*efip;\n\txfs_efi_log_format_t\t*efi_formatp;\n\n\tefi_formatp = item->ri_buf[0].i_addr;\n\n\tefip = xfs_efi_init(mp, efi_formatp->efi_nextents);\n\tif ((error = xfs_efi_copy_format(&(item->ri_buf[0]),\n\t\t\t\t\t &(efip->efi_format)))) {\n\t\txfs_efi_item_free(efip);\n\t\treturn error;\n\t}\n\tatomic_set(&efip->efi_next_extent, efi_formatp->efi_nextents);\n\n\tspin_lock(&log->l_ailp->xa_lock);\n\t/*\n\t * xfs_trans_ail_update() drops the AIL lock.\n\t */\n\txfs_trans_ail_update(log->l_ailp, &efip->efi_item, lsn);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_ail_update",
          "args": [
            "log->l_ailp",
            "&efip->efi_item",
            "lsn"
          ],
          "line": 2951
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "100-107",
          "snippet": "static inline void\nxfs_trans_ail_update(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_update_bulk(ailp, NULL, &lip, 1, lsn);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_update(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_update_bulk(ailp, NULL, &lip, 1, lsn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&log->l_ailp->xa_lock"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&efip->efi_next_extent",
            "efi_formatp->efi_nextents"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_efi_item_free",
          "args": [
            "efip"
          ],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_efi_item_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extfree_item.c",
          "lines": "39-47",
          "snippet": "void\nxfs_efi_item_free(\n\tstruct xfs_efi_log_item\t*efip)\n{\n\tif (efip->efi_format.efi_nextents > XFS_EFI_MAX_FAST_EXTENTS)\n\t\tkmem_free(efip);\n\telse\n\t\tkmem_zone_free(xfs_efi_zone, efip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_efi_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_efi_zone;\n\nvoid\nxfs_efi_item_free(\n\tstruct xfs_efi_log_item\t*efip)\n{\n\tif (efip->efi_format.efi_nextents > XFS_EFI_MAX_FAST_EXTENTS)\n\t\tkmem_free(efip);\n\telse\n\t\tkmem_zone_free(xfs_efi_zone, efip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_efi_copy_format",
          "args": [
            "&(item->ri_buf[0])",
            "&(efip->efi_format)"
          ],
          "line": 2940
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_efi_copy_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extfree_item.c",
          "lines": "256-301",
          "snippet": "int\nxfs_efi_copy_format(xfs_log_iovec_t *buf, xfs_efi_log_format_t *dst_efi_fmt)\n{\n\txfs_efi_log_format_t *src_efi_fmt = buf->i_addr;\n\tuint i;\n\tuint len = sizeof(xfs_efi_log_format_t) + \n\t\t(src_efi_fmt->efi_nextents - 1) * sizeof(xfs_extent_t);  \n\tuint len32 = sizeof(xfs_efi_log_format_32_t) + \n\t\t(src_efi_fmt->efi_nextents - 1) * sizeof(xfs_extent_32_t);  \n\tuint len64 = sizeof(xfs_efi_log_format_64_t) + \n\t\t(src_efi_fmt->efi_nextents - 1) * sizeof(xfs_extent_64_t);  \n\n\tif (buf->i_len == len) {\n\t\tmemcpy((char *)dst_efi_fmt, (char*)src_efi_fmt, len);\n\t\treturn 0;\n\t} else if (buf->i_len == len32) {\n\t\txfs_efi_log_format_32_t *src_efi_fmt_32 = buf->i_addr;\n\n\t\tdst_efi_fmt->efi_type     = src_efi_fmt_32->efi_type;\n\t\tdst_efi_fmt->efi_size     = src_efi_fmt_32->efi_size;\n\t\tdst_efi_fmt->efi_nextents = src_efi_fmt_32->efi_nextents;\n\t\tdst_efi_fmt->efi_id       = src_efi_fmt_32->efi_id;\n\t\tfor (i = 0; i < dst_efi_fmt->efi_nextents; i++) {\n\t\t\tdst_efi_fmt->efi_extents[i].ext_start =\n\t\t\t\tsrc_efi_fmt_32->efi_extents[i].ext_start;\n\t\t\tdst_efi_fmt->efi_extents[i].ext_len =\n\t\t\t\tsrc_efi_fmt_32->efi_extents[i].ext_len;\n\t\t}\n\t\treturn 0;\n\t} else if (buf->i_len == len64) {\n\t\txfs_efi_log_format_64_t *src_efi_fmt_64 = buf->i_addr;\n\n\t\tdst_efi_fmt->efi_type     = src_efi_fmt_64->efi_type;\n\t\tdst_efi_fmt->efi_size     = src_efi_fmt_64->efi_size;\n\t\tdst_efi_fmt->efi_nextents = src_efi_fmt_64->efi_nextents;\n\t\tdst_efi_fmt->efi_id       = src_efi_fmt_64->efi_id;\n\t\tfor (i = 0; i < dst_efi_fmt->efi_nextents; i++) {\n\t\t\tdst_efi_fmt->efi_extents[i].ext_start =\n\t\t\t\tsrc_efi_fmt_64->efi_extents[i].ext_start;\n\t\t\tdst_efi_fmt->efi_extents[i].ext_len =\n\t\t\t\tsrc_efi_fmt_64->efi_extents[i].ext_len;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -EFSCORRUPTED;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_efi_copy_format(xfs_log_iovec_t *buf, xfs_efi_log_format_t *dst_efi_fmt)\n{\n\txfs_efi_log_format_t *src_efi_fmt = buf->i_addr;\n\tuint i;\n\tuint len = sizeof(xfs_efi_log_format_t) + \n\t\t(src_efi_fmt->efi_nextents - 1) * sizeof(xfs_extent_t);  \n\tuint len32 = sizeof(xfs_efi_log_format_32_t) + \n\t\t(src_efi_fmt->efi_nextents - 1) * sizeof(xfs_extent_32_t);  \n\tuint len64 = sizeof(xfs_efi_log_format_64_t) + \n\t\t(src_efi_fmt->efi_nextents - 1) * sizeof(xfs_extent_64_t);  \n\n\tif (buf->i_len == len) {\n\t\tmemcpy((char *)dst_efi_fmt, (char*)src_efi_fmt, len);\n\t\treturn 0;\n\t} else if (buf->i_len == len32) {\n\t\txfs_efi_log_format_32_t *src_efi_fmt_32 = buf->i_addr;\n\n\t\tdst_efi_fmt->efi_type     = src_efi_fmt_32->efi_type;\n\t\tdst_efi_fmt->efi_size     = src_efi_fmt_32->efi_size;\n\t\tdst_efi_fmt->efi_nextents = src_efi_fmt_32->efi_nextents;\n\t\tdst_efi_fmt->efi_id       = src_efi_fmt_32->efi_id;\n\t\tfor (i = 0; i < dst_efi_fmt->efi_nextents; i++) {\n\t\t\tdst_efi_fmt->efi_extents[i].ext_start =\n\t\t\t\tsrc_efi_fmt_32->efi_extents[i].ext_start;\n\t\t\tdst_efi_fmt->efi_extents[i].ext_len =\n\t\t\t\tsrc_efi_fmt_32->efi_extents[i].ext_len;\n\t\t}\n\t\treturn 0;\n\t} else if (buf->i_len == len64) {\n\t\txfs_efi_log_format_64_t *src_efi_fmt_64 = buf->i_addr;\n\n\t\tdst_efi_fmt->efi_type     = src_efi_fmt_64->efi_type;\n\t\tdst_efi_fmt->efi_size     = src_efi_fmt_64->efi_size;\n\t\tdst_efi_fmt->efi_nextents = src_efi_fmt_64->efi_nextents;\n\t\tdst_efi_fmt->efi_id       = src_efi_fmt_64->efi_id;\n\t\tfor (i = 0; i < dst_efi_fmt->efi_nextents; i++) {\n\t\t\tdst_efi_fmt->efi_extents[i].ext_start =\n\t\t\t\tsrc_efi_fmt_64->efi_extents[i].ext_start;\n\t\t\tdst_efi_fmt->efi_extents[i].ext_len =\n\t\t\t\tsrc_efi_fmt_64->efi_extents[i].ext_len;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -EFSCORRUPTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_efi_init",
          "args": [
            "mp",
            "efi_formatp->efi_nextents"
          ],
          "line": 2939
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_efi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extfree_item.c",
          "lines": "222-247",
          "snippet": "struct xfs_efi_log_item *\nxfs_efi_init(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tnextents)\n\n{\n\tstruct xfs_efi_log_item\t*efip;\n\tuint\t\t\tsize;\n\n\tASSERT(nextents > 0);\n\tif (nextents > XFS_EFI_MAX_FAST_EXTENTS) {\n\t\tsize = (uint)(sizeof(xfs_efi_log_item_t) +\n\t\t\t((nextents - 1) * sizeof(xfs_extent_t)));\n\t\tefip = kmem_zalloc(size, KM_SLEEP);\n\t} else {\n\t\tefip = kmem_zone_zalloc(xfs_efi_zone, KM_SLEEP);\n\t}\n\n\txfs_log_item_init(mp, &efip->efi_item, XFS_LI_EFI, &xfs_efi_item_ops);\n\tefip->efi_format.efi_nextents = nextents;\n\tefip->efi_format.efi_id = (__psint_t)(void*)efip;\n\tatomic_set(&efip->efi_next_extent, 0);\n\tatomic_set(&efip->efi_refcount, 2);\n\n\treturn efip;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_efi_zone;",
            "static const struct xfs_item_ops xfs_efi_item_ops = {\n\t.iop_size\t= xfs_efi_item_size,\n\t.iop_format\t= xfs_efi_item_format,\n\t.iop_pin\t= xfs_efi_item_pin,\n\t.iop_unpin\t= xfs_efi_item_unpin,\n\t.iop_unlock\t= xfs_efi_item_unlock,\n\t.iop_committed\t= xfs_efi_item_committed,\n\t.iop_push\t= xfs_efi_item_push,\n\t.iop_committing = xfs_efi_item_committing\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_efi_zone;\nstatic const struct xfs_item_ops xfs_efi_item_ops = {\n\t.iop_size\t= xfs_efi_item_size,\n\t.iop_format\t= xfs_efi_item_format,\n\t.iop_pin\t= xfs_efi_item_pin,\n\t.iop_unpin\t= xfs_efi_item_unpin,\n\t.iop_unlock\t= xfs_efi_item_unlock,\n\t.iop_committed\t= xfs_efi_item_committed,\n\t.iop_push\t= xfs_efi_item_push,\n\t.iop_committing = xfs_efi_item_committing\n};\n\nstruct xfs_efi_log_item *\nxfs_efi_init(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tnextents)\n\n{\n\tstruct xfs_efi_log_item\t*efip;\n\tuint\t\t\tsize;\n\n\tASSERT(nextents > 0);\n\tif (nextents > XFS_EFI_MAX_FAST_EXTENTS) {\n\t\tsize = (uint)(sizeof(xfs_efi_log_item_t) +\n\t\t\t((nextents - 1) * sizeof(xfs_extent_t)));\n\t\tefip = kmem_zalloc(size, KM_SLEEP);\n\t} else {\n\t\tefip = kmem_zone_zalloc(xfs_efi_zone, KM_SLEEP);\n\t}\n\n\txfs_log_item_init(mp, &efip->efi_item, XFS_LI_EFI, &xfs_efi_item_ops);\n\tefip->efi_format.efi_nextents = nextents;\n\tefip->efi_format.efi_id = (__psint_t)(void*)efip;\n\tatomic_set(&efip->efi_next_extent, 0);\n\tatomic_set(&efip->efi_refcount, 2);\n\n\treturn efip;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_efi_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tint\t\t\terror;\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_efi_log_item_t\t*efip;\n\txfs_efi_log_format_t\t*efi_formatp;\n\n\tefi_formatp = item->ri_buf[0].i_addr;\n\n\tefip = xfs_efi_init(mp, efi_formatp->efi_nextents);\n\tif ((error = xfs_efi_copy_format(&(item->ri_buf[0]),\n\t\t\t\t\t &(efip->efi_format)))) {\n\t\txfs_efi_item_free(efip);\n\t\treturn error;\n\t}\n\tatomic_set(&efip->efi_next_extent, efi_formatp->efi_nextents);\n\n\tspin_lock(&log->l_ailp->xa_lock);\n\t/*\n\t * xfs_trans_ail_update() drops the AIL lock.\n\t */\n\txfs_trans_ail_update(log->l_ailp, &efip->efi_item, lsn);\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_recover_dquot_pass2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "2816-2917",
    "snippet": "STATIC int\nxlog_recover_dquot_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_buf_t\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddq, *recddq;\n\tint\t\t\terror;\n\txfs_dq_logformat_t\t*dq_f;\n\tuint\t\t\ttype;\n\n\n\t/*\n\t * Filesystems are required to send in quota flags at mount time.\n\t */\n\tif (mp->m_qflags == 0)\n\t\treturn 0;\n\n\trecddq = item->ri_buf[1].i_addr;\n\tif (recddq == NULL) {\n\t\txfs_alert(log->l_mp, \"NULL dquot in %s.\", __func__);\n\t\treturn -EIO;\n\t}\n\tif (item->ri_buf[1].i_len < sizeof(xfs_disk_dquot_t)) {\n\t\txfs_alert(log->l_mp, \"dquot too small (%d) in %s.\",\n\t\t\titem->ri_buf[1].i_len, __func__);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * This type of quotas was turned off, so ignore this record.\n\t */\n\ttype = recddq->d_flags & (XFS_DQ_USER | XFS_DQ_PROJ | XFS_DQ_GROUP);\n\tASSERT(type);\n\tif (log->l_quotaoffs_flag & type)\n\t\treturn 0;\n\n\t/*\n\t * At this point we know that quota was _not_ turned off.\n\t * Since the mount flags are not indicating to us otherwise, this\n\t * must mean that quota is on, and the dquot needs to be replayed.\n\t * Remember that we may not have fully recovered the superblock yet,\n\t * so we can't do the usual trick of looking at the SB quota bits.\n\t *\n\t * The other possibility, of course, is that the quota subsystem was\n\t * removed since the last mount - ENOSYS.\n\t */\n\tdq_f = item->ri_buf[0].i_addr;\n\tASSERT(dq_f);\n\terror = xfs_dqcheck(mp, recddq, dq_f->qlf_id, 0, XFS_QMOPT_DOWARN,\n\t\t\t   \"xlog_recover_dquot_pass2 (log copy)\");\n\tif (error)\n\t\treturn -EIO;\n\tASSERT(dq_f->qlf_len == 1);\n\n\t/*\n\t * At this point we are assuming that the dquots have been allocated\n\t * and hence the buffer has valid dquots stamped in it. It should,\n\t * therefore, pass verifier validation. If the dquot is bad, then the\n\t * we'll return an error here, so we don't need to specifically check\n\t * the dquot in the buffer after the verifier has run.\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dq_f->qlf_blkno,\n\t\t\t\t   XFS_FSB_TO_BB(mp, dq_f->qlf_len), 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(bp);\n\tddq = (xfs_disk_dquot_t *)xfs_buf_offset(bp, dq_f->qlf_boffset);\n\n\t/*\n\t * If the dquot has an LSN in it, recover the dquot only if it's less\n\t * than the lsn of the transaction we are replaying.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddq;\n\t\txfs_lsn_t\tlsn = be64_to_cpu(dqb->dd_lsn);\n\n\t\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) >= 0) {\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\tmemcpy(ddq, recddq, item->ri_buf[1].i_len);\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\txfs_update_cksum((char *)ddq, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\tASSERT(dq_f->qlf_size == 2);\n\tASSERT(bp->b_target->bt_mount == mp);\n\tbp->b_iodone = xlog_recover_iodone;\n\txfs_buf_delwri_queue(bp, buffer_list);\n\nout_release:\n\txfs_buf_relse(bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_queue",
          "args": [
            "bp",
            "buffer_list"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1709-1744",
          "snippet": "bool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nbool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_target->bt_mount == mp"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dq_f->qlf_size == 2"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_update_cksum",
          "args": [
            "(char *)ddq",
            "sizeof(struct xfs_dqblk)",
            "XFS_DQUOT_CRC_OFF"
          ],
          "line": 2905
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "44-50",
          "snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 2904
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ddq",
            "recddq",
            "item->ri_buf[1].i_len"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "lsn",
            "current_lsn"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqb->dd_lsn"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_offset",
          "args": [
            "bp",
            "dq_f->qlf_boffset"
          ],
          "line": 2888
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1422-1435",
          "snippet": "xfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "NULL",
            "mp->m_ddev_targp",
            "dq_f->qlf_blkno",
            "XFS_FSB_TO_BB(mp, dq_f->qlf_len)",
            "0",
            "&bp",
            "&xfs_dquot_buf_ops"
          ],
          "line": 2881
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "dq_f->qlf_len"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dq_f->qlf_len == 1"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dqcheck",
          "args": [
            "mp",
            "recddq",
            "dq_f->qlf_id",
            "0",
            "XFS_QMOPT_DOWARN",
            "\"xlog_recover_dquot_pass2 (log copy)\""
          ],
          "line": 2868
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqcheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
          "lines": "50-172",
          "snippet": "int\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dq_f"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "type"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "log->l_mp",
            "\"dquot too small (%d) in %s.\"",
            "item->ri_buf[1].i_len",
            "__func__"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_dquot_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_buf_t\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddq, *recddq;\n\tint\t\t\terror;\n\txfs_dq_logformat_t\t*dq_f;\n\tuint\t\t\ttype;\n\n\n\t/*\n\t * Filesystems are required to send in quota flags at mount time.\n\t */\n\tif (mp->m_qflags == 0)\n\t\treturn 0;\n\n\trecddq = item->ri_buf[1].i_addr;\n\tif (recddq == NULL) {\n\t\txfs_alert(log->l_mp, \"NULL dquot in %s.\", __func__);\n\t\treturn -EIO;\n\t}\n\tif (item->ri_buf[1].i_len < sizeof(xfs_disk_dquot_t)) {\n\t\txfs_alert(log->l_mp, \"dquot too small (%d) in %s.\",\n\t\t\titem->ri_buf[1].i_len, __func__);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * This type of quotas was turned off, so ignore this record.\n\t */\n\ttype = recddq->d_flags & (XFS_DQ_USER | XFS_DQ_PROJ | XFS_DQ_GROUP);\n\tASSERT(type);\n\tif (log->l_quotaoffs_flag & type)\n\t\treturn 0;\n\n\t/*\n\t * At this point we know that quota was _not_ turned off.\n\t * Since the mount flags are not indicating to us otherwise, this\n\t * must mean that quota is on, and the dquot needs to be replayed.\n\t * Remember that we may not have fully recovered the superblock yet,\n\t * so we can't do the usual trick of looking at the SB quota bits.\n\t *\n\t * The other possibility, of course, is that the quota subsystem was\n\t * removed since the last mount - ENOSYS.\n\t */\n\tdq_f = item->ri_buf[0].i_addr;\n\tASSERT(dq_f);\n\terror = xfs_dqcheck(mp, recddq, dq_f->qlf_id, 0, XFS_QMOPT_DOWARN,\n\t\t\t   \"xlog_recover_dquot_pass2 (log copy)\");\n\tif (error)\n\t\treturn -EIO;\n\tASSERT(dq_f->qlf_len == 1);\n\n\t/*\n\t * At this point we are assuming that the dquots have been allocated\n\t * and hence the buffer has valid dquots stamped in it. It should,\n\t * therefore, pass verifier validation. If the dquot is bad, then the\n\t * we'll return an error here, so we don't need to specifically check\n\t * the dquot in the buffer after the verifier has run.\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dq_f->qlf_blkno,\n\t\t\t\t   XFS_FSB_TO_BB(mp, dq_f->qlf_len), 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(bp);\n\tddq = (xfs_disk_dquot_t *)xfs_buf_offset(bp, dq_f->qlf_boffset);\n\n\t/*\n\t * If the dquot has an LSN in it, recover the dquot only if it's less\n\t * than the lsn of the transaction we are replaying.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddq;\n\t\txfs_lsn_t\tlsn = be64_to_cpu(dqb->dd_lsn);\n\n\t\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) >= 0) {\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\tmemcpy(ddq, recddq, item->ri_buf[1].i_len);\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\txfs_update_cksum((char *)ddq, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\tASSERT(dq_f->qlf_size == 2);\n\tASSERT(bp->b_target->bt_mount == mp);\n\tbp->b_iodone = xlog_recover_iodone;\n\txfs_buf_delwri_queue(bp, buffer_list);\n\nout_release:\n\txfs_buf_relse(bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_recover_quotaoff_pass1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "2791-2811",
    "snippet": "STATIC int\nxlog_recover_quotaoff_pass1(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\txfs_qoff_logformat_t\t*qoff_f = item->ri_buf[0].i_addr;\n\tASSERT(qoff_f);\n\n\t/*\n\t * The logitem format's flag tells us if this was user quotaoff,\n\t * group/project quotaoff or both.\n\t */\n\tif (qoff_f->qf_flags & XFS_UQUOTA_ACCT)\n\t\tlog->l_quotaoffs_flag |= XFS_DQ_USER;\n\tif (qoff_f->qf_flags & XFS_PQUOTA_ACCT)\n\t\tlog->l_quotaoffs_flag |= XFS_DQ_PROJ;\n\tif (qoff_f->qf_flags & XFS_GQUOTA_ACCT)\n\t\tlog->l_quotaoffs_flag |= XFS_DQ_GROUP;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "qoff_f"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_quotaoff_pass1(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\txfs_qoff_logformat_t\t*qoff_f = item->ri_buf[0].i_addr;\n\tASSERT(qoff_f);\n\n\t/*\n\t * The logitem format's flag tells us if this was user quotaoff,\n\t * group/project quotaoff or both.\n\t */\n\tif (qoff_f->qf_flags & XFS_UQUOTA_ACCT)\n\t\tlog->l_quotaoffs_flag |= XFS_DQ_USER;\n\tif (qoff_f->qf_flags & XFS_PQUOTA_ACCT)\n\t\tlog->l_quotaoffs_flag |= XFS_DQ_PROJ;\n\tif (qoff_f->qf_flags & XFS_GQUOTA_ACCT)\n\t\tlog->l_quotaoffs_flag |= XFS_DQ_GROUP;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_recover_inode_pass2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "2494-2784",
    "snippet": "STATIC int\nxlog_recover_inode_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\txfs_inode_log_format_t\t*in_f;\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_buf_t\t\t*bp;\n\txfs_dinode_t\t\t*dip;\n\tint\t\t\tlen;\n\txfs_caddr_t\t\tsrc;\n\txfs_caddr_t\t\tdest;\n\tint\t\t\terror;\n\tint\t\t\tattr_index;\n\tuint\t\t\tfields;\n\txfs_icdinode_t\t\t*dicp;\n\tuint\t\t\tisize;\n\tint\t\t\tneed_free = 0;\n\n\tif (item->ri_buf[0].i_len == sizeof(xfs_inode_log_format_t)) {\n\t\tin_f = item->ri_buf[0].i_addr;\n\t} else {\n\t\tin_f = kmem_alloc(sizeof(xfs_inode_log_format_t), KM_SLEEP);\n\t\tneed_free = 1;\n\t\terror = xfs_inode_item_format_convert(&item->ri_buf[0], in_f);\n\t\tif (error)\n\t\t\tgoto error;\n\t}\n\n\t/*\n\t * Inode buffers can be freed, look out for it,\n\t * and do not replay the inode.\n\t */\n\tif (xlog_check_buffer_cancelled(log, in_f->ilf_blkno,\n\t\t\t\t\tin_f->ilf_len, 0)) {\n\t\terror = 0;\n\t\ttrace_xfs_log_recover_inode_cancel(log, in_f);\n\t\tgoto error;\n\t}\n\ttrace_xfs_log_recover_inode_recover(log, in_f);\n\n\tbp = xfs_buf_read(mp->m_ddev_targp, in_f->ilf_blkno, in_f->ilf_len, 0,\n\t\t\t  &xfs_inode_buf_ops);\n\tif (!bp) {\n\t\terror = -ENOMEM;\n\t\tgoto error;\n\t}\n\terror = bp->b_error;\n\tif (error) {\n\t\txfs_buf_ioerror_alert(bp, \"xlog_recover_do..(read#2)\");\n\t\tgoto out_release;\n\t}\n\tASSERT(in_f->ilf_fields & XFS_ILOG_CORE);\n\tdip = (xfs_dinode_t *)xfs_buf_offset(bp, in_f->ilf_boffset);\n\n\t/*\n\t * Make sure the place we're flushing out to really looks\n\t * like an inode!\n\t */\n\tif (unlikely(dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))) {\n\t\txfs_alert(mp,\n\t\"%s: Bad inode magic number, dip = 0x%p, dino bp = 0x%p, ino = %Ld\",\n\t\t\t__func__, dip, bp, in_f->ilf_ino);\n\t\tXFS_ERROR_REPORT(\"xlog_recover_inode_pass2(1)\",\n\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tdicp = item->ri_buf[1].i_addr;\n\tif (unlikely(dicp->di_magic != XFS_DINODE_MAGIC)) {\n\t\txfs_alert(mp,\n\t\t\t\"%s: Bad inode log record, rec ptr 0x%p, ino %Ld\",\n\t\t\t__func__, item, in_f->ilf_ino);\n\t\tXFS_ERROR_REPORT(\"xlog_recover_inode_pass2(2)\",\n\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * If the inode has an LSN in it, recover the inode only if it's less\n\t * than the lsn of the transaction we are replaying. Note: we still\n\t * need to replay an owner change even though the inode is more recent\n\t * than the transaction as there is no guarantee that all the btree\n\t * blocks are more recent than this transaction, too.\n\t */\n\tif (dip->di_version >= 3) {\n\t\txfs_lsn_t\tlsn = be64_to_cpu(dip->di_lsn);\n\n\t\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) >= 0) {\n\t\t\ttrace_xfs_log_recover_inode_skip(log, in_f);\n\t\t\terror = 0;\n\t\t\tgoto out_owner_change;\n\t\t}\n\t}\n\n\t/*\n\t * di_flushiter is only valid for v1/2 inodes. All changes for v3 inodes\n\t * are transactional and if ordering is necessary we can determine that\n\t * more accurately by the LSN field in the V3 inode core. Don't trust\n\t * the inode versions we might be changing them here - use the\n\t * superblock flag to determine whether we need to look at di_flushiter\n\t * to skip replay when the on disk inode is newer than the log one\n\t */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    dicp->di_flushiter < be16_to_cpu(dip->di_flushiter)) {\n\t\t/*\n\t\t * Deal with the wrap case, DI_MAX_FLUSH is less\n\t\t * than smaller numbers\n\t\t */\n\t\tif (be16_to_cpu(dip->di_flushiter) == DI_MAX_FLUSH &&\n\t\t    dicp->di_flushiter < (DI_MAX_FLUSH >> 1)) {\n\t\t\t/* do nothing */\n\t\t} else {\n\t\t\ttrace_xfs_log_recover_inode_skip(log, in_f);\n\t\t\terror = 0;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\t/* Take the opportunity to reset the flush iteration count */\n\tdicp->di_flushiter = 0;\n\n\tif (unlikely(S_ISREG(dicp->di_mode))) {\n\t\tif ((dicp->di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (dicp->di_format != XFS_DINODE_FMT_BTREE)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(3)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp, dicp);\n\t\t\txfs_alert(mp,\n\t\t\"%s: Bad regular inode log record, rec ptr 0x%p, \"\n\t\t\"ino ptr = 0x%p, ino bp = 0x%p, ino %Ld\",\n\t\t\t\t__func__, item, dip, bp, in_f->ilf_ino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_release;\n\t\t}\n\t} else if (unlikely(S_ISDIR(dicp->di_mode))) {\n\t\tif ((dicp->di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (dicp->di_format != XFS_DINODE_FMT_BTREE) &&\n\t\t    (dicp->di_format != XFS_DINODE_FMT_LOCAL)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(4)\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\t\txfs_alert(mp,\n\t\t\"%s: Bad dir inode log record, rec ptr 0x%p, \"\n\t\t\"ino ptr = 0x%p, ino bp = 0x%p, ino %Ld\",\n\t\t\t\t__func__, item, dip, bp, in_f->ilf_ino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\tif (unlikely(dicp->di_nextents + dicp->di_anextents > dicp->di_nblocks)){\n\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(5)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\txfs_alert(mp,\n\t\"%s: Bad inode log record, rec ptr 0x%p, dino ptr 0x%p, \"\n\t\"dino bp 0x%p, ino %Ld, total extents = %d, nblocks = %Ld\",\n\t\t\t__func__, item, dip, bp, in_f->ilf_ino,\n\t\t\tdicp->di_nextents + dicp->di_anextents,\n\t\t\tdicp->di_nblocks);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tif (unlikely(dicp->di_forkoff > mp->m_sb.sb_inodesize)) {\n\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(6)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\txfs_alert(mp,\n\t\"%s: Bad inode log record, rec ptr 0x%p, dino ptr 0x%p, \"\n\t\"dino bp 0x%p, ino %Ld, forkoff 0x%x\", __func__,\n\t\t\titem, dip, bp, in_f->ilf_ino, dicp->di_forkoff);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tisize = xfs_icdinode_size(dicp->di_version);\n\tif (unlikely(item->ri_buf[1].i_len > isize)) {\n\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(7)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\txfs_alert(mp,\n\t\t\t\"%s: Bad inode log record length %d, rec ptr 0x%p\",\n\t\t\t__func__, item->ri_buf[1].i_len, item);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\n\t/* The core is in in-core format */\n\txfs_dinode_to_disk(dip, dicp);\n\n\t/* the rest is in on-disk format */\n\tif (item->ri_buf[1].i_len > isize) {\n\t\tmemcpy((char *)dip + isize,\n\t\t\titem->ri_buf[1].i_addr + isize,\n\t\t\titem->ri_buf[1].i_len - isize);\n\t}\n\n\tfields = in_f->ilf_fields;\n\tswitch (fields & (XFS_ILOG_DEV | XFS_ILOG_UUID)) {\n\tcase XFS_ILOG_DEV:\n\t\txfs_dinode_put_rdev(dip, in_f->ilf_u.ilfu_rdev);\n\t\tbreak;\n\tcase XFS_ILOG_UUID:\n\t\tmemcpy(XFS_DFORK_DPTR(dip),\n\t\t       &in_f->ilf_u.ilfu_uuid,\n\t\t       sizeof(uuid_t));\n\t\tbreak;\n\t}\n\n\tif (in_f->ilf_size == 2)\n\t\tgoto out_owner_change;\n\tlen = item->ri_buf[2].i_len;\n\tsrc = item->ri_buf[2].i_addr;\n\tASSERT(in_f->ilf_size <= 4);\n\tASSERT((in_f->ilf_size == 3) || (fields & XFS_ILOG_AFORK));\n\tASSERT(!(fields & XFS_ILOG_DFORK) ||\n\t       (len == in_f->ilf_dsize));\n\n\tswitch (fields & XFS_ILOG_DFORK) {\n\tcase XFS_ILOG_DDATA:\n\tcase XFS_ILOG_DEXT:\n\t\tmemcpy(XFS_DFORK_DPTR(dip), src, len);\n\t\tbreak;\n\n\tcase XFS_ILOG_DBROOT:\n\t\txfs_bmbt_to_bmdr(mp, (struct xfs_btree_block *)src, len,\n\t\t\t\t (xfs_bmdr_block_t *)XFS_DFORK_DPTR(dip),\n\t\t\t\t XFS_DFORK_DSIZE(dip, mp));\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * There are no data fork flags set.\n\t\t */\n\t\tASSERT((fields & XFS_ILOG_DFORK) == 0);\n\t\tbreak;\n\t}\n\n\t/*\n\t * If we logged any attribute data, recover it.  There may or\n\t * may not have been any other non-core data logged in this\n\t * transaction.\n\t */\n\tif (in_f->ilf_fields & XFS_ILOG_AFORK) {\n\t\tif (in_f->ilf_fields & XFS_ILOG_DFORK) {\n\t\t\tattr_index = 3;\n\t\t} else {\n\t\t\tattr_index = 2;\n\t\t}\n\t\tlen = item->ri_buf[attr_index].i_len;\n\t\tsrc = item->ri_buf[attr_index].i_addr;\n\t\tASSERT(len == in_f->ilf_asize);\n\n\t\tswitch (in_f->ilf_fields & XFS_ILOG_AFORK) {\n\t\tcase XFS_ILOG_ADATA:\n\t\tcase XFS_ILOG_AEXT:\n\t\t\tdest = XFS_DFORK_APTR(dip);\n\t\t\tASSERT(len <= XFS_DFORK_ASIZE(dip, mp));\n\t\t\tmemcpy(dest, src, len);\n\t\t\tbreak;\n\n\t\tcase XFS_ILOG_ABROOT:\n\t\t\tdest = XFS_DFORK_APTR(dip);\n\t\t\txfs_bmbt_to_bmdr(mp, (struct xfs_btree_block *)src,\n\t\t\t\t\t len, (xfs_bmdr_block_t*)dest,\n\t\t\t\t\t XFS_DFORK_ASIZE(dip, mp));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\txfs_warn(log->l_mp, \"%s: Invalid flag\", __func__);\n\t\t\tASSERT(0);\n\t\t\terror = -EIO;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\nout_owner_change:\n\tif (in_f->ilf_fields & (XFS_ILOG_DOWNER|XFS_ILOG_AOWNER))\n\t\terror = xfs_recover_inode_owner_change(mp, dip, in_f,\n\t\t\t\t\t\t       buffer_list);\n\t/* re-generate the checksum. */\n\txfs_dinode_calc_crc(log->l_mp, dip);\n\n\tASSERT(bp->b_target->bt_mount == mp);\n\tbp->b_iodone = xlog_recover_iodone;\n\txfs_buf_delwri_queue(bp, buffer_list);\n\nout_release:\n\txfs_buf_relse(bp);\nerror:\n\tif (need_free)\n\t\tkmem_free(in_f);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "in_f"
          ],
          "line": 2782
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_queue",
          "args": [
            "bp",
            "buffer_list"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1709-1744",
          "snippet": "bool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nbool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_target->bt_mount == mp"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dinode_calc_crc",
          "args": [
            "log->l_mp",
            "dip"
          ],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_calc_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "314-328",
          "snippet": "void\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_recover_inode_owner_change",
          "args": [
            "mp",
            "dip",
            "in_f",
            "buffer_list"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_recover_inode_owner_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "2448-2492",
          "snippet": "STATIC int\nxfs_recover_inode_owner_change(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip,\n\tstruct xfs_inode_log_format *in_f,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\n\tASSERT(in_f->ilf_fields & (XFS_ILOG_DOWNER|XFS_ILOG_AOWNER));\n\n\tip = xfs_inode_alloc(mp, in_f->ilf_ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\t/* instantiate the inode */\n\txfs_dinode_from_disk(&ip->i_d, dip);\n\tASSERT(ip->i_d.di_version >= 3);\n\n\terror = xfs_iformat_fork(ip, dip);\n\tif (error)\n\t\tgoto out_free_ip;\n\n\n\tif (in_f->ilf_fields & XFS_ILOG_DOWNER) {\n\t\tASSERT(in_f->ilf_fields & XFS_ILOG_DBROOT);\n\t\terror = xfs_bmbt_change_owner(NULL, ip, XFS_DATA_FORK,\n\t\t\t\t\t      ip->i_ino, buffer_list);\n\t\tif (error)\n\t\t\tgoto out_free_ip;\n\t}\n\n\tif (in_f->ilf_fields & XFS_ILOG_AOWNER) {\n\t\tASSERT(in_f->ilf_fields & XFS_ILOG_ABROOT);\n\t\terror = xfs_bmbt_change_owner(NULL, ip, XFS_ATTR_FORK,\n\t\t\t\t\t      ip->i_ino, buffer_list);\n\t\tif (error)\n\t\t\tgoto out_free_ip;\n\t}\n\nout_free_ip:\n\txfs_inode_free(ip);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_recover_inode_owner_change(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip,\n\tstruct xfs_inode_log_format *in_f,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\n\tASSERT(in_f->ilf_fields & (XFS_ILOG_DOWNER|XFS_ILOG_AOWNER));\n\n\tip = xfs_inode_alloc(mp, in_f->ilf_ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\t/* instantiate the inode */\n\txfs_dinode_from_disk(&ip->i_d, dip);\n\tASSERT(ip->i_d.di_version >= 3);\n\n\terror = xfs_iformat_fork(ip, dip);\n\tif (error)\n\t\tgoto out_free_ip;\n\n\n\tif (in_f->ilf_fields & XFS_ILOG_DOWNER) {\n\t\tASSERT(in_f->ilf_fields & XFS_ILOG_DBROOT);\n\t\terror = xfs_bmbt_change_owner(NULL, ip, XFS_DATA_FORK,\n\t\t\t\t\t      ip->i_ino, buffer_list);\n\t\tif (error)\n\t\t\tgoto out_free_ip;\n\t}\n\n\tif (in_f->ilf_fields & XFS_ILOG_AOWNER) {\n\t\tASSERT(in_f->ilf_fields & XFS_ILOG_ABROOT);\n\t\terror = xfs_bmbt_change_owner(NULL, ip, XFS_ATTR_FORK,\n\t\t\t\t\t      ip->i_ino, buffer_list);\n\t\tif (error)\n\t\t\tgoto out_free_ip;\n\t}\n\nout_free_ip:\n\txfs_inode_free(ip);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"%s: Invalid flag\"",
            "__func__"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_to_bmdr",
          "args": [
            "mp",
            "(struct xfs_btree_block *)src",
            "len",
            "(xfs_bmdr_block_t*)dest",
            "XFS_DFORK_ASIZE(dip, mp)"
          ],
          "line": 2754
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_to_bmdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "336-370",
          "snippet": "void\nxfs_bmbt_to_bmdr(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*rblock,\n\tint\t\t\trblocklen,\n\txfs_bmdr_block_t\t*dblock,\n\tint\t\t\tdblocklen)\n{\n\tint\t\t\tdmxr;\n\txfs_bmbt_key_t\t\t*fkp;\n\t__be64\t\t\t*fpp;\n\txfs_bmbt_key_t\t\t*tkp;\n\t__be64\t\t\t*tpp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tASSERT(rblock->bb_magic == cpu_to_be32(XFS_BMAP_CRC_MAGIC));\n\t\tASSERT(uuid_equal(&rblock->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid));\n\t\tASSERT(rblock->bb_u.l.bb_blkno ==\n\t\t       cpu_to_be64(XFS_BUF_DADDR_NULL));\n\t} else\n\t\tASSERT(rblock->bb_magic == cpu_to_be32(XFS_BMAP_MAGIC));\n\tASSERT(rblock->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK));\n\tASSERT(rblock->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK));\n\tASSERT(rblock->bb_level != 0);\n\tdblock->bb_level = rblock->bb_level;\n\tdblock->bb_numrecs = rblock->bb_numrecs;\n\tdmxr = xfs_bmdr_maxrecs(dblocklen, 0);\n\tfkp = XFS_BMBT_KEY_ADDR(mp, rblock, 1);\n\ttkp = XFS_BMDR_KEY_ADDR(dblock, 1);\n\tfpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, rblocklen);\n\ttpp = XFS_BMDR_PTR_ADDR(dblock, 1, dmxr);\n\tdmxr = be16_to_cpu(dblock->bb_numrecs);\n\tmemcpy(tkp, fkp, sizeof(*fkp) * dmxr);\n\tmemcpy(tpp, fpp, sizeof(*fpp) * dmxr);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_bmbt_to_bmdr(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*rblock,\n\tint\t\t\trblocklen,\n\txfs_bmdr_block_t\t*dblock,\n\tint\t\t\tdblocklen)\n{\n\tint\t\t\tdmxr;\n\txfs_bmbt_key_t\t\t*fkp;\n\t__be64\t\t\t*fpp;\n\txfs_bmbt_key_t\t\t*tkp;\n\t__be64\t\t\t*tpp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tASSERT(rblock->bb_magic == cpu_to_be32(XFS_BMAP_CRC_MAGIC));\n\t\tASSERT(uuid_equal(&rblock->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid));\n\t\tASSERT(rblock->bb_u.l.bb_blkno ==\n\t\t       cpu_to_be64(XFS_BUF_DADDR_NULL));\n\t} else\n\t\tASSERT(rblock->bb_magic == cpu_to_be32(XFS_BMAP_MAGIC));\n\tASSERT(rblock->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK));\n\tASSERT(rblock->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK));\n\tASSERT(rblock->bb_level != 0);\n\tdblock->bb_level = rblock->bb_level;\n\tdblock->bb_numrecs = rblock->bb_numrecs;\n\tdmxr = xfs_bmdr_maxrecs(dblocklen, 0);\n\tfkp = XFS_BMBT_KEY_ADDR(mp, rblock, 1);\n\ttkp = XFS_BMDR_KEY_ADDR(dblock, 1);\n\tfpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, rblocklen);\n\ttpp = XFS_BMDR_PTR_ADDR(dblock, 1, dmxr);\n\tdmxr = be16_to_cpu(dblock->bb_numrecs);\n\tmemcpy(tkp, fkp, sizeof(*fkp) * dmxr);\n\tmemcpy(tpp, fpp, sizeof(*fpp) * dmxr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_ASIZE",
          "args": [
            "dip",
            "mp"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_APTR",
          "args": [
            "dip"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "src",
            "len"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len <= XFS_DFORK_ASIZE(dip, mp)"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_ASIZE",
          "args": [
            "dip",
            "mp"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_APTR",
          "args": [
            "dip"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len == in_f->ilf_asize"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(fields & XFS_ILOG_DFORK) == 0"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_DSIZE",
          "args": [
            "dip",
            "mp"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_DPTR",
          "args": [
            "dip"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "XFS_DFORK_DPTR(dip)",
            "src",
            "len"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_DPTR",
          "args": [
            "dip"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(fields & XFS_ILOG_DFORK) ||\n\t       (len == in_f->ilf_dsize)"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(in_f->ilf_size == 3) || (fields & XFS_ILOG_AFORK)"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "in_f->ilf_size <= 4"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "XFS_DFORK_DPTR(dip)",
            "&in_f->ilf_u.ilfu_uuid",
            "sizeof(uuid_t)"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_DPTR",
          "args": [
            "dip"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dinode_put_rdev",
          "args": [
            "dip",
            "in_f->ilf_u.ilfu_rdev"
          ],
          "line": 2691
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_put_rdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1023-1026",
          "snippet": "static inline void xfs_dinode_put_rdev(struct xfs_dinode *dip, xfs_dev_t rdev)\n{\n\t*(__be32 *)XFS_DFORK_DPTR(dip) = cpu_to_be32(rdev);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dinode_put_rdev(struct xfs_dinode *dip, xfs_dev_t rdev)\n{\n\t*(__be32 *)XFS_DFORK_DPTR(dip) = cpu_to_be32(rdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)dip + isize",
            "item->ri_buf[1].i_addr + isize",
            "item->ri_buf[1].i_len - isize"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dinode_to_disk",
          "args": [
            "dip",
            "dicp"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "240-287",
          "snippet": "void\nxfs_dinode_to_disk(\n\txfs_dinode_t\t\t*to,\n\txfs_icdinode_t\t\t*from)\n{\n\tto->di_magic = cpu_to_be16(from->di_magic);\n\tto->di_mode = cpu_to_be16(from->di_mode);\n\tto->di_version = from ->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = cpu_to_be16(from->di_onlink);\n\tto->di_uid = cpu_to_be32(from->di_uid);\n\tto->di_gid = cpu_to_be32(from->di_gid);\n\tto->di_nlink = cpu_to_be32(from->di_nlink);\n\tto->di_projid_lo = cpu_to_be16(from->di_projid_lo);\n\tto->di_projid_hi = cpu_to_be16(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\tto->di_atime.t_sec = cpu_to_be32(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = cpu_to_be32(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = cpu_to_be32(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = cpu_to_be32(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = cpu_to_be32(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = cpu_to_be32(from->di_ctime.t_nsec);\n\tto->di_size = cpu_to_be64(from->di_size);\n\tto->di_nblocks = cpu_to_be64(from->di_nblocks);\n\tto->di_extsize = cpu_to_be32(from->di_extsize);\n\tto->di_nextents = cpu_to_be32(from->di_nextents);\n\tto->di_anextents = cpu_to_be16(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat = from->di_aformat;\n\tto->di_dmevmask = cpu_to_be32(from->di_dmevmask);\n\tto->di_dmstate = cpu_to_be16(from->di_dmstate);\n\tto->di_flags = cpu_to_be16(from->di_flags);\n\tto->di_gen = cpu_to_be32(from->di_gen);\n\n\tif (from->di_version == 3) {\n\t\tto->di_changecount = cpu_to_be64(from->di_changecount);\n\t\tto->di_crtime.t_sec = cpu_to_be32(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = cpu_to_be32(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = cpu_to_be64(from->di_flags2);\n\t\tto->di_ino = cpu_to_be64(from->di_ino);\n\t\tto->di_lsn = cpu_to_be64(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t\tto->di_flushiter = 0;\n\t} else {\n\t\tto->di_flushiter = cpu_to_be16(from->di_flushiter);\n\t}\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dinode_to_disk(\n\txfs_dinode_t\t\t*to,\n\txfs_icdinode_t\t\t*from)\n{\n\tto->di_magic = cpu_to_be16(from->di_magic);\n\tto->di_mode = cpu_to_be16(from->di_mode);\n\tto->di_version = from ->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = cpu_to_be16(from->di_onlink);\n\tto->di_uid = cpu_to_be32(from->di_uid);\n\tto->di_gid = cpu_to_be32(from->di_gid);\n\tto->di_nlink = cpu_to_be32(from->di_nlink);\n\tto->di_projid_lo = cpu_to_be16(from->di_projid_lo);\n\tto->di_projid_hi = cpu_to_be16(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\tto->di_atime.t_sec = cpu_to_be32(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = cpu_to_be32(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = cpu_to_be32(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = cpu_to_be32(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = cpu_to_be32(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = cpu_to_be32(from->di_ctime.t_nsec);\n\tto->di_size = cpu_to_be64(from->di_size);\n\tto->di_nblocks = cpu_to_be64(from->di_nblocks);\n\tto->di_extsize = cpu_to_be32(from->di_extsize);\n\tto->di_nextents = cpu_to_be32(from->di_nextents);\n\tto->di_anextents = cpu_to_be16(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat = from->di_aformat;\n\tto->di_dmevmask = cpu_to_be32(from->di_dmevmask);\n\tto->di_dmstate = cpu_to_be16(from->di_dmstate);\n\tto->di_flags = cpu_to_be16(from->di_flags);\n\tto->di_gen = cpu_to_be32(from->di_gen);\n\n\tif (from->di_version == 3) {\n\t\tto->di_changecount = cpu_to_be64(from->di_changecount);\n\t\tto->di_crtime.t_sec = cpu_to_be32(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = cpu_to_be32(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = cpu_to_be64(from->di_flags2);\n\t\tto->di_ino = cpu_to_be64(from->di_ino);\n\t\tto->di_lsn = cpu_to_be64(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t\tto->di_flushiter = 0;\n\t} else {\n\t\tto->di_flushiter = cpu_to_be16(from->di_flushiter);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"%s: Bad inode log record length %d, rec ptr 0x%p\"",
            "__func__",
            "item->ri_buf[1].i_len",
            "item"
          ],
          "line": 2671
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xlog_recover_inode_pass2(7)\"",
            "XFS_ERRLEVEL_LOW",
            "mp",
            "dicp"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "item->ri_buf[1].i_len > isize"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icdinode_size",
          "args": [
            "dicp->di_version"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icdinode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "412-417",
          "snippet": "static inline uint xfs_icdinode_size(int version)\n{\n\tif (version == 3)\n\t\treturn sizeof(struct xfs_icdinode);\n\treturn offsetof(struct xfs_icdinode, di_next_unlinked);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline uint xfs_icdinode_size(int version)\n{\n\tif (version == 3)\n\t\treturn sizeof(struct xfs_icdinode);\n\treturn offsetof(struct xfs_icdinode, di_next_unlinked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xlog_recover_inode_pass2(6)\"",
            "XFS_ERRLEVEL_LOW",
            "mp",
            "dicp"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dicp->di_forkoff > mp->m_sb.sb_inodesize"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xlog_recover_inode_pass2(5)\"",
            "XFS_ERRLEVEL_LOW",
            "mp",
            "dicp"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dicp->di_nextents + dicp->di_anextents > dicp->di_nblocks"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xlog_recover_inode_pass2(4)\"",
            "XFS_ERRLEVEL_LOW",
            "mp",
            "dicp"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "S_ISDIR(dicp->di_mode)"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dicp->di_mode"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xlog_recover_inode_pass2(3)\"",
            "XFS_ERRLEVEL_LOW",
            "mp",
            "dicp"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "S_ISREG(dicp->di_mode)"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "dicp->di_mode"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_inode_skip",
          "args": [
            "log",
            "in_f"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dip->di_flushiter"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dip->di_flushiter"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_inode_skip",
          "args": [
            "log",
            "in_f"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "lsn",
            "current_lsn"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dip->di_lsn"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xlog_recover_inode_pass2(2)\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dicp->di_magic != XFS_DINODE_MAGIC"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xlog_recover_inode_pass2(1)\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC)"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DINODE_MAGIC"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_offset",
          "args": [
            "bp",
            "in_f->ilf_boffset"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1422-1435",
          "snippet": "xfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "in_f->ilf_fields & XFS_ILOG_CORE"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror_alert",
          "args": [
            "bp",
            "\"xlog_recover_do..(read#2)\""
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_read",
          "args": [
            "mp->m_ddev_targp",
            "in_f->ilf_blkno",
            "in_f->ilf_len",
            "0",
            "&xfs_inode_buf_ops"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "244-254",
          "snippet": "static inline struct xfs_buf *\nxfs_buf_read(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_read_map(target, &map, 1, flags, ops);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline struct xfs_buf *\nxfs_buf_read(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_read_map(target, &map, 1, flags, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_inode_recover",
          "args": [
            "log",
            "in_f"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_inode_cancel",
          "args": [
            "log",
            "in_f"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_check_buffer_cancelled",
          "args": [
            "log",
            "in_f->ilf_blkno",
            "in_f->ilf_len",
            "0"
          ],
          "line": 2529
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_check_buffer_cancelled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1663-1689",
          "snippet": "STATIC int\nxlog_check_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tbcp = xlog_peek_buffer_cancelled(log, blkno, len, flags);\n\tif (!bcp)\n\t\treturn 0;\n\n\t/*\n\t * We've go a match, so return 1 so that the recovery of this buffer\n\t * is cancelled.  If this buffer is actually a buffer cancel log\n\t * item, then decrement the refcount on the one in the table and\n\t * remove it if this is the last reference.\n\t */\n\tif (flags & XFS_BLF_CANCEL) {\n\t\tif (--bcp->bc_refcount == 0) {\n\t\t\tlist_del(&bcp->bc_list);\n\t\t\tkmem_free(bcp);\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_check_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tbcp = xlog_peek_buffer_cancelled(log, blkno, len, flags);\n\tif (!bcp)\n\t\treturn 0;\n\n\t/*\n\t * We've go a match, so return 1 so that the recovery of this buffer\n\t * is cancelled.  If this buffer is actually a buffer cancel log\n\t * item, then decrement the refcount on the one in the table and\n\t * remove it if this is the last reference.\n\t */\n\tif (flags & XFS_BLF_CANCEL) {\n\t\tif (--bcp->bc_refcount == 0) {\n\t\t\tlist_del(&bcp->bc_list);\n\t\t\tkmem_free(bcp);\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_item_format_convert",
          "args": [
            "&item->ri_buf[0]",
            "in_f"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_item_format_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "748-789",
          "snippet": "int\nxfs_inode_item_format_convert(\n\txfs_log_iovec_t\t\t*buf,\n\txfs_inode_log_format_t\t*in_f)\n{\n\tif (buf->i_len == sizeof(xfs_inode_log_format_32_t)) {\n\t\txfs_inode_log_format_32_t *in_f32 = buf->i_addr;\n\n\t\tin_f->ilf_type = in_f32->ilf_type;\n\t\tin_f->ilf_size = in_f32->ilf_size;\n\t\tin_f->ilf_fields = in_f32->ilf_fields;\n\t\tin_f->ilf_asize = in_f32->ilf_asize;\n\t\tin_f->ilf_dsize = in_f32->ilf_dsize;\n\t\tin_f->ilf_ino = in_f32->ilf_ino;\n\t\t/* copy biggest field of ilf_u */\n\t\tmemcpy(in_f->ilf_u.ilfu_uuid.__u_bits,\n\t\t       in_f32->ilf_u.ilfu_uuid.__u_bits,\n\t\t       sizeof(uuid_t));\n\t\tin_f->ilf_blkno = in_f32->ilf_blkno;\n\t\tin_f->ilf_len = in_f32->ilf_len;\n\t\tin_f->ilf_boffset = in_f32->ilf_boffset;\n\t\treturn 0;\n\t} else if (buf->i_len == sizeof(xfs_inode_log_format_64_t)){\n\t\txfs_inode_log_format_64_t *in_f64 = buf->i_addr;\n\n\t\tin_f->ilf_type = in_f64->ilf_type;\n\t\tin_f->ilf_size = in_f64->ilf_size;\n\t\tin_f->ilf_fields = in_f64->ilf_fields;\n\t\tin_f->ilf_asize = in_f64->ilf_asize;\n\t\tin_f->ilf_dsize = in_f64->ilf_dsize;\n\t\tin_f->ilf_ino = in_f64->ilf_ino;\n\t\t/* copy biggest field of ilf_u */\n\t\tmemcpy(in_f->ilf_u.ilfu_uuid.__u_bits,\n\t\t       in_f64->ilf_u.ilfu_uuid.__u_bits,\n\t\t       sizeof(uuid_t));\n\t\tin_f->ilf_blkno = in_f64->ilf_blkno;\n\t\tin_f->ilf_len = in_f64->ilf_len;\n\t\tin_f->ilf_boffset = in_f64->ilf_boffset;\n\t\treturn 0;\n\t}\n\treturn -EFSCORRUPTED;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_inode_item_format_convert(\n\txfs_log_iovec_t\t\t*buf,\n\txfs_inode_log_format_t\t*in_f)\n{\n\tif (buf->i_len == sizeof(xfs_inode_log_format_32_t)) {\n\t\txfs_inode_log_format_32_t *in_f32 = buf->i_addr;\n\n\t\tin_f->ilf_type = in_f32->ilf_type;\n\t\tin_f->ilf_size = in_f32->ilf_size;\n\t\tin_f->ilf_fields = in_f32->ilf_fields;\n\t\tin_f->ilf_asize = in_f32->ilf_asize;\n\t\tin_f->ilf_dsize = in_f32->ilf_dsize;\n\t\tin_f->ilf_ino = in_f32->ilf_ino;\n\t\t/* copy biggest field of ilf_u */\n\t\tmemcpy(in_f->ilf_u.ilfu_uuid.__u_bits,\n\t\t       in_f32->ilf_u.ilfu_uuid.__u_bits,\n\t\t       sizeof(uuid_t));\n\t\tin_f->ilf_blkno = in_f32->ilf_blkno;\n\t\tin_f->ilf_len = in_f32->ilf_len;\n\t\tin_f->ilf_boffset = in_f32->ilf_boffset;\n\t\treturn 0;\n\t} else if (buf->i_len == sizeof(xfs_inode_log_format_64_t)){\n\t\txfs_inode_log_format_64_t *in_f64 = buf->i_addr;\n\n\t\tin_f->ilf_type = in_f64->ilf_type;\n\t\tin_f->ilf_size = in_f64->ilf_size;\n\t\tin_f->ilf_fields = in_f64->ilf_fields;\n\t\tin_f->ilf_asize = in_f64->ilf_asize;\n\t\tin_f->ilf_dsize = in_f64->ilf_dsize;\n\t\tin_f->ilf_ino = in_f64->ilf_ino;\n\t\t/* copy biggest field of ilf_u */\n\t\tmemcpy(in_f->ilf_u.ilfu_uuid.__u_bits,\n\t\t       in_f64->ilf_u.ilfu_uuid.__u_bits,\n\t\t       sizeof(uuid_t));\n\t\tin_f->ilf_blkno = in_f64->ilf_blkno;\n\t\tin_f->ilf_len = in_f64->ilf_len;\n\t\tin_f->ilf_boffset = in_f64->ilf_boffset;\n\t\treturn 0;\n\t}\n\treturn -EFSCORRUPTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "sizeof(xfs_inode_log_format_t)",
            "KM_SLEEP"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_inode_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\txfs_inode_log_format_t\t*in_f;\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_buf_t\t\t*bp;\n\txfs_dinode_t\t\t*dip;\n\tint\t\t\tlen;\n\txfs_caddr_t\t\tsrc;\n\txfs_caddr_t\t\tdest;\n\tint\t\t\terror;\n\tint\t\t\tattr_index;\n\tuint\t\t\tfields;\n\txfs_icdinode_t\t\t*dicp;\n\tuint\t\t\tisize;\n\tint\t\t\tneed_free = 0;\n\n\tif (item->ri_buf[0].i_len == sizeof(xfs_inode_log_format_t)) {\n\t\tin_f = item->ri_buf[0].i_addr;\n\t} else {\n\t\tin_f = kmem_alloc(sizeof(xfs_inode_log_format_t), KM_SLEEP);\n\t\tneed_free = 1;\n\t\terror = xfs_inode_item_format_convert(&item->ri_buf[0], in_f);\n\t\tif (error)\n\t\t\tgoto error;\n\t}\n\n\t/*\n\t * Inode buffers can be freed, look out for it,\n\t * and do not replay the inode.\n\t */\n\tif (xlog_check_buffer_cancelled(log, in_f->ilf_blkno,\n\t\t\t\t\tin_f->ilf_len, 0)) {\n\t\terror = 0;\n\t\ttrace_xfs_log_recover_inode_cancel(log, in_f);\n\t\tgoto error;\n\t}\n\ttrace_xfs_log_recover_inode_recover(log, in_f);\n\n\tbp = xfs_buf_read(mp->m_ddev_targp, in_f->ilf_blkno, in_f->ilf_len, 0,\n\t\t\t  &xfs_inode_buf_ops);\n\tif (!bp) {\n\t\terror = -ENOMEM;\n\t\tgoto error;\n\t}\n\terror = bp->b_error;\n\tif (error) {\n\t\txfs_buf_ioerror_alert(bp, \"xlog_recover_do..(read#2)\");\n\t\tgoto out_release;\n\t}\n\tASSERT(in_f->ilf_fields & XFS_ILOG_CORE);\n\tdip = (xfs_dinode_t *)xfs_buf_offset(bp, in_f->ilf_boffset);\n\n\t/*\n\t * Make sure the place we're flushing out to really looks\n\t * like an inode!\n\t */\n\tif (unlikely(dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))) {\n\t\txfs_alert(mp,\n\t\"%s: Bad inode magic number, dip = 0x%p, dino bp = 0x%p, ino = %Ld\",\n\t\t\t__func__, dip, bp, in_f->ilf_ino);\n\t\tXFS_ERROR_REPORT(\"xlog_recover_inode_pass2(1)\",\n\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tdicp = item->ri_buf[1].i_addr;\n\tif (unlikely(dicp->di_magic != XFS_DINODE_MAGIC)) {\n\t\txfs_alert(mp,\n\t\t\t\"%s: Bad inode log record, rec ptr 0x%p, ino %Ld\",\n\t\t\t__func__, item, in_f->ilf_ino);\n\t\tXFS_ERROR_REPORT(\"xlog_recover_inode_pass2(2)\",\n\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * If the inode has an LSN in it, recover the inode only if it's less\n\t * than the lsn of the transaction we are replaying. Note: we still\n\t * need to replay an owner change even though the inode is more recent\n\t * than the transaction as there is no guarantee that all the btree\n\t * blocks are more recent than this transaction, too.\n\t */\n\tif (dip->di_version >= 3) {\n\t\txfs_lsn_t\tlsn = be64_to_cpu(dip->di_lsn);\n\n\t\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) >= 0) {\n\t\t\ttrace_xfs_log_recover_inode_skip(log, in_f);\n\t\t\terror = 0;\n\t\t\tgoto out_owner_change;\n\t\t}\n\t}\n\n\t/*\n\t * di_flushiter is only valid for v1/2 inodes. All changes for v3 inodes\n\t * are transactional and if ordering is necessary we can determine that\n\t * more accurately by the LSN field in the V3 inode core. Don't trust\n\t * the inode versions we might be changing them here - use the\n\t * superblock flag to determine whether we need to look at di_flushiter\n\t * to skip replay when the on disk inode is newer than the log one\n\t */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    dicp->di_flushiter < be16_to_cpu(dip->di_flushiter)) {\n\t\t/*\n\t\t * Deal with the wrap case, DI_MAX_FLUSH is less\n\t\t * than smaller numbers\n\t\t */\n\t\tif (be16_to_cpu(dip->di_flushiter) == DI_MAX_FLUSH &&\n\t\t    dicp->di_flushiter < (DI_MAX_FLUSH >> 1)) {\n\t\t\t/* do nothing */\n\t\t} else {\n\t\t\ttrace_xfs_log_recover_inode_skip(log, in_f);\n\t\t\terror = 0;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\t/* Take the opportunity to reset the flush iteration count */\n\tdicp->di_flushiter = 0;\n\n\tif (unlikely(S_ISREG(dicp->di_mode))) {\n\t\tif ((dicp->di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (dicp->di_format != XFS_DINODE_FMT_BTREE)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(3)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp, dicp);\n\t\t\txfs_alert(mp,\n\t\t\"%s: Bad regular inode log record, rec ptr 0x%p, \"\n\t\t\"ino ptr = 0x%p, ino bp = 0x%p, ino %Ld\",\n\t\t\t\t__func__, item, dip, bp, in_f->ilf_ino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_release;\n\t\t}\n\t} else if (unlikely(S_ISDIR(dicp->di_mode))) {\n\t\tif ((dicp->di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (dicp->di_format != XFS_DINODE_FMT_BTREE) &&\n\t\t    (dicp->di_format != XFS_DINODE_FMT_LOCAL)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(4)\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\t\txfs_alert(mp,\n\t\t\"%s: Bad dir inode log record, rec ptr 0x%p, \"\n\t\t\"ino ptr = 0x%p, ino bp = 0x%p, ino %Ld\",\n\t\t\t\t__func__, item, dip, bp, in_f->ilf_ino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\tif (unlikely(dicp->di_nextents + dicp->di_anextents > dicp->di_nblocks)){\n\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(5)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\txfs_alert(mp,\n\t\"%s: Bad inode log record, rec ptr 0x%p, dino ptr 0x%p, \"\n\t\"dino bp 0x%p, ino %Ld, total extents = %d, nblocks = %Ld\",\n\t\t\t__func__, item, dip, bp, in_f->ilf_ino,\n\t\t\tdicp->di_nextents + dicp->di_anextents,\n\t\t\tdicp->di_nblocks);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tif (unlikely(dicp->di_forkoff > mp->m_sb.sb_inodesize)) {\n\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(6)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\txfs_alert(mp,\n\t\"%s: Bad inode log record, rec ptr 0x%p, dino ptr 0x%p, \"\n\t\"dino bp 0x%p, ino %Ld, forkoff 0x%x\", __func__,\n\t\t\titem, dip, bp, in_f->ilf_ino, dicp->di_forkoff);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tisize = xfs_icdinode_size(dicp->di_version);\n\tif (unlikely(item->ri_buf[1].i_len > isize)) {\n\t\tXFS_CORRUPTION_ERROR(\"xlog_recover_inode_pass2(7)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, mp, dicp);\n\t\txfs_alert(mp,\n\t\t\t\"%s: Bad inode log record length %d, rec ptr 0x%p\",\n\t\t\t__func__, item->ri_buf[1].i_len, item);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\n\t/* The core is in in-core format */\n\txfs_dinode_to_disk(dip, dicp);\n\n\t/* the rest is in on-disk format */\n\tif (item->ri_buf[1].i_len > isize) {\n\t\tmemcpy((char *)dip + isize,\n\t\t\titem->ri_buf[1].i_addr + isize,\n\t\t\titem->ri_buf[1].i_len - isize);\n\t}\n\n\tfields = in_f->ilf_fields;\n\tswitch (fields & (XFS_ILOG_DEV | XFS_ILOG_UUID)) {\n\tcase XFS_ILOG_DEV:\n\t\txfs_dinode_put_rdev(dip, in_f->ilf_u.ilfu_rdev);\n\t\tbreak;\n\tcase XFS_ILOG_UUID:\n\t\tmemcpy(XFS_DFORK_DPTR(dip),\n\t\t       &in_f->ilf_u.ilfu_uuid,\n\t\t       sizeof(uuid_t));\n\t\tbreak;\n\t}\n\n\tif (in_f->ilf_size == 2)\n\t\tgoto out_owner_change;\n\tlen = item->ri_buf[2].i_len;\n\tsrc = item->ri_buf[2].i_addr;\n\tASSERT(in_f->ilf_size <= 4);\n\tASSERT((in_f->ilf_size == 3) || (fields & XFS_ILOG_AFORK));\n\tASSERT(!(fields & XFS_ILOG_DFORK) ||\n\t       (len == in_f->ilf_dsize));\n\n\tswitch (fields & XFS_ILOG_DFORK) {\n\tcase XFS_ILOG_DDATA:\n\tcase XFS_ILOG_DEXT:\n\t\tmemcpy(XFS_DFORK_DPTR(dip), src, len);\n\t\tbreak;\n\n\tcase XFS_ILOG_DBROOT:\n\t\txfs_bmbt_to_bmdr(mp, (struct xfs_btree_block *)src, len,\n\t\t\t\t (xfs_bmdr_block_t *)XFS_DFORK_DPTR(dip),\n\t\t\t\t XFS_DFORK_DSIZE(dip, mp));\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * There are no data fork flags set.\n\t\t */\n\t\tASSERT((fields & XFS_ILOG_DFORK) == 0);\n\t\tbreak;\n\t}\n\n\t/*\n\t * If we logged any attribute data, recover it.  There may or\n\t * may not have been any other non-core data logged in this\n\t * transaction.\n\t */\n\tif (in_f->ilf_fields & XFS_ILOG_AFORK) {\n\t\tif (in_f->ilf_fields & XFS_ILOG_DFORK) {\n\t\t\tattr_index = 3;\n\t\t} else {\n\t\t\tattr_index = 2;\n\t\t}\n\t\tlen = item->ri_buf[attr_index].i_len;\n\t\tsrc = item->ri_buf[attr_index].i_addr;\n\t\tASSERT(len == in_f->ilf_asize);\n\n\t\tswitch (in_f->ilf_fields & XFS_ILOG_AFORK) {\n\t\tcase XFS_ILOG_ADATA:\n\t\tcase XFS_ILOG_AEXT:\n\t\t\tdest = XFS_DFORK_APTR(dip);\n\t\t\tASSERT(len <= XFS_DFORK_ASIZE(dip, mp));\n\t\t\tmemcpy(dest, src, len);\n\t\t\tbreak;\n\n\t\tcase XFS_ILOG_ABROOT:\n\t\t\tdest = XFS_DFORK_APTR(dip);\n\t\t\txfs_bmbt_to_bmdr(mp, (struct xfs_btree_block *)src,\n\t\t\t\t\t len, (xfs_bmdr_block_t*)dest,\n\t\t\t\t\t XFS_DFORK_ASIZE(dip, mp));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\txfs_warn(log->l_mp, \"%s: Invalid flag\", __func__);\n\t\t\tASSERT(0);\n\t\t\terror = -EIO;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\nout_owner_change:\n\tif (in_f->ilf_fields & (XFS_ILOG_DOWNER|XFS_ILOG_AOWNER))\n\t\terror = xfs_recover_inode_owner_change(mp, dip, in_f,\n\t\t\t\t\t\t       buffer_list);\n\t/* re-generate the checksum. */\n\txfs_dinode_calc_crc(log->l_mp, dip);\n\n\tASSERT(bp->b_target->bt_mount == mp);\n\tbp->b_iodone = xlog_recover_iodone;\n\txfs_buf_delwri_queue(bp, buffer_list);\n\nout_release:\n\txfs_buf_relse(bp);\nerror:\n\tif (need_free)\n\t\tkmem_free(in_f);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_recover_inode_owner_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "2448-2492",
    "snippet": "STATIC int\nxfs_recover_inode_owner_change(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip,\n\tstruct xfs_inode_log_format *in_f,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\n\tASSERT(in_f->ilf_fields & (XFS_ILOG_DOWNER|XFS_ILOG_AOWNER));\n\n\tip = xfs_inode_alloc(mp, in_f->ilf_ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\t/* instantiate the inode */\n\txfs_dinode_from_disk(&ip->i_d, dip);\n\tASSERT(ip->i_d.di_version >= 3);\n\n\terror = xfs_iformat_fork(ip, dip);\n\tif (error)\n\t\tgoto out_free_ip;\n\n\n\tif (in_f->ilf_fields & XFS_ILOG_DOWNER) {\n\t\tASSERT(in_f->ilf_fields & XFS_ILOG_DBROOT);\n\t\terror = xfs_bmbt_change_owner(NULL, ip, XFS_DATA_FORK,\n\t\t\t\t\t      ip->i_ino, buffer_list);\n\t\tif (error)\n\t\t\tgoto out_free_ip;\n\t}\n\n\tif (in_f->ilf_fields & XFS_ILOG_AOWNER) {\n\t\tASSERT(in_f->ilf_fields & XFS_ILOG_ABROOT);\n\t\terror = xfs_bmbt_change_owner(NULL, ip, XFS_ATTR_FORK,\n\t\t\t\t\t      ip->i_ino, buffer_list);\n\t\tif (error)\n\t\t\tgoto out_free_ip;\n\t}\n\nout_free_ip:\n\txfs_inode_free(ip);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inode_free",
          "args": [
            "ip"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_free_quota_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1311-1352",
          "snippet": "int\nxfs_inode_free_quota_eofblocks(\n\tstruct xfs_inode *ip)\n{\n\tint scan = 0;\n\tstruct xfs_eofblocks eofb = {0};\n\tstruct xfs_dquot *dq;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\t/*\n\t * Set the scan owner to avoid a potential livelock. Otherwise, the scan\n\t * can repeatedly trylock on the inode we're currently processing. We\n\t * run a sync scan to increase effectiveness and use the union filter to\n\t * cover all applicable quotas in a single scan.\n\t */\n\teofb.eof_scan_owner = ip->i_ino;\n\teofb.eof_flags = XFS_EOF_FLAGS_UNION|XFS_EOF_FLAGS_SYNC;\n\n\tif (XFS_IS_UQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_USER);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_uid = VFS_I(ip)->i_uid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_UID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (XFS_IS_GQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_GROUP);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_gid = VFS_I(ip)->i_gid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_GID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (scan)\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\n\treturn scan;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_inode_free_quota_eofblocks(\n\tstruct xfs_inode *ip)\n{\n\tint scan = 0;\n\tstruct xfs_eofblocks eofb = {0};\n\tstruct xfs_dquot *dq;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\t/*\n\t * Set the scan owner to avoid a potential livelock. Otherwise, the scan\n\t * can repeatedly trylock on the inode we're currently processing. We\n\t * run a sync scan to increase effectiveness and use the union filter to\n\t * cover all applicable quotas in a single scan.\n\t */\n\teofb.eof_scan_owner = ip->i_ino;\n\teofb.eof_flags = XFS_EOF_FLAGS_UNION|XFS_EOF_FLAGS_SYNC;\n\n\tif (XFS_IS_UQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_USER);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_uid = VFS_I(ip)->i_uid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_UID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (XFS_IS_GQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_GROUP);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_gid = VFS_I(ip)->i_gid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_GID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (scan)\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\n\treturn scan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_change_owner",
          "args": [
            "NULL",
            "ip",
            "XFS_ATTR_FORK",
            "ip->i_ino",
            "buffer_list"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_change_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "858-883",
          "snippet": "int\nxfs_bmbt_change_owner(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_ino_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_btree_cur\t*cur;\n\tint\t\t\terror;\n\n\tASSERT(tp || buffer_list);\n\tASSERT(!(tp && buffer_list));\n\tif (whichfork == XFS_DATA_FORK)\n\t\tASSERT(ip->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\telse\n\t\tASSERT(ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE);\n\n\tcur = xfs_bmbt_init_cursor(ip->i_mount, tp, ip, whichfork);\n\tif (!cur)\n\t\treturn -ENOMEM;\n\n\terror = xfs_btree_change_owner(cur, new_owner, buffer_list);\n\txfs_btree_del_cursor(cur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_bmbt_change_owner(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_ino_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_btree_cur\t*cur;\n\tint\t\t\terror;\n\n\tASSERT(tp || buffer_list);\n\tASSERT(!(tp && buffer_list));\n\tif (whichfork == XFS_DATA_FORK)\n\t\tASSERT(ip->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\telse\n\t\tASSERT(ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE);\n\n\tcur = xfs_bmbt_init_cursor(ip->i_mount, tp, ip, whichfork);\n\tif (!cur)\n\t\treturn -ENOMEM;\n\n\terror = xfs_btree_change_owner(cur, new_owner, buffer_list);\n\txfs_btree_del_cursor(cur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "in_f->ilf_fields & XFS_ILOG_ABROOT"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "in_f->ilf_fields & XFS_ILOG_DBROOT"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iformat_fork",
          "args": [
            "ip",
            "dip"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iformat_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "79-231",
          "snippet": "int\nxfs_iformat_fork(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip)\n{\n\txfs_attr_shortform_t\t*atp;\n\tint\t\t\tsize;\n\tint\t\t\terror = 0;\n\txfs_fsize_t             di_size;\n\n\tif (unlikely(be32_to_cpu(dip->di_nextents) +\n\t\t     be16_to_cpu(dip->di_anextents) >\n\t\t     be64_to_cpu(dip->di_nblocks))) {\n\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, extent total = %d, nblocks = %Lu.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(int)(be32_to_cpu(dip->di_nextents) +\n\t\t\t      be16_to_cpu(dip->di_anextents)),\n\t\t\t(unsigned long long)\n\t\t\t\tbe64_to_cpu(dip->di_nblocks));\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely(dip->di_forkoff > ip->i_mount->m_sb.sb_inodesize)) {\n\t\txfs_warn(ip->i_mount, \"corrupt dinode %Lu, forkoff = 0x%x.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\tdip->di_forkoff);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely((ip->i_d.di_flags & XFS_DIFLAG_REALTIME) &&\n\t\t     !ip->i_mount->m_rtdev_targp)) {\n\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, has realtime flag set.\",\n\t\t\tip->i_ino);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(realtime)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tswitch (ip->i_d.di_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tif (unlikely(dip->di_format != XFS_DINODE_FMT_DEV)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(3)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t      ip->i_mount, dip);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tip->i_d.di_size = 0;\n\t\tip->i_df.if_u2.if_rdev = xfs_dinode_get_rdev(dip);\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\tcase S_IFDIR:\n\t\tswitch (dip->di_format) {\n\t\tcase XFS_DINODE_FMT_LOCAL:\n\t\t\t/*\n\t\t\t * no local regular files yet\n\t\t\t */\n\t\t\tif (unlikely(S_ISREG(be16_to_cpu(dip->di_mode)))) {\n\t\t\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt inode %Lu (local format for regular file).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(4)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tdi_size = be64_to_cpu(dip->di_size);\n\t\t\tif (unlikely(di_size < 0 ||\n\t\t\t\t     di_size > XFS_DFORK_DSIZE(dip, ip->i_mount))) {\n\t\t\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt inode %Lu (bad size %Ld for local inode).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t\t(long long) di_size);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(5)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tsize = (int)di_size;\n\t\t\terror = xfs_iformat_local(ip, dip, XFS_DATA_FORK, size);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t\terror = xfs_iformat_extents(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_BTREE:\n\t\t\terror = xfs_iformat_btree(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tXFS_ERROR_REPORT(\"xfs_iformat(6)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"xfs_iformat(7)\", XFS_ERRLEVEL_LOW, ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (error) {\n\t\treturn error;\n\t}\n\tif (!XFS_DFORK_Q(dip))\n\t\treturn 0;\n\n\tASSERT(ip->i_afp == NULL);\n\tip->i_afp = kmem_zone_zalloc(xfs_ifork_zone, KM_SLEEP | KM_NOFS);\n\n\tswitch (dip->di_aformat) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tatp = (xfs_attr_shortform_t *)XFS_DFORK_APTR(dip);\n\t\tsize = be16_to_cpu(atp->hdr.totsize);\n\n\t\tif (unlikely(size < sizeof(struct xfs_attr_sf_hdr))) {\n\t\t\txfs_warn(ip->i_mount,\n\t\t\t\t\"corrupt inode %Lu (bad attr fork size %Ld).\",\n\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t(long long) size);\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(8)\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     ip->i_mount, dip);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\terror = xfs_iformat_local(ip, dip, XFS_ATTR_FORK, size);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\terror = xfs_iformat_extents(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_iformat_btree(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tdefault:\n\t\terror = -EFSCORRUPTED;\n\t\tbreak;\n\t}\n\tif (error) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_ifork_zone;",
            "STATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);",
            "STATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);",
            "STATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nkmem_zone_t *xfs_ifork_zone;\nSTATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);\nSTATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);\nSTATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);\n\nint\nxfs_iformat_fork(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip)\n{\n\txfs_attr_shortform_t\t*atp;\n\tint\t\t\tsize;\n\tint\t\t\terror = 0;\n\txfs_fsize_t             di_size;\n\n\tif (unlikely(be32_to_cpu(dip->di_nextents) +\n\t\t     be16_to_cpu(dip->di_anextents) >\n\t\t     be64_to_cpu(dip->di_nblocks))) {\n\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, extent total = %d, nblocks = %Lu.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(int)(be32_to_cpu(dip->di_nextents) +\n\t\t\t      be16_to_cpu(dip->di_anextents)),\n\t\t\t(unsigned long long)\n\t\t\t\tbe64_to_cpu(dip->di_nblocks));\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely(dip->di_forkoff > ip->i_mount->m_sb.sb_inodesize)) {\n\t\txfs_warn(ip->i_mount, \"corrupt dinode %Lu, forkoff = 0x%x.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\tdip->di_forkoff);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely((ip->i_d.di_flags & XFS_DIFLAG_REALTIME) &&\n\t\t     !ip->i_mount->m_rtdev_targp)) {\n\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, has realtime flag set.\",\n\t\t\tip->i_ino);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(realtime)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tswitch (ip->i_d.di_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tif (unlikely(dip->di_format != XFS_DINODE_FMT_DEV)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(3)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t      ip->i_mount, dip);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tip->i_d.di_size = 0;\n\t\tip->i_df.if_u2.if_rdev = xfs_dinode_get_rdev(dip);\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\tcase S_IFDIR:\n\t\tswitch (dip->di_format) {\n\t\tcase XFS_DINODE_FMT_LOCAL:\n\t\t\t/*\n\t\t\t * no local regular files yet\n\t\t\t */\n\t\t\tif (unlikely(S_ISREG(be16_to_cpu(dip->di_mode)))) {\n\t\t\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt inode %Lu (local format for regular file).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(4)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tdi_size = be64_to_cpu(dip->di_size);\n\t\t\tif (unlikely(di_size < 0 ||\n\t\t\t\t     di_size > XFS_DFORK_DSIZE(dip, ip->i_mount))) {\n\t\t\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt inode %Lu (bad size %Ld for local inode).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t\t(long long) di_size);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(5)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tsize = (int)di_size;\n\t\t\terror = xfs_iformat_local(ip, dip, XFS_DATA_FORK, size);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t\terror = xfs_iformat_extents(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_BTREE:\n\t\t\terror = xfs_iformat_btree(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tXFS_ERROR_REPORT(\"xfs_iformat(6)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"xfs_iformat(7)\", XFS_ERRLEVEL_LOW, ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (error) {\n\t\treturn error;\n\t}\n\tif (!XFS_DFORK_Q(dip))\n\t\treturn 0;\n\n\tASSERT(ip->i_afp == NULL);\n\tip->i_afp = kmem_zone_zalloc(xfs_ifork_zone, KM_SLEEP | KM_NOFS);\n\n\tswitch (dip->di_aformat) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tatp = (xfs_attr_shortform_t *)XFS_DFORK_APTR(dip);\n\t\tsize = be16_to_cpu(atp->hdr.totsize);\n\n\t\tif (unlikely(size < sizeof(struct xfs_attr_sf_hdr))) {\n\t\t\txfs_warn(ip->i_mount,\n\t\t\t\t\"corrupt inode %Lu (bad attr fork size %Ld).\",\n\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t(long long) size);\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(8)\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     ip->i_mount, dip);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\terror = xfs_iformat_local(ip, dip, XFS_ATTR_FORK, size);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\terror = xfs_iformat_extents(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_iformat_btree(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tdefault:\n\t\terror = -EFSCORRUPTED;\n\t\tbreak;\n\t}\n\tif (error) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_version >= 3"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dinode_from_disk",
          "args": [
            "&ip->i_d",
            "dip"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "193-238",
          "snippet": "void\nxfs_dinode_from_disk(\n\txfs_icdinode_t\t\t*to,\n\txfs_dinode_t\t\t*from)\n{\n\tto->di_magic = be16_to_cpu(from->di_magic);\n\tto->di_mode = be16_to_cpu(from->di_mode);\n\tto->di_version = from ->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = be16_to_cpu(from->di_onlink);\n\tto->di_uid = be32_to_cpu(from->di_uid);\n\tto->di_gid = be32_to_cpu(from->di_gid);\n\tto->di_nlink = be32_to_cpu(from->di_nlink);\n\tto->di_projid_lo = be16_to_cpu(from->di_projid_lo);\n\tto->di_projid_hi = be16_to_cpu(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\tto->di_flushiter = be16_to_cpu(from->di_flushiter);\n\tto->di_atime.t_sec = be32_to_cpu(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = be32_to_cpu(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = be32_to_cpu(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = be32_to_cpu(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = be32_to_cpu(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = be32_to_cpu(from->di_ctime.t_nsec);\n\tto->di_size = be64_to_cpu(from->di_size);\n\tto->di_nblocks = be64_to_cpu(from->di_nblocks);\n\tto->di_extsize = be32_to_cpu(from->di_extsize);\n\tto->di_nextents = be32_to_cpu(from->di_nextents);\n\tto->di_anextents = be16_to_cpu(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat\t= from->di_aformat;\n\tto->di_dmevmask\t= be32_to_cpu(from->di_dmevmask);\n\tto->di_dmstate\t= be16_to_cpu(from->di_dmstate);\n\tto->di_flags\t= be16_to_cpu(from->di_flags);\n\tto->di_gen\t= be32_to_cpu(from->di_gen);\n\n\tif (to->di_version == 3) {\n\t\tto->di_changecount = be64_to_cpu(from->di_changecount);\n\t\tto->di_crtime.t_sec = be32_to_cpu(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = be32_to_cpu(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = be64_to_cpu(from->di_flags2);\n\t\tto->di_ino = be64_to_cpu(from->di_ino);\n\t\tto->di_lsn = be64_to_cpu(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t}\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dinode_from_disk(\n\txfs_icdinode_t\t\t*to,\n\txfs_dinode_t\t\t*from)\n{\n\tto->di_magic = be16_to_cpu(from->di_magic);\n\tto->di_mode = be16_to_cpu(from->di_mode);\n\tto->di_version = from ->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = be16_to_cpu(from->di_onlink);\n\tto->di_uid = be32_to_cpu(from->di_uid);\n\tto->di_gid = be32_to_cpu(from->di_gid);\n\tto->di_nlink = be32_to_cpu(from->di_nlink);\n\tto->di_projid_lo = be16_to_cpu(from->di_projid_lo);\n\tto->di_projid_hi = be16_to_cpu(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\tto->di_flushiter = be16_to_cpu(from->di_flushiter);\n\tto->di_atime.t_sec = be32_to_cpu(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = be32_to_cpu(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = be32_to_cpu(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = be32_to_cpu(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = be32_to_cpu(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = be32_to_cpu(from->di_ctime.t_nsec);\n\tto->di_size = be64_to_cpu(from->di_size);\n\tto->di_nblocks = be64_to_cpu(from->di_nblocks);\n\tto->di_extsize = be32_to_cpu(from->di_extsize);\n\tto->di_nextents = be32_to_cpu(from->di_nextents);\n\tto->di_anextents = be16_to_cpu(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat\t= from->di_aformat;\n\tto->di_dmevmask\t= be32_to_cpu(from->di_dmevmask);\n\tto->di_dmstate\t= be16_to_cpu(from->di_dmstate);\n\tto->di_flags\t= be16_to_cpu(from->di_flags);\n\tto->di_gen\t= be32_to_cpu(from->di_gen);\n\n\tif (to->di_version == 3) {\n\t\tto->di_changecount = be64_to_cpu(from->di_changecount);\n\t\tto->di_crtime.t_sec = be32_to_cpu(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = be32_to_cpu(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = be64_to_cpu(from->di_flags2);\n\t\tto->di_ino = be64_to_cpu(from->di_ino);\n\t\tto->di_lsn = be64_to_cpu(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_alloc",
          "args": [
            "mp",
            "in_f->ilf_ino"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "46-85",
          "snippet": "struct xfs_inode *\nxfs_inode_alloc(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino)\n{\n\tstruct xfs_inode\t*ip;\n\n\t/*\n\t * if this didn't occur in transactions, we could use\n\t * KM_MAYFAIL and return NULL here on ENOMEM. Set the\n\t * code up to do this anyway.\n\t */\n\tip = kmem_zone_alloc(xfs_inode_zone, KM_SLEEP);\n\tif (!ip)\n\t\treturn NULL;\n\tif (inode_init_always(mp->m_super, VFS_I(ip))) {\n\t\tkmem_zone_free(xfs_inode_zone, ip);\n\t\treturn NULL;\n\t}\n\n\tXFS_STATS_INC(vn_active);\n\tASSERT(atomic_read(&ip->i_pincount) == 0);\n\tASSERT(!spin_is_locked(&ip->i_flags_lock));\n\tASSERT(!xfs_isiflocked(ip));\n\tASSERT(ip->i_ino == 0);\n\n\tmrlock_init(&ip->i_iolock, MRLOCK_BARRIER, \"xfsio\", ip->i_ino);\n\n\t/* initialise the xfs inode */\n\tip->i_ino = ino;\n\tip->i_mount = mp;\n\tmemset(&ip->i_imap, 0, sizeof(struct xfs_imap));\n\tip->i_afp = NULL;\n\tmemset(&ip->i_df, 0, sizeof(xfs_ifork_t));\n\tip->i_flags = 0;\n\tip->i_delayed_blks = 0;\n\tmemset(&ip->i_d, 0, sizeof(xfs_icdinode_t));\n\n\treturn ip;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nstruct xfs_inode *\nxfs_inode_alloc(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino)\n{\n\tstruct xfs_inode\t*ip;\n\n\t/*\n\t * if this didn't occur in transactions, we could use\n\t * KM_MAYFAIL and return NULL here on ENOMEM. Set the\n\t * code up to do this anyway.\n\t */\n\tip = kmem_zone_alloc(xfs_inode_zone, KM_SLEEP);\n\tif (!ip)\n\t\treturn NULL;\n\tif (inode_init_always(mp->m_super, VFS_I(ip))) {\n\t\tkmem_zone_free(xfs_inode_zone, ip);\n\t\treturn NULL;\n\t}\n\n\tXFS_STATS_INC(vn_active);\n\tASSERT(atomic_read(&ip->i_pincount) == 0);\n\tASSERT(!spin_is_locked(&ip->i_flags_lock));\n\tASSERT(!xfs_isiflocked(ip));\n\tASSERT(ip->i_ino == 0);\n\n\tmrlock_init(&ip->i_iolock, MRLOCK_BARRIER, \"xfsio\", ip->i_ino);\n\n\t/* initialise the xfs inode */\n\tip->i_ino = ino;\n\tip->i_mount = mp;\n\tmemset(&ip->i_imap, 0, sizeof(struct xfs_imap));\n\tip->i_afp = NULL;\n\tmemset(&ip->i_df, 0, sizeof(xfs_ifork_t));\n\tip->i_flags = 0;\n\tip->i_delayed_blks = 0;\n\tmemset(&ip->i_d, 0, sizeof(xfs_icdinode_t));\n\n\treturn ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "in_f->ilf_fields & (XFS_ILOG_DOWNER|XFS_ILOG_AOWNER)"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_recover_inode_owner_change(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip,\n\tstruct xfs_inode_log_format *in_f,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\n\tASSERT(in_f->ilf_fields & (XFS_ILOG_DOWNER|XFS_ILOG_AOWNER));\n\n\tip = xfs_inode_alloc(mp, in_f->ilf_ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\t/* instantiate the inode */\n\txfs_dinode_from_disk(&ip->i_d, dip);\n\tASSERT(ip->i_d.di_version >= 3);\n\n\terror = xfs_iformat_fork(ip, dip);\n\tif (error)\n\t\tgoto out_free_ip;\n\n\n\tif (in_f->ilf_fields & XFS_ILOG_DOWNER) {\n\t\tASSERT(in_f->ilf_fields & XFS_ILOG_DBROOT);\n\t\terror = xfs_bmbt_change_owner(NULL, ip, XFS_DATA_FORK,\n\t\t\t\t\t      ip->i_ino, buffer_list);\n\t\tif (error)\n\t\t\tgoto out_free_ip;\n\t}\n\n\tif (in_f->ilf_fields & XFS_ILOG_AOWNER) {\n\t\tASSERT(in_f->ilf_fields & XFS_ILOG_ABROOT);\n\t\terror = xfs_bmbt_change_owner(NULL, ip, XFS_ATTR_FORK,\n\t\t\t\t\t      ip->i_ino, buffer_list);\n\t\tif (error)\n\t\t\tgoto out_free_ip;\n\t}\n\nout_free_ip:\n\txfs_inode_free(ip);\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_recover_buffer_pass2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "2306-2416",
    "snippet": "STATIC int\nxlog_recover_buffer_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\txfs_buf_log_format_t\t*buf_f = item->ri_buf[0].i_addr;\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\tuint\t\t\tbuf_flags;\n\txfs_lsn_t\t\tlsn;\n\n\t/*\n\t * In this pass we only want to recover all the buffers which have\n\t * not been cancelled and are not cancellation buffers themselves.\n\t */\n\tif (xlog_check_buffer_cancelled(log, buf_f->blf_blkno,\n\t\t\tbuf_f->blf_len, buf_f->blf_flags)) {\n\t\ttrace_xfs_log_recover_buf_cancel(log, buf_f);\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_log_recover_buf_recover(log, buf_f);\n\n\tbuf_flags = 0;\n\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF)\n\t\tbuf_flags |= XBF_UNMAPPED;\n\n\tbp = xfs_buf_read(mp->m_ddev_targp, buf_f->blf_blkno, buf_f->blf_len,\n\t\t\t  buf_flags, NULL);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\terror = bp->b_error;\n\tif (error) {\n\t\txfs_buf_ioerror_alert(bp, \"xlog_recover_do..(read#1)\");\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * Recover the buffer only if we get an LSN from it and it's less than\n\t * the lsn of the transaction we are replaying.\n\t *\n\t * Note that we have to be extremely careful of readahead here.\n\t * Readahead does not attach verfiers to the buffers so if we don't\n\t * actually do any replay after readahead because of the LSN we found\n\t * in the buffer if more recent than that current transaction then we\n\t * need to attach the verifier directly. Failure to do so can lead to\n\t * future recovery actions (e.g. EFI and unlinked list recovery) can\n\t * operate on the buffers and they won't get the verifier attached. This\n\t * can lead to blocks on disk having the correct content but a stale\n\t * CRC.\n\t *\n\t * It is safe to assume these clean buffers are currently up to date.\n\t * If the buffer is dirtied by a later transaction being replayed, then\n\t * the verifier will be reset to match whatever recover turns that\n\t * buffer into.\n\t */\n\tlsn = xlog_recover_get_buf_lsn(mp, bp);\n\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) >= 0) {\n\t\txlog_recover_validate_buf_type(mp, bp, buf_f);\n\t\tgoto out_release;\n\t}\n\n\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF) {\n\t\terror = xlog_recover_do_inode_buffer(mp, item, bp, buf_f);\n\t\tif (error)\n\t\t\tgoto out_release;\n\t} else if (buf_f->blf_flags &\n\t\t  (XFS_BLF_UDQUOT_BUF|XFS_BLF_PDQUOT_BUF|XFS_BLF_GDQUOT_BUF)) {\n\t\tbool\tdirty;\n\n\t\tdirty = xlog_recover_do_dquot_buffer(mp, log, item, bp, buf_f);\n\t\tif (!dirty)\n\t\t\tgoto out_release;\n\t} else {\n\t\txlog_recover_do_reg_buffer(mp, item, bp, buf_f);\n\t}\n\n\t/*\n\t * Perform delayed write on the buffer.  Asynchronous writes will be\n\t * slower when taking into account all the buffers to be flushed.\n\t *\n\t * Also make sure that only inode buffers with good sizes stay in\n\t * the buffer cache.  The kernel moves inodes in buffers of 1 block\n\t * or mp->m_inode_cluster_size bytes, whichever is bigger.  The inode\n\t * buffers in the log can be a different size if the log was generated\n\t * by an older kernel using unclustered inode buffers or a newer kernel\n\t * running with a different inode cluster size.  Regardless, if the\n\t * the inode buffer size isn't MAX(blocksize, mp->m_inode_cluster_size)\n\t * for *our* value of mp->m_inode_cluster_size, then we need to keep\n\t * the buffer out of the buffer cache so that the buffer won't\n\t * overlap with future reads of those inodes.\n\t */\n\tif (XFS_DINODE_MAGIC ==\n\t    be16_to_cpu(*((__be16 *)xfs_buf_offset(bp, 0))) &&\n\t    (BBTOB(bp->b_io_length) != MAX(log->l_mp->m_sb.sb_blocksize,\n\t\t\t(__uint32_t)log->l_mp->m_inode_cluster_size))) {\n\t\txfs_buf_stale(bp);\n\t\terror = xfs_bwrite(bp);\n\t} else {\n\t\tASSERT(bp->b_target->bt_mount == mp);\n\t\tbp->b_iodone = xlog_recover_iodone;\n\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t}\n\nout_release:\n\txfs_buf_relse(bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_queue",
          "args": [
            "bp",
            "buffer_list"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1709-1744",
          "snippet": "bool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nbool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_target->bt_mount == mp"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bwrite",
          "args": [
            "bp"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1077-1095",
          "snippet": "int\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_stale",
          "args": [
            "bp"
          ],
          "line": 2405
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "90-113",
          "snippet": "void\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "log->l_mp->m_sb.sb_blocksize",
            "(__uint32_t)log->l_mp->m_inode_cluster_size"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_io_length"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*((__be16 *)xfs_buf_offset(bp, 0))"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_offset",
          "args": [
            "bp",
            "0"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1422-1435",
          "snippet": "xfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_do_reg_buffer",
          "args": [
            "mp",
            "item",
            "bp",
            "buf_f"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_do_reg_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "2158-2237",
          "snippet": "STATIC void\nxlog_recover_do_reg_buffer(\n\tstruct xfs_mount\t*mp,\n\txlog_recover_item_t\t*item,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tint\t\t\ti;\n\tint\t\t\tbit;\n\tint\t\t\tnbits;\n\tint                     error;\n\n\ttrace_xfs_log_recover_buf_reg_buf(mp->m_log, buf_f);\n\n\tbit = 0;\n\ti = 1;  /* 0 is the buf format structure */\n\twhile (1) {\n\t\tbit = xfs_next_bit(buf_f->blf_data_map,\n\t\t\t\t   buf_f->blf_map_size, bit);\n\t\tif (bit == -1)\n\t\t\tbreak;\n\t\tnbits = xfs_contig_bits(buf_f->blf_data_map,\n\t\t\t\t\tbuf_f->blf_map_size, bit);\n\t\tASSERT(nbits > 0);\n\t\tASSERT(item->ri_buf[i].i_addr != NULL);\n\t\tASSERT(item->ri_buf[i].i_len % XFS_BLF_CHUNK == 0);\n\t\tASSERT(BBTOB(bp->b_io_length) >=\n\t\t       ((uint)bit << XFS_BLF_SHIFT) + (nbits << XFS_BLF_SHIFT));\n\n\t\t/*\n\t\t * The dirty regions logged in the buffer, even though\n\t\t * contiguous, may span multiple chunks. This is because the\n\t\t * dirty region may span a physical page boundary in a buffer\n\t\t * and hence be split into two separate vectors for writing into\n\t\t * the log. Hence we need to trim nbits back to the length of\n\t\t * the current region being copied out of the log.\n\t\t */\n\t\tif (item->ri_buf[i].i_len < (nbits << XFS_BLF_SHIFT))\n\t\t\tnbits = item->ri_buf[i].i_len >> XFS_BLF_SHIFT;\n\n\t\t/*\n\t\t * Do a sanity check if this is a dquot buffer. Just checking\n\t\t * the first dquot in the buffer should do. XXXThis is\n\t\t * probably a good thing to do for other buf types also.\n\t\t */\n\t\terror = 0;\n\t\tif (buf_f->blf_flags &\n\t\t   (XFS_BLF_UDQUOT_BUF|XFS_BLF_PDQUOT_BUF|XFS_BLF_GDQUOT_BUF)) {\n\t\t\tif (item->ri_buf[i].i_addr == NULL) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: NULL dquot in %s.\", __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (item->ri_buf[i].i_len < sizeof(xfs_disk_dquot_t)) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: dquot too small (%d) in %s.\",\n\t\t\t\t\titem->ri_buf[i].i_len, __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\terror = xfs_dqcheck(mp, item->ri_buf[i].i_addr,\n\t\t\t\t\t       -1, 0, XFS_QMOPT_DOWARN,\n\t\t\t\t\t       \"dquot_buf_recover\");\n\t\t\tif (error)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tmemcpy(xfs_buf_offset(bp,\n\t\t\t(uint)bit << XFS_BLF_SHIFT),\t/* dest */\n\t\t\titem->ri_buf[i].i_addr,\t\t/* source */\n\t\t\tnbits<<XFS_BLF_SHIFT);\t\t/* length */\n next:\n\t\ti++;\n\t\tbit += nbits;\n\t}\n\n\t/* Shouldn't be any more regions */\n\tASSERT(i == item->ri_total);\n\n\txlog_recover_validate_buf_type(mp, bp, buf_f);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_do_reg_buffer(\n\tstruct xfs_mount\t*mp,\n\txlog_recover_item_t\t*item,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tint\t\t\ti;\n\tint\t\t\tbit;\n\tint\t\t\tnbits;\n\tint                     error;\n\n\ttrace_xfs_log_recover_buf_reg_buf(mp->m_log, buf_f);\n\n\tbit = 0;\n\ti = 1;  /* 0 is the buf format structure */\n\twhile (1) {\n\t\tbit = xfs_next_bit(buf_f->blf_data_map,\n\t\t\t\t   buf_f->blf_map_size, bit);\n\t\tif (bit == -1)\n\t\t\tbreak;\n\t\tnbits = xfs_contig_bits(buf_f->blf_data_map,\n\t\t\t\t\tbuf_f->blf_map_size, bit);\n\t\tASSERT(nbits > 0);\n\t\tASSERT(item->ri_buf[i].i_addr != NULL);\n\t\tASSERT(item->ri_buf[i].i_len % XFS_BLF_CHUNK == 0);\n\t\tASSERT(BBTOB(bp->b_io_length) >=\n\t\t       ((uint)bit << XFS_BLF_SHIFT) + (nbits << XFS_BLF_SHIFT));\n\n\t\t/*\n\t\t * The dirty regions logged in the buffer, even though\n\t\t * contiguous, may span multiple chunks. This is because the\n\t\t * dirty region may span a physical page boundary in a buffer\n\t\t * and hence be split into two separate vectors for writing into\n\t\t * the log. Hence we need to trim nbits back to the length of\n\t\t * the current region being copied out of the log.\n\t\t */\n\t\tif (item->ri_buf[i].i_len < (nbits << XFS_BLF_SHIFT))\n\t\t\tnbits = item->ri_buf[i].i_len >> XFS_BLF_SHIFT;\n\n\t\t/*\n\t\t * Do a sanity check if this is a dquot buffer. Just checking\n\t\t * the first dquot in the buffer should do. XXXThis is\n\t\t * probably a good thing to do for other buf types also.\n\t\t */\n\t\terror = 0;\n\t\tif (buf_f->blf_flags &\n\t\t   (XFS_BLF_UDQUOT_BUF|XFS_BLF_PDQUOT_BUF|XFS_BLF_GDQUOT_BUF)) {\n\t\t\tif (item->ri_buf[i].i_addr == NULL) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: NULL dquot in %s.\", __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (item->ri_buf[i].i_len < sizeof(xfs_disk_dquot_t)) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: dquot too small (%d) in %s.\",\n\t\t\t\t\titem->ri_buf[i].i_len, __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\terror = xfs_dqcheck(mp, item->ri_buf[i].i_addr,\n\t\t\t\t\t       -1, 0, XFS_QMOPT_DOWARN,\n\t\t\t\t\t       \"dquot_buf_recover\");\n\t\t\tif (error)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tmemcpy(xfs_buf_offset(bp,\n\t\t\t(uint)bit << XFS_BLF_SHIFT),\t/* dest */\n\t\t\titem->ri_buf[i].i_addr,\t\t/* source */\n\t\t\tnbits<<XFS_BLF_SHIFT);\t\t/* length */\n next:\n\t\ti++;\n\t\tbit += nbits;\n\t}\n\n\t/* Shouldn't be any more regions */\n\tASSERT(i == item->ri_total);\n\n\txlog_recover_validate_buf_type(mp, bp, buf_f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_do_dquot_buffer",
          "args": [
            "mp",
            "log",
            "item",
            "bp",
            "buf_f"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_do_dquot_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "2248-2281",
          "snippet": "STATIC bool\nxlog_recover_do_dquot_buffer(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item,\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_buf_log_format\t*buf_f)\n{\n\tuint\t\t\ttype;\n\n\ttrace_xfs_log_recover_buf_dquot_buf(log, buf_f);\n\n\t/*\n\t * Filesystems are required to send in quota flags at mount time.\n\t */\n\tif (!mp->m_qflags)\n\t\treturn false;\n\n\ttype = 0;\n\tif (buf_f->blf_flags & XFS_BLF_UDQUOT_BUF)\n\t\ttype |= XFS_DQ_USER;\n\tif (buf_f->blf_flags & XFS_BLF_PDQUOT_BUF)\n\t\ttype |= XFS_DQ_PROJ;\n\tif (buf_f->blf_flags & XFS_BLF_GDQUOT_BUF)\n\t\ttype |= XFS_DQ_GROUP;\n\t/*\n\t * This type of quotas was turned off, so ignore this buffer\n\t */\n\tif (log->l_quotaoffs_flag & type)\n\t\treturn false;\n\n\txlog_recover_do_reg_buffer(mp, item, bp, buf_f);\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC bool\nxlog_recover_do_dquot_buffer(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item,\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_buf_log_format\t*buf_f)\n{\n\tuint\t\t\ttype;\n\n\ttrace_xfs_log_recover_buf_dquot_buf(log, buf_f);\n\n\t/*\n\t * Filesystems are required to send in quota flags at mount time.\n\t */\n\tif (!mp->m_qflags)\n\t\treturn false;\n\n\ttype = 0;\n\tif (buf_f->blf_flags & XFS_BLF_UDQUOT_BUF)\n\t\ttype |= XFS_DQ_USER;\n\tif (buf_f->blf_flags & XFS_BLF_PDQUOT_BUF)\n\t\ttype |= XFS_DQ_PROJ;\n\tif (buf_f->blf_flags & XFS_BLF_GDQUOT_BUF)\n\t\ttype |= XFS_DQ_GROUP;\n\t/*\n\t * This type of quotas was turned off, so ignore this buffer\n\t */\n\tif (log->l_quotaoffs_flag & type)\n\t\treturn false;\n\n\txlog_recover_do_reg_buffer(mp, item, bp, buf_f);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_do_inode_buffer",
          "args": [
            "mp",
            "item",
            "bp",
            "buf_f"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_do_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1703-1807",
          "snippet": "STATIC int\nxlog_recover_do_inode_buffer(\n\tstruct xfs_mount\t*mp,\n\txlog_recover_item_t\t*item,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tint\t\t\ti;\n\tint\t\t\titem_index = 0;\n\tint\t\t\tbit = 0;\n\tint\t\t\tnbits = 0;\n\tint\t\t\treg_buf_offset = 0;\n\tint\t\t\treg_buf_bytes = 0;\n\tint\t\t\tnext_unlinked_offset;\n\tint\t\t\tinodes_per_buf;\n\txfs_agino_t\t\t*logged_nextp;\n\txfs_agino_t\t\t*buffer_nextp;\n\n\ttrace_xfs_log_recover_buf_inode_buf(mp->m_log, buf_f);\n\n\t/*\n\t * Post recovery validation only works properly on CRC enabled\n\t * filesystems.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\n\tinodes_per_buf = BBTOB(bp->b_io_length) >> mp->m_sb.sb_inodelog;\n\tfor (i = 0; i < inodes_per_buf; i++) {\n\t\tnext_unlinked_offset = (i * mp->m_sb.sb_inodesize) +\n\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\twhile (next_unlinked_offset >=\n\t\t       (reg_buf_offset + reg_buf_bytes)) {\n\t\t\t/*\n\t\t\t * The next di_next_unlinked field is beyond\n\t\t\t * the current logged region.  Find the next\n\t\t\t * logged region that contains or is beyond\n\t\t\t * the current di_next_unlinked field.\n\t\t\t */\n\t\t\tbit += nbits;\n\t\t\tbit = xfs_next_bit(buf_f->blf_data_map,\n\t\t\t\t\t   buf_f->blf_map_size, bit);\n\n\t\t\t/*\n\t\t\t * If there are no more logged regions in the\n\t\t\t * buffer, then we're done.\n\t\t\t */\n\t\t\tif (bit == -1)\n\t\t\t\treturn 0;\n\n\t\t\tnbits = xfs_contig_bits(buf_f->blf_data_map,\n\t\t\t\t\t\tbuf_f->blf_map_size, bit);\n\t\t\tASSERT(nbits > 0);\n\t\t\treg_buf_offset = bit << XFS_BLF_SHIFT;\n\t\t\treg_buf_bytes = nbits << XFS_BLF_SHIFT;\n\t\t\titem_index++;\n\t\t}\n\n\t\t/*\n\t\t * If the current logged region starts after the current\n\t\t * di_next_unlinked field, then move on to the next\n\t\t * di_next_unlinked field.\n\t\t */\n\t\tif (next_unlinked_offset < reg_buf_offset)\n\t\t\tcontinue;\n\n\t\tASSERT(item->ri_buf[item_index].i_addr != NULL);\n\t\tASSERT((item->ri_buf[item_index].i_len % XFS_BLF_CHUNK) == 0);\n\t\tASSERT((reg_buf_offset + reg_buf_bytes) <=\n\t\t\t\t\t\t\tBBTOB(bp->b_io_length));\n\n\t\t/*\n\t\t * The current logged region contains a copy of the\n\t\t * current di_next_unlinked field.  Extract its value\n\t\t * and copy it to the buffer copy.\n\t\t */\n\t\tlogged_nextp = item->ri_buf[item_index].i_addr +\n\t\t\t\tnext_unlinked_offset - reg_buf_offset;\n\t\tif (unlikely(*logged_nextp == 0)) {\n\t\t\txfs_alert(mp,\n\t\t\"Bad inode buffer log record (ptr = 0x%p, bp = 0x%p). \"\n\t\t\"Trying to replay bad (0) inode di_next_unlinked field.\",\n\t\t\t\titem, bp);\n\t\t\tXFS_ERROR_REPORT(\"xlog_recover_do_inode_buf\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tbuffer_nextp = (xfs_agino_t *)xfs_buf_offset(bp,\n\t\t\t\t\t      next_unlinked_offset);\n\t\t*buffer_nextp = *logged_nextp;\n\n\t\t/*\n\t\t * If necessary, recalculate the CRC in the on-disk inode. We\n\t\t * have to leave the inode in a consistent state for whoever\n\t\t * reads it next....\n\t\t */\n\t\txfs_dinode_calc_crc(mp, (struct xfs_dinode *)\n\t\t\t\txfs_buf_offset(bp, i * mp->m_sb.sb_inodesize));\n\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_do_inode_buffer(\n\tstruct xfs_mount\t*mp,\n\txlog_recover_item_t\t*item,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tint\t\t\ti;\n\tint\t\t\titem_index = 0;\n\tint\t\t\tbit = 0;\n\tint\t\t\tnbits = 0;\n\tint\t\t\treg_buf_offset = 0;\n\tint\t\t\treg_buf_bytes = 0;\n\tint\t\t\tnext_unlinked_offset;\n\tint\t\t\tinodes_per_buf;\n\txfs_agino_t\t\t*logged_nextp;\n\txfs_agino_t\t\t*buffer_nextp;\n\n\ttrace_xfs_log_recover_buf_inode_buf(mp->m_log, buf_f);\n\n\t/*\n\t * Post recovery validation only works properly on CRC enabled\n\t * filesystems.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\n\tinodes_per_buf = BBTOB(bp->b_io_length) >> mp->m_sb.sb_inodelog;\n\tfor (i = 0; i < inodes_per_buf; i++) {\n\t\tnext_unlinked_offset = (i * mp->m_sb.sb_inodesize) +\n\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\twhile (next_unlinked_offset >=\n\t\t       (reg_buf_offset + reg_buf_bytes)) {\n\t\t\t/*\n\t\t\t * The next di_next_unlinked field is beyond\n\t\t\t * the current logged region.  Find the next\n\t\t\t * logged region that contains or is beyond\n\t\t\t * the current di_next_unlinked field.\n\t\t\t */\n\t\t\tbit += nbits;\n\t\t\tbit = xfs_next_bit(buf_f->blf_data_map,\n\t\t\t\t\t   buf_f->blf_map_size, bit);\n\n\t\t\t/*\n\t\t\t * If there are no more logged regions in the\n\t\t\t * buffer, then we're done.\n\t\t\t */\n\t\t\tif (bit == -1)\n\t\t\t\treturn 0;\n\n\t\t\tnbits = xfs_contig_bits(buf_f->blf_data_map,\n\t\t\t\t\t\tbuf_f->blf_map_size, bit);\n\t\t\tASSERT(nbits > 0);\n\t\t\treg_buf_offset = bit << XFS_BLF_SHIFT;\n\t\t\treg_buf_bytes = nbits << XFS_BLF_SHIFT;\n\t\t\titem_index++;\n\t\t}\n\n\t\t/*\n\t\t * If the current logged region starts after the current\n\t\t * di_next_unlinked field, then move on to the next\n\t\t * di_next_unlinked field.\n\t\t */\n\t\tif (next_unlinked_offset < reg_buf_offset)\n\t\t\tcontinue;\n\n\t\tASSERT(item->ri_buf[item_index].i_addr != NULL);\n\t\tASSERT((item->ri_buf[item_index].i_len % XFS_BLF_CHUNK) == 0);\n\t\tASSERT((reg_buf_offset + reg_buf_bytes) <=\n\t\t\t\t\t\t\tBBTOB(bp->b_io_length));\n\n\t\t/*\n\t\t * The current logged region contains a copy of the\n\t\t * current di_next_unlinked field.  Extract its value\n\t\t * and copy it to the buffer copy.\n\t\t */\n\t\tlogged_nextp = item->ri_buf[item_index].i_addr +\n\t\t\t\tnext_unlinked_offset - reg_buf_offset;\n\t\tif (unlikely(*logged_nextp == 0)) {\n\t\t\txfs_alert(mp,\n\t\t\"Bad inode buffer log record (ptr = 0x%p, bp = 0x%p). \"\n\t\t\"Trying to replay bad (0) inode di_next_unlinked field.\",\n\t\t\t\titem, bp);\n\t\t\tXFS_ERROR_REPORT(\"xlog_recover_do_inode_buf\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tbuffer_nextp = (xfs_agino_t *)xfs_buf_offset(bp,\n\t\t\t\t\t      next_unlinked_offset);\n\t\t*buffer_nextp = *logged_nextp;\n\n\t\t/*\n\t\t * If necessary, recalculate the CRC in the on-disk inode. We\n\t\t * have to leave the inode in a consistent state for whoever\n\t\t * reads it next....\n\t\t */\n\t\txfs_dinode_calc_crc(mp, (struct xfs_dinode *)\n\t\t\t\txfs_buf_offset(bp, i * mp->m_sb.sb_inodesize));\n\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_validate_buf_type",
          "args": [
            "mp",
            "bp",
            "buf_f"
          ],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_validate_buf_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1960-2150",
          "snippet": "static void\nxlog_recover_validate_buf_type(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\t__uint32_t\t\tmagic32;\n\t__uint16_t\t\tmagic16;\n\t__uint16_t\t\tmagicda;\n\n\t/*\n\t * We can only do post recovery validation on items on CRC enabled\n\t * fielsystems as we need to know when the buffer was written to be able\n\t * to determine if we should have replayed the item. If we replay old\n\t * metadata over a newer buffer, then it will enter a temporarily\n\t * inconsistent state resulting in verification failures. Hence for now\n\t * just avoid the verification stage for non-crc filesystems\n\t */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tmagic32 = be32_to_cpu(*(__be32 *)bp->b_addr);\n\tmagic16 = be16_to_cpu(*(__be16*)bp->b_addr);\n\tmagicda = be16_to_cpu(info->magic);\n\tswitch (xfs_blft_from_flags(buf_f)) {\n\tcase XFS_BLFT_BTREE_BUF:\n\t\tswitch (magic32) {\n\t\tcase XFS_ABTB_CRC_MAGIC:\n\t\tcase XFS_ABTC_CRC_MAGIC:\n\t\tcase XFS_ABTB_MAGIC:\n\t\tcase XFS_ABTC_MAGIC:\n\t\t\tbp->b_ops = &xfs_allocbt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_IBT_CRC_MAGIC:\n\t\tcase XFS_FIBT_CRC_MAGIC:\n\t\tcase XFS_IBT_MAGIC:\n\t\tcase XFS_FIBT_MAGIC:\n\t\t\tbp->b_ops = &xfs_inobt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_BMAP_CRC_MAGIC:\n\t\tcase XFS_BMAP_MAGIC:\n\t\t\tbp->b_ops = &xfs_bmbt_buf_ops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txfs_warn(mp, \"Bad btree block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase XFS_BLFT_AGF_BUF:\n\t\tif (magic32 != XFS_AGF_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGF block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGFL_BUF:\n\t\tif (magic32 != XFS_AGFL_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGFL block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agfl_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGI_BUF:\n\t\tif (magic32 != XFS_AGI_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGI block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agi_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_UDQUOT_BUF:\n\tcase XFS_BLFT_PDQUOT_BUF:\n\tcase XFS_BLFT_GDQUOT_BUF:\n#ifdef CONFIG_XFS_QUOTA\n\t\tif (magic16 != XFS_DQUOT_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad DQUOT block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dquot_buf_ops;\n#else\n\t\txfs_alert(mp,\n\t\"Trying to recover dquots without QUOTA support built in!\");\n\t\tASSERT(0);\n#endif\n\t\tbreak;\n\tcase XFS_BLFT_DINO_BUF:\n\t\tif (magic16 != XFS_DINODE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad INODE block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SYMLINK_BUF:\n\t\tif (magic32 != XFS_SYMLINK_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad symlink block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_symlink_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_BLOCK_BUF:\n\t\tif (magic32 != XFS_DIR2_BLOCK_MAGIC &&\n\t\t    magic32 != XFS_DIR3_BLOCK_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_DATA_BUF:\n\t\tif (magic32 != XFS_DIR2_DATA_MAGIC &&\n\t\t    magic32 != XFS_DIR3_DATA_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir data magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_FREE_BUF:\n\t\tif (magic32 != XFS_DIR2_FREE_MAGIC &&\n\t\t    magic32 != XFS_DIR3_FREE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir3 free magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAF1_BUF:\n\t\tif (magicda != XFS_DIR2_LEAF1_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAF1_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir leaf1 magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAFN_BUF:\n\t\tif (magicda != XFS_DIR2_LEAFN_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAFN_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir leafn magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DA_NODE_BUF:\n\t\tif (magicda != XFS_DA_NODE_MAGIC &&\n\t\t    magicda != XFS_DA3_NODE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad da node magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_da3_node_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_LEAF_BUF:\n\t\tif (magicda != XFS_ATTR_LEAF_MAGIC &&\n\t\t    magicda != XFS_ATTR3_LEAF_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad attr leaf magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_RMT_BUF:\n\t\tif (magic32 != XFS_ATTR3_RMT_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad attr remote magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SB_BUF:\n\t\tif (magic32 != XFS_SB_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad SB block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_sb_buf_ops;\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(mp, \"Unknown buffer type %d!\",\n\t\t\t xfs_blft_from_flags(buf_f));\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxlog_recover_validate_buf_type(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\t__uint32_t\t\tmagic32;\n\t__uint16_t\t\tmagic16;\n\t__uint16_t\t\tmagicda;\n\n\t/*\n\t * We can only do post recovery validation on items on CRC enabled\n\t * fielsystems as we need to know when the buffer was written to be able\n\t * to determine if we should have replayed the item. If we replay old\n\t * metadata over a newer buffer, then it will enter a temporarily\n\t * inconsistent state resulting in verification failures. Hence for now\n\t * just avoid the verification stage for non-crc filesystems\n\t */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tmagic32 = be32_to_cpu(*(__be32 *)bp->b_addr);\n\tmagic16 = be16_to_cpu(*(__be16*)bp->b_addr);\n\tmagicda = be16_to_cpu(info->magic);\n\tswitch (xfs_blft_from_flags(buf_f)) {\n\tcase XFS_BLFT_BTREE_BUF:\n\t\tswitch (magic32) {\n\t\tcase XFS_ABTB_CRC_MAGIC:\n\t\tcase XFS_ABTC_CRC_MAGIC:\n\t\tcase XFS_ABTB_MAGIC:\n\t\tcase XFS_ABTC_MAGIC:\n\t\t\tbp->b_ops = &xfs_allocbt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_IBT_CRC_MAGIC:\n\t\tcase XFS_FIBT_CRC_MAGIC:\n\t\tcase XFS_IBT_MAGIC:\n\t\tcase XFS_FIBT_MAGIC:\n\t\t\tbp->b_ops = &xfs_inobt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_BMAP_CRC_MAGIC:\n\t\tcase XFS_BMAP_MAGIC:\n\t\t\tbp->b_ops = &xfs_bmbt_buf_ops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txfs_warn(mp, \"Bad btree block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase XFS_BLFT_AGF_BUF:\n\t\tif (magic32 != XFS_AGF_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGF block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGFL_BUF:\n\t\tif (magic32 != XFS_AGFL_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGFL block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agfl_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGI_BUF:\n\t\tif (magic32 != XFS_AGI_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGI block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agi_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_UDQUOT_BUF:\n\tcase XFS_BLFT_PDQUOT_BUF:\n\tcase XFS_BLFT_GDQUOT_BUF:\n#ifdef CONFIG_XFS_QUOTA\n\t\tif (magic16 != XFS_DQUOT_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad DQUOT block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dquot_buf_ops;\n#else\n\t\txfs_alert(mp,\n\t\"Trying to recover dquots without QUOTA support built in!\");\n\t\tASSERT(0);\n#endif\n\t\tbreak;\n\tcase XFS_BLFT_DINO_BUF:\n\t\tif (magic16 != XFS_DINODE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad INODE block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SYMLINK_BUF:\n\t\tif (magic32 != XFS_SYMLINK_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad symlink block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_symlink_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_BLOCK_BUF:\n\t\tif (magic32 != XFS_DIR2_BLOCK_MAGIC &&\n\t\t    magic32 != XFS_DIR3_BLOCK_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_DATA_BUF:\n\t\tif (magic32 != XFS_DIR2_DATA_MAGIC &&\n\t\t    magic32 != XFS_DIR3_DATA_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir data magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_FREE_BUF:\n\t\tif (magic32 != XFS_DIR2_FREE_MAGIC &&\n\t\t    magic32 != XFS_DIR3_FREE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir3 free magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAF1_BUF:\n\t\tif (magicda != XFS_DIR2_LEAF1_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAF1_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir leaf1 magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAFN_BUF:\n\t\tif (magicda != XFS_DIR2_LEAFN_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAFN_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir leafn magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DA_NODE_BUF:\n\t\tif (magicda != XFS_DA_NODE_MAGIC &&\n\t\t    magicda != XFS_DA3_NODE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad da node magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_da3_node_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_LEAF_BUF:\n\t\tif (magicda != XFS_ATTR_LEAF_MAGIC &&\n\t\t    magicda != XFS_ATTR3_LEAF_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad attr leaf magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_RMT_BUF:\n\t\tif (magic32 != XFS_ATTR3_RMT_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad attr remote magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SB_BUF:\n\t\tif (magic32 != XFS_SB_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad SB block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_sb_buf_ops;\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(mp, \"Unknown buffer type %d!\",\n\t\t\t xfs_blft_from_flags(buf_f));\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "lsn",
            "current_lsn"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_recover_get_buf_lsn",
          "args": [
            "mp",
            "bp"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_get_buf_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1829-1950",
          "snippet": "static xfs_lsn_t\nxlog_recover_get_buf_lsn(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\t__uint32_t\t\tmagic32;\n\t__uint16_t\t\tmagic16;\n\t__uint16_t\t\tmagicda;\n\tvoid\t\t\t*blk = bp->b_addr;\n\tuuid_t\t\t\t*uuid;\n\txfs_lsn_t\t\tlsn = -1;\n\n\t/* v4 filesystems always recover immediately */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\tgoto recover_immediately;\n\n\tmagic32 = be32_to_cpu(*(__be32 *)blk);\n\tswitch (magic32) {\n\tcase XFS_ABTB_CRC_MAGIC:\n\tcase XFS_ABTC_CRC_MAGIC:\n\tcase XFS_ABTB_MAGIC:\n\tcase XFS_ABTC_MAGIC:\n\tcase XFS_IBT_CRC_MAGIC:\n\tcase XFS_IBT_MAGIC: {\n\t\tstruct xfs_btree_block *btb = blk;\n\n\t\tlsn = be64_to_cpu(btb->bb_u.s.bb_lsn);\n\t\tuuid = &btb->bb_u.s.bb_uuid;\n\t\tbreak;\n\t}\n\tcase XFS_BMAP_CRC_MAGIC:\n\tcase XFS_BMAP_MAGIC: {\n\t\tstruct xfs_btree_block *btb = blk;\n\n\t\tlsn = be64_to_cpu(btb->bb_u.l.bb_lsn);\n\t\tuuid = &btb->bb_u.l.bb_uuid;\n\t\tbreak;\n\t}\n\tcase XFS_AGF_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agf *)blk)->agf_lsn);\n\t\tuuid = &((struct xfs_agf *)blk)->agf_uuid;\n\t\tbreak;\n\tcase XFS_AGFL_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agfl *)blk)->agfl_lsn);\n\t\tuuid = &((struct xfs_agfl *)blk)->agfl_uuid;\n\t\tbreak;\n\tcase XFS_AGI_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agi *)blk)->agi_lsn);\n\t\tuuid = &((struct xfs_agi *)blk)->agi_uuid;\n\t\tbreak;\n\tcase XFS_SYMLINK_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dsymlink_hdr *)blk)->sl_lsn);\n\t\tuuid = &((struct xfs_dsymlink_hdr *)blk)->sl_uuid;\n\t\tbreak;\n\tcase XFS_DIR3_BLOCK_MAGIC:\n\tcase XFS_DIR3_DATA_MAGIC:\n\tcase XFS_DIR3_FREE_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dir3_blk_hdr *)blk)->lsn);\n\t\tuuid = &((struct xfs_dir3_blk_hdr *)blk)->uuid;\n\t\tbreak;\n\tcase XFS_ATTR3_RMT_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_attr3_rmt_hdr *)blk)->rm_lsn);\n\t\tuuid = &((struct xfs_attr3_rmt_hdr *)blk)->rm_uuid;\n\t\tbreak;\n\tcase XFS_SB_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dsb *)blk)->sb_lsn);\n\t\tuuid = &((struct xfs_dsb *)blk)->sb_uuid;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (lsn != (xfs_lsn_t)-1) {\n\t\tif (!uuid_equal(&mp->m_sb.sb_uuid, uuid))\n\t\t\tgoto recover_immediately;\n\t\treturn lsn;\n\t}\n\n\tmagicda = be16_to_cpu(((struct xfs_da_blkinfo *)blk)->magic);\n\tswitch (magicda) {\n\tcase XFS_DIR3_LEAF1_MAGIC:\n\tcase XFS_DIR3_LEAFN_MAGIC:\n\tcase XFS_DA3_NODE_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_da3_blkinfo *)blk)->lsn);\n\t\tuuid = &((struct xfs_da3_blkinfo *)blk)->uuid;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (lsn != (xfs_lsn_t)-1) {\n\t\tif (!uuid_equal(&mp->m_sb.sb_uuid, uuid))\n\t\t\tgoto recover_immediately;\n\t\treturn lsn;\n\t}\n\n\t/*\n\t * We do individual object checks on dquot and inode buffers as they\n\t * have their own individual LSN records. Also, we could have a stale\n\t * buffer here, so we have to at least recognise these buffer types.\n\t *\n\t * A notd complexity here is inode unlinked list processing - it logs\n\t * the inode directly in the buffer, but we don't know which inodes have\n\t * been modified, and there is no global buffer LSN. Hence we need to\n\t * recover all inode buffer types immediately. This problem will be\n\t * fixed by logical logging of the unlinked list modifications.\n\t */\n\tmagic16 = be16_to_cpu(*(__be16 *)blk);\n\tswitch (magic16) {\n\tcase XFS_DQUOT_MAGIC:\n\tcase XFS_DINODE_MAGIC:\n\t\tgoto recover_immediately;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* unknown buffer contents, recover immediately */\n\nrecover_immediately:\n\treturn (xfs_lsn_t)-1;\n\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nstatic xfs_lsn_t\nxlog_recover_get_buf_lsn(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\t__uint32_t\t\tmagic32;\n\t__uint16_t\t\tmagic16;\n\t__uint16_t\t\tmagicda;\n\tvoid\t\t\t*blk = bp->b_addr;\n\tuuid_t\t\t\t*uuid;\n\txfs_lsn_t\t\tlsn = -1;\n\n\t/* v4 filesystems always recover immediately */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\tgoto recover_immediately;\n\n\tmagic32 = be32_to_cpu(*(__be32 *)blk);\n\tswitch (magic32) {\n\tcase XFS_ABTB_CRC_MAGIC:\n\tcase XFS_ABTC_CRC_MAGIC:\n\tcase XFS_ABTB_MAGIC:\n\tcase XFS_ABTC_MAGIC:\n\tcase XFS_IBT_CRC_MAGIC:\n\tcase XFS_IBT_MAGIC: {\n\t\tstruct xfs_btree_block *btb = blk;\n\n\t\tlsn = be64_to_cpu(btb->bb_u.s.bb_lsn);\n\t\tuuid = &btb->bb_u.s.bb_uuid;\n\t\tbreak;\n\t}\n\tcase XFS_BMAP_CRC_MAGIC:\n\tcase XFS_BMAP_MAGIC: {\n\t\tstruct xfs_btree_block *btb = blk;\n\n\t\tlsn = be64_to_cpu(btb->bb_u.l.bb_lsn);\n\t\tuuid = &btb->bb_u.l.bb_uuid;\n\t\tbreak;\n\t}\n\tcase XFS_AGF_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agf *)blk)->agf_lsn);\n\t\tuuid = &((struct xfs_agf *)blk)->agf_uuid;\n\t\tbreak;\n\tcase XFS_AGFL_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agfl *)blk)->agfl_lsn);\n\t\tuuid = &((struct xfs_agfl *)blk)->agfl_uuid;\n\t\tbreak;\n\tcase XFS_AGI_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agi *)blk)->agi_lsn);\n\t\tuuid = &((struct xfs_agi *)blk)->agi_uuid;\n\t\tbreak;\n\tcase XFS_SYMLINK_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dsymlink_hdr *)blk)->sl_lsn);\n\t\tuuid = &((struct xfs_dsymlink_hdr *)blk)->sl_uuid;\n\t\tbreak;\n\tcase XFS_DIR3_BLOCK_MAGIC:\n\tcase XFS_DIR3_DATA_MAGIC:\n\tcase XFS_DIR3_FREE_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dir3_blk_hdr *)blk)->lsn);\n\t\tuuid = &((struct xfs_dir3_blk_hdr *)blk)->uuid;\n\t\tbreak;\n\tcase XFS_ATTR3_RMT_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_attr3_rmt_hdr *)blk)->rm_lsn);\n\t\tuuid = &((struct xfs_attr3_rmt_hdr *)blk)->rm_uuid;\n\t\tbreak;\n\tcase XFS_SB_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dsb *)blk)->sb_lsn);\n\t\tuuid = &((struct xfs_dsb *)blk)->sb_uuid;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (lsn != (xfs_lsn_t)-1) {\n\t\tif (!uuid_equal(&mp->m_sb.sb_uuid, uuid))\n\t\t\tgoto recover_immediately;\n\t\treturn lsn;\n\t}\n\n\tmagicda = be16_to_cpu(((struct xfs_da_blkinfo *)blk)->magic);\n\tswitch (magicda) {\n\tcase XFS_DIR3_LEAF1_MAGIC:\n\tcase XFS_DIR3_LEAFN_MAGIC:\n\tcase XFS_DA3_NODE_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_da3_blkinfo *)blk)->lsn);\n\t\tuuid = &((struct xfs_da3_blkinfo *)blk)->uuid;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (lsn != (xfs_lsn_t)-1) {\n\t\tif (!uuid_equal(&mp->m_sb.sb_uuid, uuid))\n\t\t\tgoto recover_immediately;\n\t\treturn lsn;\n\t}\n\n\t/*\n\t * We do individual object checks on dquot and inode buffers as they\n\t * have their own individual LSN records. Also, we could have a stale\n\t * buffer here, so we have to at least recognise these buffer types.\n\t *\n\t * A notd complexity here is inode unlinked list processing - it logs\n\t * the inode directly in the buffer, but we don't know which inodes have\n\t * been modified, and there is no global buffer LSN. Hence we need to\n\t * recover all inode buffer types immediately. This problem will be\n\t * fixed by logical logging of the unlinked list modifications.\n\t */\n\tmagic16 = be16_to_cpu(*(__be16 *)blk);\n\tswitch (magic16) {\n\tcase XFS_DQUOT_MAGIC:\n\tcase XFS_DINODE_MAGIC:\n\t\tgoto recover_immediately;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* unknown buffer contents, recover immediately */\n\nrecover_immediately:\n\treturn (xfs_lsn_t)-1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror_alert",
          "args": [
            "bp",
            "\"xlog_recover_do..(read#1)\""
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_read",
          "args": [
            "mp->m_ddev_targp",
            "buf_f->blf_blkno",
            "buf_f->blf_len",
            "buf_flags",
            "NULL"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "244-254",
          "snippet": "static inline struct xfs_buf *\nxfs_buf_read(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_read_map(target, &map, 1, flags, ops);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline struct xfs_buf *\nxfs_buf_read(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_read_map(target, &map, 1, flags, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_buf_recover",
          "args": [
            "log",
            "buf_f"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_buf_cancel",
          "args": [
            "log",
            "buf_f"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_check_buffer_cancelled",
          "args": [
            "log",
            "buf_f->blf_blkno",
            "buf_f->blf_len",
            "buf_f->blf_flags"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_check_buffer_cancelled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1663-1689",
          "snippet": "STATIC int\nxlog_check_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tbcp = xlog_peek_buffer_cancelled(log, blkno, len, flags);\n\tif (!bcp)\n\t\treturn 0;\n\n\t/*\n\t * We've go a match, so return 1 so that the recovery of this buffer\n\t * is cancelled.  If this buffer is actually a buffer cancel log\n\t * item, then decrement the refcount on the one in the table and\n\t * remove it if this is the last reference.\n\t */\n\tif (flags & XFS_BLF_CANCEL) {\n\t\tif (--bcp->bc_refcount == 0) {\n\t\t\tlist_del(&bcp->bc_list);\n\t\t\tkmem_free(bcp);\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_check_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tbcp = xlog_peek_buffer_cancelled(log, blkno, len, flags);\n\tif (!bcp)\n\t\treturn 0;\n\n\t/*\n\t * We've go a match, so return 1 so that the recovery of this buffer\n\t * is cancelled.  If this buffer is actually a buffer cancel log\n\t * item, then decrement the refcount on the one in the table and\n\t * remove it if this is the last reference.\n\t */\n\tif (flags & XFS_BLF_CANCEL) {\n\t\tif (--bcp->bc_refcount == 0) {\n\t\t\tlist_del(&bcp->bc_list);\n\t\t\tkmem_free(bcp);\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_buffer_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\txfs_buf_log_format_t\t*buf_f = item->ri_buf[0].i_addr;\n\txfs_mount_t\t\t*mp = log->l_mp;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\tuint\t\t\tbuf_flags;\n\txfs_lsn_t\t\tlsn;\n\n\t/*\n\t * In this pass we only want to recover all the buffers which have\n\t * not been cancelled and are not cancellation buffers themselves.\n\t */\n\tif (xlog_check_buffer_cancelled(log, buf_f->blf_blkno,\n\t\t\tbuf_f->blf_len, buf_f->blf_flags)) {\n\t\ttrace_xfs_log_recover_buf_cancel(log, buf_f);\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_log_recover_buf_recover(log, buf_f);\n\n\tbuf_flags = 0;\n\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF)\n\t\tbuf_flags |= XBF_UNMAPPED;\n\n\tbp = xfs_buf_read(mp->m_ddev_targp, buf_f->blf_blkno, buf_f->blf_len,\n\t\t\t  buf_flags, NULL);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\terror = bp->b_error;\n\tif (error) {\n\t\txfs_buf_ioerror_alert(bp, \"xlog_recover_do..(read#1)\");\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * Recover the buffer only if we get an LSN from it and it's less than\n\t * the lsn of the transaction we are replaying.\n\t *\n\t * Note that we have to be extremely careful of readahead here.\n\t * Readahead does not attach verfiers to the buffers so if we don't\n\t * actually do any replay after readahead because of the LSN we found\n\t * in the buffer if more recent than that current transaction then we\n\t * need to attach the verifier directly. Failure to do so can lead to\n\t * future recovery actions (e.g. EFI and unlinked list recovery) can\n\t * operate on the buffers and they won't get the verifier attached. This\n\t * can lead to blocks on disk having the correct content but a stale\n\t * CRC.\n\t *\n\t * It is safe to assume these clean buffers are currently up to date.\n\t * If the buffer is dirtied by a later transaction being replayed, then\n\t * the verifier will be reset to match whatever recover turns that\n\t * buffer into.\n\t */\n\tlsn = xlog_recover_get_buf_lsn(mp, bp);\n\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) >= 0) {\n\t\txlog_recover_validate_buf_type(mp, bp, buf_f);\n\t\tgoto out_release;\n\t}\n\n\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF) {\n\t\terror = xlog_recover_do_inode_buffer(mp, item, bp, buf_f);\n\t\tif (error)\n\t\t\tgoto out_release;\n\t} else if (buf_f->blf_flags &\n\t\t  (XFS_BLF_UDQUOT_BUF|XFS_BLF_PDQUOT_BUF|XFS_BLF_GDQUOT_BUF)) {\n\t\tbool\tdirty;\n\n\t\tdirty = xlog_recover_do_dquot_buffer(mp, log, item, bp, buf_f);\n\t\tif (!dirty)\n\t\t\tgoto out_release;\n\t} else {\n\t\txlog_recover_do_reg_buffer(mp, item, bp, buf_f);\n\t}\n\n\t/*\n\t * Perform delayed write on the buffer.  Asynchronous writes will be\n\t * slower when taking into account all the buffers to be flushed.\n\t *\n\t * Also make sure that only inode buffers with good sizes stay in\n\t * the buffer cache.  The kernel moves inodes in buffers of 1 block\n\t * or mp->m_inode_cluster_size bytes, whichever is bigger.  The inode\n\t * buffers in the log can be a different size if the log was generated\n\t * by an older kernel using unclustered inode buffers or a newer kernel\n\t * running with a different inode cluster size.  Regardless, if the\n\t * the inode buffer size isn't MAX(blocksize, mp->m_inode_cluster_size)\n\t * for *our* value of mp->m_inode_cluster_size, then we need to keep\n\t * the buffer out of the buffer cache so that the buffer won't\n\t * overlap with future reads of those inodes.\n\t */\n\tif (XFS_DINODE_MAGIC ==\n\t    be16_to_cpu(*((__be16 *)xfs_buf_offset(bp, 0))) &&\n\t    (BBTOB(bp->b_io_length) != MAX(log->l_mp->m_sb.sb_blocksize,\n\t\t\t(__uint32_t)log->l_mp->m_inode_cluster_size))) {\n\t\txfs_buf_stale(bp);\n\t\terror = xfs_bwrite(bp);\n\t} else {\n\t\tASSERT(bp->b_target->bt_mount == mp);\n\t\tbp->b_iodone = xlog_recover_iodone;\n\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t}\n\nout_release:\n\txfs_buf_relse(bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_recover_do_dquot_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "2248-2281",
    "snippet": "STATIC bool\nxlog_recover_do_dquot_buffer(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item,\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_buf_log_format\t*buf_f)\n{\n\tuint\t\t\ttype;\n\n\ttrace_xfs_log_recover_buf_dquot_buf(log, buf_f);\n\n\t/*\n\t * Filesystems are required to send in quota flags at mount time.\n\t */\n\tif (!mp->m_qflags)\n\t\treturn false;\n\n\ttype = 0;\n\tif (buf_f->blf_flags & XFS_BLF_UDQUOT_BUF)\n\t\ttype |= XFS_DQ_USER;\n\tif (buf_f->blf_flags & XFS_BLF_PDQUOT_BUF)\n\t\ttype |= XFS_DQ_PROJ;\n\tif (buf_f->blf_flags & XFS_BLF_GDQUOT_BUF)\n\t\ttype |= XFS_DQ_GROUP;\n\t/*\n\t * This type of quotas was turned off, so ignore this buffer\n\t */\n\tif (log->l_quotaoffs_flag & type)\n\t\treturn false;\n\n\txlog_recover_do_reg_buffer(mp, item, bp, buf_f);\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_recover_do_reg_buffer",
          "args": [
            "mp",
            "item",
            "bp",
            "buf_f"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_do_reg_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "2158-2237",
          "snippet": "STATIC void\nxlog_recover_do_reg_buffer(\n\tstruct xfs_mount\t*mp,\n\txlog_recover_item_t\t*item,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tint\t\t\ti;\n\tint\t\t\tbit;\n\tint\t\t\tnbits;\n\tint                     error;\n\n\ttrace_xfs_log_recover_buf_reg_buf(mp->m_log, buf_f);\n\n\tbit = 0;\n\ti = 1;  /* 0 is the buf format structure */\n\twhile (1) {\n\t\tbit = xfs_next_bit(buf_f->blf_data_map,\n\t\t\t\t   buf_f->blf_map_size, bit);\n\t\tif (bit == -1)\n\t\t\tbreak;\n\t\tnbits = xfs_contig_bits(buf_f->blf_data_map,\n\t\t\t\t\tbuf_f->blf_map_size, bit);\n\t\tASSERT(nbits > 0);\n\t\tASSERT(item->ri_buf[i].i_addr != NULL);\n\t\tASSERT(item->ri_buf[i].i_len % XFS_BLF_CHUNK == 0);\n\t\tASSERT(BBTOB(bp->b_io_length) >=\n\t\t       ((uint)bit << XFS_BLF_SHIFT) + (nbits << XFS_BLF_SHIFT));\n\n\t\t/*\n\t\t * The dirty regions logged in the buffer, even though\n\t\t * contiguous, may span multiple chunks. This is because the\n\t\t * dirty region may span a physical page boundary in a buffer\n\t\t * and hence be split into two separate vectors for writing into\n\t\t * the log. Hence we need to trim nbits back to the length of\n\t\t * the current region being copied out of the log.\n\t\t */\n\t\tif (item->ri_buf[i].i_len < (nbits << XFS_BLF_SHIFT))\n\t\t\tnbits = item->ri_buf[i].i_len >> XFS_BLF_SHIFT;\n\n\t\t/*\n\t\t * Do a sanity check if this is a dquot buffer. Just checking\n\t\t * the first dquot in the buffer should do. XXXThis is\n\t\t * probably a good thing to do for other buf types also.\n\t\t */\n\t\terror = 0;\n\t\tif (buf_f->blf_flags &\n\t\t   (XFS_BLF_UDQUOT_BUF|XFS_BLF_PDQUOT_BUF|XFS_BLF_GDQUOT_BUF)) {\n\t\t\tif (item->ri_buf[i].i_addr == NULL) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: NULL dquot in %s.\", __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (item->ri_buf[i].i_len < sizeof(xfs_disk_dquot_t)) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: dquot too small (%d) in %s.\",\n\t\t\t\t\titem->ri_buf[i].i_len, __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\terror = xfs_dqcheck(mp, item->ri_buf[i].i_addr,\n\t\t\t\t\t       -1, 0, XFS_QMOPT_DOWARN,\n\t\t\t\t\t       \"dquot_buf_recover\");\n\t\t\tif (error)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tmemcpy(xfs_buf_offset(bp,\n\t\t\t(uint)bit << XFS_BLF_SHIFT),\t/* dest */\n\t\t\titem->ri_buf[i].i_addr,\t\t/* source */\n\t\t\tnbits<<XFS_BLF_SHIFT);\t\t/* length */\n next:\n\t\ti++;\n\t\tbit += nbits;\n\t}\n\n\t/* Shouldn't be any more regions */\n\tASSERT(i == item->ri_total);\n\n\txlog_recover_validate_buf_type(mp, bp, buf_f);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_do_reg_buffer(\n\tstruct xfs_mount\t*mp,\n\txlog_recover_item_t\t*item,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tint\t\t\ti;\n\tint\t\t\tbit;\n\tint\t\t\tnbits;\n\tint                     error;\n\n\ttrace_xfs_log_recover_buf_reg_buf(mp->m_log, buf_f);\n\n\tbit = 0;\n\ti = 1;  /* 0 is the buf format structure */\n\twhile (1) {\n\t\tbit = xfs_next_bit(buf_f->blf_data_map,\n\t\t\t\t   buf_f->blf_map_size, bit);\n\t\tif (bit == -1)\n\t\t\tbreak;\n\t\tnbits = xfs_contig_bits(buf_f->blf_data_map,\n\t\t\t\t\tbuf_f->blf_map_size, bit);\n\t\tASSERT(nbits > 0);\n\t\tASSERT(item->ri_buf[i].i_addr != NULL);\n\t\tASSERT(item->ri_buf[i].i_len % XFS_BLF_CHUNK == 0);\n\t\tASSERT(BBTOB(bp->b_io_length) >=\n\t\t       ((uint)bit << XFS_BLF_SHIFT) + (nbits << XFS_BLF_SHIFT));\n\n\t\t/*\n\t\t * The dirty regions logged in the buffer, even though\n\t\t * contiguous, may span multiple chunks. This is because the\n\t\t * dirty region may span a physical page boundary in a buffer\n\t\t * and hence be split into two separate vectors for writing into\n\t\t * the log. Hence we need to trim nbits back to the length of\n\t\t * the current region being copied out of the log.\n\t\t */\n\t\tif (item->ri_buf[i].i_len < (nbits << XFS_BLF_SHIFT))\n\t\t\tnbits = item->ri_buf[i].i_len >> XFS_BLF_SHIFT;\n\n\t\t/*\n\t\t * Do a sanity check if this is a dquot buffer. Just checking\n\t\t * the first dquot in the buffer should do. XXXThis is\n\t\t * probably a good thing to do for other buf types also.\n\t\t */\n\t\terror = 0;\n\t\tif (buf_f->blf_flags &\n\t\t   (XFS_BLF_UDQUOT_BUF|XFS_BLF_PDQUOT_BUF|XFS_BLF_GDQUOT_BUF)) {\n\t\t\tif (item->ri_buf[i].i_addr == NULL) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: NULL dquot in %s.\", __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (item->ri_buf[i].i_len < sizeof(xfs_disk_dquot_t)) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: dquot too small (%d) in %s.\",\n\t\t\t\t\titem->ri_buf[i].i_len, __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\terror = xfs_dqcheck(mp, item->ri_buf[i].i_addr,\n\t\t\t\t\t       -1, 0, XFS_QMOPT_DOWARN,\n\t\t\t\t\t       \"dquot_buf_recover\");\n\t\t\tif (error)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tmemcpy(xfs_buf_offset(bp,\n\t\t\t(uint)bit << XFS_BLF_SHIFT),\t/* dest */\n\t\t\titem->ri_buf[i].i_addr,\t\t/* source */\n\t\t\tnbits<<XFS_BLF_SHIFT);\t\t/* length */\n next:\n\t\ti++;\n\t\tbit += nbits;\n\t}\n\n\t/* Shouldn't be any more regions */\n\tASSERT(i == item->ri_total);\n\n\txlog_recover_validate_buf_type(mp, bp, buf_f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_buf_dquot_buf",
          "args": [
            "log",
            "buf_f"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC bool\nxlog_recover_do_dquot_buffer(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item,\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_buf_log_format\t*buf_f)\n{\n\tuint\t\t\ttype;\n\n\ttrace_xfs_log_recover_buf_dquot_buf(log, buf_f);\n\n\t/*\n\t * Filesystems are required to send in quota flags at mount time.\n\t */\n\tif (!mp->m_qflags)\n\t\treturn false;\n\n\ttype = 0;\n\tif (buf_f->blf_flags & XFS_BLF_UDQUOT_BUF)\n\t\ttype |= XFS_DQ_USER;\n\tif (buf_f->blf_flags & XFS_BLF_PDQUOT_BUF)\n\t\ttype |= XFS_DQ_PROJ;\n\tif (buf_f->blf_flags & XFS_BLF_GDQUOT_BUF)\n\t\ttype |= XFS_DQ_GROUP;\n\t/*\n\t * This type of quotas was turned off, so ignore this buffer\n\t */\n\tif (log->l_quotaoffs_flag & type)\n\t\treturn false;\n\n\txlog_recover_do_reg_buffer(mp, item, bp, buf_f);\n\treturn true;\n}"
  },
  {
    "function_name": "xlog_recover_do_reg_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "2158-2237",
    "snippet": "STATIC void\nxlog_recover_do_reg_buffer(\n\tstruct xfs_mount\t*mp,\n\txlog_recover_item_t\t*item,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tint\t\t\ti;\n\tint\t\t\tbit;\n\tint\t\t\tnbits;\n\tint                     error;\n\n\ttrace_xfs_log_recover_buf_reg_buf(mp->m_log, buf_f);\n\n\tbit = 0;\n\ti = 1;  /* 0 is the buf format structure */\n\twhile (1) {\n\t\tbit = xfs_next_bit(buf_f->blf_data_map,\n\t\t\t\t   buf_f->blf_map_size, bit);\n\t\tif (bit == -1)\n\t\t\tbreak;\n\t\tnbits = xfs_contig_bits(buf_f->blf_data_map,\n\t\t\t\t\tbuf_f->blf_map_size, bit);\n\t\tASSERT(nbits > 0);\n\t\tASSERT(item->ri_buf[i].i_addr != NULL);\n\t\tASSERT(item->ri_buf[i].i_len % XFS_BLF_CHUNK == 0);\n\t\tASSERT(BBTOB(bp->b_io_length) >=\n\t\t       ((uint)bit << XFS_BLF_SHIFT) + (nbits << XFS_BLF_SHIFT));\n\n\t\t/*\n\t\t * The dirty regions logged in the buffer, even though\n\t\t * contiguous, may span multiple chunks. This is because the\n\t\t * dirty region may span a physical page boundary in a buffer\n\t\t * and hence be split into two separate vectors for writing into\n\t\t * the log. Hence we need to trim nbits back to the length of\n\t\t * the current region being copied out of the log.\n\t\t */\n\t\tif (item->ri_buf[i].i_len < (nbits << XFS_BLF_SHIFT))\n\t\t\tnbits = item->ri_buf[i].i_len >> XFS_BLF_SHIFT;\n\n\t\t/*\n\t\t * Do a sanity check if this is a dquot buffer. Just checking\n\t\t * the first dquot in the buffer should do. XXXThis is\n\t\t * probably a good thing to do for other buf types also.\n\t\t */\n\t\terror = 0;\n\t\tif (buf_f->blf_flags &\n\t\t   (XFS_BLF_UDQUOT_BUF|XFS_BLF_PDQUOT_BUF|XFS_BLF_GDQUOT_BUF)) {\n\t\t\tif (item->ri_buf[i].i_addr == NULL) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: NULL dquot in %s.\", __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (item->ri_buf[i].i_len < sizeof(xfs_disk_dquot_t)) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: dquot too small (%d) in %s.\",\n\t\t\t\t\titem->ri_buf[i].i_len, __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\terror = xfs_dqcheck(mp, item->ri_buf[i].i_addr,\n\t\t\t\t\t       -1, 0, XFS_QMOPT_DOWARN,\n\t\t\t\t\t       \"dquot_buf_recover\");\n\t\t\tif (error)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tmemcpy(xfs_buf_offset(bp,\n\t\t\t(uint)bit << XFS_BLF_SHIFT),\t/* dest */\n\t\t\titem->ri_buf[i].i_addr,\t\t/* source */\n\t\t\tnbits<<XFS_BLF_SHIFT);\t\t/* length */\n next:\n\t\ti++;\n\t\tbit += nbits;\n\t}\n\n\t/* Shouldn't be any more regions */\n\tASSERT(i == item->ri_total);\n\n\txlog_recover_validate_buf_type(mp, bp, buf_f);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_recover_validate_buf_type",
          "args": [
            "mp",
            "bp",
            "buf_f"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_validate_buf_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1960-2150",
          "snippet": "static void\nxlog_recover_validate_buf_type(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\t__uint32_t\t\tmagic32;\n\t__uint16_t\t\tmagic16;\n\t__uint16_t\t\tmagicda;\n\n\t/*\n\t * We can only do post recovery validation on items on CRC enabled\n\t * fielsystems as we need to know when the buffer was written to be able\n\t * to determine if we should have replayed the item. If we replay old\n\t * metadata over a newer buffer, then it will enter a temporarily\n\t * inconsistent state resulting in verification failures. Hence for now\n\t * just avoid the verification stage for non-crc filesystems\n\t */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tmagic32 = be32_to_cpu(*(__be32 *)bp->b_addr);\n\tmagic16 = be16_to_cpu(*(__be16*)bp->b_addr);\n\tmagicda = be16_to_cpu(info->magic);\n\tswitch (xfs_blft_from_flags(buf_f)) {\n\tcase XFS_BLFT_BTREE_BUF:\n\t\tswitch (magic32) {\n\t\tcase XFS_ABTB_CRC_MAGIC:\n\t\tcase XFS_ABTC_CRC_MAGIC:\n\t\tcase XFS_ABTB_MAGIC:\n\t\tcase XFS_ABTC_MAGIC:\n\t\t\tbp->b_ops = &xfs_allocbt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_IBT_CRC_MAGIC:\n\t\tcase XFS_FIBT_CRC_MAGIC:\n\t\tcase XFS_IBT_MAGIC:\n\t\tcase XFS_FIBT_MAGIC:\n\t\t\tbp->b_ops = &xfs_inobt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_BMAP_CRC_MAGIC:\n\t\tcase XFS_BMAP_MAGIC:\n\t\t\tbp->b_ops = &xfs_bmbt_buf_ops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txfs_warn(mp, \"Bad btree block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase XFS_BLFT_AGF_BUF:\n\t\tif (magic32 != XFS_AGF_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGF block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGFL_BUF:\n\t\tif (magic32 != XFS_AGFL_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGFL block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agfl_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGI_BUF:\n\t\tif (magic32 != XFS_AGI_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGI block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agi_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_UDQUOT_BUF:\n\tcase XFS_BLFT_PDQUOT_BUF:\n\tcase XFS_BLFT_GDQUOT_BUF:\n#ifdef CONFIG_XFS_QUOTA\n\t\tif (magic16 != XFS_DQUOT_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad DQUOT block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dquot_buf_ops;\n#else\n\t\txfs_alert(mp,\n\t\"Trying to recover dquots without QUOTA support built in!\");\n\t\tASSERT(0);\n#endif\n\t\tbreak;\n\tcase XFS_BLFT_DINO_BUF:\n\t\tif (magic16 != XFS_DINODE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad INODE block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SYMLINK_BUF:\n\t\tif (magic32 != XFS_SYMLINK_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad symlink block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_symlink_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_BLOCK_BUF:\n\t\tif (magic32 != XFS_DIR2_BLOCK_MAGIC &&\n\t\t    magic32 != XFS_DIR3_BLOCK_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_DATA_BUF:\n\t\tif (magic32 != XFS_DIR2_DATA_MAGIC &&\n\t\t    magic32 != XFS_DIR3_DATA_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir data magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_FREE_BUF:\n\t\tif (magic32 != XFS_DIR2_FREE_MAGIC &&\n\t\t    magic32 != XFS_DIR3_FREE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir3 free magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAF1_BUF:\n\t\tif (magicda != XFS_DIR2_LEAF1_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAF1_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir leaf1 magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAFN_BUF:\n\t\tif (magicda != XFS_DIR2_LEAFN_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAFN_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir leafn magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DA_NODE_BUF:\n\t\tif (magicda != XFS_DA_NODE_MAGIC &&\n\t\t    magicda != XFS_DA3_NODE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad da node magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_da3_node_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_LEAF_BUF:\n\t\tif (magicda != XFS_ATTR_LEAF_MAGIC &&\n\t\t    magicda != XFS_ATTR3_LEAF_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad attr leaf magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_RMT_BUF:\n\t\tif (magic32 != XFS_ATTR3_RMT_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad attr remote magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SB_BUF:\n\t\tif (magic32 != XFS_SB_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad SB block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_sb_buf_ops;\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(mp, \"Unknown buffer type %d!\",\n\t\t\t xfs_blft_from_flags(buf_f));\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxlog_recover_validate_buf_type(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\t__uint32_t\t\tmagic32;\n\t__uint16_t\t\tmagic16;\n\t__uint16_t\t\tmagicda;\n\n\t/*\n\t * We can only do post recovery validation on items on CRC enabled\n\t * fielsystems as we need to know when the buffer was written to be able\n\t * to determine if we should have replayed the item. If we replay old\n\t * metadata over a newer buffer, then it will enter a temporarily\n\t * inconsistent state resulting in verification failures. Hence for now\n\t * just avoid the verification stage for non-crc filesystems\n\t */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tmagic32 = be32_to_cpu(*(__be32 *)bp->b_addr);\n\tmagic16 = be16_to_cpu(*(__be16*)bp->b_addr);\n\tmagicda = be16_to_cpu(info->magic);\n\tswitch (xfs_blft_from_flags(buf_f)) {\n\tcase XFS_BLFT_BTREE_BUF:\n\t\tswitch (magic32) {\n\t\tcase XFS_ABTB_CRC_MAGIC:\n\t\tcase XFS_ABTC_CRC_MAGIC:\n\t\tcase XFS_ABTB_MAGIC:\n\t\tcase XFS_ABTC_MAGIC:\n\t\t\tbp->b_ops = &xfs_allocbt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_IBT_CRC_MAGIC:\n\t\tcase XFS_FIBT_CRC_MAGIC:\n\t\tcase XFS_IBT_MAGIC:\n\t\tcase XFS_FIBT_MAGIC:\n\t\t\tbp->b_ops = &xfs_inobt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_BMAP_CRC_MAGIC:\n\t\tcase XFS_BMAP_MAGIC:\n\t\t\tbp->b_ops = &xfs_bmbt_buf_ops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txfs_warn(mp, \"Bad btree block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase XFS_BLFT_AGF_BUF:\n\t\tif (magic32 != XFS_AGF_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGF block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGFL_BUF:\n\t\tif (magic32 != XFS_AGFL_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGFL block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agfl_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGI_BUF:\n\t\tif (magic32 != XFS_AGI_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGI block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agi_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_UDQUOT_BUF:\n\tcase XFS_BLFT_PDQUOT_BUF:\n\tcase XFS_BLFT_GDQUOT_BUF:\n#ifdef CONFIG_XFS_QUOTA\n\t\tif (magic16 != XFS_DQUOT_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad DQUOT block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dquot_buf_ops;\n#else\n\t\txfs_alert(mp,\n\t\"Trying to recover dquots without QUOTA support built in!\");\n\t\tASSERT(0);\n#endif\n\t\tbreak;\n\tcase XFS_BLFT_DINO_BUF:\n\t\tif (magic16 != XFS_DINODE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad INODE block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SYMLINK_BUF:\n\t\tif (magic32 != XFS_SYMLINK_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad symlink block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_symlink_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_BLOCK_BUF:\n\t\tif (magic32 != XFS_DIR2_BLOCK_MAGIC &&\n\t\t    magic32 != XFS_DIR3_BLOCK_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_DATA_BUF:\n\t\tif (magic32 != XFS_DIR2_DATA_MAGIC &&\n\t\t    magic32 != XFS_DIR3_DATA_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir data magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_FREE_BUF:\n\t\tif (magic32 != XFS_DIR2_FREE_MAGIC &&\n\t\t    magic32 != XFS_DIR3_FREE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir3 free magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAF1_BUF:\n\t\tif (magicda != XFS_DIR2_LEAF1_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAF1_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir leaf1 magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAFN_BUF:\n\t\tif (magicda != XFS_DIR2_LEAFN_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAFN_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir leafn magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DA_NODE_BUF:\n\t\tif (magicda != XFS_DA_NODE_MAGIC &&\n\t\t    magicda != XFS_DA3_NODE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad da node magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_da3_node_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_LEAF_BUF:\n\t\tif (magicda != XFS_ATTR_LEAF_MAGIC &&\n\t\t    magicda != XFS_ATTR3_LEAF_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad attr leaf magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_RMT_BUF:\n\t\tif (magic32 != XFS_ATTR3_RMT_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad attr remote magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SB_BUF:\n\t\tif (magic32 != XFS_SB_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad SB block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_sb_buf_ops;\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(mp, \"Unknown buffer type %d!\",\n\t\t\t xfs_blft_from_flags(buf_f));\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i == item->ri_total"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "xfs_buf_offset(bp,\n\t\t\t(uint)bit << XFS_BLF_SHIFT)",
            "/* dest */item->ri_buf[i].i_addr",
            "/* source */nbits<<XFS_BLF_SHIFT"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_offset",
          "args": [
            "bp",
            "(uint)bit << XFS_BLF_SHIFT"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1422-1435",
          "snippet": "xfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqcheck",
          "args": [
            "mp",
            "item->ri_buf[i].i_addr",
            "-1",
            "0",
            "XFS_QMOPT_DOWARN",
            "\"dquot_buf_recover\""
          ],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqcheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
          "lines": "50-172",
          "snippet": "int\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"XFS: dquot too small (%d) in %s.\"",
            "item->ri_buf[i].i_len",
            "__func__"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "BBTOB(bp->b_io_length) >=\n\t\t       ((uint)bit << XFS_BLF_SHIFT) + (nbits << XFS_BLF_SHIFT)"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_io_length"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "item->ri_buf[i].i_len % XFS_BLF_CHUNK == 0"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "item->ri_buf[i].i_addr != NULL"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nbits > 0"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_contig_bits",
          "args": [
            "buf_f->blf_data_map",
            "buf_f->blf_map_size",
            "bit"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_contig_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bit.c",
          "lines": "48-78",
          "snippet": "int\nxfs_contig_bits(uint *map, uint\tsize, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = 0;\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tASSERT(start_bit < size);\n\tsize -= start_bit & ~(NBWORD - 1);\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to one first offset bits prior to start */\n\t\ttmp |= (~0U >> (NBWORD-start_bit));\n\t\tif (tmp != ~0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != ~0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn result - start_bit;\nfound:\n\treturn result + ffz(tmp) - start_bit;\n}",
          "includes": [
            "#include \"xfs_bit.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bit.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_contig_bits(uint *map, uint\tsize, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = 0;\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tASSERT(start_bit < size);\n\tsize -= start_bit & ~(NBWORD - 1);\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to one first offset bits prior to start */\n\t\ttmp |= (~0U >> (NBWORD-start_bit));\n\t\tif (tmp != ~0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != ~0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn result - start_bit;\nfound:\n\treturn result + ffz(tmp) - start_bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_next_bit",
          "args": [
            "buf_f->blf_data_map",
            "buf_f->blf_map_size",
            "bit"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bit.c",
          "lines": "88-118",
          "snippet": "int xfs_next_bit(uint *map, uint size, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = start_bit & ~(NBWORD - 1);\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tif (start_bit >= size)\n\t\treturn -1;\n\tsize -= result;\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to zero first offset bits prior to start */\n\t\ttmp &= (~0U << start_bit);\n\t\tif (tmp != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn -1;\nfound:\n\treturn result + ffs(tmp) - 1;\n}",
          "includes": [
            "#include \"xfs_bit.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bit.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs.h\"\n\nint xfs_next_bit(uint *map, uint size, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = start_bit & ~(NBWORD - 1);\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tif (start_bit >= size)\n\t\treturn -1;\n\tsize -= result;\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to zero first offset bits prior to start */\n\t\ttmp &= (~0U << start_bit);\n\t\tif (tmp != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn -1;\nfound:\n\treturn result + ffs(tmp) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_buf_reg_buf",
          "args": [
            "mp->m_log",
            "buf_f"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_do_reg_buffer(\n\tstruct xfs_mount\t*mp,\n\txlog_recover_item_t\t*item,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tint\t\t\ti;\n\tint\t\t\tbit;\n\tint\t\t\tnbits;\n\tint                     error;\n\n\ttrace_xfs_log_recover_buf_reg_buf(mp->m_log, buf_f);\n\n\tbit = 0;\n\ti = 1;  /* 0 is the buf format structure */\n\twhile (1) {\n\t\tbit = xfs_next_bit(buf_f->blf_data_map,\n\t\t\t\t   buf_f->blf_map_size, bit);\n\t\tif (bit == -1)\n\t\t\tbreak;\n\t\tnbits = xfs_contig_bits(buf_f->blf_data_map,\n\t\t\t\t\tbuf_f->blf_map_size, bit);\n\t\tASSERT(nbits > 0);\n\t\tASSERT(item->ri_buf[i].i_addr != NULL);\n\t\tASSERT(item->ri_buf[i].i_len % XFS_BLF_CHUNK == 0);\n\t\tASSERT(BBTOB(bp->b_io_length) >=\n\t\t       ((uint)bit << XFS_BLF_SHIFT) + (nbits << XFS_BLF_SHIFT));\n\n\t\t/*\n\t\t * The dirty regions logged in the buffer, even though\n\t\t * contiguous, may span multiple chunks. This is because the\n\t\t * dirty region may span a physical page boundary in a buffer\n\t\t * and hence be split into two separate vectors for writing into\n\t\t * the log. Hence we need to trim nbits back to the length of\n\t\t * the current region being copied out of the log.\n\t\t */\n\t\tif (item->ri_buf[i].i_len < (nbits << XFS_BLF_SHIFT))\n\t\t\tnbits = item->ri_buf[i].i_len >> XFS_BLF_SHIFT;\n\n\t\t/*\n\t\t * Do a sanity check if this is a dquot buffer. Just checking\n\t\t * the first dquot in the buffer should do. XXXThis is\n\t\t * probably a good thing to do for other buf types also.\n\t\t */\n\t\terror = 0;\n\t\tif (buf_f->blf_flags &\n\t\t   (XFS_BLF_UDQUOT_BUF|XFS_BLF_PDQUOT_BUF|XFS_BLF_GDQUOT_BUF)) {\n\t\t\tif (item->ri_buf[i].i_addr == NULL) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: NULL dquot in %s.\", __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (item->ri_buf[i].i_len < sizeof(xfs_disk_dquot_t)) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: dquot too small (%d) in %s.\",\n\t\t\t\t\titem->ri_buf[i].i_len, __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\terror = xfs_dqcheck(mp, item->ri_buf[i].i_addr,\n\t\t\t\t\t       -1, 0, XFS_QMOPT_DOWARN,\n\t\t\t\t\t       \"dquot_buf_recover\");\n\t\t\tif (error)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tmemcpy(xfs_buf_offset(bp,\n\t\t\t(uint)bit << XFS_BLF_SHIFT),\t/* dest */\n\t\t\titem->ri_buf[i].i_addr,\t\t/* source */\n\t\t\tnbits<<XFS_BLF_SHIFT);\t\t/* length */\n next:\n\t\ti++;\n\t\tbit += nbits;\n\t}\n\n\t/* Shouldn't be any more regions */\n\tASSERT(i == item->ri_total);\n\n\txlog_recover_validate_buf_type(mp, bp, buf_f);\n}"
  },
  {
    "function_name": "xlog_recover_validate_buf_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "1960-2150",
    "snippet": "static void\nxlog_recover_validate_buf_type(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\t__uint32_t\t\tmagic32;\n\t__uint16_t\t\tmagic16;\n\t__uint16_t\t\tmagicda;\n\n\t/*\n\t * We can only do post recovery validation on items on CRC enabled\n\t * fielsystems as we need to know when the buffer was written to be able\n\t * to determine if we should have replayed the item. If we replay old\n\t * metadata over a newer buffer, then it will enter a temporarily\n\t * inconsistent state resulting in verification failures. Hence for now\n\t * just avoid the verification stage for non-crc filesystems\n\t */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tmagic32 = be32_to_cpu(*(__be32 *)bp->b_addr);\n\tmagic16 = be16_to_cpu(*(__be16*)bp->b_addr);\n\tmagicda = be16_to_cpu(info->magic);\n\tswitch (xfs_blft_from_flags(buf_f)) {\n\tcase XFS_BLFT_BTREE_BUF:\n\t\tswitch (magic32) {\n\t\tcase XFS_ABTB_CRC_MAGIC:\n\t\tcase XFS_ABTC_CRC_MAGIC:\n\t\tcase XFS_ABTB_MAGIC:\n\t\tcase XFS_ABTC_MAGIC:\n\t\t\tbp->b_ops = &xfs_allocbt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_IBT_CRC_MAGIC:\n\t\tcase XFS_FIBT_CRC_MAGIC:\n\t\tcase XFS_IBT_MAGIC:\n\t\tcase XFS_FIBT_MAGIC:\n\t\t\tbp->b_ops = &xfs_inobt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_BMAP_CRC_MAGIC:\n\t\tcase XFS_BMAP_MAGIC:\n\t\t\tbp->b_ops = &xfs_bmbt_buf_ops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txfs_warn(mp, \"Bad btree block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase XFS_BLFT_AGF_BUF:\n\t\tif (magic32 != XFS_AGF_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGF block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGFL_BUF:\n\t\tif (magic32 != XFS_AGFL_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGFL block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agfl_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGI_BUF:\n\t\tif (magic32 != XFS_AGI_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGI block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agi_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_UDQUOT_BUF:\n\tcase XFS_BLFT_PDQUOT_BUF:\n\tcase XFS_BLFT_GDQUOT_BUF:\n#ifdef CONFIG_XFS_QUOTA\n\t\tif (magic16 != XFS_DQUOT_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad DQUOT block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dquot_buf_ops;\n#else\n\t\txfs_alert(mp,\n\t\"Trying to recover dquots without QUOTA support built in!\");\n\t\tASSERT(0);\n#endif\n\t\tbreak;\n\tcase XFS_BLFT_DINO_BUF:\n\t\tif (magic16 != XFS_DINODE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad INODE block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SYMLINK_BUF:\n\t\tif (magic32 != XFS_SYMLINK_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad symlink block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_symlink_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_BLOCK_BUF:\n\t\tif (magic32 != XFS_DIR2_BLOCK_MAGIC &&\n\t\t    magic32 != XFS_DIR3_BLOCK_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_DATA_BUF:\n\t\tif (magic32 != XFS_DIR2_DATA_MAGIC &&\n\t\t    magic32 != XFS_DIR3_DATA_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir data magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_FREE_BUF:\n\t\tif (magic32 != XFS_DIR2_FREE_MAGIC &&\n\t\t    magic32 != XFS_DIR3_FREE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir3 free magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAF1_BUF:\n\t\tif (magicda != XFS_DIR2_LEAF1_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAF1_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir leaf1 magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAFN_BUF:\n\t\tif (magicda != XFS_DIR2_LEAFN_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAFN_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir leafn magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DA_NODE_BUF:\n\t\tif (magicda != XFS_DA_NODE_MAGIC &&\n\t\t    magicda != XFS_DA3_NODE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad da node magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_da3_node_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_LEAF_BUF:\n\t\tif (magicda != XFS_ATTR_LEAF_MAGIC &&\n\t\t    magicda != XFS_ATTR3_LEAF_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad attr leaf magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_RMT_BUF:\n\t\tif (magic32 != XFS_ATTR3_RMT_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad attr remote magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SB_BUF:\n\t\tif (magic32 != XFS_SB_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad SB block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_sb_buf_ops;\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(mp, \"Unknown buffer type %d!\",\n\t\t\t xfs_blft_from_flags(buf_f));\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Unknown buffer type %d!\"",
            "xfs_blft_from_flags(buf_f)"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_blft_from_flags",
          "args": [
            "buf_f"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_blft_from_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "509-513",
          "snippet": "static inline __uint16_t\nxfs_blft_from_flags(struct xfs_buf_log_format *blf)\n{\n\treturn (blf->blf_flags & XFS_BLFT_MASK) >> XFS_BLFT_SHIFT;\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_BLFT_MASK\t(((1 << XFS_BLFT_BITS) - 1) << XFS_BLFT_SHIFT)",
            "#define XFS_BLFT_SHIFT\t11"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_BLFT_MASK\t(((1 << XFS_BLFT_BITS) - 1) << XFS_BLFT_SHIFT)\n#define XFS_BLFT_SHIFT\t11\n\nstatic inline __uint16_t\nxfs_blft_from_flags(struct xfs_buf_log_format *blf)\n{\n\treturn (blf->blf_flags & XFS_BLFT_MASK) >> XFS_BLFT_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad SB block magic!\""
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad attr remote magic!\""
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad attr leaf magic!\""
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad da node magic!\""
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad dir leafn magic!\""
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad dir leaf1 magic!\""
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad dir3 free magic!\""
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad dir data magic!\""
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad dir block magic!\""
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad symlink block magic!\""
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad INODE block magic!\""
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"Trying to recover dquots without QUOTA support built in!\""
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_fsblock_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iomap.c",
          "lines": "95-110",
          "snippet": "STATIC int\nxfs_alert_fsblock_zero(\n\txfs_inode_t\t*ip,\n\txfs_bmbt_irec_t\t*imap)\n{\n\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\"blkcnt: %llx extent-state: %x\",\n\t\t(unsigned long long)ip->i_ino,\n\t\t(unsigned long long)imap->br_startblock,\n\t\t(unsigned long long)imap->br_startoff,\n\t\t(unsigned long long)imap->br_blockcount,\n\t\timap->br_state);\n\treturn -EFSCORRUPTED;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_alert_fsblock_zero(\n\txfs_inode_t\t*ip,\n\txfs_bmbt_irec_t\t*imap)\n{\n\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\"blkcnt: %llx extent-state: %x\",\n\t\t(unsigned long long)ip->i_ino,\n\t\t(unsigned long long)imap->br_startblock,\n\t\t(unsigned long long)imap->br_startoff,\n\t\t(unsigned long long)imap->br_blockcount,\n\t\timap->br_state);\n\treturn -EFSCORRUPTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad DQUOT block magic!\""
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad AGI block magic!\""
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad AGFL block magic!\""
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad AGF block magic!\""
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Bad btree block magic!\""
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "info->magic"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*(__be16*)bp->b_addr"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*(__be32 *)bp->b_addr"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxlog_recover_validate_buf_type(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\t__uint32_t\t\tmagic32;\n\t__uint16_t\t\tmagic16;\n\t__uint16_t\t\tmagicda;\n\n\t/*\n\t * We can only do post recovery validation on items on CRC enabled\n\t * fielsystems as we need to know when the buffer was written to be able\n\t * to determine if we should have replayed the item. If we replay old\n\t * metadata over a newer buffer, then it will enter a temporarily\n\t * inconsistent state resulting in verification failures. Hence for now\n\t * just avoid the verification stage for non-crc filesystems\n\t */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tmagic32 = be32_to_cpu(*(__be32 *)bp->b_addr);\n\tmagic16 = be16_to_cpu(*(__be16*)bp->b_addr);\n\tmagicda = be16_to_cpu(info->magic);\n\tswitch (xfs_blft_from_flags(buf_f)) {\n\tcase XFS_BLFT_BTREE_BUF:\n\t\tswitch (magic32) {\n\t\tcase XFS_ABTB_CRC_MAGIC:\n\t\tcase XFS_ABTC_CRC_MAGIC:\n\t\tcase XFS_ABTB_MAGIC:\n\t\tcase XFS_ABTC_MAGIC:\n\t\t\tbp->b_ops = &xfs_allocbt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_IBT_CRC_MAGIC:\n\t\tcase XFS_FIBT_CRC_MAGIC:\n\t\tcase XFS_IBT_MAGIC:\n\t\tcase XFS_FIBT_MAGIC:\n\t\t\tbp->b_ops = &xfs_inobt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_BMAP_CRC_MAGIC:\n\t\tcase XFS_BMAP_MAGIC:\n\t\t\tbp->b_ops = &xfs_bmbt_buf_ops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txfs_warn(mp, \"Bad btree block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase XFS_BLFT_AGF_BUF:\n\t\tif (magic32 != XFS_AGF_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGF block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGFL_BUF:\n\t\tif (magic32 != XFS_AGFL_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGFL block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agfl_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGI_BUF:\n\t\tif (magic32 != XFS_AGI_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad AGI block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agi_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_UDQUOT_BUF:\n\tcase XFS_BLFT_PDQUOT_BUF:\n\tcase XFS_BLFT_GDQUOT_BUF:\n#ifdef CONFIG_XFS_QUOTA\n\t\tif (magic16 != XFS_DQUOT_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad DQUOT block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dquot_buf_ops;\n#else\n\t\txfs_alert(mp,\n\t\"Trying to recover dquots without QUOTA support built in!\");\n\t\tASSERT(0);\n#endif\n\t\tbreak;\n\tcase XFS_BLFT_DINO_BUF:\n\t\tif (magic16 != XFS_DINODE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad INODE block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SYMLINK_BUF:\n\t\tif (magic32 != XFS_SYMLINK_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad symlink block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_symlink_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_BLOCK_BUF:\n\t\tif (magic32 != XFS_DIR2_BLOCK_MAGIC &&\n\t\t    magic32 != XFS_DIR3_BLOCK_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_DATA_BUF:\n\t\tif (magic32 != XFS_DIR2_DATA_MAGIC &&\n\t\t    magic32 != XFS_DIR3_DATA_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir data magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_FREE_BUF:\n\t\tif (magic32 != XFS_DIR2_FREE_MAGIC &&\n\t\t    magic32 != XFS_DIR3_FREE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir3 free magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAF1_BUF:\n\t\tif (magicda != XFS_DIR2_LEAF1_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAF1_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir leaf1 magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAFN_BUF:\n\t\tif (magicda != XFS_DIR2_LEAFN_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAFN_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad dir leafn magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DA_NODE_BUF:\n\t\tif (magicda != XFS_DA_NODE_MAGIC &&\n\t\t    magicda != XFS_DA3_NODE_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad da node magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_da3_node_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_LEAF_BUF:\n\t\tif (magicda != XFS_ATTR_LEAF_MAGIC &&\n\t\t    magicda != XFS_ATTR3_LEAF_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad attr leaf magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_RMT_BUF:\n\t\tif (magic32 != XFS_ATTR3_RMT_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad attr remote magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SB_BUF:\n\t\tif (magic32 != XFS_SB_MAGIC) {\n\t\t\txfs_warn(mp, \"Bad SB block magic!\");\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_sb_buf_ops;\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(mp, \"Unknown buffer type %d!\",\n\t\t\t xfs_blft_from_flags(buf_f));\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "xlog_recover_get_buf_lsn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "1829-1950",
    "snippet": "static xfs_lsn_t\nxlog_recover_get_buf_lsn(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\t__uint32_t\t\tmagic32;\n\t__uint16_t\t\tmagic16;\n\t__uint16_t\t\tmagicda;\n\tvoid\t\t\t*blk = bp->b_addr;\n\tuuid_t\t\t\t*uuid;\n\txfs_lsn_t\t\tlsn = -1;\n\n\t/* v4 filesystems always recover immediately */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\tgoto recover_immediately;\n\n\tmagic32 = be32_to_cpu(*(__be32 *)blk);\n\tswitch (magic32) {\n\tcase XFS_ABTB_CRC_MAGIC:\n\tcase XFS_ABTC_CRC_MAGIC:\n\tcase XFS_ABTB_MAGIC:\n\tcase XFS_ABTC_MAGIC:\n\tcase XFS_IBT_CRC_MAGIC:\n\tcase XFS_IBT_MAGIC: {\n\t\tstruct xfs_btree_block *btb = blk;\n\n\t\tlsn = be64_to_cpu(btb->bb_u.s.bb_lsn);\n\t\tuuid = &btb->bb_u.s.bb_uuid;\n\t\tbreak;\n\t}\n\tcase XFS_BMAP_CRC_MAGIC:\n\tcase XFS_BMAP_MAGIC: {\n\t\tstruct xfs_btree_block *btb = blk;\n\n\t\tlsn = be64_to_cpu(btb->bb_u.l.bb_lsn);\n\t\tuuid = &btb->bb_u.l.bb_uuid;\n\t\tbreak;\n\t}\n\tcase XFS_AGF_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agf *)blk)->agf_lsn);\n\t\tuuid = &((struct xfs_agf *)blk)->agf_uuid;\n\t\tbreak;\n\tcase XFS_AGFL_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agfl *)blk)->agfl_lsn);\n\t\tuuid = &((struct xfs_agfl *)blk)->agfl_uuid;\n\t\tbreak;\n\tcase XFS_AGI_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agi *)blk)->agi_lsn);\n\t\tuuid = &((struct xfs_agi *)blk)->agi_uuid;\n\t\tbreak;\n\tcase XFS_SYMLINK_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dsymlink_hdr *)blk)->sl_lsn);\n\t\tuuid = &((struct xfs_dsymlink_hdr *)blk)->sl_uuid;\n\t\tbreak;\n\tcase XFS_DIR3_BLOCK_MAGIC:\n\tcase XFS_DIR3_DATA_MAGIC:\n\tcase XFS_DIR3_FREE_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dir3_blk_hdr *)blk)->lsn);\n\t\tuuid = &((struct xfs_dir3_blk_hdr *)blk)->uuid;\n\t\tbreak;\n\tcase XFS_ATTR3_RMT_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_attr3_rmt_hdr *)blk)->rm_lsn);\n\t\tuuid = &((struct xfs_attr3_rmt_hdr *)blk)->rm_uuid;\n\t\tbreak;\n\tcase XFS_SB_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dsb *)blk)->sb_lsn);\n\t\tuuid = &((struct xfs_dsb *)blk)->sb_uuid;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (lsn != (xfs_lsn_t)-1) {\n\t\tif (!uuid_equal(&mp->m_sb.sb_uuid, uuid))\n\t\t\tgoto recover_immediately;\n\t\treturn lsn;\n\t}\n\n\tmagicda = be16_to_cpu(((struct xfs_da_blkinfo *)blk)->magic);\n\tswitch (magicda) {\n\tcase XFS_DIR3_LEAF1_MAGIC:\n\tcase XFS_DIR3_LEAFN_MAGIC:\n\tcase XFS_DA3_NODE_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_da3_blkinfo *)blk)->lsn);\n\t\tuuid = &((struct xfs_da3_blkinfo *)blk)->uuid;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (lsn != (xfs_lsn_t)-1) {\n\t\tif (!uuid_equal(&mp->m_sb.sb_uuid, uuid))\n\t\t\tgoto recover_immediately;\n\t\treturn lsn;\n\t}\n\n\t/*\n\t * We do individual object checks on dquot and inode buffers as they\n\t * have their own individual LSN records. Also, we could have a stale\n\t * buffer here, so we have to at least recognise these buffer types.\n\t *\n\t * A notd complexity here is inode unlinked list processing - it logs\n\t * the inode directly in the buffer, but we don't know which inodes have\n\t * been modified, and there is no global buffer LSN. Hence we need to\n\t * recover all inode buffer types immediately. This problem will be\n\t * fixed by logical logging of the unlinked list modifications.\n\t */\n\tmagic16 = be16_to_cpu(*(__be16 *)blk);\n\tswitch (magic16) {\n\tcase XFS_DQUOT_MAGIC:\n\tcase XFS_DINODE_MAGIC:\n\t\tgoto recover_immediately;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* unknown buffer contents, recover immediately */\n\nrecover_immediately:\n\treturn (xfs_lsn_t)-1;\n\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*(__be16 *)blk"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&mp->m_sb.sb_uuid",
            "uuid"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "((struct xfs_da3_blkinfo *)blk)->lsn"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "((struct xfs_da_blkinfo *)blk)->magic"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "((struct xfs_dsb *)blk)->sb_lsn"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "((struct xfs_attr3_rmt_hdr *)blk)->rm_lsn"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "((struct xfs_dir3_blk_hdr *)blk)->lsn"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "((struct xfs_dsymlink_hdr *)blk)->sl_lsn"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "((struct xfs_agi *)blk)->agi_lsn"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "((struct xfs_agfl *)blk)->agfl_lsn"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "((struct xfs_agf *)blk)->agf_lsn"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "btb->bb_u.l.bb_lsn"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "btb->bb_u.s.bb_lsn"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*(__be32 *)blk"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nstatic xfs_lsn_t\nxlog_recover_get_buf_lsn(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\t__uint32_t\t\tmagic32;\n\t__uint16_t\t\tmagic16;\n\t__uint16_t\t\tmagicda;\n\tvoid\t\t\t*blk = bp->b_addr;\n\tuuid_t\t\t\t*uuid;\n\txfs_lsn_t\t\tlsn = -1;\n\n\t/* v4 filesystems always recover immediately */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\tgoto recover_immediately;\n\n\tmagic32 = be32_to_cpu(*(__be32 *)blk);\n\tswitch (magic32) {\n\tcase XFS_ABTB_CRC_MAGIC:\n\tcase XFS_ABTC_CRC_MAGIC:\n\tcase XFS_ABTB_MAGIC:\n\tcase XFS_ABTC_MAGIC:\n\tcase XFS_IBT_CRC_MAGIC:\n\tcase XFS_IBT_MAGIC: {\n\t\tstruct xfs_btree_block *btb = blk;\n\n\t\tlsn = be64_to_cpu(btb->bb_u.s.bb_lsn);\n\t\tuuid = &btb->bb_u.s.bb_uuid;\n\t\tbreak;\n\t}\n\tcase XFS_BMAP_CRC_MAGIC:\n\tcase XFS_BMAP_MAGIC: {\n\t\tstruct xfs_btree_block *btb = blk;\n\n\t\tlsn = be64_to_cpu(btb->bb_u.l.bb_lsn);\n\t\tuuid = &btb->bb_u.l.bb_uuid;\n\t\tbreak;\n\t}\n\tcase XFS_AGF_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agf *)blk)->agf_lsn);\n\t\tuuid = &((struct xfs_agf *)blk)->agf_uuid;\n\t\tbreak;\n\tcase XFS_AGFL_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agfl *)blk)->agfl_lsn);\n\t\tuuid = &((struct xfs_agfl *)blk)->agfl_uuid;\n\t\tbreak;\n\tcase XFS_AGI_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agi *)blk)->agi_lsn);\n\t\tuuid = &((struct xfs_agi *)blk)->agi_uuid;\n\t\tbreak;\n\tcase XFS_SYMLINK_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dsymlink_hdr *)blk)->sl_lsn);\n\t\tuuid = &((struct xfs_dsymlink_hdr *)blk)->sl_uuid;\n\t\tbreak;\n\tcase XFS_DIR3_BLOCK_MAGIC:\n\tcase XFS_DIR3_DATA_MAGIC:\n\tcase XFS_DIR3_FREE_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dir3_blk_hdr *)blk)->lsn);\n\t\tuuid = &((struct xfs_dir3_blk_hdr *)blk)->uuid;\n\t\tbreak;\n\tcase XFS_ATTR3_RMT_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_attr3_rmt_hdr *)blk)->rm_lsn);\n\t\tuuid = &((struct xfs_attr3_rmt_hdr *)blk)->rm_uuid;\n\t\tbreak;\n\tcase XFS_SB_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dsb *)blk)->sb_lsn);\n\t\tuuid = &((struct xfs_dsb *)blk)->sb_uuid;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (lsn != (xfs_lsn_t)-1) {\n\t\tif (!uuid_equal(&mp->m_sb.sb_uuid, uuid))\n\t\t\tgoto recover_immediately;\n\t\treturn lsn;\n\t}\n\n\tmagicda = be16_to_cpu(((struct xfs_da_blkinfo *)blk)->magic);\n\tswitch (magicda) {\n\tcase XFS_DIR3_LEAF1_MAGIC:\n\tcase XFS_DIR3_LEAFN_MAGIC:\n\tcase XFS_DA3_NODE_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_da3_blkinfo *)blk)->lsn);\n\t\tuuid = &((struct xfs_da3_blkinfo *)blk)->uuid;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (lsn != (xfs_lsn_t)-1) {\n\t\tif (!uuid_equal(&mp->m_sb.sb_uuid, uuid))\n\t\t\tgoto recover_immediately;\n\t\treturn lsn;\n\t}\n\n\t/*\n\t * We do individual object checks on dquot and inode buffers as they\n\t * have their own individual LSN records. Also, we could have a stale\n\t * buffer here, so we have to at least recognise these buffer types.\n\t *\n\t * A notd complexity here is inode unlinked list processing - it logs\n\t * the inode directly in the buffer, but we don't know which inodes have\n\t * been modified, and there is no global buffer LSN. Hence we need to\n\t * recover all inode buffer types immediately. This problem will be\n\t * fixed by logical logging of the unlinked list modifications.\n\t */\n\tmagic16 = be16_to_cpu(*(__be16 *)blk);\n\tswitch (magic16) {\n\tcase XFS_DQUOT_MAGIC:\n\tcase XFS_DINODE_MAGIC:\n\t\tgoto recover_immediately;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* unknown buffer contents, recover immediately */\n\nrecover_immediately:\n\treturn (xfs_lsn_t)-1;\n\n}"
  },
  {
    "function_name": "xlog_recover_do_inode_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "1703-1807",
    "snippet": "STATIC int\nxlog_recover_do_inode_buffer(\n\tstruct xfs_mount\t*mp,\n\txlog_recover_item_t\t*item,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tint\t\t\ti;\n\tint\t\t\titem_index = 0;\n\tint\t\t\tbit = 0;\n\tint\t\t\tnbits = 0;\n\tint\t\t\treg_buf_offset = 0;\n\tint\t\t\treg_buf_bytes = 0;\n\tint\t\t\tnext_unlinked_offset;\n\tint\t\t\tinodes_per_buf;\n\txfs_agino_t\t\t*logged_nextp;\n\txfs_agino_t\t\t*buffer_nextp;\n\n\ttrace_xfs_log_recover_buf_inode_buf(mp->m_log, buf_f);\n\n\t/*\n\t * Post recovery validation only works properly on CRC enabled\n\t * filesystems.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\n\tinodes_per_buf = BBTOB(bp->b_io_length) >> mp->m_sb.sb_inodelog;\n\tfor (i = 0; i < inodes_per_buf; i++) {\n\t\tnext_unlinked_offset = (i * mp->m_sb.sb_inodesize) +\n\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\twhile (next_unlinked_offset >=\n\t\t       (reg_buf_offset + reg_buf_bytes)) {\n\t\t\t/*\n\t\t\t * The next di_next_unlinked field is beyond\n\t\t\t * the current logged region.  Find the next\n\t\t\t * logged region that contains or is beyond\n\t\t\t * the current di_next_unlinked field.\n\t\t\t */\n\t\t\tbit += nbits;\n\t\t\tbit = xfs_next_bit(buf_f->blf_data_map,\n\t\t\t\t\t   buf_f->blf_map_size, bit);\n\n\t\t\t/*\n\t\t\t * If there are no more logged regions in the\n\t\t\t * buffer, then we're done.\n\t\t\t */\n\t\t\tif (bit == -1)\n\t\t\t\treturn 0;\n\n\t\t\tnbits = xfs_contig_bits(buf_f->blf_data_map,\n\t\t\t\t\t\tbuf_f->blf_map_size, bit);\n\t\t\tASSERT(nbits > 0);\n\t\t\treg_buf_offset = bit << XFS_BLF_SHIFT;\n\t\t\treg_buf_bytes = nbits << XFS_BLF_SHIFT;\n\t\t\titem_index++;\n\t\t}\n\n\t\t/*\n\t\t * If the current logged region starts after the current\n\t\t * di_next_unlinked field, then move on to the next\n\t\t * di_next_unlinked field.\n\t\t */\n\t\tif (next_unlinked_offset < reg_buf_offset)\n\t\t\tcontinue;\n\n\t\tASSERT(item->ri_buf[item_index].i_addr != NULL);\n\t\tASSERT((item->ri_buf[item_index].i_len % XFS_BLF_CHUNK) == 0);\n\t\tASSERT((reg_buf_offset + reg_buf_bytes) <=\n\t\t\t\t\t\t\tBBTOB(bp->b_io_length));\n\n\t\t/*\n\t\t * The current logged region contains a copy of the\n\t\t * current di_next_unlinked field.  Extract its value\n\t\t * and copy it to the buffer copy.\n\t\t */\n\t\tlogged_nextp = item->ri_buf[item_index].i_addr +\n\t\t\t\tnext_unlinked_offset - reg_buf_offset;\n\t\tif (unlikely(*logged_nextp == 0)) {\n\t\t\txfs_alert(mp,\n\t\t\"Bad inode buffer log record (ptr = 0x%p, bp = 0x%p). \"\n\t\t\"Trying to replay bad (0) inode di_next_unlinked field.\",\n\t\t\t\titem, bp);\n\t\t\tXFS_ERROR_REPORT(\"xlog_recover_do_inode_buf\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tbuffer_nextp = (xfs_agino_t *)xfs_buf_offset(bp,\n\t\t\t\t\t      next_unlinked_offset);\n\t\t*buffer_nextp = *logged_nextp;\n\n\t\t/*\n\t\t * If necessary, recalculate the CRC in the on-disk inode. We\n\t\t * have to leave the inode in a consistent state for whoever\n\t\t * reads it next....\n\t\t */\n\t\txfs_dinode_calc_crc(mp, (struct xfs_dinode *)\n\t\t\t\txfs_buf_offset(bp, i * mp->m_sb.sb_inodesize));\n\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dinode_calc_crc",
          "args": [
            "mp",
            "(struct xfs_dinode *)\n\t\t\t\txfs_buf_offset(bp, i * mp->m_sb.sb_inodesize)"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_calc_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "314-328",
          "snippet": "void\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_offset",
          "args": [
            "bp",
            "i * mp->m_sb.sb_inodesize"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1422-1435",
          "snippet": "xfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xlog_recover_do_inode_buf\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"Bad inode buffer log record (ptr = 0x%p, bp = 0x%p). \"\n\t\t\"Trying to replay bad (0) inode di_next_unlinked field.\"",
            "item",
            "bp"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*logged_nextp == 0"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(reg_buf_offset + reg_buf_bytes) <=\n\t\t\t\t\t\t\tBBTOB(bp->b_io_length)"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_io_length"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(item->ri_buf[item_index].i_len % XFS_BLF_CHUNK) == 0"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "item->ri_buf[item_index].i_addr != NULL"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nbits > 0"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_contig_bits",
          "args": [
            "buf_f->blf_data_map",
            "buf_f->blf_map_size",
            "bit"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_contig_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bit.c",
          "lines": "48-78",
          "snippet": "int\nxfs_contig_bits(uint *map, uint\tsize, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = 0;\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tASSERT(start_bit < size);\n\tsize -= start_bit & ~(NBWORD - 1);\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to one first offset bits prior to start */\n\t\ttmp |= (~0U >> (NBWORD-start_bit));\n\t\tif (tmp != ~0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != ~0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn result - start_bit;\nfound:\n\treturn result + ffz(tmp) - start_bit;\n}",
          "includes": [
            "#include \"xfs_bit.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bit.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_contig_bits(uint *map, uint\tsize, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = 0;\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tASSERT(start_bit < size);\n\tsize -= start_bit & ~(NBWORD - 1);\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to one first offset bits prior to start */\n\t\ttmp |= (~0U >> (NBWORD-start_bit));\n\t\tif (tmp != ~0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != ~0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn result - start_bit;\nfound:\n\treturn result + ffz(tmp) - start_bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_next_bit",
          "args": [
            "buf_f->blf_data_map",
            "buf_f->blf_map_size",
            "bit"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bit.c",
          "lines": "88-118",
          "snippet": "int xfs_next_bit(uint *map, uint size, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = start_bit & ~(NBWORD - 1);\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tif (start_bit >= size)\n\t\treturn -1;\n\tsize -= result;\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to zero first offset bits prior to start */\n\t\ttmp &= (~0U << start_bit);\n\t\tif (tmp != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn -1;\nfound:\n\treturn result + ffs(tmp) - 1;\n}",
          "includes": [
            "#include \"xfs_bit.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bit.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs.h\"\n\nint xfs_next_bit(uint *map, uint size, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = start_bit & ~(NBWORD - 1);\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tif (start_bit >= size)\n\t\treturn -1;\n\tsize -= result;\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to zero first offset bits prior to start */\n\t\ttmp &= (~0U << start_bit);\n\t\tif (tmp != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn -1;\nfound:\n\treturn result + ffs(tmp) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_io_length"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_buf_inode_buf",
          "args": [
            "mp->m_log",
            "buf_f"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_do_inode_buffer(\n\tstruct xfs_mount\t*mp,\n\txlog_recover_item_t\t*item,\n\tstruct xfs_buf\t\t*bp,\n\txfs_buf_log_format_t\t*buf_f)\n{\n\tint\t\t\ti;\n\tint\t\t\titem_index = 0;\n\tint\t\t\tbit = 0;\n\tint\t\t\tnbits = 0;\n\tint\t\t\treg_buf_offset = 0;\n\tint\t\t\treg_buf_bytes = 0;\n\tint\t\t\tnext_unlinked_offset;\n\tint\t\t\tinodes_per_buf;\n\txfs_agino_t\t\t*logged_nextp;\n\txfs_agino_t\t\t*buffer_nextp;\n\n\ttrace_xfs_log_recover_buf_inode_buf(mp->m_log, buf_f);\n\n\t/*\n\t * Post recovery validation only works properly on CRC enabled\n\t * filesystems.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\n\tinodes_per_buf = BBTOB(bp->b_io_length) >> mp->m_sb.sb_inodelog;\n\tfor (i = 0; i < inodes_per_buf; i++) {\n\t\tnext_unlinked_offset = (i * mp->m_sb.sb_inodesize) +\n\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\n\t\twhile (next_unlinked_offset >=\n\t\t       (reg_buf_offset + reg_buf_bytes)) {\n\t\t\t/*\n\t\t\t * The next di_next_unlinked field is beyond\n\t\t\t * the current logged region.  Find the next\n\t\t\t * logged region that contains or is beyond\n\t\t\t * the current di_next_unlinked field.\n\t\t\t */\n\t\t\tbit += nbits;\n\t\t\tbit = xfs_next_bit(buf_f->blf_data_map,\n\t\t\t\t\t   buf_f->blf_map_size, bit);\n\n\t\t\t/*\n\t\t\t * If there are no more logged regions in the\n\t\t\t * buffer, then we're done.\n\t\t\t */\n\t\t\tif (bit == -1)\n\t\t\t\treturn 0;\n\n\t\t\tnbits = xfs_contig_bits(buf_f->blf_data_map,\n\t\t\t\t\t\tbuf_f->blf_map_size, bit);\n\t\t\tASSERT(nbits > 0);\n\t\t\treg_buf_offset = bit << XFS_BLF_SHIFT;\n\t\t\treg_buf_bytes = nbits << XFS_BLF_SHIFT;\n\t\t\titem_index++;\n\t\t}\n\n\t\t/*\n\t\t * If the current logged region starts after the current\n\t\t * di_next_unlinked field, then move on to the next\n\t\t * di_next_unlinked field.\n\t\t */\n\t\tif (next_unlinked_offset < reg_buf_offset)\n\t\t\tcontinue;\n\n\t\tASSERT(item->ri_buf[item_index].i_addr != NULL);\n\t\tASSERT((item->ri_buf[item_index].i_len % XFS_BLF_CHUNK) == 0);\n\t\tASSERT((reg_buf_offset + reg_buf_bytes) <=\n\t\t\t\t\t\t\tBBTOB(bp->b_io_length));\n\n\t\t/*\n\t\t * The current logged region contains a copy of the\n\t\t * current di_next_unlinked field.  Extract its value\n\t\t * and copy it to the buffer copy.\n\t\t */\n\t\tlogged_nextp = item->ri_buf[item_index].i_addr +\n\t\t\t\tnext_unlinked_offset - reg_buf_offset;\n\t\tif (unlikely(*logged_nextp == 0)) {\n\t\t\txfs_alert(mp,\n\t\t\"Bad inode buffer log record (ptr = 0x%p, bp = 0x%p). \"\n\t\t\"Trying to replay bad (0) inode di_next_unlinked field.\",\n\t\t\t\titem, bp);\n\t\t\tXFS_ERROR_REPORT(\"xlog_recover_do_inode_buf\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tbuffer_nextp = (xfs_agino_t *)xfs_buf_offset(bp,\n\t\t\t\t\t      next_unlinked_offset);\n\t\t*buffer_nextp = *logged_nextp;\n\n\t\t/*\n\t\t * If necessary, recalculate the CRC in the on-disk inode. We\n\t\t * have to leave the inode in a consistent state for whoever\n\t\t * reads it next....\n\t\t */\n\t\txfs_dinode_calc_crc(mp, (struct xfs_dinode *)\n\t\t\t\txfs_buf_offset(bp, i * mp->m_sb.sb_inodesize));\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_check_buffer_cancelled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "1663-1689",
    "snippet": "STATIC int\nxlog_check_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tbcp = xlog_peek_buffer_cancelled(log, blkno, len, flags);\n\tif (!bcp)\n\t\treturn 0;\n\n\t/*\n\t * We've go a match, so return 1 so that the recovery of this buffer\n\t * is cancelled.  If this buffer is actually a buffer cancel log\n\t * item, then decrement the refcount on the one in the table and\n\t * remove it if this is the last reference.\n\t */\n\tif (flags & XFS_BLF_CANCEL) {\n\t\tif (--bcp->bc_refcount == 0) {\n\t\t\tlist_del(&bcp->bc_list);\n\t\t\tkmem_free(bcp);\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "bcp"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&bcp->bc_list"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_peek_buffer_cancelled",
          "args": [
            "log",
            "blkno",
            "len",
            "flags"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_peek_buffer_cancelled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1623-1651",
          "snippet": "xfs_buf_cancel *\nxlog_peek_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct list_head\t*bucket;\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tif (!log->l_buf_cancel_table) {\n\t\t/* empty table means no cancelled buffers in the log */\n\t\tASSERT(!(flags & XFS_BLF_CANCEL));\n\t\treturn NULL;\n\t}\n\n\tbucket = XLOG_BUF_CANCEL_BUCKET(log, blkno);\n\tlist_for_each_entry(bcp, bucket, bc_list) {\n\t\tif (bcp->bc_blkno == blkno && bcp->bc_len == len)\n\t\t\treturn bcp;\n\t}\n\n\t/*\n\t * We didn't find a corresponding entry in the table, so return 0 so\n\t * that the buffer is NOT cancelled.\n\t */\n\tASSERT(!(flags & XFS_BLF_CANCEL));\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nxfs_buf_cancel *\nxlog_peek_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct list_head\t*bucket;\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tif (!log->l_buf_cancel_table) {\n\t\t/* empty table means no cancelled buffers in the log */\n\t\tASSERT(!(flags & XFS_BLF_CANCEL));\n\t\treturn NULL;\n\t}\n\n\tbucket = XLOG_BUF_CANCEL_BUCKET(log, blkno);\n\tlist_for_each_entry(bcp, bucket, bc_list) {\n\t\tif (bcp->bc_blkno == blkno && bcp->bc_len == len)\n\t\t\treturn bcp;\n\t}\n\n\t/*\n\t * We didn't find a corresponding entry in the table, so return 0 so\n\t * that the buffer is NOT cancelled.\n\t */\n\tASSERT(!(flags & XFS_BLF_CANCEL));\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_check_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tbcp = xlog_peek_buffer_cancelled(log, blkno, len, flags);\n\tif (!bcp)\n\t\treturn 0;\n\n\t/*\n\t * We've go a match, so return 1 so that the recovery of this buffer\n\t * is cancelled.  If this buffer is actually a buffer cancel log\n\t * item, then decrement the refcount on the one in the table and\n\t * remove it if this is the last reference.\n\t */\n\tif (flags & XFS_BLF_CANCEL) {\n\t\tif (--bcp->bc_refcount == 0) {\n\t\t\tlist_del(&bcp->bc_list);\n\t\t\tkmem_free(bcp);\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "xlog_peek_buffer_cancelled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "1623-1651",
    "snippet": "xfs_buf_cancel *\nxlog_peek_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct list_head\t*bucket;\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tif (!log->l_buf_cancel_table) {\n\t\t/* empty table means no cancelled buffers in the log */\n\t\tASSERT(!(flags & XFS_BLF_CANCEL));\n\t\treturn NULL;\n\t}\n\n\tbucket = XLOG_BUF_CANCEL_BUCKET(log, blkno);\n\tlist_for_each_entry(bcp, bucket, bc_list) {\n\t\tif (bcp->bc_blkno == blkno && bcp->bc_len == len)\n\t\t\treturn bcp;\n\t}\n\n\t/*\n\t * We didn't find a corresponding entry in the table, so return 0 so\n\t * that the buffer is NOT cancelled.\n\t */\n\tASSERT(!(flags & XFS_BLF_CANCEL));\n\treturn NULL;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(flags & XFS_BLF_CANCEL)"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bcp",
            "bucket",
            "bc_list"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_BUF_CANCEL_BUCKET",
          "args": [
            "log",
            "blkno"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(flags & XFS_BLF_CANCEL)"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nxfs_buf_cancel *\nxlog_peek_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tushort\t\t\tflags)\n{\n\tstruct list_head\t*bucket;\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tif (!log->l_buf_cancel_table) {\n\t\t/* empty table means no cancelled buffers in the log */\n\t\tASSERT(!(flags & XFS_BLF_CANCEL));\n\t\treturn NULL;\n\t}\n\n\tbucket = XLOG_BUF_CANCEL_BUCKET(log, blkno);\n\tlist_for_each_entry(bcp, bucket, bc_list) {\n\t\tif (bcp->bc_blkno == blkno && bcp->bc_len == len)\n\t\t\treturn bcp;\n\t}\n\n\t/*\n\t * We didn't find a corresponding entry in the table, so return 0 so\n\t * that the buffer is NOT cancelled.\n\t */\n\tASSERT(!(flags & XFS_BLF_CANCEL));\n\treturn NULL;\n}"
  },
  {
    "function_name": "xlog_recover_buffer_pass1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "1577-1616",
    "snippet": "STATIC int\nxlog_recover_buffer_pass1(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\txfs_buf_log_format_t\t*buf_f = item->ri_buf[0].i_addr;\n\tstruct list_head\t*bucket;\n\tstruct xfs_buf_cancel\t*bcp;\n\n\t/*\n\t * If this isn't a cancel buffer item, then just return.\n\t */\n\tif (!(buf_f->blf_flags & XFS_BLF_CANCEL)) {\n\t\ttrace_xfs_log_recover_buf_not_cancel(log, buf_f);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Insert an xfs_buf_cancel record into the hash table of them.\n\t * If there is already an identical record, bump its reference count.\n\t */\n\tbucket = XLOG_BUF_CANCEL_BUCKET(log, buf_f->blf_blkno);\n\tlist_for_each_entry(bcp, bucket, bc_list) {\n\t\tif (bcp->bc_blkno == buf_f->blf_blkno &&\n\t\t    bcp->bc_len == buf_f->blf_len) {\n\t\t\tbcp->bc_refcount++;\n\t\t\ttrace_xfs_log_recover_buf_cancel_ref_inc(log, buf_f);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tbcp = kmem_alloc(sizeof(struct xfs_buf_cancel), KM_SLEEP);\n\tbcp->bc_blkno = buf_f->blf_blkno;\n\tbcp->bc_len = buf_f->blf_len;\n\tbcp->bc_refcount = 1;\n\tlist_add_tail(&bcp->bc_list, bucket);\n\n\ttrace_xfs_log_recover_buf_cancel_add(log, buf_f);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_buf_cancel_add",
          "args": [
            "log",
            "buf_f"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&bcp->bc_list",
            "bucket"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "sizeof(struct xfs_buf_cancel)",
            "KM_SLEEP"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_buf_cancel_ref_inc",
          "args": [
            "log",
            "buf_f"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bcp",
            "bucket",
            "bc_list"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_BUF_CANCEL_BUCKET",
          "args": [
            "log",
            "buf_f->blf_blkno"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_buf_not_cancel",
          "args": [
            "log",
            "buf_f"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_buffer_pass1(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\txfs_buf_log_format_t\t*buf_f = item->ri_buf[0].i_addr;\n\tstruct list_head\t*bucket;\n\tstruct xfs_buf_cancel\t*bcp;\n\n\t/*\n\t * If this isn't a cancel buffer item, then just return.\n\t */\n\tif (!(buf_f->blf_flags & XFS_BLF_CANCEL)) {\n\t\ttrace_xfs_log_recover_buf_not_cancel(log, buf_f);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Insert an xfs_buf_cancel record into the hash table of them.\n\t * If there is already an identical record, bump its reference count.\n\t */\n\tbucket = XLOG_BUF_CANCEL_BUCKET(log, buf_f->blf_blkno);\n\tlist_for_each_entry(bcp, bucket, bc_list) {\n\t\tif (bcp->bc_blkno == buf_f->blf_blkno &&\n\t\t    bcp->bc_len == buf_f->blf_len) {\n\t\t\tbcp->bc_refcount++;\n\t\t\ttrace_xfs_log_recover_buf_cancel_ref_inc(log, buf_f);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tbcp = kmem_alloc(sizeof(struct xfs_buf_cancel), KM_SLEEP);\n\tbcp->bc_blkno = buf_f->blf_blkno;\n\tbcp->bc_len = buf_f->blf_len;\n\tbcp->bc_refcount = 1;\n\tlist_add_tail(&bcp->bc_list, bucket);\n\n\ttrace_xfs_log_recover_buf_cancel_add(log, buf_f);\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_recover_reorder_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "1493-1563",
    "snippet": "STATIC int\nxlog_recover_reorder_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\tint\t\t\tpass)\n{\n\txlog_recover_item_t\t*item, *n;\n\tint\t\t\terror = 0;\n\tLIST_HEAD(sort_list);\n\tLIST_HEAD(cancel_list);\n\tLIST_HEAD(buffer_list);\n\tLIST_HEAD(inode_buffer_list);\n\tLIST_HEAD(inode_list);\n\n\tlist_splice_init(&trans->r_itemq, &sort_list);\n\tlist_for_each_entry_safe(item, n, &sort_list, ri_list) {\n\t\txfs_buf_log_format_t\t*buf_f = item->ri_buf[0].i_addr;\n\n\t\tswitch (ITEM_TYPE(item)) {\n\t\tcase XFS_LI_ICREATE:\n\t\t\tlist_move_tail(&item->ri_list, &buffer_list);\n\t\t\tbreak;\n\t\tcase XFS_LI_BUF:\n\t\t\tif (buf_f->blf_flags & XFS_BLF_CANCEL) {\n\t\t\t\ttrace_xfs_log_recover_item_reorder_head(log,\n\t\t\t\t\t\t\ttrans, item, pass);\n\t\t\t\tlist_move(&item->ri_list, &cancel_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF) {\n\t\t\t\tlist_move(&item->ri_list, &inode_buffer_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_move_tail(&item->ri_list, &buffer_list);\n\t\t\tbreak;\n\t\tcase XFS_LI_INODE:\n\t\tcase XFS_LI_DQUOT:\n\t\tcase XFS_LI_QUOTAOFF:\n\t\tcase XFS_LI_EFD:\n\t\tcase XFS_LI_EFI:\n\t\t\ttrace_xfs_log_recover_item_reorder_tail(log,\n\t\t\t\t\t\t\ttrans, item, pass);\n\t\t\tlist_move_tail(&item->ri_list, &inode_list);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: unrecognized type of log operation\",\n\t\t\t\t__func__);\n\t\t\tASSERT(0);\n\t\t\t/*\n\t\t\t * return the remaining items back to the transaction\n\t\t\t * item list so they can be freed in caller.\n\t\t\t */\n\t\t\tif (!list_empty(&sort_list))\n\t\t\t\tlist_splice_init(&sort_list, &trans->r_itemq);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tASSERT(list_empty(&sort_list));\n\tif (!list_empty(&buffer_list))\n\t\tlist_splice(&buffer_list, &trans->r_itemq);\n\tif (!list_empty(&inode_list))\n\t\tlist_splice_tail(&inode_list, &trans->r_itemq);\n\tif (!list_empty(&inode_buffer_list))\n\t\tlist_splice_tail(&inode_buffer_list, &trans->r_itemq);\n\tif (!list_empty(&cancel_list))\n\t\tlist_splice_tail(&cancel_list, &trans->r_itemq);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_splice_tail",
          "args": [
            "&cancel_list",
            "&trans->r_itemq"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cancel_list"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail",
          "args": [
            "&inode_buffer_list",
            "&trans->r_itemq"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_tail",
          "args": [
            "&inode_list",
            "&trans->r_itemq"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&buffer_list",
            "&trans->r_itemq"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&sort_list)"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&sort_list",
            "&trans->r_itemq"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"%s: unrecognized type of log operation\"",
            "__func__"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&item->ri_list",
            "&inode_list"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_item_reorder_tail",
          "args": [
            "log",
            "trans",
            "item",
            "pass"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&item->ri_list",
            "&buffer_list"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&item->ri_list",
            "&inode_buffer_list"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&item->ri_list",
            "&cancel_list"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_recover_item_reorder_head",
          "args": [
            "log",
            "trans",
            "item",
            "pass"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&item->ri_list",
            "&buffer_list"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ITEM_TYPE",
          "args": [
            "item"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "item",
            "n",
            "&sort_list",
            "ri_list"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&trans->r_itemq",
            "&sort_list"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "inode_list"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "inode_buffer_list"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "buffer_list"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "cancel_list"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "sort_list"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_recover_reorder_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\tint\t\t\tpass)\n{\n\txlog_recover_item_t\t*item, *n;\n\tint\t\t\terror = 0;\n\tLIST_HEAD(sort_list);\n\tLIST_HEAD(cancel_list);\n\tLIST_HEAD(buffer_list);\n\tLIST_HEAD(inode_buffer_list);\n\tLIST_HEAD(inode_list);\n\n\tlist_splice_init(&trans->r_itemq, &sort_list);\n\tlist_for_each_entry_safe(item, n, &sort_list, ri_list) {\n\t\txfs_buf_log_format_t\t*buf_f = item->ri_buf[0].i_addr;\n\n\t\tswitch (ITEM_TYPE(item)) {\n\t\tcase XFS_LI_ICREATE:\n\t\t\tlist_move_tail(&item->ri_list, &buffer_list);\n\t\t\tbreak;\n\t\tcase XFS_LI_BUF:\n\t\t\tif (buf_f->blf_flags & XFS_BLF_CANCEL) {\n\t\t\t\ttrace_xfs_log_recover_item_reorder_head(log,\n\t\t\t\t\t\t\ttrans, item, pass);\n\t\t\t\tlist_move(&item->ri_list, &cancel_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF) {\n\t\t\t\tlist_move(&item->ri_list, &inode_buffer_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_move_tail(&item->ri_list, &buffer_list);\n\t\t\tbreak;\n\t\tcase XFS_LI_INODE:\n\t\tcase XFS_LI_DQUOT:\n\t\tcase XFS_LI_QUOTAOFF:\n\t\tcase XFS_LI_EFD:\n\t\tcase XFS_LI_EFI:\n\t\t\ttrace_xfs_log_recover_item_reorder_tail(log,\n\t\t\t\t\t\t\ttrans, item, pass);\n\t\t\tlist_move_tail(&item->ri_list, &inode_list);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: unrecognized type of log operation\",\n\t\t\t\t__func__);\n\t\t\tASSERT(0);\n\t\t\t/*\n\t\t\t * return the remaining items back to the transaction\n\t\t\t * item list so they can be freed in caller.\n\t\t\t */\n\t\t\tif (!list_empty(&sort_list))\n\t\t\t\tlist_splice_init(&sort_list, &trans->r_itemq);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tASSERT(list_empty(&sort_list));\n\tif (!list_empty(&buffer_list))\n\t\tlist_splice(&buffer_list, &trans->r_itemq);\n\tif (!list_empty(&inode_list))\n\t\tlist_splice_tail(&inode_list, &trans->r_itemq);\n\tif (!list_empty(&inode_buffer_list))\n\t\tlist_splice_tail(&inode_buffer_list, &trans->r_itemq);\n\tif (!list_empty(&cancel_list))\n\t\tlist_splice_tail(&cancel_list, &trans->r_itemq);\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_clear_stale_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "1321-1435",
    "snippet": "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*log,\n\txfs_lsn_t\ttail_lsn)\n{\n\tint\t\ttail_cycle, head_cycle;\n\tint\t\ttail_block, head_block;\n\tint\t\ttail_distance, max_distance;\n\tint\t\tdistance;\n\tint\t\terror;\n\n\ttail_cycle = CYCLE_LSN(tail_lsn);\n\ttail_block = BLOCK_LSN(tail_lsn);\n\thead_cycle = log->l_curr_cycle;\n\thead_block = log->l_curr_block;\n\n\t/*\n\t * Figure out the distance between the new head of the log\n\t * and the tail.  We want to write over any blocks beyond the\n\t * head that we may have written just before the crash, but\n\t * we don't want to overwrite the tail of the log.\n\t */\n\tif (head_cycle == tail_cycle) {\n\t\t/*\n\t\t * The tail is behind the head in the physical log,\n\t\t * so the distance from the head to the tail is the\n\t\t * distance from the head to the end of the log plus\n\t\t * the distance from the beginning of the log to the\n\t\t * tail.\n\t\t */\n\t\tif (unlikely(head_block < tail_block || head_block >= log->l_logBBsize)) {\n\t\t\tXFS_ERROR_REPORT(\"xlog_clear_stale_blocks(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, log->l_mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\ttail_distance = tail_block + (log->l_logBBsize - head_block);\n\t} else {\n\t\t/*\n\t\t * The head is behind the tail in the physical log,\n\t\t * so the distance from the head to the tail is just\n\t\t * the tail block minus the head block.\n\t\t */\n\t\tif (unlikely(head_block >= tail_block || head_cycle != (tail_cycle + 1))){\n\t\t\tXFS_ERROR_REPORT(\"xlog_clear_stale_blocks(2)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, log->l_mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\ttail_distance = tail_block - head_block;\n\t}\n\n\t/*\n\t * If the head is right up against the tail, we can't clear\n\t * anything.\n\t */\n\tif (tail_distance <= 0) {\n\t\tASSERT(tail_distance == 0);\n\t\treturn 0;\n\t}\n\n\tmax_distance = XLOG_TOTAL_REC_SHIFT(log);\n\t/*\n\t * Take the smaller of the maximum amount of outstanding I/O\n\t * we could have and the distance to the tail to clear out.\n\t * We take the smaller so that we don't overwrite the tail and\n\t * we don't waste all day writing from the head to the tail\n\t * for no reason.\n\t */\n\tmax_distance = MIN(max_distance, tail_distance);\n\n\tif ((head_block + max_distance) <= log->l_logBBsize) {\n\t\t/*\n\t\t * We can stomp all the blocks we need to without\n\t\t * wrapping around the end of the log.  Just do it\n\t\t * in a single write.  Use the cycle number of the\n\t\t * current cycle minus one so that the log will look like:\n\t\t *     n ... | n - 1 ...\n\t\t */\n\t\terror = xlog_write_log_records(log, (head_cycle - 1),\n\t\t\t\thead_block, max_distance, tail_cycle,\n\t\t\t\ttail_block);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\t/*\n\t\t * We need to wrap around the end of the physical log in\n\t\t * order to clear all the blocks.  Do it in two separate\n\t\t * I/Os.  The first write should be from the head to the\n\t\t * end of the physical log, and it should use the current\n\t\t * cycle number minus one just like above.\n\t\t */\n\t\tdistance = log->l_logBBsize - head_block;\n\t\terror = xlog_write_log_records(log, (head_cycle - 1),\n\t\t\t\thead_block, distance, tail_cycle,\n\t\t\t\ttail_block);\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Now write the blocks at the start of the physical log.\n\t\t * This writes the remainder of the blocks we want to clear.\n\t\t * It uses the current cycle number since we're now on the\n\t\t * same cycle as the head so that we get:\n\t\t *    n ... n ... | n - 1 ...\n\t\t *    ^^^^^ blocks we're writing\n\t\t */\n\t\tdistance = max_distance - (log->l_logBBsize - head_block);\n\t\terror = xlog_write_log_records(log, head_cycle, 0, distance,\n\t\t\t\ttail_cycle, tail_block);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_write_log_records",
          "args": [
            "log",
            "head_cycle",
            "0",
            "distance",
            "tail_cycle",
            "tail_block"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_write_log_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1221-1303",
          "snippet": "STATIC int\nxlog_write_log_records(\n\tstruct xlog\t*log,\n\tint\t\tcycle,\n\tint\t\tstart_block,\n\tint\t\tblocks,\n\tint\t\ttail_cycle,\n\tint\t\ttail_block)\n{\n\txfs_caddr_t\toffset;\n\txfs_buf_t\t*bp;\n\tint\t\tbalign, ealign;\n\tint\t\tsectbb = log->l_sectBBsize;\n\tint\t\tend_block = start_block + blocks;\n\tint\t\tbufblks;\n\tint\t\terror = 0;\n\tint\t\ti, j = 0;\n\n\t/*\n\t * Greedily allocate a buffer big enough to handle the full\n\t * range of basic blocks to be written.  If that fails, try\n\t * a smaller size.  We need to be able to write at least a\n\t * log sector, or we're out of luck.\n\t */\n\tbufblks = 1 << ffs(blocks);\n\twhile (bufblks > log->l_logBBsize)\n\t\tbufblks >>= 1;\n\twhile (!(bp = xlog_get_bp(log, bufblks))) {\n\t\tbufblks >>= 1;\n\t\tif (bufblks < sectbb)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We may need to do a read at the start to fill in part of\n\t * the buffer in the starting sector not covered by the first\n\t * write below.\n\t */\n\tbalign = round_down(start_block, sectbb);\n\tif (balign != start_block) {\n\t\terror = xlog_bread_noalign(log, start_block, 1, bp);\n\t\tif (error)\n\t\t\tgoto out_put_bp;\n\n\t\tj = start_block - balign;\n\t}\n\n\tfor (i = start_block; i < end_block; i += bufblks) {\n\t\tint\t\tbcount, endcount;\n\n\t\tbcount = min(bufblks, end_block - start_block);\n\t\tendcount = bcount - j;\n\n\t\t/* We may need to do a read at the end to fill in part of\n\t\t * the buffer in the final sector not covered by the write.\n\t\t * If this is the same sector as the above read, skip it.\n\t\t */\n\t\tealign = round_down(end_block, sectbb);\n\t\tif (j == 0 && (start_block + endcount > ealign)) {\n\t\t\toffset = bp->b_addr + BBTOB(ealign - start_block);\n\t\t\terror = xlog_bread_offset(log, ealign, sectbb,\n\t\t\t\t\t\t\tbp, offset);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\toffset = xlog_align(log, start_block, endcount, bp);\n\t\tfor (; j < endcount; j++) {\n\t\t\txlog_add_record(log, offset, cycle, i+j,\n\t\t\t\t\ttail_cycle, tail_block);\n\t\t\toffset += BBSIZE;\n\t\t}\n\t\terror = xlog_bwrite(log, start_block, endcount, bp);\n\t\tif (error)\n\t\t\tbreak;\n\t\tstart_block += endcount;\n\t\tj = 0;\n\t}\n\n out_put_bp:\n\txlog_put_bp(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_write_log_records(\n\tstruct xlog\t*log,\n\tint\t\tcycle,\n\tint\t\tstart_block,\n\tint\t\tblocks,\n\tint\t\ttail_cycle,\n\tint\t\ttail_block)\n{\n\txfs_caddr_t\toffset;\n\txfs_buf_t\t*bp;\n\tint\t\tbalign, ealign;\n\tint\t\tsectbb = log->l_sectBBsize;\n\tint\t\tend_block = start_block + blocks;\n\tint\t\tbufblks;\n\tint\t\terror = 0;\n\tint\t\ti, j = 0;\n\n\t/*\n\t * Greedily allocate a buffer big enough to handle the full\n\t * range of basic blocks to be written.  If that fails, try\n\t * a smaller size.  We need to be able to write at least a\n\t * log sector, or we're out of luck.\n\t */\n\tbufblks = 1 << ffs(blocks);\n\twhile (bufblks > log->l_logBBsize)\n\t\tbufblks >>= 1;\n\twhile (!(bp = xlog_get_bp(log, bufblks))) {\n\t\tbufblks >>= 1;\n\t\tif (bufblks < sectbb)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We may need to do a read at the start to fill in part of\n\t * the buffer in the starting sector not covered by the first\n\t * write below.\n\t */\n\tbalign = round_down(start_block, sectbb);\n\tif (balign != start_block) {\n\t\terror = xlog_bread_noalign(log, start_block, 1, bp);\n\t\tif (error)\n\t\t\tgoto out_put_bp;\n\n\t\tj = start_block - balign;\n\t}\n\n\tfor (i = start_block; i < end_block; i += bufblks) {\n\t\tint\t\tbcount, endcount;\n\n\t\tbcount = min(bufblks, end_block - start_block);\n\t\tendcount = bcount - j;\n\n\t\t/* We may need to do a read at the end to fill in part of\n\t\t * the buffer in the final sector not covered by the write.\n\t\t * If this is the same sector as the above read, skip it.\n\t\t */\n\t\tealign = round_down(end_block, sectbb);\n\t\tif (j == 0 && (start_block + endcount > ealign)) {\n\t\t\toffset = bp->b_addr + BBTOB(ealign - start_block);\n\t\t\terror = xlog_bread_offset(log, ealign, sectbb,\n\t\t\t\t\t\t\tbp, offset);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\toffset = xlog_align(log, start_block, endcount, bp);\n\t\tfor (; j < endcount; j++) {\n\t\t\txlog_add_record(log, offset, cycle, i+j,\n\t\t\t\t\ttail_cycle, tail_block);\n\t\t\toffset += BBSIZE;\n\t\t}\n\t\terror = xlog_bwrite(log, start_block, endcount, bp);\n\t\tif (error)\n\t\t\tbreak;\n\t\tstart_block += endcount;\n\t\tj = 0;\n\t}\n\n out_put_bp:\n\txlog_put_bp(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "max_distance",
            "tail_distance"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_TOTAL_REC_SHIFT",
          "args": [
            "log"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tail_distance == 0"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xlog_clear_stale_blocks(2)\"",
            "XFS_ERRLEVEL_LOW",
            "log->l_mp"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "head_block >= tail_block || head_cycle != (tail_cycle + 1)"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xlog_clear_stale_blocks(1)\"",
            "XFS_ERRLEVEL_LOW",
            "log->l_mp"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "head_block < tail_block || head_block >= log->l_logBBsize"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLOCK_LSN",
          "args": [
            "tail_lsn"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CYCLE_LSN",
          "args": [
            "tail_lsn"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*log,\n\txfs_lsn_t\ttail_lsn)\n{\n\tint\t\ttail_cycle, head_cycle;\n\tint\t\ttail_block, head_block;\n\tint\t\ttail_distance, max_distance;\n\tint\t\tdistance;\n\tint\t\terror;\n\n\ttail_cycle = CYCLE_LSN(tail_lsn);\n\ttail_block = BLOCK_LSN(tail_lsn);\n\thead_cycle = log->l_curr_cycle;\n\thead_block = log->l_curr_block;\n\n\t/*\n\t * Figure out the distance between the new head of the log\n\t * and the tail.  We want to write over any blocks beyond the\n\t * head that we may have written just before the crash, but\n\t * we don't want to overwrite the tail of the log.\n\t */\n\tif (head_cycle == tail_cycle) {\n\t\t/*\n\t\t * The tail is behind the head in the physical log,\n\t\t * so the distance from the head to the tail is the\n\t\t * distance from the head to the end of the log plus\n\t\t * the distance from the beginning of the log to the\n\t\t * tail.\n\t\t */\n\t\tif (unlikely(head_block < tail_block || head_block >= log->l_logBBsize)) {\n\t\t\tXFS_ERROR_REPORT(\"xlog_clear_stale_blocks(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, log->l_mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\ttail_distance = tail_block + (log->l_logBBsize - head_block);\n\t} else {\n\t\t/*\n\t\t * The head is behind the tail in the physical log,\n\t\t * so the distance from the head to the tail is just\n\t\t * the tail block minus the head block.\n\t\t */\n\t\tif (unlikely(head_block >= tail_block || head_cycle != (tail_cycle + 1))){\n\t\t\tXFS_ERROR_REPORT(\"xlog_clear_stale_blocks(2)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, log->l_mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\ttail_distance = tail_block - head_block;\n\t}\n\n\t/*\n\t * If the head is right up against the tail, we can't clear\n\t * anything.\n\t */\n\tif (tail_distance <= 0) {\n\t\tASSERT(tail_distance == 0);\n\t\treturn 0;\n\t}\n\n\tmax_distance = XLOG_TOTAL_REC_SHIFT(log);\n\t/*\n\t * Take the smaller of the maximum amount of outstanding I/O\n\t * we could have and the distance to the tail to clear out.\n\t * We take the smaller so that we don't overwrite the tail and\n\t * we don't waste all day writing from the head to the tail\n\t * for no reason.\n\t */\n\tmax_distance = MIN(max_distance, tail_distance);\n\n\tif ((head_block + max_distance) <= log->l_logBBsize) {\n\t\t/*\n\t\t * We can stomp all the blocks we need to without\n\t\t * wrapping around the end of the log.  Just do it\n\t\t * in a single write.  Use the cycle number of the\n\t\t * current cycle minus one so that the log will look like:\n\t\t *     n ... | n - 1 ...\n\t\t */\n\t\terror = xlog_write_log_records(log, (head_cycle - 1),\n\t\t\t\thead_block, max_distance, tail_cycle,\n\t\t\t\ttail_block);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\t/*\n\t\t * We need to wrap around the end of the physical log in\n\t\t * order to clear all the blocks.  Do it in two separate\n\t\t * I/Os.  The first write should be from the head to the\n\t\t * end of the physical log, and it should use the current\n\t\t * cycle number minus one just like above.\n\t\t */\n\t\tdistance = log->l_logBBsize - head_block;\n\t\terror = xlog_write_log_records(log, (head_cycle - 1),\n\t\t\t\thead_block, distance, tail_cycle,\n\t\t\t\ttail_block);\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Now write the blocks at the start of the physical log.\n\t\t * This writes the remainder of the blocks we want to clear.\n\t\t * It uses the current cycle number since we're now on the\n\t\t * same cycle as the head so that we get:\n\t\t *    n ... n ... | n - 1 ...\n\t\t *    ^^^^^ blocks we're writing\n\t\t */\n\t\tdistance = max_distance - (log->l_logBBsize - head_block);\n\t\terror = xlog_write_log_records(log, head_cycle, 0, distance,\n\t\t\t\ttail_cycle, tail_block);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_write_log_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "1221-1303",
    "snippet": "STATIC int\nxlog_write_log_records(\n\tstruct xlog\t*log,\n\tint\t\tcycle,\n\tint\t\tstart_block,\n\tint\t\tblocks,\n\tint\t\ttail_cycle,\n\tint\t\ttail_block)\n{\n\txfs_caddr_t\toffset;\n\txfs_buf_t\t*bp;\n\tint\t\tbalign, ealign;\n\tint\t\tsectbb = log->l_sectBBsize;\n\tint\t\tend_block = start_block + blocks;\n\tint\t\tbufblks;\n\tint\t\terror = 0;\n\tint\t\ti, j = 0;\n\n\t/*\n\t * Greedily allocate a buffer big enough to handle the full\n\t * range of basic blocks to be written.  If that fails, try\n\t * a smaller size.  We need to be able to write at least a\n\t * log sector, or we're out of luck.\n\t */\n\tbufblks = 1 << ffs(blocks);\n\twhile (bufblks > log->l_logBBsize)\n\t\tbufblks >>= 1;\n\twhile (!(bp = xlog_get_bp(log, bufblks))) {\n\t\tbufblks >>= 1;\n\t\tif (bufblks < sectbb)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We may need to do a read at the start to fill in part of\n\t * the buffer in the starting sector not covered by the first\n\t * write below.\n\t */\n\tbalign = round_down(start_block, sectbb);\n\tif (balign != start_block) {\n\t\terror = xlog_bread_noalign(log, start_block, 1, bp);\n\t\tif (error)\n\t\t\tgoto out_put_bp;\n\n\t\tj = start_block - balign;\n\t}\n\n\tfor (i = start_block; i < end_block; i += bufblks) {\n\t\tint\t\tbcount, endcount;\n\n\t\tbcount = min(bufblks, end_block - start_block);\n\t\tendcount = bcount - j;\n\n\t\t/* We may need to do a read at the end to fill in part of\n\t\t * the buffer in the final sector not covered by the write.\n\t\t * If this is the same sector as the above read, skip it.\n\t\t */\n\t\tealign = round_down(end_block, sectbb);\n\t\tif (j == 0 && (start_block + endcount > ealign)) {\n\t\t\toffset = bp->b_addr + BBTOB(ealign - start_block);\n\t\t\terror = xlog_bread_offset(log, ealign, sectbb,\n\t\t\t\t\t\t\tbp, offset);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\toffset = xlog_align(log, start_block, endcount, bp);\n\t\tfor (; j < endcount; j++) {\n\t\t\txlog_add_record(log, offset, cycle, i+j,\n\t\t\t\t\ttail_cycle, tail_block);\n\t\t\toffset += BBSIZE;\n\t\t}\n\t\terror = xlog_bwrite(log, start_block, endcount, bp);\n\t\tif (error)\n\t\t\tbreak;\n\t\tstart_block += endcount;\n\t\tj = 0;\n\t}\n\n out_put_bp:\n\txlog_put_bp(bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_put_bp",
          "args": [
            "bp"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_put_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "139-144",
          "snippet": "STATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_bwrite",
          "args": [
            "log",
            "start_block",
            "endcount",
            "bp"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_bwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "252-286",
          "snippet": "STATIC int\nxlog_bwrite(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tblk_no = round_down(blk_no, log->l_sectBBsize);\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tASSERT(nbblks > 0);\n\tASSERT(nbblks <= bp->b_length);\n\n\tXFS_BUF_SET_ADDR(bp, log->l_logBBstart + blk_no);\n\tXFS_BUF_ZEROFLAGS(bp);\n\txfs_buf_hold(bp);\n\txfs_buf_lock(bp);\n\tbp->b_io_length = nbblks;\n\tbp->b_error = 0;\n\n\terror = xfs_bwrite(bp);\n\tif (error)\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\txfs_buf_relse(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bwrite(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tblk_no = round_down(blk_no, log->l_sectBBsize);\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tASSERT(nbblks > 0);\n\tASSERT(nbblks <= bp->b_length);\n\n\tXFS_BUF_SET_ADDR(bp, log->l_logBBstart + blk_no);\n\tXFS_BUF_ZEROFLAGS(bp);\n\txfs_buf_hold(bp);\n\txfs_buf_lock(bp);\n\tbp->b_io_length = nbblks;\n\tbp->b_error = 0;\n\n\terror = xfs_bwrite(bp);\n\tif (error)\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\txfs_buf_relse(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_add_record",
          "args": [
            "log",
            "offset",
            "cycle",
            "i+j",
            "tail_cycle",
            "tail_block"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_add_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1199-1219",
          "snippet": "STATIC void\nxlog_add_record(\n\tstruct xlog\t\t*log,\n\txfs_caddr_t\t\tbuf,\n\tint\t\t\tcycle,\n\tint\t\t\tblock,\n\tint\t\t\ttail_cycle,\n\tint\t\t\ttail_block)\n{\n\txlog_rec_header_t\t*recp = (xlog_rec_header_t *)buf;\n\n\tmemset(buf, 0, BBSIZE);\n\trecp->h_magicno = cpu_to_be32(XLOG_HEADER_MAGIC_NUM);\n\trecp->h_cycle = cpu_to_be32(cycle);\n\trecp->h_version = cpu_to_be32(\n\t\t\txfs_sb_version_haslogv2(&log->l_mp->m_sb) ? 2 : 1);\n\trecp->h_lsn = cpu_to_be64(xlog_assign_lsn(cycle, block));\n\trecp->h_tail_lsn = cpu_to_be64(xlog_assign_lsn(tail_cycle, tail_block));\n\trecp->h_fmt = cpu_to_be32(XLOG_FMT);\n\tmemcpy(&recp->h_fs_uuid, &log->l_mp->m_sb.sb_uuid, sizeof(uuid_t));\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_add_record(\n\tstruct xlog\t\t*log,\n\txfs_caddr_t\t\tbuf,\n\tint\t\t\tcycle,\n\tint\t\t\tblock,\n\tint\t\t\ttail_cycle,\n\tint\t\t\ttail_block)\n{\n\txlog_rec_header_t\t*recp = (xlog_rec_header_t *)buf;\n\n\tmemset(buf, 0, BBSIZE);\n\trecp->h_magicno = cpu_to_be32(XLOG_HEADER_MAGIC_NUM);\n\trecp->h_cycle = cpu_to_be32(cycle);\n\trecp->h_version = cpu_to_be32(\n\t\t\txfs_sb_version_haslogv2(&log->l_mp->m_sb) ? 2 : 1);\n\trecp->h_lsn = cpu_to_be64(xlog_assign_lsn(cycle, block));\n\trecp->h_tail_lsn = cpu_to_be64(xlog_assign_lsn(tail_cycle, tail_block));\n\trecp->h_fmt = cpu_to_be32(XLOG_FMT);\n\tmemcpy(&recp->h_fs_uuid, &log->l_mp->m_sb.sb_uuid, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_align",
          "args": [
            "log",
            "start_block",
            "endcount",
            "bp"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_align",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "150-161",
          "snippet": "STATIC xfs_caddr_t\nxlog_align(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_daddr_t\toffset = blk_no & ((xfs_daddr_t)log->l_sectBBsize - 1);\n\n\tASSERT(offset + nbblks <= bp->b_length);\n\treturn bp->b_addr + BBTOB(offset);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_caddr_t\nxlog_align(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_daddr_t\toffset = blk_no & ((xfs_daddr_t)log->l_sectBBsize - 1);\n\n\tASSERT(offset + nbblks <= bp->b_length);\n\treturn bp->b_addr + BBTOB(offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_bread_offset",
          "args": [
            "log",
            "ealign",
            "sectbb",
            "bp",
            "offset"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_bread_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "222-245",
          "snippet": "STATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "ealign - start_block"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "end_block",
            "sectbb"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bufblks",
            "end_block - start_block"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_bread_noalign",
          "args": [
            "log",
            "start_block",
            "1",
            "bp"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_bread_noalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "167-198",
          "snippet": "STATIC int\nxlog_bread_noalign(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tblk_no = round_down(blk_no, log->l_sectBBsize);\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tASSERT(nbblks > 0);\n\tASSERT(nbblks <= bp->b_length);\n\n\tXFS_BUF_SET_ADDR(bp, log->l_logBBstart + blk_no);\n\tXFS_BUF_READ(bp);\n\tbp->b_io_length = nbblks;\n\tbp->b_error = 0;\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error && !XFS_FORCED_SHUTDOWN(log->l_mp))\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread_noalign(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tblk_no = round_down(blk_no, log->l_sectBBsize);\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tASSERT(nbblks > 0);\n\tASSERT(nbblks <= bp->b_length);\n\n\tXFS_BUF_SET_ADDR(bp, log->l_logBBstart + blk_no);\n\tXFS_BUF_READ(bp);\n\tbp->b_io_length = nbblks;\n\tbp->b_error = 0;\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error && !XFS_FORCED_SHUTDOWN(log->l_mp))\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "start_block",
            "sectbb"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_get_bp",
          "args": [
            "log",
            "bufblks"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "99-137",
          "snippet": "STATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "blocks"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_max_file_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "561-593",
          "snippet": "__uint64_t\nxfs_max_file_offset(\n\tunsigned int\t\tblockshift)\n{\n\tunsigned int\t\tpagefactor = 1;\n\tunsigned int\t\tbitshift = BITS_PER_LONG - 1;\n\n\t/* Figure out maximum filesize, on Linux this can depend on\n\t * the filesystem blocksize (on 32 bit platforms).\n\t * __block_write_begin does this in an [unsigned] long...\n\t *      page->index << (PAGE_CACHE_SHIFT - bbits)\n\t * So, for page sized blocks (4K on 32 bit platforms),\n\t * this wraps at around 8Tb (hence MAX_LFS_FILESIZE which is\n\t *      (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)\n\t * but for smaller blocksizes it is less (bbits = log2 bsize).\n\t * Note1: get_block_t takes a long (implicit cast from above)\n\t * Note2: The Large Block Device (LBD and HAVE_SECTOR_T) patch\n\t * can optionally convert the [unsigned] long from above into\n\t * an [unsigned] long long.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tASSERT(sizeof(sector_t) == 8);\n\tpagefactor = PAGE_CACHE_SIZE;\n\tbitshift = BITS_PER_LONG;\n# else\n\tpagefactor = PAGE_CACHE_SIZE >> (PAGE_CACHE_SHIFT - blockshift);\n# endif\n#endif\n\n\treturn (((__uint64_t)pagefactor) << bitshift) - 1;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n__uint64_t\nxfs_max_file_offset(\n\tunsigned int\t\tblockshift)\n{\n\tunsigned int\t\tpagefactor = 1;\n\tunsigned int\t\tbitshift = BITS_PER_LONG - 1;\n\n\t/* Figure out maximum filesize, on Linux this can depend on\n\t * the filesystem blocksize (on 32 bit platforms).\n\t * __block_write_begin does this in an [unsigned] long...\n\t *      page->index << (PAGE_CACHE_SHIFT - bbits)\n\t * So, for page sized blocks (4K on 32 bit platforms),\n\t * this wraps at around 8Tb (hence MAX_LFS_FILESIZE which is\n\t *      (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)\n\t * but for smaller blocksizes it is less (bbits = log2 bsize).\n\t * Note1: get_block_t takes a long (implicit cast from above)\n\t * Note2: The Large Block Device (LBD and HAVE_SECTOR_T) patch\n\t * can optionally convert the [unsigned] long from above into\n\t * an [unsigned] long long.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tASSERT(sizeof(sector_t) == 8);\n\tpagefactor = PAGE_CACHE_SIZE;\n\tbitshift = BITS_PER_LONG;\n# else\n\tpagefactor = PAGE_CACHE_SIZE >> (PAGE_CACHE_SHIFT - blockshift);\n# endif\n#endif\n\n\treturn (((__uint64_t)pagefactor) << bitshift) - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_write_log_records(\n\tstruct xlog\t*log,\n\tint\t\tcycle,\n\tint\t\tstart_block,\n\tint\t\tblocks,\n\tint\t\ttail_cycle,\n\tint\t\ttail_block)\n{\n\txfs_caddr_t\toffset;\n\txfs_buf_t\t*bp;\n\tint\t\tbalign, ealign;\n\tint\t\tsectbb = log->l_sectBBsize;\n\tint\t\tend_block = start_block + blocks;\n\tint\t\tbufblks;\n\tint\t\terror = 0;\n\tint\t\ti, j = 0;\n\n\t/*\n\t * Greedily allocate a buffer big enough to handle the full\n\t * range of basic blocks to be written.  If that fails, try\n\t * a smaller size.  We need to be able to write at least a\n\t * log sector, or we're out of luck.\n\t */\n\tbufblks = 1 << ffs(blocks);\n\twhile (bufblks > log->l_logBBsize)\n\t\tbufblks >>= 1;\n\twhile (!(bp = xlog_get_bp(log, bufblks))) {\n\t\tbufblks >>= 1;\n\t\tif (bufblks < sectbb)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We may need to do a read at the start to fill in part of\n\t * the buffer in the starting sector not covered by the first\n\t * write below.\n\t */\n\tbalign = round_down(start_block, sectbb);\n\tif (balign != start_block) {\n\t\terror = xlog_bread_noalign(log, start_block, 1, bp);\n\t\tif (error)\n\t\t\tgoto out_put_bp;\n\n\t\tj = start_block - balign;\n\t}\n\n\tfor (i = start_block; i < end_block; i += bufblks) {\n\t\tint\t\tbcount, endcount;\n\n\t\tbcount = min(bufblks, end_block - start_block);\n\t\tendcount = bcount - j;\n\n\t\t/* We may need to do a read at the end to fill in part of\n\t\t * the buffer in the final sector not covered by the write.\n\t\t * If this is the same sector as the above read, skip it.\n\t\t */\n\t\tealign = round_down(end_block, sectbb);\n\t\tif (j == 0 && (start_block + endcount > ealign)) {\n\t\t\toffset = bp->b_addr + BBTOB(ealign - start_block);\n\t\t\terror = xlog_bread_offset(log, ealign, sectbb,\n\t\t\t\t\t\t\tbp, offset);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\toffset = xlog_align(log, start_block, endcount, bp);\n\t\tfor (; j < endcount; j++) {\n\t\t\txlog_add_record(log, offset, cycle, i+j,\n\t\t\t\t\ttail_cycle, tail_block);\n\t\t\toffset += BBSIZE;\n\t\t}\n\t\terror = xlog_bwrite(log, start_block, endcount, bp);\n\t\tif (error)\n\t\t\tbreak;\n\t\tstart_block += endcount;\n\t\tj = 0;\n\t}\n\n out_put_bp:\n\txlog_put_bp(bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_add_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "1199-1219",
    "snippet": "STATIC void\nxlog_add_record(\n\tstruct xlog\t\t*log,\n\txfs_caddr_t\t\tbuf,\n\tint\t\t\tcycle,\n\tint\t\t\tblock,\n\tint\t\t\ttail_cycle,\n\tint\t\t\ttail_block)\n{\n\txlog_rec_header_t\t*recp = (xlog_rec_header_t *)buf;\n\n\tmemset(buf, 0, BBSIZE);\n\trecp->h_magicno = cpu_to_be32(XLOG_HEADER_MAGIC_NUM);\n\trecp->h_cycle = cpu_to_be32(cycle);\n\trecp->h_version = cpu_to_be32(\n\t\t\txfs_sb_version_haslogv2(&log->l_mp->m_sb) ? 2 : 1);\n\trecp->h_lsn = cpu_to_be64(xlog_assign_lsn(cycle, block));\n\trecp->h_tail_lsn = cpu_to_be64(xlog_assign_lsn(tail_cycle, tail_block));\n\trecp->h_fmt = cpu_to_be32(XLOG_FMT);\n\tmemcpy(&recp->h_fs_uuid, &log->l_mp->m_sb.sb_uuid, sizeof(uuid_t));\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&recp->h_fs_uuid",
            "&log->l_mp->m_sb.sb_uuid",
            "sizeof(uuid_t)"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XLOG_FMT"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "xlog_assign_lsn(tail_cycle, tail_block)"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_assign_lsn",
          "args": [
            "tail_cycle",
            "tail_block"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "72-75",
          "snippet": "static inline xfs_lsn_t xlog_assign_lsn(uint cycle, uint block)\n{\n\treturn ((xfs_lsn_t)cycle << 32) | block;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_lsn_t xlog_assign_lsn(uint cycle, uint block)\n{\n\treturn ((xfs_lsn_t)cycle << 32) | block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "xlog_assign_lsn(cycle, block)"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "xfs_sb_version_haslogv2(&log->l_mp->m_sb) ? 2 : 1"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&log->l_mp->m_sb"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "cycle"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XLOG_HEADER_MAGIC_NUM"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "BBSIZE"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_add_record(\n\tstruct xlog\t\t*log,\n\txfs_caddr_t\t\tbuf,\n\tint\t\t\tcycle,\n\tint\t\t\tblock,\n\tint\t\t\ttail_cycle,\n\tint\t\t\ttail_block)\n{\n\txlog_rec_header_t\t*recp = (xlog_rec_header_t *)buf;\n\n\tmemset(buf, 0, BBSIZE);\n\trecp->h_magicno = cpu_to_be32(XLOG_HEADER_MAGIC_NUM);\n\trecp->h_cycle = cpu_to_be32(cycle);\n\trecp->h_version = cpu_to_be32(\n\t\t\txfs_sb_version_haslogv2(&log->l_mp->m_sb) ? 2 : 1);\n\trecp->h_lsn = cpu_to_be64(xlog_assign_lsn(cycle, block));\n\trecp->h_tail_lsn = cpu_to_be64(xlog_assign_lsn(tail_cycle, tail_block));\n\trecp->h_fmt = cpu_to_be32(XLOG_FMT);\n\tmemcpy(&recp->h_fs_uuid, &log->l_mp->m_sb.sb_uuid, sizeof(uuid_t));\n}"
  },
  {
    "function_name": "xlog_find_zeroed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "1096-1192",
    "snippet": "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*log,\n\txfs_daddr_t\t*blk_no)\n{\n\txfs_buf_t\t*bp;\n\txfs_caddr_t\toffset;\n\tuint\t        first_cycle, last_cycle;\n\txfs_daddr_t\tnew_blk, last_blk, start_blk;\n\txfs_daddr_t     num_scan_bblks;\n\tint\t        error, log_bbnum = log->l_logBBsize;\n\n\t*blk_no = 0;\n\n\t/* check totally zeroed log */\n\tbp = xlog_get_bp(log, 1);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\terror = xlog_bread(log, 0, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tfirst_cycle = xlog_get_cycle(offset);\n\tif (first_cycle == 0) {\t\t/* completely zeroed log */\n\t\t*blk_no = 0;\n\t\txlog_put_bp(bp);\n\t\treturn 1;\n\t}\n\n\t/* check partially zeroed log */\n\terror = xlog_bread(log, log_bbnum-1, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tlast_cycle = xlog_get_cycle(offset);\n\tif (last_cycle != 0) {\t\t/* log completely written to */\n\t\txlog_put_bp(bp);\n\t\treturn 0;\n\t} else if (first_cycle != 1) {\n\t\t/*\n\t\t * If the cycle of the last block is zero, the cycle of\n\t\t * the first block must be 1. If it's not, maybe we're\n\t\t * not looking at a log... Bail out.\n\t\t */\n\t\txfs_warn(log->l_mp,\n\t\t\t\"Log inconsistent or not a log (last==0, first!=1)\");\n\t\terror = -EINVAL;\n\t\tgoto bp_err;\n\t}\n\n\t/* we have a partially zeroed log */\n\tlast_blk = log_bbnum-1;\n\tif ((error = xlog_find_cycle_start(log, bp, 0, &last_blk, 0)))\n\t\tgoto bp_err;\n\n\t/*\n\t * Validate the answer.  Because there is no way to guarantee that\n\t * the entire log is made up of log records which are the same size,\n\t * we scan over the defined maximum blocks.  At this point, the maximum\n\t * is not chosen to mean anything special.   XXXmiken\n\t */\n\tnum_scan_bblks = XLOG_TOTAL_REC_SHIFT(log);\n\tASSERT(num_scan_bblks <= INT_MAX);\n\n\tif (last_blk < num_scan_bblks)\n\t\tnum_scan_bblks = last_blk;\n\tstart_blk = last_blk - num_scan_bblks;\n\n\t/*\n\t * We search for any instances of cycle number 0 that occur before\n\t * our current estimate of the head.  What we're trying to detect is\n\t *        1 ... | 0 | 1 | 0...\n\t *                       ^ binary search ends here\n\t */\n\tif ((error = xlog_find_verify_cycle(log, start_blk,\n\t\t\t\t\t (int)num_scan_bblks, 0, &new_blk)))\n\t\tgoto bp_err;\n\tif (new_blk != -1)\n\t\tlast_blk = new_blk;\n\n\t/*\n\t * Potentially backup over partial log record write.  We don't need\n\t * to search the end of the log because we know it is zero.\n\t */\n\terror = xlog_find_verify_log_record(log, start_blk, &last_blk, 0);\n\tif (error == 1)\n\t\terror = -EIO;\n\tif (error)\n\t\tgoto bp_err;\n\n\t*blk_no = last_blk;\nbp_err:\n\txlog_put_bp(bp);\n\tif (error)\n\t\treturn error;\n\treturn 1;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_put_bp",
          "args": [
            "bp"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_put_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "139-144",
          "snippet": "STATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_find_verify_log_record",
          "args": [
            "log",
            "start_blk",
            "&last_blk",
            "0"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_find_verify_log_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "503-598",
          "snippet": "STATIC int\nxlog_find_verify_log_record(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tstart_blk,\n\txfs_daddr_t\t\t*last_blk,\n\tint\t\t\textra_bblks)\n{\n\txfs_daddr_t\t\ti;\n\txfs_buf_t\t\t*bp;\n\txfs_caddr_t\t\toffset = NULL;\n\txlog_rec_header_t\t*head = NULL;\n\tint\t\t\terror = 0;\n\tint\t\t\tsmallmem = 0;\n\tint\t\t\tnum_blks = *last_blk - start_blk;\n\tint\t\t\txhdrs;\n\n\tASSERT(start_blk != 0 || *last_blk != start_blk);\n\n\tif (!(bp = xlog_get_bp(log, num_blks))) {\n\t\tif (!(bp = xlog_get_bp(log, 1)))\n\t\t\treturn -ENOMEM;\n\t\tsmallmem = 1;\n\t} else {\n\t\terror = xlog_bread(log, start_blk, num_blks, bp, &offset);\n\t\tif (error)\n\t\t\tgoto out;\n\t\toffset += ((num_blks - 1) << BBSHIFT);\n\t}\n\n\tfor (i = (*last_blk) - 1; i >= 0; i--) {\n\t\tif (i < start_blk) {\n\t\t\t/* valid log record not found */\n\t\t\txfs_warn(log->l_mp,\n\t\t\"Log inconsistent (didn't find previous header)\");\n\t\t\tASSERT(0);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (smallmem) {\n\t\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\thead = (xlog_rec_header_t *)offset;\n\n\t\tif (head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\t\tbreak;\n\n\t\tif (!smallmem)\n\t\t\toffset -= BBSIZE;\n\t}\n\n\t/*\n\t * We hit the beginning of the physical log & still no header.  Return\n\t * to caller.  If caller can handle a return of -1, then this routine\n\t * will be called again for the end of the physical log.\n\t */\n\tif (i == -1) {\n\t\terror = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have the final block of the good log (the first block\n\t * of the log record _before_ the head. So we check the uuid.\n\t */\n\tif ((error = xlog_header_check_mount(log->l_mp, head)))\n\t\tgoto out;\n\n\t/*\n\t * We may have found a log record header before we expected one.\n\t * last_blk will be the 1st block # with a given cycle #.  We may end\n\t * up reading an entire log record.  In this case, we don't want to\n\t * reset last_blk.  Only when last_blk points in the middle of a log\n\t * record do we update last_blk.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tuint\th_size = be32_to_cpu(head->h_size);\n\n\t\txhdrs = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\txhdrs++;\n\t} else {\n\t\txhdrs = 1;\n\t}\n\n\tif (*last_blk - i + extra_bblks !=\n\t    BTOBB(be32_to_cpu(head->h_len)) + xhdrs)\n\t\t*last_blk = i;\n\nout:\n\txlog_put_bp(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_verify_log_record(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tstart_blk,\n\txfs_daddr_t\t\t*last_blk,\n\tint\t\t\textra_bblks)\n{\n\txfs_daddr_t\t\ti;\n\txfs_buf_t\t\t*bp;\n\txfs_caddr_t\t\toffset = NULL;\n\txlog_rec_header_t\t*head = NULL;\n\tint\t\t\terror = 0;\n\tint\t\t\tsmallmem = 0;\n\tint\t\t\tnum_blks = *last_blk - start_blk;\n\tint\t\t\txhdrs;\n\n\tASSERT(start_blk != 0 || *last_blk != start_blk);\n\n\tif (!(bp = xlog_get_bp(log, num_blks))) {\n\t\tif (!(bp = xlog_get_bp(log, 1)))\n\t\t\treturn -ENOMEM;\n\t\tsmallmem = 1;\n\t} else {\n\t\terror = xlog_bread(log, start_blk, num_blks, bp, &offset);\n\t\tif (error)\n\t\t\tgoto out;\n\t\toffset += ((num_blks - 1) << BBSHIFT);\n\t}\n\n\tfor (i = (*last_blk) - 1; i >= 0; i--) {\n\t\tif (i < start_blk) {\n\t\t\t/* valid log record not found */\n\t\t\txfs_warn(log->l_mp,\n\t\t\"Log inconsistent (didn't find previous header)\");\n\t\t\tASSERT(0);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (smallmem) {\n\t\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\thead = (xlog_rec_header_t *)offset;\n\n\t\tif (head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\t\tbreak;\n\n\t\tif (!smallmem)\n\t\t\toffset -= BBSIZE;\n\t}\n\n\t/*\n\t * We hit the beginning of the physical log & still no header.  Return\n\t * to caller.  If caller can handle a return of -1, then this routine\n\t * will be called again for the end of the physical log.\n\t */\n\tif (i == -1) {\n\t\terror = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have the final block of the good log (the first block\n\t * of the log record _before_ the head. So we check the uuid.\n\t */\n\tif ((error = xlog_header_check_mount(log->l_mp, head)))\n\t\tgoto out;\n\n\t/*\n\t * We may have found a log record header before we expected one.\n\t * last_blk will be the 1st block # with a given cycle #.  We may end\n\t * up reading an entire log record.  In this case, we don't want to\n\t * reset last_blk.  Only when last_blk points in the middle of a log\n\t * record do we update last_blk.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tuint\th_size = be32_to_cpu(head->h_size);\n\n\t\txhdrs = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\txhdrs++;\n\t} else {\n\t\txhdrs = 1;\n\t}\n\n\tif (*last_blk - i + extra_bblks !=\n\t    BTOBB(be32_to_cpu(head->h_len)) + xhdrs)\n\t\t*last_blk = i;\n\nout:\n\txlog_put_bp(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_find_verify_cycle",
          "args": [
            "log",
            "start_blk",
            "(int)num_scan_bblks",
            "0",
            "&new_blk"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_find_verify_cycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "434-489",
          "snippet": "STATIC int\nxlog_find_verify_cycle(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tstart_blk,\n\tint\t\tnbblks,\n\tuint\t\tstop_on_cycle_no,\n\txfs_daddr_t\t*new_blk)\n{\n\txfs_daddr_t\ti, j;\n\tuint\t\tcycle;\n\txfs_buf_t\t*bp;\n\txfs_daddr_t\tbufblks;\n\txfs_caddr_t\tbuf = NULL;\n\tint\t\terror = 0;\n\n\t/*\n\t * Greedily allocate a buffer big enough to handle the full\n\t * range of basic blocks we'll be examining.  If that fails,\n\t * try a smaller size.  We need to be able to read at least\n\t * a log sector, or we're out of luck.\n\t */\n\tbufblks = 1 << ffs(nbblks);\n\twhile (bufblks > log->l_logBBsize)\n\t\tbufblks >>= 1;\n\twhile (!(bp = xlog_get_bp(log, bufblks))) {\n\t\tbufblks >>= 1;\n\t\tif (bufblks < log->l_sectBBsize)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = start_blk; i < start_blk + nbblks; i += bufblks) {\n\t\tint\tbcount;\n\n\t\tbcount = min(bufblks, (start_blk + nbblks - i));\n\n\t\terror = xlog_bread(log, i, bcount, bp, &buf);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tfor (j = 0; j < bcount; j++) {\n\t\t\tcycle = xlog_get_cycle(buf);\n\t\t\tif (cycle == stop_on_cycle_no) {\n\t\t\t\t*new_blk = i+j;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbuf += BBSIZE;\n\t\t}\n\t}\n\n\t*new_blk = -1;\n\nout:\n\txlog_put_bp(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_verify_cycle(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tstart_blk,\n\tint\t\tnbblks,\n\tuint\t\tstop_on_cycle_no,\n\txfs_daddr_t\t*new_blk)\n{\n\txfs_daddr_t\ti, j;\n\tuint\t\tcycle;\n\txfs_buf_t\t*bp;\n\txfs_daddr_t\tbufblks;\n\txfs_caddr_t\tbuf = NULL;\n\tint\t\terror = 0;\n\n\t/*\n\t * Greedily allocate a buffer big enough to handle the full\n\t * range of basic blocks we'll be examining.  If that fails,\n\t * try a smaller size.  We need to be able to read at least\n\t * a log sector, or we're out of luck.\n\t */\n\tbufblks = 1 << ffs(nbblks);\n\twhile (bufblks > log->l_logBBsize)\n\t\tbufblks >>= 1;\n\twhile (!(bp = xlog_get_bp(log, bufblks))) {\n\t\tbufblks >>= 1;\n\t\tif (bufblks < log->l_sectBBsize)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = start_blk; i < start_blk + nbblks; i += bufblks) {\n\t\tint\tbcount;\n\n\t\tbcount = min(bufblks, (start_blk + nbblks - i));\n\n\t\terror = xlog_bread(log, i, bcount, bp, &buf);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tfor (j = 0; j < bcount; j++) {\n\t\t\tcycle = xlog_get_cycle(buf);\n\t\t\tif (cycle == stop_on_cycle_no) {\n\t\t\t\t*new_blk = i+j;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbuf += BBSIZE;\n\t\t}\n\t}\n\n\t*new_blk = -1;\n\nout:\n\txlog_put_bp(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "num_scan_bblks <= INT_MAX"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_TOTAL_REC_SHIFT",
          "args": [
            "log"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_find_cycle_start",
          "args": [
            "log",
            "bp",
            "0",
            "&last_blk",
            "0"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_find_cycle_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "391-424",
          "snippet": "STATIC int\nxlog_find_cycle_start(\n\tstruct xlog\t*log,\n\tstruct xfs_buf\t*bp,\n\txfs_daddr_t\tfirst_blk,\n\txfs_daddr_t\t*last_blk,\n\tuint\t\tcycle)\n{\n\txfs_caddr_t\toffset;\n\txfs_daddr_t\tmid_blk;\n\txfs_daddr_t\tend_blk;\n\tuint\t\tmid_cycle;\n\tint\t\terror;\n\n\tend_blk = *last_blk;\n\tmid_blk = BLK_AVG(first_blk, end_blk);\n\twhile (mid_blk != first_blk && mid_blk != end_blk) {\n\t\terror = xlog_bread(log, mid_blk, 1, bp, &offset);\n\t\tif (error)\n\t\t\treturn error;\n\t\tmid_cycle = xlog_get_cycle(offset);\n\t\tif (mid_cycle == cycle)\n\t\t\tend_blk = mid_blk;   /* last_half_cycle == mid_cycle */\n\t\telse\n\t\t\tfirst_blk = mid_blk; /* first_half_cycle == mid_cycle */\n\t\tmid_blk = BLK_AVG(first_blk, end_blk);\n\t}\n\tASSERT((mid_blk == first_blk && mid_blk+1 == end_blk) ||\n\t       (mid_blk == end_blk && mid_blk-1 == first_blk));\n\n\t*last_blk = end_blk;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_cycle_start(\n\tstruct xlog\t*log,\n\tstruct xfs_buf\t*bp,\n\txfs_daddr_t\tfirst_blk,\n\txfs_daddr_t\t*last_blk,\n\tuint\t\tcycle)\n{\n\txfs_caddr_t\toffset;\n\txfs_daddr_t\tmid_blk;\n\txfs_daddr_t\tend_blk;\n\tuint\t\tmid_cycle;\n\tint\t\terror;\n\n\tend_blk = *last_blk;\n\tmid_blk = BLK_AVG(first_blk, end_blk);\n\twhile (mid_blk != first_blk && mid_blk != end_blk) {\n\t\terror = xlog_bread(log, mid_blk, 1, bp, &offset);\n\t\tif (error)\n\t\t\treturn error;\n\t\tmid_cycle = xlog_get_cycle(offset);\n\t\tif (mid_cycle == cycle)\n\t\t\tend_blk = mid_blk;   /* last_half_cycle == mid_cycle */\n\t\telse\n\t\t\tfirst_blk = mid_blk; /* first_half_cycle == mid_cycle */\n\t\tmid_blk = BLK_AVG(first_blk, end_blk);\n\t}\n\tASSERT((mid_blk == first_blk && mid_blk+1 == end_blk) ||\n\t       (mid_blk == end_blk && mid_blk-1 == first_blk));\n\n\t*last_blk = end_blk;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"Log inconsistent or not a log (last==0, first!=1)\""
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_get_cycle",
          "args": [
            "offset"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_cycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "77-83",
          "snippet": "static inline uint xlog_get_cycle(char *ptr)\n{\n\tif (be32_to_cpu(*(__be32 *)ptr) == XLOG_HEADER_MAGIC_NUM)\n\t\treturn be32_to_cpu(*((__be32 *)ptr + 1));\n\telse\n\t\treturn be32_to_cpu(*(__be32 *)ptr);\n}",
          "includes": [],
          "macros_used": [
            "#define XLOG_HEADER_MAGIC_NUM\t0xFEEDbabe\t/* Invalid cycle number */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XLOG_HEADER_MAGIC_NUM\t0xFEEDbabe\t/* Invalid cycle number */\n\nstatic inline uint xlog_get_cycle(char *ptr)\n{\n\tif (be32_to_cpu(*(__be32 *)ptr) == XLOG_HEADER_MAGIC_NUM)\n\t\treturn be32_to_cpu(*((__be32 *)ptr + 1));\n\telse\n\t\treturn be32_to_cpu(*(__be32 *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_bread",
          "args": [
            "log",
            "log_bbnum-1",
            "1",
            "bp",
            "&offset"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_bread_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "222-245",
          "snippet": "STATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_get_bp",
          "args": [
            "log",
            "1"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "99-137",
          "snippet": "STATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*log,\n\txfs_daddr_t\t*blk_no)\n{\n\txfs_buf_t\t*bp;\n\txfs_caddr_t\toffset;\n\tuint\t        first_cycle, last_cycle;\n\txfs_daddr_t\tnew_blk, last_blk, start_blk;\n\txfs_daddr_t     num_scan_bblks;\n\tint\t        error, log_bbnum = log->l_logBBsize;\n\n\t*blk_no = 0;\n\n\t/* check totally zeroed log */\n\tbp = xlog_get_bp(log, 1);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\terror = xlog_bread(log, 0, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tfirst_cycle = xlog_get_cycle(offset);\n\tif (first_cycle == 0) {\t\t/* completely zeroed log */\n\t\t*blk_no = 0;\n\t\txlog_put_bp(bp);\n\t\treturn 1;\n\t}\n\n\t/* check partially zeroed log */\n\terror = xlog_bread(log, log_bbnum-1, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tlast_cycle = xlog_get_cycle(offset);\n\tif (last_cycle != 0) {\t\t/* log completely written to */\n\t\txlog_put_bp(bp);\n\t\treturn 0;\n\t} else if (first_cycle != 1) {\n\t\t/*\n\t\t * If the cycle of the last block is zero, the cycle of\n\t\t * the first block must be 1. If it's not, maybe we're\n\t\t * not looking at a log... Bail out.\n\t\t */\n\t\txfs_warn(log->l_mp,\n\t\t\t\"Log inconsistent or not a log (last==0, first!=1)\");\n\t\terror = -EINVAL;\n\t\tgoto bp_err;\n\t}\n\n\t/* we have a partially zeroed log */\n\tlast_blk = log_bbnum-1;\n\tif ((error = xlog_find_cycle_start(log, bp, 0, &last_blk, 0)))\n\t\tgoto bp_err;\n\n\t/*\n\t * Validate the answer.  Because there is no way to guarantee that\n\t * the entire log is made up of log records which are the same size,\n\t * we scan over the defined maximum blocks.  At this point, the maximum\n\t * is not chosen to mean anything special.   XXXmiken\n\t */\n\tnum_scan_bblks = XLOG_TOTAL_REC_SHIFT(log);\n\tASSERT(num_scan_bblks <= INT_MAX);\n\n\tif (last_blk < num_scan_bblks)\n\t\tnum_scan_bblks = last_blk;\n\tstart_blk = last_blk - num_scan_bblks;\n\n\t/*\n\t * We search for any instances of cycle number 0 that occur before\n\t * our current estimate of the head.  What we're trying to detect is\n\t *        1 ... | 0 | 1 | 0...\n\t *                       ^ binary search ends here\n\t */\n\tif ((error = xlog_find_verify_cycle(log, start_blk,\n\t\t\t\t\t (int)num_scan_bblks, 0, &new_blk)))\n\t\tgoto bp_err;\n\tif (new_blk != -1)\n\t\tlast_blk = new_blk;\n\n\t/*\n\t * Potentially backup over partial log record write.  We don't need\n\t * to search the end of the log because we know it is zero.\n\t */\n\terror = xlog_find_verify_log_record(log, start_blk, &last_blk, 0);\n\tif (error == 1)\n\t\terror = -EIO;\n\tif (error)\n\t\tgoto bp_err;\n\n\t*blk_no = last_blk;\nbp_err:\n\txlog_put_bp(bp);\n\tif (error)\n\t\treturn error;\n\treturn 1;\n}"
  },
  {
    "function_name": "xlog_find_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "886-1078",
    "snippet": "STATIC int\nxlog_find_tail(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\t*head_blk,\n\txfs_daddr_t\t\t*tail_blk)\n{\n\txlog_rec_header_t\t*rhead;\n\txlog_op_header_t\t*op_head;\n\txfs_caddr_t\t\toffset = NULL;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror, i, found;\n\txfs_daddr_t\t\tumount_data_blk;\n\txfs_daddr_t\t\tafter_umount_blk;\n\txfs_lsn_t\t\ttail_lsn;\n\tint\t\t\thblks;\n\n\tfound = 0;\n\n\t/*\n\t * Find previous log record\n\t */\n\tif ((error = xlog_find_head(log, head_blk)))\n\t\treturn error;\n\n\tbp = xlog_get_bp(log, 1);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\tif (*head_blk == 0) {\t\t\t\t/* special case */\n\t\terror = xlog_bread(log, 0, 1, bp, &offset);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\tif (xlog_get_cycle(offset) == 0) {\n\t\t\t*tail_blk = 0;\n\t\t\t/* leave all other log inited values alone */\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/*\n\t * Search backwards looking for log record header block\n\t */\n\tASSERT(*head_blk < INT_MAX);\n\tfor (i = (int)(*head_blk) - 1; i >= 0; i--) {\n\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\tif (*(__be32 *)offset == cpu_to_be32(XLOG_HEADER_MAGIC_NUM)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * If we haven't found the log record header block, start looking\n\t * again from the end of the physical log.  XXXmiken: There should be\n\t * a check here to make sure we didn't search more than N blocks in\n\t * the previous code.\n\t */\n\tif (!found) {\n\t\tfor (i = log->l_logBBsize - 1; i >= (int)(*head_blk); i--) {\n\t\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\n\t\t\tif (*(__be32 *)offset ==\n\t\t\t    cpu_to_be32(XLOG_HEADER_MAGIC_NUM)) {\n\t\t\t\tfound = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!found) {\n\t\txfs_warn(log->l_mp, \"%s: couldn't find sync record\", __func__);\n\t\txlog_put_bp(bp);\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n\n\t/* find blk_no of tail of log */\n\trhead = (xlog_rec_header_t *)offset;\n\t*tail_blk = BLOCK_LSN(be64_to_cpu(rhead->h_tail_lsn));\n\n\t/*\n\t * Reset log values according to the state of the log when we\n\t * crashed.  In the case where head_blk == 0, we bump curr_cycle\n\t * one because the next write starts a new cycle rather than\n\t * continuing the cycle of the last good log record.  At this\n\t * point we have guaranteed that all partial log records have been\n\t * accounted for.  Therefore, we know that the last good log record\n\t * written was complete and ended exactly on the end boundary\n\t * of the physical log.\n\t */\n\tlog->l_prev_block = i;\n\tlog->l_curr_block = (int)*head_blk;\n\tlog->l_curr_cycle = be32_to_cpu(rhead->h_cycle);\n\tif (found == 2)\n\t\tlog->l_curr_cycle++;\n\tatomic64_set(&log->l_tail_lsn, be64_to_cpu(rhead->h_tail_lsn));\n\tatomic64_set(&log->l_last_sync_lsn, be64_to_cpu(rhead->h_lsn));\n\txlog_assign_grant_head(&log->l_reserve_head.grant, log->l_curr_cycle,\n\t\t\t\t\tBBTOB(log->l_curr_block));\n\txlog_assign_grant_head(&log->l_write_head.grant, log->l_curr_cycle,\n\t\t\t\t\tBBTOB(log->l_curr_block));\n\n\t/*\n\t * Look for unmount record.  If we find it, then we know there\n\t * was a clean unmount.  Since 'i' could be the last block in\n\t * the physical log, we convert to a log block before comparing\n\t * to the head_blk.\n\t *\n\t * Save the current tail lsn to use to pass to\n\t * xlog_clear_stale_blocks() below.  We won't want to clear the\n\t * unmount record if there is one, so we pass the lsn of the\n\t * unmount record rather than the block after it.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tint\th_size = be32_to_cpu(rhead->h_size);\n\t\tint\th_version = be32_to_cpu(rhead->h_version);\n\n\t\tif ((h_version & XLOG_VERSION_2) &&\n\t\t    (h_size > XLOG_HEADER_CYCLE_SIZE)) {\n\t\t\thblks = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\t\thblks++;\n\t\t} else {\n\t\t\thblks = 1;\n\t\t}\n\t} else {\n\t\thblks = 1;\n\t}\n\tafter_umount_blk = (i + hblks + (int)\n\t\tBTOBB(be32_to_cpu(rhead->h_len))) % log->l_logBBsize;\n\ttail_lsn = atomic64_read(&log->l_tail_lsn);\n\tif (*head_blk == after_umount_blk &&\n\t    be32_to_cpu(rhead->h_num_logops) == 1) {\n\t\tumount_data_blk = (i + hblks) % log->l_logBBsize;\n\t\terror = xlog_bread(log, umount_data_blk, 1, bp, &offset);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\top_head = (xlog_op_header_t *)offset;\n\t\tif (op_head->oh_flags & XLOG_UNMOUNT_TRANS) {\n\t\t\t/*\n\t\t\t * Set tail and last sync so that newly written\n\t\t\t * log records will point recovery to after the\n\t\t\t * current unmount record.\n\t\t\t */\n\t\t\txlog_assign_atomic_lsn(&log->l_tail_lsn,\n\t\t\t\t\tlog->l_curr_cycle, after_umount_blk);\n\t\t\txlog_assign_atomic_lsn(&log->l_last_sync_lsn,\n\t\t\t\t\tlog->l_curr_cycle, after_umount_blk);\n\t\t\t*tail_blk = after_umount_blk;\n\n\t\t\t/*\n\t\t\t * Note that the unmount was clean. If the unmount\n\t\t\t * was not clean, we need to know this to rebuild the\n\t\t\t * superblock counters from the perag headers if we\n\t\t\t * have a filesystem using non-persistent counters.\n\t\t\t */\n\t\t\tlog->l_mp->m_flags |= XFS_MOUNT_WAS_CLEAN;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that there are no blocks in front of the head\n\t * with the same cycle number as the head.  This can happen\n\t * because we allow multiple outstanding log writes concurrently,\n\t * and the later writes might make it out before earlier ones.\n\t *\n\t * We use the lsn from before modifying it so that we'll never\n\t * overwrite the unmount record after a clean unmount.\n\t *\n\t * Do this only if we are going to recover the filesystem\n\t *\n\t * NOTE: This used to say \"if (!readonly)\"\n\t * However on Linux, we can & do recover a read-only filesystem.\n\t * We only skip recovery if NORECOVERY is specified on mount,\n\t * in which case we would not be here.\n\t *\n\t * But... if the -device- itself is readonly, just skip this.\n\t * We can't recover this device anyway, so it won't matter.\n\t */\n\tif (!xfs_readonly_buftarg(log->l_mp->m_logdev_targp))\n\t\terror = xlog_clear_stale_blocks(log, tail_lsn);\n\ndone:\n\txlog_put_bp(bp);\n\n\tif (error)\n\t\txfs_warn(log->l_mp, \"failed to locate log tail\");\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"failed to locate log tail\""
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_put_bp",
          "args": [
            "bp"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_put_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "139-144",
          "snippet": "STATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_clear_stale_blocks",
          "args": [
            "log",
            "tail_lsn"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_clear_stale_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1321-1435",
          "snippet": "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*log,\n\txfs_lsn_t\ttail_lsn)\n{\n\tint\t\ttail_cycle, head_cycle;\n\tint\t\ttail_block, head_block;\n\tint\t\ttail_distance, max_distance;\n\tint\t\tdistance;\n\tint\t\terror;\n\n\ttail_cycle = CYCLE_LSN(tail_lsn);\n\ttail_block = BLOCK_LSN(tail_lsn);\n\thead_cycle = log->l_curr_cycle;\n\thead_block = log->l_curr_block;\n\n\t/*\n\t * Figure out the distance between the new head of the log\n\t * and the tail.  We want to write over any blocks beyond the\n\t * head that we may have written just before the crash, but\n\t * we don't want to overwrite the tail of the log.\n\t */\n\tif (head_cycle == tail_cycle) {\n\t\t/*\n\t\t * The tail is behind the head in the physical log,\n\t\t * so the distance from the head to the tail is the\n\t\t * distance from the head to the end of the log plus\n\t\t * the distance from the beginning of the log to the\n\t\t * tail.\n\t\t */\n\t\tif (unlikely(head_block < tail_block || head_block >= log->l_logBBsize)) {\n\t\t\tXFS_ERROR_REPORT(\"xlog_clear_stale_blocks(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, log->l_mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\ttail_distance = tail_block + (log->l_logBBsize - head_block);\n\t} else {\n\t\t/*\n\t\t * The head is behind the tail in the physical log,\n\t\t * so the distance from the head to the tail is just\n\t\t * the tail block minus the head block.\n\t\t */\n\t\tif (unlikely(head_block >= tail_block || head_cycle != (tail_cycle + 1))){\n\t\t\tXFS_ERROR_REPORT(\"xlog_clear_stale_blocks(2)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, log->l_mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\ttail_distance = tail_block - head_block;\n\t}\n\n\t/*\n\t * If the head is right up against the tail, we can't clear\n\t * anything.\n\t */\n\tif (tail_distance <= 0) {\n\t\tASSERT(tail_distance == 0);\n\t\treturn 0;\n\t}\n\n\tmax_distance = XLOG_TOTAL_REC_SHIFT(log);\n\t/*\n\t * Take the smaller of the maximum amount of outstanding I/O\n\t * we could have and the distance to the tail to clear out.\n\t * We take the smaller so that we don't overwrite the tail and\n\t * we don't waste all day writing from the head to the tail\n\t * for no reason.\n\t */\n\tmax_distance = MIN(max_distance, tail_distance);\n\n\tif ((head_block + max_distance) <= log->l_logBBsize) {\n\t\t/*\n\t\t * We can stomp all the blocks we need to without\n\t\t * wrapping around the end of the log.  Just do it\n\t\t * in a single write.  Use the cycle number of the\n\t\t * current cycle minus one so that the log will look like:\n\t\t *     n ... | n - 1 ...\n\t\t */\n\t\terror = xlog_write_log_records(log, (head_cycle - 1),\n\t\t\t\thead_block, max_distance, tail_cycle,\n\t\t\t\ttail_block);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\t/*\n\t\t * We need to wrap around the end of the physical log in\n\t\t * order to clear all the blocks.  Do it in two separate\n\t\t * I/Os.  The first write should be from the head to the\n\t\t * end of the physical log, and it should use the current\n\t\t * cycle number minus one just like above.\n\t\t */\n\t\tdistance = log->l_logBBsize - head_block;\n\t\terror = xlog_write_log_records(log, (head_cycle - 1),\n\t\t\t\thead_block, distance, tail_cycle,\n\t\t\t\ttail_block);\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Now write the blocks at the start of the physical log.\n\t\t * This writes the remainder of the blocks we want to clear.\n\t\t * It uses the current cycle number since we're now on the\n\t\t * same cycle as the head so that we get:\n\t\t *    n ... n ... | n - 1 ...\n\t\t *    ^^^^^ blocks we're writing\n\t\t */\n\t\tdistance = max_distance - (log->l_logBBsize - head_block);\n\t\terror = xlog_write_log_records(log, head_cycle, 0, distance,\n\t\t\t\ttail_cycle, tail_block);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*log,\n\txfs_lsn_t\ttail_lsn)\n{\n\tint\t\ttail_cycle, head_cycle;\n\tint\t\ttail_block, head_block;\n\tint\t\ttail_distance, max_distance;\n\tint\t\tdistance;\n\tint\t\terror;\n\n\ttail_cycle = CYCLE_LSN(tail_lsn);\n\ttail_block = BLOCK_LSN(tail_lsn);\n\thead_cycle = log->l_curr_cycle;\n\thead_block = log->l_curr_block;\n\n\t/*\n\t * Figure out the distance between the new head of the log\n\t * and the tail.  We want to write over any blocks beyond the\n\t * head that we may have written just before the crash, but\n\t * we don't want to overwrite the tail of the log.\n\t */\n\tif (head_cycle == tail_cycle) {\n\t\t/*\n\t\t * The tail is behind the head in the physical log,\n\t\t * so the distance from the head to the tail is the\n\t\t * distance from the head to the end of the log plus\n\t\t * the distance from the beginning of the log to the\n\t\t * tail.\n\t\t */\n\t\tif (unlikely(head_block < tail_block || head_block >= log->l_logBBsize)) {\n\t\t\tXFS_ERROR_REPORT(\"xlog_clear_stale_blocks(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, log->l_mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\ttail_distance = tail_block + (log->l_logBBsize - head_block);\n\t} else {\n\t\t/*\n\t\t * The head is behind the tail in the physical log,\n\t\t * so the distance from the head to the tail is just\n\t\t * the tail block minus the head block.\n\t\t */\n\t\tif (unlikely(head_block >= tail_block || head_cycle != (tail_cycle + 1))){\n\t\t\tXFS_ERROR_REPORT(\"xlog_clear_stale_blocks(2)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, log->l_mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\ttail_distance = tail_block - head_block;\n\t}\n\n\t/*\n\t * If the head is right up against the tail, we can't clear\n\t * anything.\n\t */\n\tif (tail_distance <= 0) {\n\t\tASSERT(tail_distance == 0);\n\t\treturn 0;\n\t}\n\n\tmax_distance = XLOG_TOTAL_REC_SHIFT(log);\n\t/*\n\t * Take the smaller of the maximum amount of outstanding I/O\n\t * we could have and the distance to the tail to clear out.\n\t * We take the smaller so that we don't overwrite the tail and\n\t * we don't waste all day writing from the head to the tail\n\t * for no reason.\n\t */\n\tmax_distance = MIN(max_distance, tail_distance);\n\n\tif ((head_block + max_distance) <= log->l_logBBsize) {\n\t\t/*\n\t\t * We can stomp all the blocks we need to without\n\t\t * wrapping around the end of the log.  Just do it\n\t\t * in a single write.  Use the cycle number of the\n\t\t * current cycle minus one so that the log will look like:\n\t\t *     n ... | n - 1 ...\n\t\t */\n\t\terror = xlog_write_log_records(log, (head_cycle - 1),\n\t\t\t\thead_block, max_distance, tail_cycle,\n\t\t\t\ttail_block);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\t/*\n\t\t * We need to wrap around the end of the physical log in\n\t\t * order to clear all the blocks.  Do it in two separate\n\t\t * I/Os.  The first write should be from the head to the\n\t\t * end of the physical log, and it should use the current\n\t\t * cycle number minus one just like above.\n\t\t */\n\t\tdistance = log->l_logBBsize - head_block;\n\t\terror = xlog_write_log_records(log, (head_cycle - 1),\n\t\t\t\thead_block, distance, tail_cycle,\n\t\t\t\ttail_block);\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Now write the blocks at the start of the physical log.\n\t\t * This writes the remainder of the blocks we want to clear.\n\t\t * It uses the current cycle number since we're now on the\n\t\t * same cycle as the head so that we get:\n\t\t *    n ... n ... | n - 1 ...\n\t\t *    ^^^^^ blocks we're writing\n\t\t */\n\t\tdistance = max_distance - (log->l_logBBsize - head_block);\n\t\terror = xlog_write_log_records(log, head_cycle, 0, distance,\n\t\t\t\ttail_cycle, tail_block);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_readonly_buftarg",
          "args": [
            "log->l_mp->m_logdev_targp"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_assign_atomic_lsn",
          "args": [
            "&log->l_last_sync_lsn",
            "log->l_curr_cycle",
            "after_umount_blk"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_atomic_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "481-485",
          "snippet": "static inline void\nxlog_assign_atomic_lsn(atomic64_t *lsn, uint cycle, uint block)\n{\n\tatomic64_set(lsn, xlog_assign_lsn(cycle, block));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_assign_atomic_lsn(atomic64_t *lsn, uint cycle, uint block)\n{\n\tatomic64_set(lsn, xlog_assign_lsn(cycle, block));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_bread",
          "args": [
            "log",
            "umount_data_blk",
            "1",
            "bp",
            "&offset"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_bread_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "222-245",
          "snippet": "STATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_num_logops"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&log->l_tail_lsn"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "be32_to_cpu(rhead->h_len)"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_len"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_version"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_size"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&log->l_mp->m_sb"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_assign_grant_head",
          "args": [
            "&log->l_write_head.grant",
            "log->l_curr_cycle",
            "BBTOB(log->l_curr_block)"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_grant_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "511-515",
          "snippet": "static inline void\nxlog_assign_grant_head(atomic64_t *head, int cycle, int space)\n{\n\tatomic64_set(head, xlog_assign_grant_head_val(cycle, space));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_assign_grant_head(atomic64_t *head, int cycle, int space)\n{\n\tatomic64_set(head, xlog_assign_grant_head_val(cycle, space));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "log->l_curr_block"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "log->l_curr_block"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&log->l_last_sync_lsn",
            "be64_to_cpu(rhead->h_lsn)"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "rhead->h_lsn"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&log->l_tail_lsn",
            "be64_to_cpu(rhead->h_tail_lsn)"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "rhead->h_tail_lsn"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rhead->h_cycle"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLOCK_LSN",
          "args": [
            "be64_to_cpu(rhead->h_tail_lsn)"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "rhead->h_tail_lsn"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"%s: couldn't find sync record\"",
            "__func__"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XLOG_HEADER_MAGIC_NUM"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XLOG_HEADER_MAGIC_NUM"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*head_blk < INT_MAX"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_get_cycle",
          "args": [
            "offset"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_cycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "77-83",
          "snippet": "static inline uint xlog_get_cycle(char *ptr)\n{\n\tif (be32_to_cpu(*(__be32 *)ptr) == XLOG_HEADER_MAGIC_NUM)\n\t\treturn be32_to_cpu(*((__be32 *)ptr + 1));\n\telse\n\t\treturn be32_to_cpu(*(__be32 *)ptr);\n}",
          "includes": [],
          "macros_used": [
            "#define XLOG_HEADER_MAGIC_NUM\t0xFEEDbabe\t/* Invalid cycle number */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XLOG_HEADER_MAGIC_NUM\t0xFEEDbabe\t/* Invalid cycle number */\n\nstatic inline uint xlog_get_cycle(char *ptr)\n{\n\tif (be32_to_cpu(*(__be32 *)ptr) == XLOG_HEADER_MAGIC_NUM)\n\t\treturn be32_to_cpu(*((__be32 *)ptr + 1));\n\telse\n\t\treturn be32_to_cpu(*(__be32 *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_get_bp",
          "args": [
            "log",
            "1"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "99-137",
          "snippet": "STATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_find_head",
          "args": [
            "log",
            "head_blk"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_find_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "613-868",
          "snippet": "STATIC int\nxlog_find_head(\n\tstruct xlog\t*log,\n\txfs_daddr_t\t*return_head_blk)\n{\n\txfs_buf_t\t*bp;\n\txfs_caddr_t\toffset;\n\txfs_daddr_t\tnew_blk, first_blk, start_blk, last_blk, head_blk;\n\tint\t\tnum_scan_bblks;\n\tuint\t\tfirst_half_cycle, last_half_cycle;\n\tuint\t\tstop_on_cycle;\n\tint\t\terror, log_bbnum = log->l_logBBsize;\n\n\t/* Is the end of the log device zeroed? */\n\terror = xlog_find_zeroed(log, &first_blk);\n\tif (error < 0) {\n\t\txfs_warn(log->l_mp, \"empty log check failed\");\n\t\treturn error;\n\t}\n\tif (error == 1) {\n\t\t*return_head_blk = first_blk;\n\n\t\t/* Is the whole lot zeroed? */\n\t\tif (!first_blk) {\n\t\t\t/* Linux XFS shouldn't generate totally zeroed logs -\n\t\t\t * mkfs etc write a dummy unmount record to a fresh\n\t\t\t * log so we can store the uuid in there\n\t\t\t */\n\t\t\txfs_warn(log->l_mp, \"totally zeroed log\");\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfirst_blk = 0;\t\t\t/* get cycle # of 1st block */\n\tbp = xlog_get_bp(log, 1);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\terror = xlog_bread(log, 0, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tfirst_half_cycle = xlog_get_cycle(offset);\n\n\tlast_blk = head_blk = log_bbnum - 1;\t/* get cycle # of last block */\n\terror = xlog_bread(log, last_blk, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tlast_half_cycle = xlog_get_cycle(offset);\n\tASSERT(last_half_cycle != 0);\n\n\t/*\n\t * If the 1st half cycle number is equal to the last half cycle number,\n\t * then the entire log is stamped with the same cycle number.  In this\n\t * case, head_blk can't be set to zero (which makes sense).  The below\n\t * math doesn't work out properly with head_blk equal to zero.  Instead,\n\t * we set it to log_bbnum which is an invalid block number, but this\n\t * value makes the math correct.  If head_blk doesn't changed through\n\t * all the tests below, *head_blk is set to zero at the very end rather\n\t * than log_bbnum.  In a sense, log_bbnum and zero are the same block\n\t * in a circular file.\n\t */\n\tif (first_half_cycle == last_half_cycle) {\n\t\t/*\n\t\t * In this case we believe that the entire log should have\n\t\t * cycle number last_half_cycle.  We need to scan backwards\n\t\t * from the end verifying that there are no holes still\n\t\t * containing last_half_cycle - 1.  If we find such a hole,\n\t\t * then the start of that hole will be the new head.  The\n\t\t * simple case looks like\n\t\t *        x | x ... | x - 1 | x\n\t\t * Another case that fits this picture would be\n\t\t *        x | x + 1 | x ... | x\n\t\t * In this case the head really is somewhere at the end of the\n\t\t * log, as one of the latest writes at the beginning was\n\t\t * incomplete.\n\t\t * One more case is\n\t\t *        x | x + 1 | x ... | x - 1 | x\n\t\t * This is really the combination of the above two cases, and\n\t\t * the head has to end up at the start of the x-1 hole at the\n\t\t * end of the log.\n\t\t *\n\t\t * In the 256k log case, we will read from the beginning to the\n\t\t * end of the log and search for cycle numbers equal to x-1.\n\t\t * We don't worry about the x+1 blocks that we encounter,\n\t\t * because we know that they cannot be the head since the log\n\t\t * started with x.\n\t\t */\n\t\thead_blk = log_bbnum;\n\t\tstop_on_cycle = last_half_cycle - 1;\n\t} else {\n\t\t/*\n\t\t * In this case we want to find the first block with cycle\n\t\t * number matching last_half_cycle.  We expect the log to be\n\t\t * some variation on\n\t\t *        x + 1 ... | x ... | x\n\t\t * The first block with cycle number x (last_half_cycle) will\n\t\t * be where the new head belongs.  First we do a binary search\n\t\t * for the first occurrence of last_half_cycle.  The binary\n\t\t * search may not be totally accurate, so then we scan back\n\t\t * from there looking for occurrences of last_half_cycle before\n\t\t * us.  If that backwards scan wraps around the beginning of\n\t\t * the log, then we look for occurrences of last_half_cycle - 1\n\t\t * at the end of the log.  The cases we're looking for look\n\t\t * like\n\t\t *                               v binary search stopped here\n\t\t *        x + 1 ... | x | x + 1 | x ... | x\n\t\t *                   ^ but we want to locate this spot\n\t\t * or\n\t\t *        <---------> less than scan distance\n\t\t *        x + 1 ... | x ... | x - 1 | x\n\t\t *                           ^ we want to locate this spot\n\t\t */\n\t\tstop_on_cycle = last_half_cycle;\n\t\tif ((error = xlog_find_cycle_start(log, bp, first_blk,\n\t\t\t\t\t\t&head_blk, last_half_cycle)))\n\t\t\tgoto bp_err;\n\t}\n\n\t/*\n\t * Now validate the answer.  Scan back some number of maximum possible\n\t * blocks and make sure each one has the expected cycle number.  The\n\t * maximum is determined by the total possible amount of buffering\n\t * in the in-core log.  The following number can be made tighter if\n\t * we actually look at the block size of the filesystem.\n\t */\n\tnum_scan_bblks = XLOG_TOTAL_REC_SHIFT(log);\n\tif (head_blk >= num_scan_bblks) {\n\t\t/*\n\t\t * We are guaranteed that the entire check can be performed\n\t\t * in one buffer.\n\t\t */\n\t\tstart_blk = head_blk - num_scan_bblks;\n\t\tif ((error = xlog_find_verify_cycle(log,\n\t\t\t\t\t\tstart_blk, num_scan_bblks,\n\t\t\t\t\t\tstop_on_cycle, &new_blk)))\n\t\t\tgoto bp_err;\n\t\tif (new_blk != -1)\n\t\t\thead_blk = new_blk;\n\t} else {\t\t/* need to read 2 parts of log */\n\t\t/*\n\t\t * We are going to scan backwards in the log in two parts.\n\t\t * First we scan the physical end of the log.  In this part\n\t\t * of the log, we are looking for blocks with cycle number\n\t\t * last_half_cycle - 1.\n\t\t * If we find one, then we know that the log starts there, as\n\t\t * we've found a hole that didn't get written in going around\n\t\t * the end of the physical log.  The simple case for this is\n\t\t *        x + 1 ... | x ... | x - 1 | x\n\t\t *        <---------> less than scan distance\n\t\t * If all of the blocks at the end of the log have cycle number\n\t\t * last_half_cycle, then we check the blocks at the start of\n\t\t * the log looking for occurrences of last_half_cycle.  If we\n\t\t * find one, then our current estimate for the location of the\n\t\t * first occurrence of last_half_cycle is wrong and we move\n\t\t * back to the hole we've found.  This case looks like\n\t\t *        x + 1 ... | x | x + 1 | x ...\n\t\t *                               ^ binary search stopped here\n\t\t * Another case we need to handle that only occurs in 256k\n\t\t * logs is\n\t\t *        x + 1 ... | x ... | x+1 | x ...\n\t\t *                   ^ binary search stops here\n\t\t * In a 256k log, the scan at the end of the log will see the\n\t\t * x + 1 blocks.  We need to skip past those since that is\n\t\t * certainly not the head of the log.  By searching for\n\t\t * last_half_cycle-1 we accomplish that.\n\t\t */\n\t\tASSERT(head_blk <= INT_MAX &&\n\t\t\t(xfs_daddr_t) num_scan_bblks >= head_blk);\n\t\tstart_blk = log_bbnum - (num_scan_bblks - head_blk);\n\t\tif ((error = xlog_find_verify_cycle(log, start_blk,\n\t\t\t\t\tnum_scan_bblks - (int)head_blk,\n\t\t\t\t\t(stop_on_cycle - 1), &new_blk)))\n\t\t\tgoto bp_err;\n\t\tif (new_blk != -1) {\n\t\t\thead_blk = new_blk;\n\t\t\tgoto validate_head;\n\t\t}\n\n\t\t/*\n\t\t * Scan beginning of log now.  The last part of the physical\n\t\t * log is good.  This scan needs to verify that it doesn't find\n\t\t * the last_half_cycle.\n\t\t */\n\t\tstart_blk = 0;\n\t\tASSERT(head_blk <= INT_MAX);\n\t\tif ((error = xlog_find_verify_cycle(log,\n\t\t\t\t\tstart_blk, (int)head_blk,\n\t\t\t\t\tstop_on_cycle, &new_blk)))\n\t\t\tgoto bp_err;\n\t\tif (new_blk != -1)\n\t\t\thead_blk = new_blk;\n\t}\n\nvalidate_head:\n\t/*\n\t * Now we need to make sure head_blk is not pointing to a block in\n\t * the middle of a log record.\n\t */\n\tnum_scan_bblks = XLOG_REC_SHIFT(log);\n\tif (head_blk >= num_scan_bblks) {\n\t\tstart_blk = head_blk - num_scan_bblks; /* don't read head_blk */\n\n\t\t/* start ptr at last block ptr before head_blk */\n\t\terror = xlog_find_verify_log_record(log, start_blk, &head_blk, 0);\n\t\tif (error == 1)\n\t\t\terror = -EIO;\n\t\tif (error)\n\t\t\tgoto bp_err;\n\t} else {\n\t\tstart_blk = 0;\n\t\tASSERT(head_blk <= INT_MAX);\n\t\terror = xlog_find_verify_log_record(log, start_blk, &head_blk, 0);\n\t\tif (error < 0)\n\t\t\tgoto bp_err;\n\t\tif (error == 1) {\n\t\t\t/* We hit the beginning of the log during our search */\n\t\t\tstart_blk = log_bbnum - (num_scan_bblks - head_blk);\n\t\t\tnew_blk = log_bbnum;\n\t\t\tASSERT(start_blk <= INT_MAX &&\n\t\t\t\t(xfs_daddr_t) log_bbnum-start_blk >= 0);\n\t\t\tASSERT(head_blk <= INT_MAX);\n\t\t\terror = xlog_find_verify_log_record(log, start_blk,\n\t\t\t\t\t\t\t&new_blk, (int)head_blk);\n\t\t\tif (error == 1)\n\t\t\t\terror = -EIO;\n\t\t\tif (error)\n\t\t\t\tgoto bp_err;\n\t\t\tif (new_blk != log_bbnum)\n\t\t\t\thead_blk = new_blk;\n\t\t} else if (error)\n\t\t\tgoto bp_err;\n\t}\n\n\txlog_put_bp(bp);\n\tif (head_blk == log_bbnum)\n\t\t*return_head_blk = 0;\n\telse\n\t\t*return_head_blk = head_blk;\n\t/*\n\t * When returning here, we have a good block number.  Bad block\n\t * means that during a previous crash, we didn't have a clean break\n\t * from cycle number N to cycle number N-1.  In this case, we need\n\t * to find the first block with cycle number N-1.\n\t */\n\treturn 0;\n\n bp_err:\n\txlog_put_bp(bp);\n\n\tif (error)\n\t\txfs_warn(log->l_mp, \"failed to find log head\");\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_head(\n\tstruct xlog\t*log,\n\txfs_daddr_t\t*return_head_blk)\n{\n\txfs_buf_t\t*bp;\n\txfs_caddr_t\toffset;\n\txfs_daddr_t\tnew_blk, first_blk, start_blk, last_blk, head_blk;\n\tint\t\tnum_scan_bblks;\n\tuint\t\tfirst_half_cycle, last_half_cycle;\n\tuint\t\tstop_on_cycle;\n\tint\t\terror, log_bbnum = log->l_logBBsize;\n\n\t/* Is the end of the log device zeroed? */\n\terror = xlog_find_zeroed(log, &first_blk);\n\tif (error < 0) {\n\t\txfs_warn(log->l_mp, \"empty log check failed\");\n\t\treturn error;\n\t}\n\tif (error == 1) {\n\t\t*return_head_blk = first_blk;\n\n\t\t/* Is the whole lot zeroed? */\n\t\tif (!first_blk) {\n\t\t\t/* Linux XFS shouldn't generate totally zeroed logs -\n\t\t\t * mkfs etc write a dummy unmount record to a fresh\n\t\t\t * log so we can store the uuid in there\n\t\t\t */\n\t\t\txfs_warn(log->l_mp, \"totally zeroed log\");\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfirst_blk = 0;\t\t\t/* get cycle # of 1st block */\n\tbp = xlog_get_bp(log, 1);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\terror = xlog_bread(log, 0, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tfirst_half_cycle = xlog_get_cycle(offset);\n\n\tlast_blk = head_blk = log_bbnum - 1;\t/* get cycle # of last block */\n\terror = xlog_bread(log, last_blk, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tlast_half_cycle = xlog_get_cycle(offset);\n\tASSERT(last_half_cycle != 0);\n\n\t/*\n\t * If the 1st half cycle number is equal to the last half cycle number,\n\t * then the entire log is stamped with the same cycle number.  In this\n\t * case, head_blk can't be set to zero (which makes sense).  The below\n\t * math doesn't work out properly with head_blk equal to zero.  Instead,\n\t * we set it to log_bbnum which is an invalid block number, but this\n\t * value makes the math correct.  If head_blk doesn't changed through\n\t * all the tests below, *head_blk is set to zero at the very end rather\n\t * than log_bbnum.  In a sense, log_bbnum and zero are the same block\n\t * in a circular file.\n\t */\n\tif (first_half_cycle == last_half_cycle) {\n\t\t/*\n\t\t * In this case we believe that the entire log should have\n\t\t * cycle number last_half_cycle.  We need to scan backwards\n\t\t * from the end verifying that there are no holes still\n\t\t * containing last_half_cycle - 1.  If we find such a hole,\n\t\t * then the start of that hole will be the new head.  The\n\t\t * simple case looks like\n\t\t *        x | x ... | x - 1 | x\n\t\t * Another case that fits this picture would be\n\t\t *        x | x + 1 | x ... | x\n\t\t * In this case the head really is somewhere at the end of the\n\t\t * log, as one of the latest writes at the beginning was\n\t\t * incomplete.\n\t\t * One more case is\n\t\t *        x | x + 1 | x ... | x - 1 | x\n\t\t * This is really the combination of the above two cases, and\n\t\t * the head has to end up at the start of the x-1 hole at the\n\t\t * end of the log.\n\t\t *\n\t\t * In the 256k log case, we will read from the beginning to the\n\t\t * end of the log and search for cycle numbers equal to x-1.\n\t\t * We don't worry about the x+1 blocks that we encounter,\n\t\t * because we know that they cannot be the head since the log\n\t\t * started with x.\n\t\t */\n\t\thead_blk = log_bbnum;\n\t\tstop_on_cycle = last_half_cycle - 1;\n\t} else {\n\t\t/*\n\t\t * In this case we want to find the first block with cycle\n\t\t * number matching last_half_cycle.  We expect the log to be\n\t\t * some variation on\n\t\t *        x + 1 ... | x ... | x\n\t\t * The first block with cycle number x (last_half_cycle) will\n\t\t * be where the new head belongs.  First we do a binary search\n\t\t * for the first occurrence of last_half_cycle.  The binary\n\t\t * search may not be totally accurate, so then we scan back\n\t\t * from there looking for occurrences of last_half_cycle before\n\t\t * us.  If that backwards scan wraps around the beginning of\n\t\t * the log, then we look for occurrences of last_half_cycle - 1\n\t\t * at the end of the log.  The cases we're looking for look\n\t\t * like\n\t\t *                               v binary search stopped here\n\t\t *        x + 1 ... | x | x + 1 | x ... | x\n\t\t *                   ^ but we want to locate this spot\n\t\t * or\n\t\t *        <---------> less than scan distance\n\t\t *        x + 1 ... | x ... | x - 1 | x\n\t\t *                           ^ we want to locate this spot\n\t\t */\n\t\tstop_on_cycle = last_half_cycle;\n\t\tif ((error = xlog_find_cycle_start(log, bp, first_blk,\n\t\t\t\t\t\t&head_blk, last_half_cycle)))\n\t\t\tgoto bp_err;\n\t}\n\n\t/*\n\t * Now validate the answer.  Scan back some number of maximum possible\n\t * blocks and make sure each one has the expected cycle number.  The\n\t * maximum is determined by the total possible amount of buffering\n\t * in the in-core log.  The following number can be made tighter if\n\t * we actually look at the block size of the filesystem.\n\t */\n\tnum_scan_bblks = XLOG_TOTAL_REC_SHIFT(log);\n\tif (head_blk >= num_scan_bblks) {\n\t\t/*\n\t\t * We are guaranteed that the entire check can be performed\n\t\t * in one buffer.\n\t\t */\n\t\tstart_blk = head_blk - num_scan_bblks;\n\t\tif ((error = xlog_find_verify_cycle(log,\n\t\t\t\t\t\tstart_blk, num_scan_bblks,\n\t\t\t\t\t\tstop_on_cycle, &new_blk)))\n\t\t\tgoto bp_err;\n\t\tif (new_blk != -1)\n\t\t\thead_blk = new_blk;\n\t} else {\t\t/* need to read 2 parts of log */\n\t\t/*\n\t\t * We are going to scan backwards in the log in two parts.\n\t\t * First we scan the physical end of the log.  In this part\n\t\t * of the log, we are looking for blocks with cycle number\n\t\t * last_half_cycle - 1.\n\t\t * If we find one, then we know that the log starts there, as\n\t\t * we've found a hole that didn't get written in going around\n\t\t * the end of the physical log.  The simple case for this is\n\t\t *        x + 1 ... | x ... | x - 1 | x\n\t\t *        <---------> less than scan distance\n\t\t * If all of the blocks at the end of the log have cycle number\n\t\t * last_half_cycle, then we check the blocks at the start of\n\t\t * the log looking for occurrences of last_half_cycle.  If we\n\t\t * find one, then our current estimate for the location of the\n\t\t * first occurrence of last_half_cycle is wrong and we move\n\t\t * back to the hole we've found.  This case looks like\n\t\t *        x + 1 ... | x | x + 1 | x ...\n\t\t *                               ^ binary search stopped here\n\t\t * Another case we need to handle that only occurs in 256k\n\t\t * logs is\n\t\t *        x + 1 ... | x ... | x+1 | x ...\n\t\t *                   ^ binary search stops here\n\t\t * In a 256k log, the scan at the end of the log will see the\n\t\t * x + 1 blocks.  We need to skip past those since that is\n\t\t * certainly not the head of the log.  By searching for\n\t\t * last_half_cycle-1 we accomplish that.\n\t\t */\n\t\tASSERT(head_blk <= INT_MAX &&\n\t\t\t(xfs_daddr_t) num_scan_bblks >= head_blk);\n\t\tstart_blk = log_bbnum - (num_scan_bblks - head_blk);\n\t\tif ((error = xlog_find_verify_cycle(log, start_blk,\n\t\t\t\t\tnum_scan_bblks - (int)head_blk,\n\t\t\t\t\t(stop_on_cycle - 1), &new_blk)))\n\t\t\tgoto bp_err;\n\t\tif (new_blk != -1) {\n\t\t\thead_blk = new_blk;\n\t\t\tgoto validate_head;\n\t\t}\n\n\t\t/*\n\t\t * Scan beginning of log now.  The last part of the physical\n\t\t * log is good.  This scan needs to verify that it doesn't find\n\t\t * the last_half_cycle.\n\t\t */\n\t\tstart_blk = 0;\n\t\tASSERT(head_blk <= INT_MAX);\n\t\tif ((error = xlog_find_verify_cycle(log,\n\t\t\t\t\tstart_blk, (int)head_blk,\n\t\t\t\t\tstop_on_cycle, &new_blk)))\n\t\t\tgoto bp_err;\n\t\tif (new_blk != -1)\n\t\t\thead_blk = new_blk;\n\t}\n\nvalidate_head:\n\t/*\n\t * Now we need to make sure head_blk is not pointing to a block in\n\t * the middle of a log record.\n\t */\n\tnum_scan_bblks = XLOG_REC_SHIFT(log);\n\tif (head_blk >= num_scan_bblks) {\n\t\tstart_blk = head_blk - num_scan_bblks; /* don't read head_blk */\n\n\t\t/* start ptr at last block ptr before head_blk */\n\t\terror = xlog_find_verify_log_record(log, start_blk, &head_blk, 0);\n\t\tif (error == 1)\n\t\t\terror = -EIO;\n\t\tif (error)\n\t\t\tgoto bp_err;\n\t} else {\n\t\tstart_blk = 0;\n\t\tASSERT(head_blk <= INT_MAX);\n\t\terror = xlog_find_verify_log_record(log, start_blk, &head_blk, 0);\n\t\tif (error < 0)\n\t\t\tgoto bp_err;\n\t\tif (error == 1) {\n\t\t\t/* We hit the beginning of the log during our search */\n\t\t\tstart_blk = log_bbnum - (num_scan_bblks - head_blk);\n\t\t\tnew_blk = log_bbnum;\n\t\t\tASSERT(start_blk <= INT_MAX &&\n\t\t\t\t(xfs_daddr_t) log_bbnum-start_blk >= 0);\n\t\t\tASSERT(head_blk <= INT_MAX);\n\t\t\terror = xlog_find_verify_log_record(log, start_blk,\n\t\t\t\t\t\t\t&new_blk, (int)head_blk);\n\t\t\tif (error == 1)\n\t\t\t\terror = -EIO;\n\t\t\tif (error)\n\t\t\t\tgoto bp_err;\n\t\t\tif (new_blk != log_bbnum)\n\t\t\t\thead_blk = new_blk;\n\t\t} else if (error)\n\t\t\tgoto bp_err;\n\t}\n\n\txlog_put_bp(bp);\n\tif (head_blk == log_bbnum)\n\t\t*return_head_blk = 0;\n\telse\n\t\t*return_head_blk = head_blk;\n\t/*\n\t * When returning here, we have a good block number.  Bad block\n\t * means that during a previous crash, we didn't have a clean break\n\t * from cycle number N to cycle number N-1.  In this case, we need\n\t * to find the first block with cycle number N-1.\n\t */\n\treturn 0;\n\n bp_err:\n\txlog_put_bp(bp);\n\n\tif (error)\n\t\txfs_warn(log->l_mp, \"failed to find log head\");\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_tail(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\t*head_blk,\n\txfs_daddr_t\t\t*tail_blk)\n{\n\txlog_rec_header_t\t*rhead;\n\txlog_op_header_t\t*op_head;\n\txfs_caddr_t\t\toffset = NULL;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror, i, found;\n\txfs_daddr_t\t\tumount_data_blk;\n\txfs_daddr_t\t\tafter_umount_blk;\n\txfs_lsn_t\t\ttail_lsn;\n\tint\t\t\thblks;\n\n\tfound = 0;\n\n\t/*\n\t * Find previous log record\n\t */\n\tif ((error = xlog_find_head(log, head_blk)))\n\t\treturn error;\n\n\tbp = xlog_get_bp(log, 1);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\tif (*head_blk == 0) {\t\t\t\t/* special case */\n\t\terror = xlog_bread(log, 0, 1, bp, &offset);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\tif (xlog_get_cycle(offset) == 0) {\n\t\t\t*tail_blk = 0;\n\t\t\t/* leave all other log inited values alone */\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/*\n\t * Search backwards looking for log record header block\n\t */\n\tASSERT(*head_blk < INT_MAX);\n\tfor (i = (int)(*head_blk) - 1; i >= 0; i--) {\n\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\tif (*(__be32 *)offset == cpu_to_be32(XLOG_HEADER_MAGIC_NUM)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * If we haven't found the log record header block, start looking\n\t * again from the end of the physical log.  XXXmiken: There should be\n\t * a check here to make sure we didn't search more than N blocks in\n\t * the previous code.\n\t */\n\tif (!found) {\n\t\tfor (i = log->l_logBBsize - 1; i >= (int)(*head_blk); i--) {\n\t\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\n\t\t\tif (*(__be32 *)offset ==\n\t\t\t    cpu_to_be32(XLOG_HEADER_MAGIC_NUM)) {\n\t\t\t\tfound = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!found) {\n\t\txfs_warn(log->l_mp, \"%s: couldn't find sync record\", __func__);\n\t\txlog_put_bp(bp);\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n\n\t/* find blk_no of tail of log */\n\trhead = (xlog_rec_header_t *)offset;\n\t*tail_blk = BLOCK_LSN(be64_to_cpu(rhead->h_tail_lsn));\n\n\t/*\n\t * Reset log values according to the state of the log when we\n\t * crashed.  In the case where head_blk == 0, we bump curr_cycle\n\t * one because the next write starts a new cycle rather than\n\t * continuing the cycle of the last good log record.  At this\n\t * point we have guaranteed that all partial log records have been\n\t * accounted for.  Therefore, we know that the last good log record\n\t * written was complete and ended exactly on the end boundary\n\t * of the physical log.\n\t */\n\tlog->l_prev_block = i;\n\tlog->l_curr_block = (int)*head_blk;\n\tlog->l_curr_cycle = be32_to_cpu(rhead->h_cycle);\n\tif (found == 2)\n\t\tlog->l_curr_cycle++;\n\tatomic64_set(&log->l_tail_lsn, be64_to_cpu(rhead->h_tail_lsn));\n\tatomic64_set(&log->l_last_sync_lsn, be64_to_cpu(rhead->h_lsn));\n\txlog_assign_grant_head(&log->l_reserve_head.grant, log->l_curr_cycle,\n\t\t\t\t\tBBTOB(log->l_curr_block));\n\txlog_assign_grant_head(&log->l_write_head.grant, log->l_curr_cycle,\n\t\t\t\t\tBBTOB(log->l_curr_block));\n\n\t/*\n\t * Look for unmount record.  If we find it, then we know there\n\t * was a clean unmount.  Since 'i' could be the last block in\n\t * the physical log, we convert to a log block before comparing\n\t * to the head_blk.\n\t *\n\t * Save the current tail lsn to use to pass to\n\t * xlog_clear_stale_blocks() below.  We won't want to clear the\n\t * unmount record if there is one, so we pass the lsn of the\n\t * unmount record rather than the block after it.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tint\th_size = be32_to_cpu(rhead->h_size);\n\t\tint\th_version = be32_to_cpu(rhead->h_version);\n\n\t\tif ((h_version & XLOG_VERSION_2) &&\n\t\t    (h_size > XLOG_HEADER_CYCLE_SIZE)) {\n\t\t\thblks = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\t\thblks++;\n\t\t} else {\n\t\t\thblks = 1;\n\t\t}\n\t} else {\n\t\thblks = 1;\n\t}\n\tafter_umount_blk = (i + hblks + (int)\n\t\tBTOBB(be32_to_cpu(rhead->h_len))) % log->l_logBBsize;\n\ttail_lsn = atomic64_read(&log->l_tail_lsn);\n\tif (*head_blk == after_umount_blk &&\n\t    be32_to_cpu(rhead->h_num_logops) == 1) {\n\t\tumount_data_blk = (i + hblks) % log->l_logBBsize;\n\t\terror = xlog_bread(log, umount_data_blk, 1, bp, &offset);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\top_head = (xlog_op_header_t *)offset;\n\t\tif (op_head->oh_flags & XLOG_UNMOUNT_TRANS) {\n\t\t\t/*\n\t\t\t * Set tail and last sync so that newly written\n\t\t\t * log records will point recovery to after the\n\t\t\t * current unmount record.\n\t\t\t */\n\t\t\txlog_assign_atomic_lsn(&log->l_tail_lsn,\n\t\t\t\t\tlog->l_curr_cycle, after_umount_blk);\n\t\t\txlog_assign_atomic_lsn(&log->l_last_sync_lsn,\n\t\t\t\t\tlog->l_curr_cycle, after_umount_blk);\n\t\t\t*tail_blk = after_umount_blk;\n\n\t\t\t/*\n\t\t\t * Note that the unmount was clean. If the unmount\n\t\t\t * was not clean, we need to know this to rebuild the\n\t\t\t * superblock counters from the perag headers if we\n\t\t\t * have a filesystem using non-persistent counters.\n\t\t\t */\n\t\t\tlog->l_mp->m_flags |= XFS_MOUNT_WAS_CLEAN;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that there are no blocks in front of the head\n\t * with the same cycle number as the head.  This can happen\n\t * because we allow multiple outstanding log writes concurrently,\n\t * and the later writes might make it out before earlier ones.\n\t *\n\t * We use the lsn from before modifying it so that we'll never\n\t * overwrite the unmount record after a clean unmount.\n\t *\n\t * Do this only if we are going to recover the filesystem\n\t *\n\t * NOTE: This used to say \"if (!readonly)\"\n\t * However on Linux, we can & do recover a read-only filesystem.\n\t * We only skip recovery if NORECOVERY is specified on mount,\n\t * in which case we would not be here.\n\t *\n\t * But... if the -device- itself is readonly, just skip this.\n\t * We can't recover this device anyway, so it won't matter.\n\t */\n\tif (!xfs_readonly_buftarg(log->l_mp->m_logdev_targp))\n\t\terror = xlog_clear_stale_blocks(log, tail_lsn);\n\ndone:\n\txlog_put_bp(bp);\n\n\tif (error)\n\t\txfs_warn(log->l_mp, \"failed to locate log tail\");\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_find_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "613-868",
    "snippet": "STATIC int\nxlog_find_head(\n\tstruct xlog\t*log,\n\txfs_daddr_t\t*return_head_blk)\n{\n\txfs_buf_t\t*bp;\n\txfs_caddr_t\toffset;\n\txfs_daddr_t\tnew_blk, first_blk, start_blk, last_blk, head_blk;\n\tint\t\tnum_scan_bblks;\n\tuint\t\tfirst_half_cycle, last_half_cycle;\n\tuint\t\tstop_on_cycle;\n\tint\t\terror, log_bbnum = log->l_logBBsize;\n\n\t/* Is the end of the log device zeroed? */\n\terror = xlog_find_zeroed(log, &first_blk);\n\tif (error < 0) {\n\t\txfs_warn(log->l_mp, \"empty log check failed\");\n\t\treturn error;\n\t}\n\tif (error == 1) {\n\t\t*return_head_blk = first_blk;\n\n\t\t/* Is the whole lot zeroed? */\n\t\tif (!first_blk) {\n\t\t\t/* Linux XFS shouldn't generate totally zeroed logs -\n\t\t\t * mkfs etc write a dummy unmount record to a fresh\n\t\t\t * log so we can store the uuid in there\n\t\t\t */\n\t\t\txfs_warn(log->l_mp, \"totally zeroed log\");\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfirst_blk = 0;\t\t\t/* get cycle # of 1st block */\n\tbp = xlog_get_bp(log, 1);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\terror = xlog_bread(log, 0, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tfirst_half_cycle = xlog_get_cycle(offset);\n\n\tlast_blk = head_blk = log_bbnum - 1;\t/* get cycle # of last block */\n\terror = xlog_bread(log, last_blk, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tlast_half_cycle = xlog_get_cycle(offset);\n\tASSERT(last_half_cycle != 0);\n\n\t/*\n\t * If the 1st half cycle number is equal to the last half cycle number,\n\t * then the entire log is stamped with the same cycle number.  In this\n\t * case, head_blk can't be set to zero (which makes sense).  The below\n\t * math doesn't work out properly with head_blk equal to zero.  Instead,\n\t * we set it to log_bbnum which is an invalid block number, but this\n\t * value makes the math correct.  If head_blk doesn't changed through\n\t * all the tests below, *head_blk is set to zero at the very end rather\n\t * than log_bbnum.  In a sense, log_bbnum and zero are the same block\n\t * in a circular file.\n\t */\n\tif (first_half_cycle == last_half_cycle) {\n\t\t/*\n\t\t * In this case we believe that the entire log should have\n\t\t * cycle number last_half_cycle.  We need to scan backwards\n\t\t * from the end verifying that there are no holes still\n\t\t * containing last_half_cycle - 1.  If we find such a hole,\n\t\t * then the start of that hole will be the new head.  The\n\t\t * simple case looks like\n\t\t *        x | x ... | x - 1 | x\n\t\t * Another case that fits this picture would be\n\t\t *        x | x + 1 | x ... | x\n\t\t * In this case the head really is somewhere at the end of the\n\t\t * log, as one of the latest writes at the beginning was\n\t\t * incomplete.\n\t\t * One more case is\n\t\t *        x | x + 1 | x ... | x - 1 | x\n\t\t * This is really the combination of the above two cases, and\n\t\t * the head has to end up at the start of the x-1 hole at the\n\t\t * end of the log.\n\t\t *\n\t\t * In the 256k log case, we will read from the beginning to the\n\t\t * end of the log and search for cycle numbers equal to x-1.\n\t\t * We don't worry about the x+1 blocks that we encounter,\n\t\t * because we know that they cannot be the head since the log\n\t\t * started with x.\n\t\t */\n\t\thead_blk = log_bbnum;\n\t\tstop_on_cycle = last_half_cycle - 1;\n\t} else {\n\t\t/*\n\t\t * In this case we want to find the first block with cycle\n\t\t * number matching last_half_cycle.  We expect the log to be\n\t\t * some variation on\n\t\t *        x + 1 ... | x ... | x\n\t\t * The first block with cycle number x (last_half_cycle) will\n\t\t * be where the new head belongs.  First we do a binary search\n\t\t * for the first occurrence of last_half_cycle.  The binary\n\t\t * search may not be totally accurate, so then we scan back\n\t\t * from there looking for occurrences of last_half_cycle before\n\t\t * us.  If that backwards scan wraps around the beginning of\n\t\t * the log, then we look for occurrences of last_half_cycle - 1\n\t\t * at the end of the log.  The cases we're looking for look\n\t\t * like\n\t\t *                               v binary search stopped here\n\t\t *        x + 1 ... | x | x + 1 | x ... | x\n\t\t *                   ^ but we want to locate this spot\n\t\t * or\n\t\t *        <---------> less than scan distance\n\t\t *        x + 1 ... | x ... | x - 1 | x\n\t\t *                           ^ we want to locate this spot\n\t\t */\n\t\tstop_on_cycle = last_half_cycle;\n\t\tif ((error = xlog_find_cycle_start(log, bp, first_blk,\n\t\t\t\t\t\t&head_blk, last_half_cycle)))\n\t\t\tgoto bp_err;\n\t}\n\n\t/*\n\t * Now validate the answer.  Scan back some number of maximum possible\n\t * blocks and make sure each one has the expected cycle number.  The\n\t * maximum is determined by the total possible amount of buffering\n\t * in the in-core log.  The following number can be made tighter if\n\t * we actually look at the block size of the filesystem.\n\t */\n\tnum_scan_bblks = XLOG_TOTAL_REC_SHIFT(log);\n\tif (head_blk >= num_scan_bblks) {\n\t\t/*\n\t\t * We are guaranteed that the entire check can be performed\n\t\t * in one buffer.\n\t\t */\n\t\tstart_blk = head_blk - num_scan_bblks;\n\t\tif ((error = xlog_find_verify_cycle(log,\n\t\t\t\t\t\tstart_blk, num_scan_bblks,\n\t\t\t\t\t\tstop_on_cycle, &new_blk)))\n\t\t\tgoto bp_err;\n\t\tif (new_blk != -1)\n\t\t\thead_blk = new_blk;\n\t} else {\t\t/* need to read 2 parts of log */\n\t\t/*\n\t\t * We are going to scan backwards in the log in two parts.\n\t\t * First we scan the physical end of the log.  In this part\n\t\t * of the log, we are looking for blocks with cycle number\n\t\t * last_half_cycle - 1.\n\t\t * If we find one, then we know that the log starts there, as\n\t\t * we've found a hole that didn't get written in going around\n\t\t * the end of the physical log.  The simple case for this is\n\t\t *        x + 1 ... | x ... | x - 1 | x\n\t\t *        <---------> less than scan distance\n\t\t * If all of the blocks at the end of the log have cycle number\n\t\t * last_half_cycle, then we check the blocks at the start of\n\t\t * the log looking for occurrences of last_half_cycle.  If we\n\t\t * find one, then our current estimate for the location of the\n\t\t * first occurrence of last_half_cycle is wrong and we move\n\t\t * back to the hole we've found.  This case looks like\n\t\t *        x + 1 ... | x | x + 1 | x ...\n\t\t *                               ^ binary search stopped here\n\t\t * Another case we need to handle that only occurs in 256k\n\t\t * logs is\n\t\t *        x + 1 ... | x ... | x+1 | x ...\n\t\t *                   ^ binary search stops here\n\t\t * In a 256k log, the scan at the end of the log will see the\n\t\t * x + 1 blocks.  We need to skip past those since that is\n\t\t * certainly not the head of the log.  By searching for\n\t\t * last_half_cycle-1 we accomplish that.\n\t\t */\n\t\tASSERT(head_blk <= INT_MAX &&\n\t\t\t(xfs_daddr_t) num_scan_bblks >= head_blk);\n\t\tstart_blk = log_bbnum - (num_scan_bblks - head_blk);\n\t\tif ((error = xlog_find_verify_cycle(log, start_blk,\n\t\t\t\t\tnum_scan_bblks - (int)head_blk,\n\t\t\t\t\t(stop_on_cycle - 1), &new_blk)))\n\t\t\tgoto bp_err;\n\t\tif (new_blk != -1) {\n\t\t\thead_blk = new_blk;\n\t\t\tgoto validate_head;\n\t\t}\n\n\t\t/*\n\t\t * Scan beginning of log now.  The last part of the physical\n\t\t * log is good.  This scan needs to verify that it doesn't find\n\t\t * the last_half_cycle.\n\t\t */\n\t\tstart_blk = 0;\n\t\tASSERT(head_blk <= INT_MAX);\n\t\tif ((error = xlog_find_verify_cycle(log,\n\t\t\t\t\tstart_blk, (int)head_blk,\n\t\t\t\t\tstop_on_cycle, &new_blk)))\n\t\t\tgoto bp_err;\n\t\tif (new_blk != -1)\n\t\t\thead_blk = new_blk;\n\t}\n\nvalidate_head:\n\t/*\n\t * Now we need to make sure head_blk is not pointing to a block in\n\t * the middle of a log record.\n\t */\n\tnum_scan_bblks = XLOG_REC_SHIFT(log);\n\tif (head_blk >= num_scan_bblks) {\n\t\tstart_blk = head_blk - num_scan_bblks; /* don't read head_blk */\n\n\t\t/* start ptr at last block ptr before head_blk */\n\t\terror = xlog_find_verify_log_record(log, start_blk, &head_blk, 0);\n\t\tif (error == 1)\n\t\t\terror = -EIO;\n\t\tif (error)\n\t\t\tgoto bp_err;\n\t} else {\n\t\tstart_blk = 0;\n\t\tASSERT(head_blk <= INT_MAX);\n\t\terror = xlog_find_verify_log_record(log, start_blk, &head_blk, 0);\n\t\tif (error < 0)\n\t\t\tgoto bp_err;\n\t\tif (error == 1) {\n\t\t\t/* We hit the beginning of the log during our search */\n\t\t\tstart_blk = log_bbnum - (num_scan_bblks - head_blk);\n\t\t\tnew_blk = log_bbnum;\n\t\t\tASSERT(start_blk <= INT_MAX &&\n\t\t\t\t(xfs_daddr_t) log_bbnum-start_blk >= 0);\n\t\t\tASSERT(head_blk <= INT_MAX);\n\t\t\terror = xlog_find_verify_log_record(log, start_blk,\n\t\t\t\t\t\t\t&new_blk, (int)head_blk);\n\t\t\tif (error == 1)\n\t\t\t\terror = -EIO;\n\t\t\tif (error)\n\t\t\t\tgoto bp_err;\n\t\t\tif (new_blk != log_bbnum)\n\t\t\t\thead_blk = new_blk;\n\t\t} else if (error)\n\t\t\tgoto bp_err;\n\t}\n\n\txlog_put_bp(bp);\n\tif (head_blk == log_bbnum)\n\t\t*return_head_blk = 0;\n\telse\n\t\t*return_head_blk = head_blk;\n\t/*\n\t * When returning here, we have a good block number.  Bad block\n\t * means that during a previous crash, we didn't have a clean break\n\t * from cycle number N to cycle number N-1.  In this case, we need\n\t * to find the first block with cycle number N-1.\n\t */\n\treturn 0;\n\n bp_err:\n\txlog_put_bp(bp);\n\n\tif (error)\n\t\txfs_warn(log->l_mp, \"failed to find log head\");\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"failed to find log head\""
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_put_bp",
          "args": [
            "bp"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_put_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "139-144",
          "snippet": "STATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_find_verify_log_record",
          "args": [
            "log",
            "start_blk",
            "&new_blk",
            "(int)head_blk"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_find_verify_log_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "503-598",
          "snippet": "STATIC int\nxlog_find_verify_log_record(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tstart_blk,\n\txfs_daddr_t\t\t*last_blk,\n\tint\t\t\textra_bblks)\n{\n\txfs_daddr_t\t\ti;\n\txfs_buf_t\t\t*bp;\n\txfs_caddr_t\t\toffset = NULL;\n\txlog_rec_header_t\t*head = NULL;\n\tint\t\t\terror = 0;\n\tint\t\t\tsmallmem = 0;\n\tint\t\t\tnum_blks = *last_blk - start_blk;\n\tint\t\t\txhdrs;\n\n\tASSERT(start_blk != 0 || *last_blk != start_blk);\n\n\tif (!(bp = xlog_get_bp(log, num_blks))) {\n\t\tif (!(bp = xlog_get_bp(log, 1)))\n\t\t\treturn -ENOMEM;\n\t\tsmallmem = 1;\n\t} else {\n\t\terror = xlog_bread(log, start_blk, num_blks, bp, &offset);\n\t\tif (error)\n\t\t\tgoto out;\n\t\toffset += ((num_blks - 1) << BBSHIFT);\n\t}\n\n\tfor (i = (*last_blk) - 1; i >= 0; i--) {\n\t\tif (i < start_blk) {\n\t\t\t/* valid log record not found */\n\t\t\txfs_warn(log->l_mp,\n\t\t\"Log inconsistent (didn't find previous header)\");\n\t\t\tASSERT(0);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (smallmem) {\n\t\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\thead = (xlog_rec_header_t *)offset;\n\n\t\tif (head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\t\tbreak;\n\n\t\tif (!smallmem)\n\t\t\toffset -= BBSIZE;\n\t}\n\n\t/*\n\t * We hit the beginning of the physical log & still no header.  Return\n\t * to caller.  If caller can handle a return of -1, then this routine\n\t * will be called again for the end of the physical log.\n\t */\n\tif (i == -1) {\n\t\terror = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have the final block of the good log (the first block\n\t * of the log record _before_ the head. So we check the uuid.\n\t */\n\tif ((error = xlog_header_check_mount(log->l_mp, head)))\n\t\tgoto out;\n\n\t/*\n\t * We may have found a log record header before we expected one.\n\t * last_blk will be the 1st block # with a given cycle #.  We may end\n\t * up reading an entire log record.  In this case, we don't want to\n\t * reset last_blk.  Only when last_blk points in the middle of a log\n\t * record do we update last_blk.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tuint\th_size = be32_to_cpu(head->h_size);\n\n\t\txhdrs = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\txhdrs++;\n\t} else {\n\t\txhdrs = 1;\n\t}\n\n\tif (*last_blk - i + extra_bblks !=\n\t    BTOBB(be32_to_cpu(head->h_len)) + xhdrs)\n\t\t*last_blk = i;\n\nout:\n\txlog_put_bp(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_verify_log_record(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tstart_blk,\n\txfs_daddr_t\t\t*last_blk,\n\tint\t\t\textra_bblks)\n{\n\txfs_daddr_t\t\ti;\n\txfs_buf_t\t\t*bp;\n\txfs_caddr_t\t\toffset = NULL;\n\txlog_rec_header_t\t*head = NULL;\n\tint\t\t\terror = 0;\n\tint\t\t\tsmallmem = 0;\n\tint\t\t\tnum_blks = *last_blk - start_blk;\n\tint\t\t\txhdrs;\n\n\tASSERT(start_blk != 0 || *last_blk != start_blk);\n\n\tif (!(bp = xlog_get_bp(log, num_blks))) {\n\t\tif (!(bp = xlog_get_bp(log, 1)))\n\t\t\treturn -ENOMEM;\n\t\tsmallmem = 1;\n\t} else {\n\t\terror = xlog_bread(log, start_blk, num_blks, bp, &offset);\n\t\tif (error)\n\t\t\tgoto out;\n\t\toffset += ((num_blks - 1) << BBSHIFT);\n\t}\n\n\tfor (i = (*last_blk) - 1; i >= 0; i--) {\n\t\tif (i < start_blk) {\n\t\t\t/* valid log record not found */\n\t\t\txfs_warn(log->l_mp,\n\t\t\"Log inconsistent (didn't find previous header)\");\n\t\t\tASSERT(0);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (smallmem) {\n\t\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\thead = (xlog_rec_header_t *)offset;\n\n\t\tif (head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\t\tbreak;\n\n\t\tif (!smallmem)\n\t\t\toffset -= BBSIZE;\n\t}\n\n\t/*\n\t * We hit the beginning of the physical log & still no header.  Return\n\t * to caller.  If caller can handle a return of -1, then this routine\n\t * will be called again for the end of the physical log.\n\t */\n\tif (i == -1) {\n\t\terror = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have the final block of the good log (the first block\n\t * of the log record _before_ the head. So we check the uuid.\n\t */\n\tif ((error = xlog_header_check_mount(log->l_mp, head)))\n\t\tgoto out;\n\n\t/*\n\t * We may have found a log record header before we expected one.\n\t * last_blk will be the 1st block # with a given cycle #.  We may end\n\t * up reading an entire log record.  In this case, we don't want to\n\t * reset last_blk.  Only when last_blk points in the middle of a log\n\t * record do we update last_blk.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tuint\th_size = be32_to_cpu(head->h_size);\n\n\t\txhdrs = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\txhdrs++;\n\t} else {\n\t\txhdrs = 1;\n\t}\n\n\tif (*last_blk - i + extra_bblks !=\n\t    BTOBB(be32_to_cpu(head->h_len)) + xhdrs)\n\t\t*last_blk = i;\n\nout:\n\txlog_put_bp(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "head_blk <= INT_MAX"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "start_blk <= INT_MAX &&\n\t\t\t\t(xfs_daddr_t) log_bbnum-start_blk >= 0"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "head_blk <= INT_MAX"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_REC_SHIFT",
          "args": [
            "log"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_find_verify_cycle",
          "args": [
            "log",
            "start_blk",
            "(int)head_blk",
            "stop_on_cycle",
            "&new_blk"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_find_verify_cycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "434-489",
          "snippet": "STATIC int\nxlog_find_verify_cycle(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tstart_blk,\n\tint\t\tnbblks,\n\tuint\t\tstop_on_cycle_no,\n\txfs_daddr_t\t*new_blk)\n{\n\txfs_daddr_t\ti, j;\n\tuint\t\tcycle;\n\txfs_buf_t\t*bp;\n\txfs_daddr_t\tbufblks;\n\txfs_caddr_t\tbuf = NULL;\n\tint\t\terror = 0;\n\n\t/*\n\t * Greedily allocate a buffer big enough to handle the full\n\t * range of basic blocks we'll be examining.  If that fails,\n\t * try a smaller size.  We need to be able to read at least\n\t * a log sector, or we're out of luck.\n\t */\n\tbufblks = 1 << ffs(nbblks);\n\twhile (bufblks > log->l_logBBsize)\n\t\tbufblks >>= 1;\n\twhile (!(bp = xlog_get_bp(log, bufblks))) {\n\t\tbufblks >>= 1;\n\t\tif (bufblks < log->l_sectBBsize)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = start_blk; i < start_blk + nbblks; i += bufblks) {\n\t\tint\tbcount;\n\n\t\tbcount = min(bufblks, (start_blk + nbblks - i));\n\n\t\terror = xlog_bread(log, i, bcount, bp, &buf);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tfor (j = 0; j < bcount; j++) {\n\t\t\tcycle = xlog_get_cycle(buf);\n\t\t\tif (cycle == stop_on_cycle_no) {\n\t\t\t\t*new_blk = i+j;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbuf += BBSIZE;\n\t\t}\n\t}\n\n\t*new_blk = -1;\n\nout:\n\txlog_put_bp(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_verify_cycle(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tstart_blk,\n\tint\t\tnbblks,\n\tuint\t\tstop_on_cycle_no,\n\txfs_daddr_t\t*new_blk)\n{\n\txfs_daddr_t\ti, j;\n\tuint\t\tcycle;\n\txfs_buf_t\t*bp;\n\txfs_daddr_t\tbufblks;\n\txfs_caddr_t\tbuf = NULL;\n\tint\t\terror = 0;\n\n\t/*\n\t * Greedily allocate a buffer big enough to handle the full\n\t * range of basic blocks we'll be examining.  If that fails,\n\t * try a smaller size.  We need to be able to read at least\n\t * a log sector, or we're out of luck.\n\t */\n\tbufblks = 1 << ffs(nbblks);\n\twhile (bufblks > log->l_logBBsize)\n\t\tbufblks >>= 1;\n\twhile (!(bp = xlog_get_bp(log, bufblks))) {\n\t\tbufblks >>= 1;\n\t\tif (bufblks < log->l_sectBBsize)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = start_blk; i < start_blk + nbblks; i += bufblks) {\n\t\tint\tbcount;\n\n\t\tbcount = min(bufblks, (start_blk + nbblks - i));\n\n\t\terror = xlog_bread(log, i, bcount, bp, &buf);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tfor (j = 0; j < bcount; j++) {\n\t\t\tcycle = xlog_get_cycle(buf);\n\t\t\tif (cycle == stop_on_cycle_no) {\n\t\t\t\t*new_blk = i+j;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbuf += BBSIZE;\n\t\t}\n\t}\n\n\t*new_blk = -1;\n\nout:\n\txlog_put_bp(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "head_blk <= INT_MAX"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "head_blk <= INT_MAX &&\n\t\t\t(xfs_daddr_t) num_scan_bblks >= head_blk"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_TOTAL_REC_SHIFT",
          "args": [
            "log"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_find_cycle_start",
          "args": [
            "log",
            "bp",
            "first_blk",
            "&head_blk",
            "last_half_cycle"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_find_cycle_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "391-424",
          "snippet": "STATIC int\nxlog_find_cycle_start(\n\tstruct xlog\t*log,\n\tstruct xfs_buf\t*bp,\n\txfs_daddr_t\tfirst_blk,\n\txfs_daddr_t\t*last_blk,\n\tuint\t\tcycle)\n{\n\txfs_caddr_t\toffset;\n\txfs_daddr_t\tmid_blk;\n\txfs_daddr_t\tend_blk;\n\tuint\t\tmid_cycle;\n\tint\t\terror;\n\n\tend_blk = *last_blk;\n\tmid_blk = BLK_AVG(first_blk, end_blk);\n\twhile (mid_blk != first_blk && mid_blk != end_blk) {\n\t\terror = xlog_bread(log, mid_blk, 1, bp, &offset);\n\t\tif (error)\n\t\t\treturn error;\n\t\tmid_cycle = xlog_get_cycle(offset);\n\t\tif (mid_cycle == cycle)\n\t\t\tend_blk = mid_blk;   /* last_half_cycle == mid_cycle */\n\t\telse\n\t\t\tfirst_blk = mid_blk; /* first_half_cycle == mid_cycle */\n\t\tmid_blk = BLK_AVG(first_blk, end_blk);\n\t}\n\tASSERT((mid_blk == first_blk && mid_blk+1 == end_blk) ||\n\t       (mid_blk == end_blk && mid_blk-1 == first_blk));\n\n\t*last_blk = end_blk;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_cycle_start(\n\tstruct xlog\t*log,\n\tstruct xfs_buf\t*bp,\n\txfs_daddr_t\tfirst_blk,\n\txfs_daddr_t\t*last_blk,\n\tuint\t\tcycle)\n{\n\txfs_caddr_t\toffset;\n\txfs_daddr_t\tmid_blk;\n\txfs_daddr_t\tend_blk;\n\tuint\t\tmid_cycle;\n\tint\t\terror;\n\n\tend_blk = *last_blk;\n\tmid_blk = BLK_AVG(first_blk, end_blk);\n\twhile (mid_blk != first_blk && mid_blk != end_blk) {\n\t\terror = xlog_bread(log, mid_blk, 1, bp, &offset);\n\t\tif (error)\n\t\t\treturn error;\n\t\tmid_cycle = xlog_get_cycle(offset);\n\t\tif (mid_cycle == cycle)\n\t\t\tend_blk = mid_blk;   /* last_half_cycle == mid_cycle */\n\t\telse\n\t\t\tfirst_blk = mid_blk; /* first_half_cycle == mid_cycle */\n\t\tmid_blk = BLK_AVG(first_blk, end_blk);\n\t}\n\tASSERT((mid_blk == first_blk && mid_blk+1 == end_blk) ||\n\t       (mid_blk == end_blk && mid_blk-1 == first_blk));\n\n\t*last_blk = end_blk;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "last_half_cycle != 0"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_get_cycle",
          "args": [
            "offset"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_cycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "77-83",
          "snippet": "static inline uint xlog_get_cycle(char *ptr)\n{\n\tif (be32_to_cpu(*(__be32 *)ptr) == XLOG_HEADER_MAGIC_NUM)\n\t\treturn be32_to_cpu(*((__be32 *)ptr + 1));\n\telse\n\t\treturn be32_to_cpu(*(__be32 *)ptr);\n}",
          "includes": [],
          "macros_used": [
            "#define XLOG_HEADER_MAGIC_NUM\t0xFEEDbabe\t/* Invalid cycle number */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XLOG_HEADER_MAGIC_NUM\t0xFEEDbabe\t/* Invalid cycle number */\n\nstatic inline uint xlog_get_cycle(char *ptr)\n{\n\tif (be32_to_cpu(*(__be32 *)ptr) == XLOG_HEADER_MAGIC_NUM)\n\t\treturn be32_to_cpu(*((__be32 *)ptr + 1));\n\telse\n\t\treturn be32_to_cpu(*(__be32 *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_bread",
          "args": [
            "log",
            "last_blk",
            "1",
            "bp",
            "&offset"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_bread_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "222-245",
          "snippet": "STATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_get_bp",
          "args": [
            "log",
            "1"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "99-137",
          "snippet": "STATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"totally zeroed log\""
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"empty log check failed\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_find_zeroed",
          "args": [
            "log",
            "&first_blk"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_find_zeroed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "1096-1192",
          "snippet": "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*log,\n\txfs_daddr_t\t*blk_no)\n{\n\txfs_buf_t\t*bp;\n\txfs_caddr_t\toffset;\n\tuint\t        first_cycle, last_cycle;\n\txfs_daddr_t\tnew_blk, last_blk, start_blk;\n\txfs_daddr_t     num_scan_bblks;\n\tint\t        error, log_bbnum = log->l_logBBsize;\n\n\t*blk_no = 0;\n\n\t/* check totally zeroed log */\n\tbp = xlog_get_bp(log, 1);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\terror = xlog_bread(log, 0, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tfirst_cycle = xlog_get_cycle(offset);\n\tif (first_cycle == 0) {\t\t/* completely zeroed log */\n\t\t*blk_no = 0;\n\t\txlog_put_bp(bp);\n\t\treturn 1;\n\t}\n\n\t/* check partially zeroed log */\n\terror = xlog_bread(log, log_bbnum-1, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tlast_cycle = xlog_get_cycle(offset);\n\tif (last_cycle != 0) {\t\t/* log completely written to */\n\t\txlog_put_bp(bp);\n\t\treturn 0;\n\t} else if (first_cycle != 1) {\n\t\t/*\n\t\t * If the cycle of the last block is zero, the cycle of\n\t\t * the first block must be 1. If it's not, maybe we're\n\t\t * not looking at a log... Bail out.\n\t\t */\n\t\txfs_warn(log->l_mp,\n\t\t\t\"Log inconsistent or not a log (last==0, first!=1)\");\n\t\terror = -EINVAL;\n\t\tgoto bp_err;\n\t}\n\n\t/* we have a partially zeroed log */\n\tlast_blk = log_bbnum-1;\n\tif ((error = xlog_find_cycle_start(log, bp, 0, &last_blk, 0)))\n\t\tgoto bp_err;\n\n\t/*\n\t * Validate the answer.  Because there is no way to guarantee that\n\t * the entire log is made up of log records which are the same size,\n\t * we scan over the defined maximum blocks.  At this point, the maximum\n\t * is not chosen to mean anything special.   XXXmiken\n\t */\n\tnum_scan_bblks = XLOG_TOTAL_REC_SHIFT(log);\n\tASSERT(num_scan_bblks <= INT_MAX);\n\n\tif (last_blk < num_scan_bblks)\n\t\tnum_scan_bblks = last_blk;\n\tstart_blk = last_blk - num_scan_bblks;\n\n\t/*\n\t * We search for any instances of cycle number 0 that occur before\n\t * our current estimate of the head.  What we're trying to detect is\n\t *        1 ... | 0 | 1 | 0...\n\t *                       ^ binary search ends here\n\t */\n\tif ((error = xlog_find_verify_cycle(log, start_blk,\n\t\t\t\t\t (int)num_scan_bblks, 0, &new_blk)))\n\t\tgoto bp_err;\n\tif (new_blk != -1)\n\t\tlast_blk = new_blk;\n\n\t/*\n\t * Potentially backup over partial log record write.  We don't need\n\t * to search the end of the log because we know it is zero.\n\t */\n\terror = xlog_find_verify_log_record(log, start_blk, &last_blk, 0);\n\tif (error == 1)\n\t\terror = -EIO;\n\tif (error)\n\t\tgoto bp_err;\n\n\t*blk_no = last_blk;\nbp_err:\n\txlog_put_bp(bp);\n\tif (error)\n\t\treturn error;\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*log,\n\txfs_daddr_t\t*blk_no)\n{\n\txfs_buf_t\t*bp;\n\txfs_caddr_t\toffset;\n\tuint\t        first_cycle, last_cycle;\n\txfs_daddr_t\tnew_blk, last_blk, start_blk;\n\txfs_daddr_t     num_scan_bblks;\n\tint\t        error, log_bbnum = log->l_logBBsize;\n\n\t*blk_no = 0;\n\n\t/* check totally zeroed log */\n\tbp = xlog_get_bp(log, 1);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\terror = xlog_bread(log, 0, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tfirst_cycle = xlog_get_cycle(offset);\n\tif (first_cycle == 0) {\t\t/* completely zeroed log */\n\t\t*blk_no = 0;\n\t\txlog_put_bp(bp);\n\t\treturn 1;\n\t}\n\n\t/* check partially zeroed log */\n\terror = xlog_bread(log, log_bbnum-1, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tlast_cycle = xlog_get_cycle(offset);\n\tif (last_cycle != 0) {\t\t/* log completely written to */\n\t\txlog_put_bp(bp);\n\t\treturn 0;\n\t} else if (first_cycle != 1) {\n\t\t/*\n\t\t * If the cycle of the last block is zero, the cycle of\n\t\t * the first block must be 1. If it's not, maybe we're\n\t\t * not looking at a log... Bail out.\n\t\t */\n\t\txfs_warn(log->l_mp,\n\t\t\t\"Log inconsistent or not a log (last==0, first!=1)\");\n\t\terror = -EINVAL;\n\t\tgoto bp_err;\n\t}\n\n\t/* we have a partially zeroed log */\n\tlast_blk = log_bbnum-1;\n\tif ((error = xlog_find_cycle_start(log, bp, 0, &last_blk, 0)))\n\t\tgoto bp_err;\n\n\t/*\n\t * Validate the answer.  Because there is no way to guarantee that\n\t * the entire log is made up of log records which are the same size,\n\t * we scan over the defined maximum blocks.  At this point, the maximum\n\t * is not chosen to mean anything special.   XXXmiken\n\t */\n\tnum_scan_bblks = XLOG_TOTAL_REC_SHIFT(log);\n\tASSERT(num_scan_bblks <= INT_MAX);\n\n\tif (last_blk < num_scan_bblks)\n\t\tnum_scan_bblks = last_blk;\n\tstart_blk = last_blk - num_scan_bblks;\n\n\t/*\n\t * We search for any instances of cycle number 0 that occur before\n\t * our current estimate of the head.  What we're trying to detect is\n\t *        1 ... | 0 | 1 | 0...\n\t *                       ^ binary search ends here\n\t */\n\tif ((error = xlog_find_verify_cycle(log, start_blk,\n\t\t\t\t\t (int)num_scan_bblks, 0, &new_blk)))\n\t\tgoto bp_err;\n\tif (new_blk != -1)\n\t\tlast_blk = new_blk;\n\n\t/*\n\t * Potentially backup over partial log record write.  We don't need\n\t * to search the end of the log because we know it is zero.\n\t */\n\terror = xlog_find_verify_log_record(log, start_blk, &last_blk, 0);\n\tif (error == 1)\n\t\terror = -EIO;\n\tif (error)\n\t\tgoto bp_err;\n\n\t*blk_no = last_blk;\nbp_err:\n\txlog_put_bp(bp);\n\tif (error)\n\t\treturn error;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_head(\n\tstruct xlog\t*log,\n\txfs_daddr_t\t*return_head_blk)\n{\n\txfs_buf_t\t*bp;\n\txfs_caddr_t\toffset;\n\txfs_daddr_t\tnew_blk, first_blk, start_blk, last_blk, head_blk;\n\tint\t\tnum_scan_bblks;\n\tuint\t\tfirst_half_cycle, last_half_cycle;\n\tuint\t\tstop_on_cycle;\n\tint\t\terror, log_bbnum = log->l_logBBsize;\n\n\t/* Is the end of the log device zeroed? */\n\terror = xlog_find_zeroed(log, &first_blk);\n\tif (error < 0) {\n\t\txfs_warn(log->l_mp, \"empty log check failed\");\n\t\treturn error;\n\t}\n\tif (error == 1) {\n\t\t*return_head_blk = first_blk;\n\n\t\t/* Is the whole lot zeroed? */\n\t\tif (!first_blk) {\n\t\t\t/* Linux XFS shouldn't generate totally zeroed logs -\n\t\t\t * mkfs etc write a dummy unmount record to a fresh\n\t\t\t * log so we can store the uuid in there\n\t\t\t */\n\t\t\txfs_warn(log->l_mp, \"totally zeroed log\");\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfirst_blk = 0;\t\t\t/* get cycle # of 1st block */\n\tbp = xlog_get_bp(log, 1);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\terror = xlog_bread(log, 0, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tfirst_half_cycle = xlog_get_cycle(offset);\n\n\tlast_blk = head_blk = log_bbnum - 1;\t/* get cycle # of last block */\n\terror = xlog_bread(log, last_blk, 1, bp, &offset);\n\tif (error)\n\t\tgoto bp_err;\n\n\tlast_half_cycle = xlog_get_cycle(offset);\n\tASSERT(last_half_cycle != 0);\n\n\t/*\n\t * If the 1st half cycle number is equal to the last half cycle number,\n\t * then the entire log is stamped with the same cycle number.  In this\n\t * case, head_blk can't be set to zero (which makes sense).  The below\n\t * math doesn't work out properly with head_blk equal to zero.  Instead,\n\t * we set it to log_bbnum which is an invalid block number, but this\n\t * value makes the math correct.  If head_blk doesn't changed through\n\t * all the tests below, *head_blk is set to zero at the very end rather\n\t * than log_bbnum.  In a sense, log_bbnum and zero are the same block\n\t * in a circular file.\n\t */\n\tif (first_half_cycle == last_half_cycle) {\n\t\t/*\n\t\t * In this case we believe that the entire log should have\n\t\t * cycle number last_half_cycle.  We need to scan backwards\n\t\t * from the end verifying that there are no holes still\n\t\t * containing last_half_cycle - 1.  If we find such a hole,\n\t\t * then the start of that hole will be the new head.  The\n\t\t * simple case looks like\n\t\t *        x | x ... | x - 1 | x\n\t\t * Another case that fits this picture would be\n\t\t *        x | x + 1 | x ... | x\n\t\t * In this case the head really is somewhere at the end of the\n\t\t * log, as one of the latest writes at the beginning was\n\t\t * incomplete.\n\t\t * One more case is\n\t\t *        x | x + 1 | x ... | x - 1 | x\n\t\t * This is really the combination of the above two cases, and\n\t\t * the head has to end up at the start of the x-1 hole at the\n\t\t * end of the log.\n\t\t *\n\t\t * In the 256k log case, we will read from the beginning to the\n\t\t * end of the log and search for cycle numbers equal to x-1.\n\t\t * We don't worry about the x+1 blocks that we encounter,\n\t\t * because we know that they cannot be the head since the log\n\t\t * started with x.\n\t\t */\n\t\thead_blk = log_bbnum;\n\t\tstop_on_cycle = last_half_cycle - 1;\n\t} else {\n\t\t/*\n\t\t * In this case we want to find the first block with cycle\n\t\t * number matching last_half_cycle.  We expect the log to be\n\t\t * some variation on\n\t\t *        x + 1 ... | x ... | x\n\t\t * The first block with cycle number x (last_half_cycle) will\n\t\t * be where the new head belongs.  First we do a binary search\n\t\t * for the first occurrence of last_half_cycle.  The binary\n\t\t * search may not be totally accurate, so then we scan back\n\t\t * from there looking for occurrences of last_half_cycle before\n\t\t * us.  If that backwards scan wraps around the beginning of\n\t\t * the log, then we look for occurrences of last_half_cycle - 1\n\t\t * at the end of the log.  The cases we're looking for look\n\t\t * like\n\t\t *                               v binary search stopped here\n\t\t *        x + 1 ... | x | x + 1 | x ... | x\n\t\t *                   ^ but we want to locate this spot\n\t\t * or\n\t\t *        <---------> less than scan distance\n\t\t *        x + 1 ... | x ... | x - 1 | x\n\t\t *                           ^ we want to locate this spot\n\t\t */\n\t\tstop_on_cycle = last_half_cycle;\n\t\tif ((error = xlog_find_cycle_start(log, bp, first_blk,\n\t\t\t\t\t\t&head_blk, last_half_cycle)))\n\t\t\tgoto bp_err;\n\t}\n\n\t/*\n\t * Now validate the answer.  Scan back some number of maximum possible\n\t * blocks and make sure each one has the expected cycle number.  The\n\t * maximum is determined by the total possible amount of buffering\n\t * in the in-core log.  The following number can be made tighter if\n\t * we actually look at the block size of the filesystem.\n\t */\n\tnum_scan_bblks = XLOG_TOTAL_REC_SHIFT(log);\n\tif (head_blk >= num_scan_bblks) {\n\t\t/*\n\t\t * We are guaranteed that the entire check can be performed\n\t\t * in one buffer.\n\t\t */\n\t\tstart_blk = head_blk - num_scan_bblks;\n\t\tif ((error = xlog_find_verify_cycle(log,\n\t\t\t\t\t\tstart_blk, num_scan_bblks,\n\t\t\t\t\t\tstop_on_cycle, &new_blk)))\n\t\t\tgoto bp_err;\n\t\tif (new_blk != -1)\n\t\t\thead_blk = new_blk;\n\t} else {\t\t/* need to read 2 parts of log */\n\t\t/*\n\t\t * We are going to scan backwards in the log in two parts.\n\t\t * First we scan the physical end of the log.  In this part\n\t\t * of the log, we are looking for blocks with cycle number\n\t\t * last_half_cycle - 1.\n\t\t * If we find one, then we know that the log starts there, as\n\t\t * we've found a hole that didn't get written in going around\n\t\t * the end of the physical log.  The simple case for this is\n\t\t *        x + 1 ... | x ... | x - 1 | x\n\t\t *        <---------> less than scan distance\n\t\t * If all of the blocks at the end of the log have cycle number\n\t\t * last_half_cycle, then we check the blocks at the start of\n\t\t * the log looking for occurrences of last_half_cycle.  If we\n\t\t * find one, then our current estimate for the location of the\n\t\t * first occurrence of last_half_cycle is wrong and we move\n\t\t * back to the hole we've found.  This case looks like\n\t\t *        x + 1 ... | x | x + 1 | x ...\n\t\t *                               ^ binary search stopped here\n\t\t * Another case we need to handle that only occurs in 256k\n\t\t * logs is\n\t\t *        x + 1 ... | x ... | x+1 | x ...\n\t\t *                   ^ binary search stops here\n\t\t * In a 256k log, the scan at the end of the log will see the\n\t\t * x + 1 blocks.  We need to skip past those since that is\n\t\t * certainly not the head of the log.  By searching for\n\t\t * last_half_cycle-1 we accomplish that.\n\t\t */\n\t\tASSERT(head_blk <= INT_MAX &&\n\t\t\t(xfs_daddr_t) num_scan_bblks >= head_blk);\n\t\tstart_blk = log_bbnum - (num_scan_bblks - head_blk);\n\t\tif ((error = xlog_find_verify_cycle(log, start_blk,\n\t\t\t\t\tnum_scan_bblks - (int)head_blk,\n\t\t\t\t\t(stop_on_cycle - 1), &new_blk)))\n\t\t\tgoto bp_err;\n\t\tif (new_blk != -1) {\n\t\t\thead_blk = new_blk;\n\t\t\tgoto validate_head;\n\t\t}\n\n\t\t/*\n\t\t * Scan beginning of log now.  The last part of the physical\n\t\t * log is good.  This scan needs to verify that it doesn't find\n\t\t * the last_half_cycle.\n\t\t */\n\t\tstart_blk = 0;\n\t\tASSERT(head_blk <= INT_MAX);\n\t\tif ((error = xlog_find_verify_cycle(log,\n\t\t\t\t\tstart_blk, (int)head_blk,\n\t\t\t\t\tstop_on_cycle, &new_blk)))\n\t\t\tgoto bp_err;\n\t\tif (new_blk != -1)\n\t\t\thead_blk = new_blk;\n\t}\n\nvalidate_head:\n\t/*\n\t * Now we need to make sure head_blk is not pointing to a block in\n\t * the middle of a log record.\n\t */\n\tnum_scan_bblks = XLOG_REC_SHIFT(log);\n\tif (head_blk >= num_scan_bblks) {\n\t\tstart_blk = head_blk - num_scan_bblks; /* don't read head_blk */\n\n\t\t/* start ptr at last block ptr before head_blk */\n\t\terror = xlog_find_verify_log_record(log, start_blk, &head_blk, 0);\n\t\tif (error == 1)\n\t\t\terror = -EIO;\n\t\tif (error)\n\t\t\tgoto bp_err;\n\t} else {\n\t\tstart_blk = 0;\n\t\tASSERT(head_blk <= INT_MAX);\n\t\terror = xlog_find_verify_log_record(log, start_blk, &head_blk, 0);\n\t\tif (error < 0)\n\t\t\tgoto bp_err;\n\t\tif (error == 1) {\n\t\t\t/* We hit the beginning of the log during our search */\n\t\t\tstart_blk = log_bbnum - (num_scan_bblks - head_blk);\n\t\t\tnew_blk = log_bbnum;\n\t\t\tASSERT(start_blk <= INT_MAX &&\n\t\t\t\t(xfs_daddr_t) log_bbnum-start_blk >= 0);\n\t\t\tASSERT(head_blk <= INT_MAX);\n\t\t\terror = xlog_find_verify_log_record(log, start_blk,\n\t\t\t\t\t\t\t&new_blk, (int)head_blk);\n\t\t\tif (error == 1)\n\t\t\t\terror = -EIO;\n\t\t\tif (error)\n\t\t\t\tgoto bp_err;\n\t\t\tif (new_blk != log_bbnum)\n\t\t\t\thead_blk = new_blk;\n\t\t} else if (error)\n\t\t\tgoto bp_err;\n\t}\n\n\txlog_put_bp(bp);\n\tif (head_blk == log_bbnum)\n\t\t*return_head_blk = 0;\n\telse\n\t\t*return_head_blk = head_blk;\n\t/*\n\t * When returning here, we have a good block number.  Bad block\n\t * means that during a previous crash, we didn't have a clean break\n\t * from cycle number N to cycle number N-1.  In this case, we need\n\t * to find the first block with cycle number N-1.\n\t */\n\treturn 0;\n\n bp_err:\n\txlog_put_bp(bp);\n\n\tif (error)\n\t\txfs_warn(log->l_mp, \"failed to find log head\");\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_find_verify_log_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "503-598",
    "snippet": "STATIC int\nxlog_find_verify_log_record(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tstart_blk,\n\txfs_daddr_t\t\t*last_blk,\n\tint\t\t\textra_bblks)\n{\n\txfs_daddr_t\t\ti;\n\txfs_buf_t\t\t*bp;\n\txfs_caddr_t\t\toffset = NULL;\n\txlog_rec_header_t\t*head = NULL;\n\tint\t\t\terror = 0;\n\tint\t\t\tsmallmem = 0;\n\tint\t\t\tnum_blks = *last_blk - start_blk;\n\tint\t\t\txhdrs;\n\n\tASSERT(start_blk != 0 || *last_blk != start_blk);\n\n\tif (!(bp = xlog_get_bp(log, num_blks))) {\n\t\tif (!(bp = xlog_get_bp(log, 1)))\n\t\t\treturn -ENOMEM;\n\t\tsmallmem = 1;\n\t} else {\n\t\terror = xlog_bread(log, start_blk, num_blks, bp, &offset);\n\t\tif (error)\n\t\t\tgoto out;\n\t\toffset += ((num_blks - 1) << BBSHIFT);\n\t}\n\n\tfor (i = (*last_blk) - 1; i >= 0; i--) {\n\t\tif (i < start_blk) {\n\t\t\t/* valid log record not found */\n\t\t\txfs_warn(log->l_mp,\n\t\t\"Log inconsistent (didn't find previous header)\");\n\t\t\tASSERT(0);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (smallmem) {\n\t\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\thead = (xlog_rec_header_t *)offset;\n\n\t\tif (head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\t\tbreak;\n\n\t\tif (!smallmem)\n\t\t\toffset -= BBSIZE;\n\t}\n\n\t/*\n\t * We hit the beginning of the physical log & still no header.  Return\n\t * to caller.  If caller can handle a return of -1, then this routine\n\t * will be called again for the end of the physical log.\n\t */\n\tif (i == -1) {\n\t\terror = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have the final block of the good log (the first block\n\t * of the log record _before_ the head. So we check the uuid.\n\t */\n\tif ((error = xlog_header_check_mount(log->l_mp, head)))\n\t\tgoto out;\n\n\t/*\n\t * We may have found a log record header before we expected one.\n\t * last_blk will be the 1st block # with a given cycle #.  We may end\n\t * up reading an entire log record.  In this case, we don't want to\n\t * reset last_blk.  Only when last_blk points in the middle of a log\n\t * record do we update last_blk.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tuint\th_size = be32_to_cpu(head->h_size);\n\n\t\txhdrs = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\txhdrs++;\n\t} else {\n\t\txhdrs = 1;\n\t}\n\n\tif (*last_blk - i + extra_bblks !=\n\t    BTOBB(be32_to_cpu(head->h_len)) + xhdrs)\n\t\t*last_blk = i;\n\nout:\n\txlog_put_bp(bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_put_bp",
          "args": [
            "bp"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_put_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "139-144",
          "snippet": "STATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "be32_to_cpu(head->h_len)"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->h_len"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->h_size"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&log->l_mp->m_sb"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_header_check_mount",
          "args": [
            "log->l_mp",
            "head"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_header_check_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "342-364",
          "snippet": "STATIC int\nxlog_header_check_mount(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\tASSERT(head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM));\n\n\tif (uuid_is_nil(&head->h_fs_uuid)) {\n\t\t/*\n\t\t * IRIX doesn't write the h_fs_uuid or h_fmt fields. If\n\t\t * h_fs_uuid is nil, we assume this log was last mounted\n\t\t * by IRIX and continue.\n\t\t */\n\t\txfs_warn(mp, \"nil uuid in log - IRIX style log\");\n\t} else if (unlikely(!uuid_equal(&mp->m_sb.sb_uuid, &head->h_fs_uuid))) {\n\t\txfs_warn(mp, \"log has mismatched uuid - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\tXFS_ERROR_REPORT(\"xlog_header_check_mount\",\n\t\t\t\t XFS_ERRLEVEL_HIGH, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_header_check_mount(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\tASSERT(head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM));\n\n\tif (uuid_is_nil(&head->h_fs_uuid)) {\n\t\t/*\n\t\t * IRIX doesn't write the h_fs_uuid or h_fmt fields. If\n\t\t * h_fs_uuid is nil, we assume this log was last mounted\n\t\t * by IRIX and continue.\n\t\t */\n\t\txfs_warn(mp, \"nil uuid in log - IRIX style log\");\n\t} else if (unlikely(!uuid_equal(&mp->m_sb.sb_uuid, &head->h_fs_uuid))) {\n\t\txfs_warn(mp, \"log has mismatched uuid - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\tXFS_ERROR_REPORT(\"xlog_header_check_mount\",\n\t\t\t\t XFS_ERRLEVEL_HIGH, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XLOG_HEADER_MAGIC_NUM"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_bread",
          "args": [
            "log",
            "i",
            "1",
            "bp",
            "&offset"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_bread_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "222-245",
          "snippet": "STATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"Log inconsistent (didn't find previous header)\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_get_bp",
          "args": [
            "log",
            "1"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "99-137",
          "snippet": "STATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "start_blk != 0 || *last_blk != start_blk"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_verify_log_record(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tstart_blk,\n\txfs_daddr_t\t\t*last_blk,\n\tint\t\t\textra_bblks)\n{\n\txfs_daddr_t\t\ti;\n\txfs_buf_t\t\t*bp;\n\txfs_caddr_t\t\toffset = NULL;\n\txlog_rec_header_t\t*head = NULL;\n\tint\t\t\terror = 0;\n\tint\t\t\tsmallmem = 0;\n\tint\t\t\tnum_blks = *last_blk - start_blk;\n\tint\t\t\txhdrs;\n\n\tASSERT(start_blk != 0 || *last_blk != start_blk);\n\n\tif (!(bp = xlog_get_bp(log, num_blks))) {\n\t\tif (!(bp = xlog_get_bp(log, 1)))\n\t\t\treturn -ENOMEM;\n\t\tsmallmem = 1;\n\t} else {\n\t\terror = xlog_bread(log, start_blk, num_blks, bp, &offset);\n\t\tif (error)\n\t\t\tgoto out;\n\t\toffset += ((num_blks - 1) << BBSHIFT);\n\t}\n\n\tfor (i = (*last_blk) - 1; i >= 0; i--) {\n\t\tif (i < start_blk) {\n\t\t\t/* valid log record not found */\n\t\t\txfs_warn(log->l_mp,\n\t\t\"Log inconsistent (didn't find previous header)\");\n\t\t\tASSERT(0);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (smallmem) {\n\t\t\terror = xlog_bread(log, i, 1, bp, &offset);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\thead = (xlog_rec_header_t *)offset;\n\n\t\tif (head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\t\tbreak;\n\n\t\tif (!smallmem)\n\t\t\toffset -= BBSIZE;\n\t}\n\n\t/*\n\t * We hit the beginning of the physical log & still no header.  Return\n\t * to caller.  If caller can handle a return of -1, then this routine\n\t * will be called again for the end of the physical log.\n\t */\n\tif (i == -1) {\n\t\terror = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have the final block of the good log (the first block\n\t * of the log record _before_ the head. So we check the uuid.\n\t */\n\tif ((error = xlog_header_check_mount(log->l_mp, head)))\n\t\tgoto out;\n\n\t/*\n\t * We may have found a log record header before we expected one.\n\t * last_blk will be the 1st block # with a given cycle #.  We may end\n\t * up reading an entire log record.  In this case, we don't want to\n\t * reset last_blk.  Only when last_blk points in the middle of a log\n\t * record do we update last_blk.\n\t */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tuint\th_size = be32_to_cpu(head->h_size);\n\n\t\txhdrs = h_size / XLOG_HEADER_CYCLE_SIZE;\n\t\tif (h_size % XLOG_HEADER_CYCLE_SIZE)\n\t\t\txhdrs++;\n\t} else {\n\t\txhdrs = 1;\n\t}\n\n\tif (*last_blk - i + extra_bblks !=\n\t    BTOBB(be32_to_cpu(head->h_len)) + xhdrs)\n\t\t*last_blk = i;\n\nout:\n\txlog_put_bp(bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_find_verify_cycle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "434-489",
    "snippet": "STATIC int\nxlog_find_verify_cycle(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tstart_blk,\n\tint\t\tnbblks,\n\tuint\t\tstop_on_cycle_no,\n\txfs_daddr_t\t*new_blk)\n{\n\txfs_daddr_t\ti, j;\n\tuint\t\tcycle;\n\txfs_buf_t\t*bp;\n\txfs_daddr_t\tbufblks;\n\txfs_caddr_t\tbuf = NULL;\n\tint\t\terror = 0;\n\n\t/*\n\t * Greedily allocate a buffer big enough to handle the full\n\t * range of basic blocks we'll be examining.  If that fails,\n\t * try a smaller size.  We need to be able to read at least\n\t * a log sector, or we're out of luck.\n\t */\n\tbufblks = 1 << ffs(nbblks);\n\twhile (bufblks > log->l_logBBsize)\n\t\tbufblks >>= 1;\n\twhile (!(bp = xlog_get_bp(log, bufblks))) {\n\t\tbufblks >>= 1;\n\t\tif (bufblks < log->l_sectBBsize)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = start_blk; i < start_blk + nbblks; i += bufblks) {\n\t\tint\tbcount;\n\n\t\tbcount = min(bufblks, (start_blk + nbblks - i));\n\n\t\terror = xlog_bread(log, i, bcount, bp, &buf);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tfor (j = 0; j < bcount; j++) {\n\t\t\tcycle = xlog_get_cycle(buf);\n\t\t\tif (cycle == stop_on_cycle_no) {\n\t\t\t\t*new_blk = i+j;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbuf += BBSIZE;\n\t\t}\n\t}\n\n\t*new_blk = -1;\n\nout:\n\txlog_put_bp(bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_put_bp",
          "args": [
            "bp"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_put_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "139-144",
          "snippet": "STATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_get_cycle",
          "args": [
            "buf"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_cycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "77-83",
          "snippet": "static inline uint xlog_get_cycle(char *ptr)\n{\n\tif (be32_to_cpu(*(__be32 *)ptr) == XLOG_HEADER_MAGIC_NUM)\n\t\treturn be32_to_cpu(*((__be32 *)ptr + 1));\n\telse\n\t\treturn be32_to_cpu(*(__be32 *)ptr);\n}",
          "includes": [],
          "macros_used": [
            "#define XLOG_HEADER_MAGIC_NUM\t0xFEEDbabe\t/* Invalid cycle number */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XLOG_HEADER_MAGIC_NUM\t0xFEEDbabe\t/* Invalid cycle number */\n\nstatic inline uint xlog_get_cycle(char *ptr)\n{\n\tif (be32_to_cpu(*(__be32 *)ptr) == XLOG_HEADER_MAGIC_NUM)\n\t\treturn be32_to_cpu(*((__be32 *)ptr + 1));\n\telse\n\t\treturn be32_to_cpu(*(__be32 *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_bread",
          "args": [
            "log",
            "i",
            "bcount",
            "bp",
            "&buf"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_bread_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "222-245",
          "snippet": "STATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bufblks",
            "(start_blk + nbblks - i)"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_get_bp",
          "args": [
            "log",
            "bufblks"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "99-137",
          "snippet": "STATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "nbblks"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_max_file_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "561-593",
          "snippet": "__uint64_t\nxfs_max_file_offset(\n\tunsigned int\t\tblockshift)\n{\n\tunsigned int\t\tpagefactor = 1;\n\tunsigned int\t\tbitshift = BITS_PER_LONG - 1;\n\n\t/* Figure out maximum filesize, on Linux this can depend on\n\t * the filesystem blocksize (on 32 bit platforms).\n\t * __block_write_begin does this in an [unsigned] long...\n\t *      page->index << (PAGE_CACHE_SHIFT - bbits)\n\t * So, for page sized blocks (4K on 32 bit platforms),\n\t * this wraps at around 8Tb (hence MAX_LFS_FILESIZE which is\n\t *      (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)\n\t * but for smaller blocksizes it is less (bbits = log2 bsize).\n\t * Note1: get_block_t takes a long (implicit cast from above)\n\t * Note2: The Large Block Device (LBD and HAVE_SECTOR_T) patch\n\t * can optionally convert the [unsigned] long from above into\n\t * an [unsigned] long long.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tASSERT(sizeof(sector_t) == 8);\n\tpagefactor = PAGE_CACHE_SIZE;\n\tbitshift = BITS_PER_LONG;\n# else\n\tpagefactor = PAGE_CACHE_SIZE >> (PAGE_CACHE_SHIFT - blockshift);\n# endif\n#endif\n\n\treturn (((__uint64_t)pagefactor) << bitshift) - 1;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n__uint64_t\nxfs_max_file_offset(\n\tunsigned int\t\tblockshift)\n{\n\tunsigned int\t\tpagefactor = 1;\n\tunsigned int\t\tbitshift = BITS_PER_LONG - 1;\n\n\t/* Figure out maximum filesize, on Linux this can depend on\n\t * the filesystem blocksize (on 32 bit platforms).\n\t * __block_write_begin does this in an [unsigned] long...\n\t *      page->index << (PAGE_CACHE_SHIFT - bbits)\n\t * So, for page sized blocks (4K on 32 bit platforms),\n\t * this wraps at around 8Tb (hence MAX_LFS_FILESIZE which is\n\t *      (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)\n\t * but for smaller blocksizes it is less (bbits = log2 bsize).\n\t * Note1: get_block_t takes a long (implicit cast from above)\n\t * Note2: The Large Block Device (LBD and HAVE_SECTOR_T) patch\n\t * can optionally convert the [unsigned] long from above into\n\t * an [unsigned] long long.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tASSERT(sizeof(sector_t) == 8);\n\tpagefactor = PAGE_CACHE_SIZE;\n\tbitshift = BITS_PER_LONG;\n# else\n\tpagefactor = PAGE_CACHE_SIZE >> (PAGE_CACHE_SHIFT - blockshift);\n# endif\n#endif\n\n\treturn (((__uint64_t)pagefactor) << bitshift) - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_verify_cycle(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tstart_blk,\n\tint\t\tnbblks,\n\tuint\t\tstop_on_cycle_no,\n\txfs_daddr_t\t*new_blk)\n{\n\txfs_daddr_t\ti, j;\n\tuint\t\tcycle;\n\txfs_buf_t\t*bp;\n\txfs_daddr_t\tbufblks;\n\txfs_caddr_t\tbuf = NULL;\n\tint\t\terror = 0;\n\n\t/*\n\t * Greedily allocate a buffer big enough to handle the full\n\t * range of basic blocks we'll be examining.  If that fails,\n\t * try a smaller size.  We need to be able to read at least\n\t * a log sector, or we're out of luck.\n\t */\n\tbufblks = 1 << ffs(nbblks);\n\twhile (bufblks > log->l_logBBsize)\n\t\tbufblks >>= 1;\n\twhile (!(bp = xlog_get_bp(log, bufblks))) {\n\t\tbufblks >>= 1;\n\t\tif (bufblks < log->l_sectBBsize)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = start_blk; i < start_blk + nbblks; i += bufblks) {\n\t\tint\tbcount;\n\n\t\tbcount = min(bufblks, (start_blk + nbblks - i));\n\n\t\terror = xlog_bread(log, i, bcount, bp, &buf);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tfor (j = 0; j < bcount; j++) {\n\t\t\tcycle = xlog_get_cycle(buf);\n\t\t\tif (cycle == stop_on_cycle_no) {\n\t\t\t\t*new_blk = i+j;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbuf += BBSIZE;\n\t\t}\n\t}\n\n\t*new_blk = -1;\n\nout:\n\txlog_put_bp(bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_find_cycle_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "391-424",
    "snippet": "STATIC int\nxlog_find_cycle_start(\n\tstruct xlog\t*log,\n\tstruct xfs_buf\t*bp,\n\txfs_daddr_t\tfirst_blk,\n\txfs_daddr_t\t*last_blk,\n\tuint\t\tcycle)\n{\n\txfs_caddr_t\toffset;\n\txfs_daddr_t\tmid_blk;\n\txfs_daddr_t\tend_blk;\n\tuint\t\tmid_cycle;\n\tint\t\terror;\n\n\tend_blk = *last_blk;\n\tmid_blk = BLK_AVG(first_blk, end_blk);\n\twhile (mid_blk != first_blk && mid_blk != end_blk) {\n\t\terror = xlog_bread(log, mid_blk, 1, bp, &offset);\n\t\tif (error)\n\t\t\treturn error;\n\t\tmid_cycle = xlog_get_cycle(offset);\n\t\tif (mid_cycle == cycle)\n\t\t\tend_blk = mid_blk;   /* last_half_cycle == mid_cycle */\n\t\telse\n\t\t\tfirst_blk = mid_blk; /* first_half_cycle == mid_cycle */\n\t\tmid_blk = BLK_AVG(first_blk, end_blk);\n\t}\n\tASSERT((mid_blk == first_blk && mid_blk+1 == end_blk) ||\n\t       (mid_blk == end_blk && mid_blk-1 == first_blk));\n\n\t*last_blk = end_blk;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(mid_blk == first_blk && mid_blk+1 == end_blk) ||\n\t       (mid_blk == end_blk && mid_blk-1 == first_blk)"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_AVG",
          "args": [
            "first_blk",
            "end_blk"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_get_cycle",
          "args": [
            "offset"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_cycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "77-83",
          "snippet": "static inline uint xlog_get_cycle(char *ptr)\n{\n\tif (be32_to_cpu(*(__be32 *)ptr) == XLOG_HEADER_MAGIC_NUM)\n\t\treturn be32_to_cpu(*((__be32 *)ptr + 1));\n\telse\n\t\treturn be32_to_cpu(*(__be32 *)ptr);\n}",
          "includes": [],
          "macros_used": [
            "#define XLOG_HEADER_MAGIC_NUM\t0xFEEDbabe\t/* Invalid cycle number */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XLOG_HEADER_MAGIC_NUM\t0xFEEDbabe\t/* Invalid cycle number */\n\nstatic inline uint xlog_get_cycle(char *ptr)\n{\n\tif (be32_to_cpu(*(__be32 *)ptr) == XLOG_HEADER_MAGIC_NUM)\n\t\treturn be32_to_cpu(*((__be32 *)ptr + 1));\n\telse\n\t\treturn be32_to_cpu(*(__be32 *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_bread",
          "args": [
            "log",
            "mid_blk",
            "1",
            "bp",
            "&offset"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_bread_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "222-245",
          "snippet": "STATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLK_AVG",
          "args": [
            "first_blk",
            "end_blk"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_find_cycle_start(\n\tstruct xlog\t*log,\n\tstruct xfs_buf\t*bp,\n\txfs_daddr_t\tfirst_blk,\n\txfs_daddr_t\t*last_blk,\n\tuint\t\tcycle)\n{\n\txfs_caddr_t\toffset;\n\txfs_daddr_t\tmid_blk;\n\txfs_daddr_t\tend_blk;\n\tuint\t\tmid_cycle;\n\tint\t\terror;\n\n\tend_blk = *last_blk;\n\tmid_blk = BLK_AVG(first_blk, end_blk);\n\twhile (mid_blk != first_blk && mid_blk != end_blk) {\n\t\terror = xlog_bread(log, mid_blk, 1, bp, &offset);\n\t\tif (error)\n\t\t\treturn error;\n\t\tmid_cycle = xlog_get_cycle(offset);\n\t\tif (mid_cycle == cycle)\n\t\t\tend_blk = mid_blk;   /* last_half_cycle == mid_cycle */\n\t\telse\n\t\t\tfirst_blk = mid_blk; /* first_half_cycle == mid_cycle */\n\t\tmid_blk = BLK_AVG(first_blk, end_blk);\n\t}\n\tASSERT((mid_blk == first_blk && mid_blk+1 == end_blk) ||\n\t       (mid_blk == end_blk && mid_blk-1 == first_blk));\n\n\t*last_blk = end_blk;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_recover_iodone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "366-383",
    "snippet": "STATIC void\nxlog_recover_iodone(\n\tstruct xfs_buf\t*bp)\n{\n\tif (bp->b_error) {\n\t\t/*\n\t\t * We're not going to bother about retrying\n\t\t * this during recovery. One strike!\n\t\t */\n\t\tif (!XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t\t\tSHUTDOWN_META_IO_ERROR);\n\t\t}\n\t}\n\tbp->b_iodone = NULL;\n\txfs_buf_ioend(bp);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_ioend",
          "args": [
            "bp"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioend_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1049-1055",
          "snippet": "void\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "bp->b_target->bt_mount",
            "SHUTDOWN_META_IO_ERROR"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror_alert",
          "args": [
            "bp",
            "__func__"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "bp->b_target->bt_mount"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxlog_recover_iodone(\n\tstruct xfs_buf\t*bp)\n{\n\tif (bp->b_error) {\n\t\t/*\n\t\t * We're not going to bother about retrying\n\t\t * this during recovery. One strike!\n\t\t */\n\t\tif (!XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t\t\tSHUTDOWN_META_IO_ERROR);\n\t\t}\n\t}\n\tbp->b_iodone = NULL;\n\txfs_buf_ioend(bp);\n}"
  },
  {
    "function_name": "xlog_header_check_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "342-364",
    "snippet": "STATIC int\nxlog_header_check_mount(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\tASSERT(head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM));\n\n\tif (uuid_is_nil(&head->h_fs_uuid)) {\n\t\t/*\n\t\t * IRIX doesn't write the h_fs_uuid or h_fmt fields. If\n\t\t * h_fs_uuid is nil, we assume this log was last mounted\n\t\t * by IRIX and continue.\n\t\t */\n\t\txfs_warn(mp, \"nil uuid in log - IRIX style log\");\n\t} else if (unlikely(!uuid_equal(&mp->m_sb.sb_uuid, &head->h_fs_uuid))) {\n\t\txfs_warn(mp, \"log has mismatched uuid - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\tXFS_ERROR_REPORT(\"xlog_header_check_mount\",\n\t\t\t\t XFS_ERRLEVEL_HIGH, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xlog_header_check_mount\"",
            "XFS_ERRLEVEL_HIGH",
            "mp"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_header_check_dump",
          "args": [
            "mp",
            "head"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_header_check_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "292-301",
          "snippet": "STATIC void\nxlog_header_check_dump(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\txfs_debug(mp, \"%s:  SB : uuid = %pU, fmt = %d\",\n\t\t__func__, &mp->m_sb.sb_uuid, XLOG_FMT);\n\txfs_debug(mp, \"    log : uuid = %pU, fmt = %d\",\n\t\t&head->h_fs_uuid, be32_to_cpu(head->h_fmt));\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_header_check_dump(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\txfs_debug(mp, \"%s:  SB : uuid = %pU, fmt = %d\",\n\t\t__func__, &mp->m_sb.sb_uuid, XLOG_FMT);\n\txfs_debug(mp, \"    log : uuid = %pU, fmt = %d\",\n\t\t&head->h_fs_uuid, be32_to_cpu(head->h_fmt));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"log has mismatched uuid - can't recover\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!uuid_equal(&mp->m_sb.sb_uuid, &head->h_fs_uuid)"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&mp->m_sb.sb_uuid",
            "&head->h_fs_uuid"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"nil uuid in log - IRIX style log\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_is_nil",
          "args": [
            "&head->h_fs_uuid"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_is_nil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "45-57",
          "snippet": "int\nuuid_is_nil(uuid_t *uuid)\n{\n\tint\ti;\n\tchar\t*cp = (char *)uuid;\n\n\tif (uuid == NULL)\n\t\treturn 0;\n\t/* implied check of version number here... */\n\tfor (i = 0; i < sizeof *uuid; i++)\n\t\tif (*cp++) return 0;\t/* not nil */\n\treturn 1;\t/* is nil */\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_is_nil(uuid_t *uuid)\n{\n\tint\ti;\n\tchar\t*cp = (char *)uuid;\n\n\tif (uuid == NULL)\n\t\treturn 0;\n\t/* implied check of version number here... */\n\tfor (i = 0; i < sizeof *uuid; i++)\n\t\tif (*cp++) return 0;\t/* not nil */\n\treturn 1;\t/* is nil */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM)"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XLOG_HEADER_MAGIC_NUM"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_header_check_mount(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\tASSERT(head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM));\n\n\tif (uuid_is_nil(&head->h_fs_uuid)) {\n\t\t/*\n\t\t * IRIX doesn't write the h_fs_uuid or h_fmt fields. If\n\t\t * h_fs_uuid is nil, we assume this log was last mounted\n\t\t * by IRIX and continue.\n\t\t */\n\t\txfs_warn(mp, \"nil uuid in log - IRIX style log\");\n\t} else if (unlikely(!uuid_equal(&mp->m_sb.sb_uuid, &head->h_fs_uuid))) {\n\t\txfs_warn(mp, \"log has mismatched uuid - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\tXFS_ERROR_REPORT(\"xlog_header_check_mount\",\n\t\t\t\t XFS_ERRLEVEL_HIGH, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_header_check_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "309-337",
    "snippet": "STATIC int\nxlog_header_check_recover(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\tASSERT(head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM));\n\n\t/*\n\t * IRIX doesn't write the h_fmt field and leaves it zeroed\n\t * (XLOG_FMT_UNKNOWN). This stops us from trying to recover\n\t * a dirty log created in IRIX.\n\t */\n\tif (unlikely(head->h_fmt != cpu_to_be32(XLOG_FMT))) {\n\t\txfs_warn(mp,\n\t\"dirty log written in incompatible format - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\tXFS_ERROR_REPORT(\"xlog_header_check_recover(1)\",\n\t\t\t\t XFS_ERRLEVEL_HIGH, mp);\n\t\treturn -EFSCORRUPTED;\n\t} else if (unlikely(!uuid_equal(&mp->m_sb.sb_uuid, &head->h_fs_uuid))) {\n\t\txfs_warn(mp,\n\t\"dirty log entry has mismatched uuid - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\tXFS_ERROR_REPORT(\"xlog_header_check_recover(2)\",\n\t\t\t\t XFS_ERRLEVEL_HIGH, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xlog_header_check_recover(2)\"",
            "XFS_ERRLEVEL_HIGH",
            "mp"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_header_check_dump",
          "args": [
            "mp",
            "head"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_header_check_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "292-301",
          "snippet": "STATIC void\nxlog_header_check_dump(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\txfs_debug(mp, \"%s:  SB : uuid = %pU, fmt = %d\",\n\t\t__func__, &mp->m_sb.sb_uuid, XLOG_FMT);\n\txfs_debug(mp, \"    log : uuid = %pU, fmt = %d\",\n\t\t&head->h_fs_uuid, be32_to_cpu(head->h_fmt));\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_header_check_dump(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\txfs_debug(mp, \"%s:  SB : uuid = %pU, fmt = %d\",\n\t\t__func__, &mp->m_sb.sb_uuid, XLOG_FMT);\n\txfs_debug(mp, \"    log : uuid = %pU, fmt = %d\",\n\t\t&head->h_fs_uuid, be32_to_cpu(head->h_fmt));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"dirty log entry has mismatched uuid - can't recover\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!uuid_equal(&mp->m_sb.sb_uuid, &head->h_fs_uuid)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&mp->m_sb.sb_uuid",
            "&head->h_fs_uuid"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xlog_header_check_recover(1)\"",
            "XFS_ERRLEVEL_HIGH",
            "mp"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"dirty log written in incompatible format - can't recover\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "head->h_fmt != cpu_to_be32(XLOG_FMT)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XLOG_FMT"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM)"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XLOG_HEADER_MAGIC_NUM"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_header_check_recover(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\tASSERT(head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM));\n\n\t/*\n\t * IRIX doesn't write the h_fmt field and leaves it zeroed\n\t * (XLOG_FMT_UNKNOWN). This stops us from trying to recover\n\t * a dirty log created in IRIX.\n\t */\n\tif (unlikely(head->h_fmt != cpu_to_be32(XLOG_FMT))) {\n\t\txfs_warn(mp,\n\t\"dirty log written in incompatible format - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\tXFS_ERROR_REPORT(\"xlog_header_check_recover(1)\",\n\t\t\t\t XFS_ERRLEVEL_HIGH, mp);\n\t\treturn -EFSCORRUPTED;\n\t} else if (unlikely(!uuid_equal(&mp->m_sb.sb_uuid, &head->h_fs_uuid))) {\n\t\txfs_warn(mp,\n\t\"dirty log entry has mismatched uuid - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\tXFS_ERROR_REPORT(\"xlog_header_check_recover(2)\",\n\t\t\t\t XFS_ERRLEVEL_HIGH, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_header_check_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "292-301",
    "snippet": "STATIC void\nxlog_header_check_dump(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\txfs_debug(mp, \"%s:  SB : uuid = %pU, fmt = %d\",\n\t\t__func__, &mp->m_sb.sb_uuid, XLOG_FMT);\n\txfs_debug(mp, \"    log : uuid = %pU, fmt = %d\",\n\t\t&head->h_fs_uuid, be32_to_cpu(head->h_fmt));\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_debug",
          "args": [
            "mp",
            "\"    log : uuid = %pU, fmt = %d\"",
            "&head->h_fs_uuid",
            "be32_to_cpu(head->h_fmt)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->h_fmt"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_debug",
          "args": [
            "mp",
            "\"%s:  SB : uuid = %pU, fmt = %d\"",
            "__func__",
            "&mp->m_sb.sb_uuid",
            "XLOG_FMT"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_header_check_dump(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\txfs_debug(mp, \"%s:  SB : uuid = %pU, fmt = %d\",\n\t\t__func__, &mp->m_sb.sb_uuid, XLOG_FMT);\n\txfs_debug(mp, \"    log : uuid = %pU, fmt = %d\",\n\t\t&head->h_fs_uuid, be32_to_cpu(head->h_fmt));\n}"
  },
  {
    "function_name": "xlog_bwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "252-286",
    "snippet": "STATIC int\nxlog_bwrite(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tblk_no = round_down(blk_no, log->l_sectBBsize);\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tASSERT(nbblks > 0);\n\tASSERT(nbblks <= bp->b_length);\n\n\tXFS_BUF_SET_ADDR(bp, log->l_logBBstart + blk_no);\n\tXFS_BUF_ZEROFLAGS(bp);\n\txfs_buf_hold(bp);\n\txfs_buf_lock(bp);\n\tbp->b_io_length = nbblks;\n\tbp->b_error = 0;\n\n\terror = xfs_bwrite(bp);\n\tif (error)\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\txfs_buf_relse(bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror_alert",
          "args": [
            "bp",
            "__func__"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bwrite",
          "args": [
            "bp"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1077-1095",
          "snippet": "int\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_lock",
          "args": [
            "bp"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "957-969",
          "snippet": "void\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_hold",
          "args": [
            "bp"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "854-860",
          "snippet": "void\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ZEROFLAGS",
          "args": [
            "bp"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_SET_ADDR",
          "args": [
            "bp",
            "log->l_logBBstart + blk_no"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nbblks <= bp->b_length"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nbblks > 0"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "nbblks",
            "log->l_sectBBsize"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "blk_no",
            "log->l_sectBBsize"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "__func__",
            "XFS_ERRLEVEL_HIGH",
            "log->l_mp"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"Invalid block length (0x%x) for buffer\"",
            "nbblks"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_buf_bbcount_valid",
          "args": [
            "log",
            "nbblks"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_buf_bbcount_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "86-92",
          "snippet": "static inline int\nxlog_buf_bbcount_valid(\n\tstruct xlog\t*log,\n\tint\t\tbbcount)\n{\n\treturn bbcount > 0 && bbcount <= log->l_logBBsize;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline int\nxlog_buf_bbcount_valid(\n\tstruct xlog\t*log,\n\tint\t\tbbcount)\n{\n\treturn bbcount > 0 && bbcount <= log->l_logBBsize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bwrite(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tblk_no = round_down(blk_no, log->l_sectBBsize);\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tASSERT(nbblks > 0);\n\tASSERT(nbblks <= bp->b_length);\n\n\tXFS_BUF_SET_ADDR(bp, log->l_logBBstart + blk_no);\n\tXFS_BUF_ZEROFLAGS(bp);\n\txfs_buf_hold(bp);\n\txfs_buf_lock(bp);\n\tbp->b_io_length = nbblks;\n\tbp->b_error = 0;\n\n\terror = xfs_bwrite(bp);\n\tif (error)\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\txfs_buf_relse(bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_bread_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "222-245",
    "snippet": "STATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_associate_memory",
          "args": [
            "bp",
            "orig_offset",
            "orig_len"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_associate_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "759-799",
          "snippet": "int\nxfs_buf_associate_memory(\n\txfs_buf_t\t\t*bp,\n\tvoid\t\t\t*mem,\n\tsize_t\t\t\tlen)\n{\n\tint\t\t\trval;\n\tint\t\t\ti = 0;\n\tunsigned long\t\tpageaddr;\n\tunsigned long\t\toffset;\n\tsize_t\t\t\tbuflen;\n\tint\t\t\tpage_count;\n\n\tpageaddr = (unsigned long)mem & PAGE_MASK;\n\toffset = (unsigned long)mem - pageaddr;\n\tbuflen = PAGE_ALIGN(len + offset);\n\tpage_count = buflen >> PAGE_SHIFT;\n\n\t/* Free any previous set of page pointers */\n\tif (bp->b_pages)\n\t\t_xfs_buf_free_pages(bp);\n\n\tbp->b_pages = NULL;\n\tbp->b_addr = mem;\n\n\trval = _xfs_buf_get_pages(bp, page_count);\n\tif (rval)\n\t\treturn rval;\n\n\tbp->b_offset = offset;\n\n\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\tbp->b_pages[i] = mem_to_page((void *)pageaddr);\n\t\tpageaddr += PAGE_SIZE;\n\t}\n\n\tbp->b_io_length = BTOBB(len);\n\tbp->b_length = BTOBB(buflen);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_associate_memory(\n\txfs_buf_t\t\t*bp,\n\tvoid\t\t\t*mem,\n\tsize_t\t\t\tlen)\n{\n\tint\t\t\trval;\n\tint\t\t\ti = 0;\n\tunsigned long\t\tpageaddr;\n\tunsigned long\t\toffset;\n\tsize_t\t\t\tbuflen;\n\tint\t\t\tpage_count;\n\n\tpageaddr = (unsigned long)mem & PAGE_MASK;\n\toffset = (unsigned long)mem - pageaddr;\n\tbuflen = PAGE_ALIGN(len + offset);\n\tpage_count = buflen >> PAGE_SHIFT;\n\n\t/* Free any previous set of page pointers */\n\tif (bp->b_pages)\n\t\t_xfs_buf_free_pages(bp);\n\n\tbp->b_pages = NULL;\n\tbp->b_addr = mem;\n\n\trval = _xfs_buf_get_pages(bp, page_count);\n\tif (rval)\n\t\treturn rval;\n\n\tbp->b_offset = offset;\n\n\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\tbp->b_pages[i] = mem_to_page((void *)pageaddr);\n\t\tpageaddr += PAGE_SIZE;\n\t}\n\n\tbp->b_io_length = BTOBB(len);\n\tbp->b_length = BTOBB(buflen);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_bread_noalign",
          "args": [
            "log",
            "blk_no",
            "nbblks",
            "bp"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_bread_noalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "167-198",
          "snippet": "STATIC int\nxlog_bread_noalign(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tblk_no = round_down(blk_no, log->l_sectBBsize);\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tASSERT(nbblks > 0);\n\tASSERT(nbblks <= bp->b_length);\n\n\tXFS_BUF_SET_ADDR(bp, log->l_logBBstart + blk_no);\n\tXFS_BUF_READ(bp);\n\tbp->b_io_length = nbblks;\n\tbp->b_error = 0;\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error && !XFS_FORCED_SHUTDOWN(log->l_mp))\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread_noalign(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tblk_no = round_down(blk_no, log->l_sectBBsize);\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tASSERT(nbblks > 0);\n\tASSERT(nbblks <= bp->b_length);\n\n\tXFS_BUF_SET_ADDR(bp, log->l_logBBstart + blk_no);\n\tXFS_BUF_READ(bp);\n\tbp->b_io_length = nbblks;\n\tbp->b_error = 0;\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error && !XFS_FORCED_SHUTDOWN(log->l_mp))\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "nbblks"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_length"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread_offset(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\t\t/* block to read from */\n\tint\t\tnbblks,\t\t/* blocks to read */\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\toffset)\n{\n\txfs_caddr_t\torig_offset = bp->b_addr;\n\tint\t\torig_len = BBTOB(bp->b_length);\n\tint\t\terror, error2;\n\n\terror = xfs_buf_associate_memory(bp, offset, BBTOB(nbblks));\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\n\t/* must reset buffer pointer even on error */\n\terror2 = xfs_buf_associate_memory(bp, orig_offset, orig_len);\n\tif (error)\n\t\treturn error;\n\treturn error2;\n}"
  },
  {
    "function_name": "xlog_bread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "200-216",
    "snippet": "STATIC int\nxlog_bread(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\t*offset)\n{\n\tint\t\terror;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\tif (error)\n\t\treturn error;\n\n\t*offset = xlog_align(log, blk_no, nbblks, bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_align",
          "args": [
            "log",
            "blk_no",
            "nbblks",
            "bp"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_align",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "150-161",
          "snippet": "STATIC xfs_caddr_t\nxlog_align(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_daddr_t\toffset = blk_no & ((xfs_daddr_t)log->l_sectBBsize - 1);\n\n\tASSERT(offset + nbblks <= bp->b_length);\n\treturn bp->b_addr + BBTOB(offset);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_caddr_t\nxlog_align(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_daddr_t\toffset = blk_no & ((xfs_daddr_t)log->l_sectBBsize - 1);\n\n\tASSERT(offset + nbblks <= bp->b_length);\n\treturn bp->b_addr + BBTOB(offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_bread_noalign",
          "args": [
            "log",
            "blk_no",
            "nbblks",
            "bp"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_bread_noalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "167-198",
          "snippet": "STATIC int\nxlog_bread_noalign(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tblk_no = round_down(blk_no, log->l_sectBBsize);\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tASSERT(nbblks > 0);\n\tASSERT(nbblks <= bp->b_length);\n\n\tXFS_BUF_SET_ADDR(bp, log->l_logBBstart + blk_no);\n\tXFS_BUF_READ(bp);\n\tbp->b_io_length = nbblks;\n\tbp->b_error = 0;\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error && !XFS_FORCED_SHUTDOWN(log->l_mp))\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread_noalign(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tblk_no = round_down(blk_no, log->l_sectBBsize);\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tASSERT(nbblks > 0);\n\tASSERT(nbblks <= bp->b_length);\n\n\tXFS_BUF_SET_ADDR(bp, log->l_logBBstart + blk_no);\n\tXFS_BUF_READ(bp);\n\tbp->b_io_length = nbblks;\n\tbp->b_error = 0;\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error && !XFS_FORCED_SHUTDOWN(log->l_mp))\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp,\n\txfs_caddr_t\t*offset)\n{\n\tint\t\terror;\n\n\terror = xlog_bread_noalign(log, blk_no, nbblks, bp);\n\tif (error)\n\t\treturn error;\n\n\t*offset = xlog_align(log, blk_no, nbblks, bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_bread_noalign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "167-198",
    "snippet": "STATIC int\nxlog_bread_noalign(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tblk_no = round_down(blk_no, log->l_sectBBsize);\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tASSERT(nbblks > 0);\n\tASSERT(nbblks <= bp->b_length);\n\n\tXFS_BUF_SET_ADDR(bp, log->l_logBBstart + blk_no);\n\tXFS_BUF_READ(bp);\n\tbp->b_io_length = nbblks;\n\tbp->b_error = 0;\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error && !XFS_FORCED_SHUTDOWN(log->l_mp))\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_ioerror_alert",
          "args": [
            "bp",
            "__func__"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "log->l_mp"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_submit_wait",
          "args": [
            "bp"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_submit_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1362-1420",
          "snippet": "int\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_READ",
          "args": [
            "bp"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_SET_ADDR",
          "args": [
            "bp",
            "log->l_logBBstart + blk_no"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nbblks <= bp->b_length"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nbblks > 0"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "nbblks",
            "log->l_sectBBsize"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "blk_no",
            "log->l_sectBBsize"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "__func__",
            "XFS_ERRLEVEL_HIGH",
            "log->l_mp"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"Invalid block length (0x%x) for buffer\"",
            "nbblks"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_buf_bbcount_valid",
          "args": [
            "log",
            "nbblks"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_buf_bbcount_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "86-92",
          "snippet": "static inline int\nxlog_buf_bbcount_valid(\n\tstruct xlog\t*log,\n\tint\t\tbbcount)\n{\n\treturn bbcount > 0 && bbcount <= log->l_logBBsize;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline int\nxlog_buf_bbcount_valid(\n\tstruct xlog\t*log,\n\tint\t\tbbcount)\n{\n\treturn bbcount > 0 && bbcount <= log->l_logBBsize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxlog_bread_noalign(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tblk_no = round_down(blk_no, log->l_sectBBsize);\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tASSERT(nbblks > 0);\n\tASSERT(nbblks <= bp->b_length);\n\n\tXFS_BUF_SET_ADDR(bp, log->l_logBBstart + blk_no);\n\tXFS_BUF_READ(bp);\n\tbp->b_io_length = nbblks;\n\tbp->b_error = 0;\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error && !XFS_FORCED_SHUTDOWN(log->l_mp))\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_align",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "150-161",
    "snippet": "STATIC xfs_caddr_t\nxlog_align(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_daddr_t\toffset = blk_no & ((xfs_daddr_t)log->l_sectBBsize - 1);\n\n\tASSERT(offset + nbblks <= bp->b_length);\n\treturn bp->b_addr + BBTOB(offset);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "offset"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset + nbblks <= bp->b_length"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_caddr_t\nxlog_align(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_daddr_t\toffset = blk_no & ((xfs_daddr_t)log->l_sectBBsize - 1);\n\n\tASSERT(offset + nbblks <= bp->b_length);\n\treturn bp->b_addr + BBTOB(offset);\n}"
  },
  {
    "function_name": "xlog_put_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "139-144",
    "snippet": "STATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_free",
          "args": [
            "bp"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "255-280",
          "snippet": "void\nxfs_buf_free(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_free(bp, _RET_IP_);\n\n\tASSERT(list_empty(&bp->b_lru));\n\n\tif (bp->b_flags & _XBF_PAGES) {\n\t\tuint\t\ti;\n\n\t\tif (xfs_buf_is_vmapped(bp))\n\t\t\tvm_unmap_ram(bp->b_addr - bp->b_offset,\n\t\t\t\t\tbp->b_page_count);\n\n\t\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\t\tstruct page\t*page = bp->b_pages[i];\n\n\t\t\t__free_page(page);\n\t\t}\n\t} else if (bp->b_flags & _XBF_KMEM)\n\t\tkmem_free(bp->b_addr);\n\t_xfs_buf_free_pages(bp);\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nvoid\nxfs_buf_free(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_free(bp, _RET_IP_);\n\n\tASSERT(list_empty(&bp->b_lru));\n\n\tif (bp->b_flags & _XBF_PAGES) {\n\t\tuint\t\ti;\n\n\t\tif (xfs_buf_is_vmapped(bp))\n\t\t\tvm_unmap_ram(bp->b_addr - bp->b_offset,\n\t\t\t\t\tbp->b_page_count);\n\n\t\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\t\tstruct page\t*page = bp->b_pages[i];\n\n\t\t\t__free_page(page);\n\t\t}\n\t} else if (bp->b_flags & _XBF_KMEM)\n\t\tkmem_free(bp->b_addr);\n\t_xfs_buf_free_pages(bp);\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_put_bp(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_free(bp);\n}"
  },
  {
    "function_name": "xlog_get_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "99-137",
    "snippet": "STATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_unlock",
          "args": [
            "bp"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "971-979",
          "snippet": "void\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_get_uncached",
          "args": [
            "log->l_mp->m_logdev_targp",
            "nbblks",
            "0"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_get_uncached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "801-847",
          "snippet": "xfs_buf_t *\nxfs_buf_get_uncached(\n\tstruct xfs_buftarg\t*target,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags)\n{\n\tunsigned long\t\tpage_count;\n\tint\t\t\terror, i;\n\tstruct xfs_buf\t\t*bp;\n\tDEFINE_SINGLE_BUF_MAP(map, XFS_BUF_DADDR_NULL, numblks);\n\n\tbp = _xfs_buf_alloc(target, &map, 1, 0);\n\tif (unlikely(bp == NULL))\n\t\tgoto fail;\n\n\tpage_count = PAGE_ALIGN(numblks << BBSHIFT) >> PAGE_SHIFT;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (error)\n\t\tgoto fail_free_buf;\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tbp->b_pages[i] = alloc_page(xb_to_gfp(flags));\n\t\tif (!bp->b_pages[i])\n\t\t\tgoto fail_free_mem;\n\t}\n\tbp->b_flags |= _XBF_PAGES;\n\n\terror = _xfs_buf_map_pages(bp, 0);\n\tif (unlikely(error)) {\n\t\txfs_warn(target->bt_mount,\n\t\t\t\"%s: failed to map pages\", __func__);\n\t\tgoto fail_free_mem;\n\t}\n\n\ttrace_xfs_buf_get_uncached(bp, _RET_IP_);\n\treturn bp;\n\n fail_free_mem:\n\twhile (--i >= 0)\n\t\t__free_page(bp->b_pages[i]);\n\t_xfs_buf_free_pages(bp);\n fail_free_buf:\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n fail:\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nxfs_buf_t *\nxfs_buf_get_uncached(\n\tstruct xfs_buftarg\t*target,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags)\n{\n\tunsigned long\t\tpage_count;\n\tint\t\t\terror, i;\n\tstruct xfs_buf\t\t*bp;\n\tDEFINE_SINGLE_BUF_MAP(map, XFS_BUF_DADDR_NULL, numblks);\n\n\tbp = _xfs_buf_alloc(target, &map, 1, 0);\n\tif (unlikely(bp == NULL))\n\t\tgoto fail;\n\n\tpage_count = PAGE_ALIGN(numblks << BBSHIFT) >> PAGE_SHIFT;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (error)\n\t\tgoto fail_free_buf;\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tbp->b_pages[i] = alloc_page(xb_to_gfp(flags));\n\t\tif (!bp->b_pages[i])\n\t\t\tgoto fail_free_mem;\n\t}\n\tbp->b_flags |= _XBF_PAGES;\n\n\terror = _xfs_buf_map_pages(bp, 0);\n\tif (unlikely(error)) {\n\t\txfs_warn(target->bt_mount,\n\t\t\t\"%s: failed to map pages\", __func__);\n\t\tgoto fail_free_mem;\n\t}\n\n\ttrace_xfs_buf_get_uncached(bp, _RET_IP_);\n\treturn bp;\n\n fail_free_mem:\n\twhile (--i >= 0)\n\t\t__free_page(bp->b_pages[i]);\n\t_xfs_buf_free_pages(bp);\n fail_free_buf:\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n fail:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "nbblks",
            "log->l_sectBBsize"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "__func__",
            "XFS_ERRLEVEL_HIGH",
            "log->l_mp"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"Invalid block length (0x%x) for buffer\"",
            "nbblks"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_buf_bbcount_valid",
          "args": [
            "log",
            "nbblks"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_buf_bbcount_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "86-92",
          "snippet": "static inline int\nxlog_buf_bbcount_valid(\n\tstruct xlog\t*log,\n\tint\t\tbbcount)\n{\n\treturn bbcount > 0 && bbcount <= log->l_logBBsize;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline int\nxlog_buf_bbcount_valid(\n\tstruct xlog\t*log,\n\tint\t\tbbcount)\n{\n\treturn bbcount > 0 && bbcount <= log->l_logBBsize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_buf_t *\nxlog_get_bp(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\tstruct xfs_buf\t*bp;\n\n\tif (!xlog_buf_bbcount_valid(log, nbblks)) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * We do log I/O in units of log sectors (a power-of-2\n\t * multiple of the basic block size), so we round up the\n\t * requested size to accommodate the basic blocks required\n\t * for complete log sectors.\n\t *\n\t * In addition, the buffer may be used for a non-sector-\n\t * aligned block offset, in which case an I/O of the\n\t * requested size could extend beyond the end of the\n\t * buffer.  If the requested size is only 1 basic block it\n\t * will never straddle a sector boundary, so this won't be\n\t * an issue.  Nor will this be a problem if the log I/O is\n\t * done in basic blocks (sector size 1).  But otherwise we\n\t * extend the buffer by one extra log sector to ensure\n\t * there's space to accommodate this possibility.\n\t */\n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\n\tbp = xfs_buf_get_uncached(log->l_mp->m_logdev_targp, nbblks, 0);\n\tif (bp)\n\t\txfs_buf_unlock(bp);\n\treturn bp;\n}"
  },
  {
    "function_name": "xlog_buf_bbcount_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
    "lines": "86-92",
    "snippet": "static inline int\nxlog_buf_bbcount_valid(\n\tstruct xlog\t*log,\n\tint\t\tbbcount)\n{\n\treturn bbcount > 0 && bbcount <= log->l_logBBsize;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline int\nxlog_buf_bbcount_valid(\n\tstruct xlog\t*log,\n\tint\t\tbbcount)\n{\n\treturn bbcount > 0 && bbcount <= log->l_logBBsize;\n}"
  }
]