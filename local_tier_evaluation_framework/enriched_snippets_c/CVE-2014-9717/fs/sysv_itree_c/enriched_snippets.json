[
  {
    "function_name": "sysv_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "490-493",
    "snippet": "static sector_t sysv_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,get_block);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "get_block"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic sector_t sysv_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,get_block);\n}"
  },
  {
    "function_name": "sysv_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "477-488",
    "snippet": "static int sysv_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep, get_block);\n\tif (unlikely(ret))\n\t\tsysv_write_failed(mapping, pos + len);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysv_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "467-475",
          "snippet": "static void sysv_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tsysv_truncate(inode);\n\t}\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic void sysv_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tsysv_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "get_block"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2008-2028",
          "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic int sysv_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep, get_block);\n\tif (unlikely(ret))\n\t\tsysv_write_failed(mapping, pos + len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sysv_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "467-475",
    "snippet": "static void sysv_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tsysv_truncate(inode);\n\t}\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysv_truncate",
          "args": [
            "inode"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "363-426",
          "snippet": "void sysv_truncate (struct inode * inode)\n{\n\tsysv_zone_t *i_data = SYSV_I(inode)->i_data;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tIndirect *partial;\n\tsysv_zone_t nr = 0;\n\tint n;\n\tlong iblock;\n\tunsigned blocksize;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> inode->i_sb->s_blocksize_bits;\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, get_block);\n\n\tn = block_to_path(inode, iblock, offsets);\n\tif (n == 0)\n\t\treturn;\n\n\tif (n == 1) {\n\t\tfree_data(inode, i_data+offsets[0], i_data + DIRECT);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (already detached) */\n\tif (nr) {\n\t\tif (partial == chain)\n\t\t\tmark_inode_dirty(inode);\n\t\telse\n\t\t\tdirty_indirect(partial->bh, inode);\n\t\tfree_branches(inode, &nr, &nr+1, (chain+n-1) - partial);\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\tfree_branches(inode, partial->p + 1, block_end(partial->bh),\n\t\t\t\t(chain+n-1) - partial);\n\t\tdirty_indirect(partial->bh, inode);\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees (== subtrees deeper than...) */\n\twhile (n < DEPTH) {\n\t\tnr = i_data[DIRECT + n - 1];\n\t\tif (nr) {\n\t\t\ti_data[DIRECT + n - 1] = 0;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tfree_branches(inode, &nr, &nr+1, n);\n\t\t}\n\t\tn++;\n\t}\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tif (IS_SYNC(inode))\n\t\tsysv_sync_inode (inode);\n\telse\n\t\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nvoid sysv_truncate (struct inode * inode)\n{\n\tsysv_zone_t *i_data = SYSV_I(inode)->i_data;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tIndirect *partial;\n\tsysv_zone_t nr = 0;\n\tint n;\n\tlong iblock;\n\tunsigned blocksize;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> inode->i_sb->s_blocksize_bits;\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, get_block);\n\n\tn = block_to_path(inode, iblock, offsets);\n\tif (n == 0)\n\t\treturn;\n\n\tif (n == 1) {\n\t\tfree_data(inode, i_data+offsets[0], i_data + DIRECT);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (already detached) */\n\tif (nr) {\n\t\tif (partial == chain)\n\t\t\tmark_inode_dirty(inode);\n\t\telse\n\t\t\tdirty_indirect(partial->bh, inode);\n\t\tfree_branches(inode, &nr, &nr+1, (chain+n-1) - partial);\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\tfree_branches(inode, partial->p + 1, block_end(partial->bh),\n\t\t\t\t(chain+n-1) - partial);\n\t\tdirty_indirect(partial->bh, inode);\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees (== subtrees deeper than...) */\n\twhile (n < DEPTH) {\n\t\tnr = i_data[DIRECT + n - 1];\n\t\tif (nr) {\n\t\t\ti_data[DIRECT + n - 1] = 0;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tfree_branches(inode, &nr, &nr+1, n);\n\t\t}\n\t\tn++;\n\t}\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tif (IS_SYNC(inode))\n\t\tsysv_sync_inode (inode);\n\telse\n\t\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic void sysv_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tsysv_truncate(inode);\n\t}\n}"
  },
  {
    "function_name": "sysv_prepare_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "462-465",
    "snippet": "int sysv_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, get_block);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "pos",
            "len",
            "get_block"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nint sysv_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, get_block);\n}"
  },
  {
    "function_name": "sysv_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "457-460",
    "snippet": "static int sysv_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page,get_block);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "get_block"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic int sysv_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page,get_block);\n}"
  },
  {
    "function_name": "sysv_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "452-455",
    "snippet": "static int sysv_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page,get_block,wbc);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "get_block",
            "wbc"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic int sysv_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page,get_block,wbc);\n}"
  },
  {
    "function_name": "sysv_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "443-450",
    "snippet": "int sysv_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct super_block *s = dentry->d_sb;\n\tgeneric_fillattr(dentry->d_inode, stat);\n\tstat->blocks = (s->s_blocksize / 512) * sysv_nblocks(s, stat->size);\n\tstat->blksize = s->s_blocksize;\n\treturn 0;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysv_nblocks",
          "args": [
            "s",
            "stat->size"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_nblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "428-441",
          "snippet": "static unsigned sysv_nblocks(struct super_block *s, loff_t size)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(s);\n\tint ptrs_bits = sbi->s_ind_per_block_bits;\n\tunsigned blocks, res, direct = DIRECT, i = DEPTH;\n\tblocks = (size + s->s_blocksize - 1) >> s->s_blocksize_bits;\n\tres = blocks;\n\twhile (--i && blocks > direct) {\n\t\tblocks = ((blocks - direct - 1) >> ptrs_bits) + 1;\n\t\tres += blocks;\n\t\tdirect = 1;\n\t}\n\treturn blocks;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic unsigned sysv_nblocks(struct super_block *s, loff_t size)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(s);\n\tint ptrs_bits = sbi->s_ind_per_block_bits;\n\tunsigned blocks, res, direct = DIRECT, i = DEPTH;\n\tblocks = (size + s->s_blocksize - 1) >> s->s_blocksize_bits;\n\tres = blocks;\n\twhile (--i && blocks > direct) {\n\t\tblocks = ((blocks - direct - 1) >> ptrs_bits) + 1;\n\t\tres += blocks;\n\t\tdirect = 1;\n\t}\n\treturn blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "dentry->d_inode",
            "stat"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nint sysv_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct super_block *s = dentry->d_sb;\n\tgeneric_fillattr(dentry->d_inode, stat);\n\tstat->blocks = (s->s_blocksize / 512) * sysv_nblocks(s, stat->size);\n\tstat->blksize = s->s_blocksize;\n\treturn 0;\n}"
  },
  {
    "function_name": "sysv_nblocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "428-441",
    "snippet": "static unsigned sysv_nblocks(struct super_block *s, loff_t size)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(s);\n\tint ptrs_bits = sbi->s_ind_per_block_bits;\n\tunsigned blocks, res, direct = DIRECT, i = DEPTH;\n\tblocks = (size + s->s_blocksize - 1) >> s->s_blocksize_bits;\n\tres = blocks;\n\twhile (--i && blocks > direct) {\n\t\tblocks = ((blocks - direct - 1) >> ptrs_bits) + 1;\n\t\tres += blocks;\n\t\tdirect = 1;\n\t}\n\treturn blocks;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSV_SB",
          "args": [
            "s"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "SYSV_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "79-82",
          "snippet": "static inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic unsigned sysv_nblocks(struct super_block *s, loff_t size)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(s);\n\tint ptrs_bits = sbi->s_ind_per_block_bits;\n\tunsigned blocks, res, direct = DIRECT, i = DEPTH;\n\tblocks = (size + s->s_blocksize - 1) >> s->s_blocksize_bits;\n\tres = blocks;\n\twhile (--i && blocks > direct) {\n\t\tblocks = ((blocks - direct - 1) >> ptrs_bits) + 1;\n\t\tres += blocks;\n\t\tdirect = 1;\n\t}\n\treturn blocks;\n}"
  },
  {
    "function_name": "sysv_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "363-426",
    "snippet": "void sysv_truncate (struct inode * inode)\n{\n\tsysv_zone_t *i_data = SYSV_I(inode)->i_data;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tIndirect *partial;\n\tsysv_zone_t nr = 0;\n\tint n;\n\tlong iblock;\n\tunsigned blocksize;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> inode->i_sb->s_blocksize_bits;\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, get_block);\n\n\tn = block_to_path(inode, iblock, offsets);\n\tif (n == 0)\n\t\treturn;\n\n\tif (n == 1) {\n\t\tfree_data(inode, i_data+offsets[0], i_data + DIRECT);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (already detached) */\n\tif (nr) {\n\t\tif (partial == chain)\n\t\t\tmark_inode_dirty(inode);\n\t\telse\n\t\t\tdirty_indirect(partial->bh, inode);\n\t\tfree_branches(inode, &nr, &nr+1, (chain+n-1) - partial);\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\tfree_branches(inode, partial->p + 1, block_end(partial->bh),\n\t\t\t\t(chain+n-1) - partial);\n\t\tdirty_indirect(partial->bh, inode);\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees (== subtrees deeper than...) */\n\twhile (n < DEPTH) {\n\t\tnr = i_data[DIRECT + n - 1];\n\t\tif (nr) {\n\t\t\ti_data[DIRECT + n - 1] = 0;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tfree_branches(inode, &nr, &nr+1, n);\n\t\t}\n\t\tn++;\n\t}\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tif (IS_SYNC(inode))\n\t\tsysv_sync_inode (inode);\n\telse\n\t\tmark_inode_dirty(inode);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_sync_inode",
          "args": [
            "inode"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_sync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/inode.c",
          "lines": "292-295",
          "snippet": "int sysv_sync_inode(struct inode *inode)\n{\n\treturn __sysv_write_inode(inode, 1);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/namei.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <asm/byteorder.h>\n#include <linux/namei.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/highuid.h>\n\nint sysv_sync_inode(struct inode *inode)\n{\n\treturn __sysv_write_inode(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_branches",
          "args": [
            "inode",
            "&nr",
            "&nr+1",
            "n"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "free_branches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "337-361",
          "snippet": "static void free_branches(struct inode *inode, sysv_zone_t *p, sysv_zone_t *q, int depth)\n{\n\tstruct buffer_head * bh;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (depth--) {\n\t\tfor ( ; p < q ; p++) {\n\t\t\tint block;\n\t\t\tsysv_zone_t nr = *p;\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\n\t\t\t*p = 0;\n\t\t\tblock = block_to_cpu(SYSV_SB(sb), nr);\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh)\n\t\t\t\tcontinue;\n\t\t\tfree_branches(inode, (sysv_zone_t*)bh->b_data,\n\t\t\t\t\tblock_end(bh), depth);\n\t\t\tbforget(bh);\n\t\t\tsysv_free_block(sb, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else\n\t\tfree_data(inode, p, q);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic void free_branches(struct inode *inode, sysv_zone_t *p, sysv_zone_t *q, int depth)\n{\n\tstruct buffer_head * bh;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (depth--) {\n\t\tfor ( ; p < q ; p++) {\n\t\t\tint block;\n\t\t\tsysv_zone_t nr = *p;\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\n\t\t\t*p = 0;\n\t\t\tblock = block_to_cpu(SYSV_SB(sb), nr);\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh)\n\t\t\t\tcontinue;\n\t\t\tfree_branches(inode, (sysv_zone_t*)bh->b_data,\n\t\t\t\t\tblock_end(bh), depth);\n\t\t\tbforget(bh);\n\t\t\tsysv_free_block(sb, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else\n\t\tfree_data(inode, p, q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "partial->bh"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirty_indirect",
          "args": [
            "partial->bh",
            "inode"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "dirty_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "15-20",
          "snippet": "static inline void dirty_indirect(struct buffer_head *bh, struct inode *inode)\n{\n\tmark_buffer_dirty_inode(bh, inode);\n\tif (IS_SYNC(inode))\n\t\tsync_dirty_buffer(bh);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline void dirty_indirect(struct buffer_head *bh, struct inode *inode)\n{\n\tmark_buffer_dirty_inode(bh, inode);\n\tif (IS_SYNC(inode))\n\t\tsync_dirty_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_end",
          "args": [
            "partial->bh"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "block_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "79-82",
          "snippet": "static inline sysv_zone_t *block_end(struct buffer_head *bh)\n{\n\treturn (sysv_zone_t*)((char*)bh->b_data + bh->b_size);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline sysv_zone_t *block_end(struct buffer_head *bh)\n{\n\treturn (sysv_zone_t*)((char*)bh->b_data + bh->b_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_shared",
          "args": [
            "inode",
            "n",
            "offsets",
            "chain",
            "&nr"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "find_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "276-323",
          "snippet": "static Indirect *find_shared(struct inode *inode,\n\t\t\t\tint depth,\n\t\t\t\tint offsets[],\n\t\t\t\tIndirect chain[],\n\t\t\t\tsysv_zone_t *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\n\twrite_lock(&pointers_lock);\n\tpartial = get_branch(inode, k, offsets, chain, &err);\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p) {\n\t\twrite_unlock(&pointers_lock);\n\t\tgoto no_top;\n\t}\n\tfor (p=partial; p>chain && all_zeroes((sysv_zone_t*)p->bh->b_data,p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t*p->p = 0;\n\t}\n\twrite_unlock(&pointers_lock);\n\n\twhile (partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(pointers_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic DEFINE_RWLOCK(pointers_lock);\n\nstatic Indirect *find_shared(struct inode *inode,\n\t\t\t\tint depth,\n\t\t\t\tint offsets[],\n\t\t\t\tIndirect chain[],\n\t\t\t\tsysv_zone_t *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\n\twrite_lock(&pointers_lock);\n\tpartial = get_branch(inode, k, offsets, chain, &err);\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p) {\n\t\twrite_unlock(&pointers_lock);\n\t\tgoto no_top;\n\t}\n\tfor (p=partial; p>chain && all_zeroes((sysv_zone_t*)p->bh->b_data,p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t*p->p = 0;\n\t}\n\twrite_unlock(&pointers_lock);\n\n\twhile (partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_data",
          "args": [
            "inode",
            "i_data+offsets[0]",
            "i_data + DIRECT"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "free_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "325-335",
          "snippet": "static inline void free_data(struct inode *inode, sysv_zone_t *p, sysv_zone_t *q)\n{\n\tfor ( ; p < q ; p++) {\n\t\tsysv_zone_t nr = *p;\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\tsysv_free_block(inode->i_sb, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline void free_data(struct inode *inode, sysv_zone_t *p, sysv_zone_t *q)\n{\n\tfor ( ; p < q ; p++) {\n\t\tsysv_zone_t nr = *p;\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\tsysv_free_block(inode->i_sb, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_to_path",
          "args": [
            "inode",
            "iblock",
            "offsets"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "block_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "22-51",
          "snippet": "static int block_to_path(struct inode *inode, long block, int offsets[DEPTH])\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tint ptrs_bits = sbi->s_ind_per_block_bits;\n\tunsigned long\tindirect_blocks = sbi->s_ind_per_block,\n\t\t\tdouble_blocks = sbi->s_ind_per_block_2;\n\tint n = 0;\n\n\tif (block < 0) {\n\t\tprintk(\"sysv_block_map: block < 0\\n\");\n\t} else if (block < DIRECT) {\n\t\toffsets[n++] = block;\n\t} else if ( (block -= DIRECT) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT;\n\t\toffsets[n++] = block;\n\t} else if ((block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = DIRECT+1;\n\t\toffsets[n++] = block >> ptrs_bits;\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else if (((block -= double_blocks) >> (ptrs_bits * 2)) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT+2;\n\t\toffsets[n++] = block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (block >> ptrs_bits) & (indirect_blocks - 1);\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else {\n\t\t/* nothing */;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic int block_to_path(struct inode *inode, long block, int offsets[DEPTH])\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tint ptrs_bits = sbi->s_ind_per_block_bits;\n\tunsigned long\tindirect_blocks = sbi->s_ind_per_block,\n\t\t\tdouble_blocks = sbi->s_ind_per_block_2;\n\tint n = 0;\n\n\tif (block < 0) {\n\t\tprintk(\"sysv_block_map: block < 0\\n\");\n\t} else if (block < DIRECT) {\n\t\toffsets[n++] = block;\n\t} else if ( (block -= DIRECT) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT;\n\t\toffsets[n++] = block;\n\t} else if ((block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = DIRECT+1;\n\t\toffsets[n++] = block >> ptrs_bits;\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else if (((block -= double_blocks) >> (ptrs_bits * 2)) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT+2;\n\t\toffsets[n++] = block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (block >> ptrs_bits) & (indirect_blocks - 1);\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else {\n\t\t/* nothing */;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_truncate_page",
          "args": [
            "inode->i_mapping",
            "inode->i_size",
            "get_block"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2806-2879",
          "snippet": "int block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSV_I",
          "args": [
            "inode"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "SYSV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "74-77",
          "snippet": "static inline struct sysv_inode_info *SYSV_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct sysv_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct sysv_inode_info *SYSV_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct sysv_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nvoid sysv_truncate (struct inode * inode)\n{\n\tsysv_zone_t *i_data = SYSV_I(inode)->i_data;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tIndirect *partial;\n\tsysv_zone_t nr = 0;\n\tint n;\n\tlong iblock;\n\tunsigned blocksize;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> inode->i_sb->s_blocksize_bits;\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, get_block);\n\n\tn = block_to_path(inode, iblock, offsets);\n\tif (n == 0)\n\t\treturn;\n\n\tif (n == 1) {\n\t\tfree_data(inode, i_data+offsets[0], i_data + DIRECT);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (already detached) */\n\tif (nr) {\n\t\tif (partial == chain)\n\t\t\tmark_inode_dirty(inode);\n\t\telse\n\t\t\tdirty_indirect(partial->bh, inode);\n\t\tfree_branches(inode, &nr, &nr+1, (chain+n-1) - partial);\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\tfree_branches(inode, partial->p + 1, block_end(partial->bh),\n\t\t\t\t(chain+n-1) - partial);\n\t\tdirty_indirect(partial->bh, inode);\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees (== subtrees deeper than...) */\n\twhile (n < DEPTH) {\n\t\tnr = i_data[DIRECT + n - 1];\n\t\tif (nr) {\n\t\t\ti_data[DIRECT + n - 1] = 0;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tfree_branches(inode, &nr, &nr+1, n);\n\t\t}\n\t\tn++;\n\t}\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tif (IS_SYNC(inode))\n\t\tsysv_sync_inode (inode);\n\telse\n\t\tmark_inode_dirty(inode);\n}"
  },
  {
    "function_name": "free_branches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "337-361",
    "snippet": "static void free_branches(struct inode *inode, sysv_zone_t *p, sysv_zone_t *q, int depth)\n{\n\tstruct buffer_head * bh;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (depth--) {\n\t\tfor ( ; p < q ; p++) {\n\t\t\tint block;\n\t\t\tsysv_zone_t nr = *p;\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\n\t\t\t*p = 0;\n\t\t\tblock = block_to_cpu(SYSV_SB(sb), nr);\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh)\n\t\t\t\tcontinue;\n\t\t\tfree_branches(inode, (sysv_zone_t*)bh->b_data,\n\t\t\t\t\tblock_end(bh), depth);\n\t\t\tbforget(bh);\n\t\t\tsysv_free_block(sb, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else\n\t\tfree_data(inode, p, q);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_data",
          "args": [
            "inode",
            "p",
            "q"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "free_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "325-335",
          "snippet": "static inline void free_data(struct inode *inode, sysv_zone_t *p, sysv_zone_t *q)\n{\n\tfor ( ; p < q ; p++) {\n\t\tsysv_zone_t nr = *p;\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\tsysv_free_block(inode->i_sb, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline void free_data(struct inode *inode, sysv_zone_t *p, sysv_zone_t *q)\n{\n\tfor ( ; p < q ; p++) {\n\t\tsysv_zone_t nr = *p;\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\tsysv_free_block(inode->i_sb, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_free_block",
          "args": [
            "sb",
            "nr"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/balloc.c",
          "lines": "42-97",
          "snippet": "void sysv_free_block(struct super_block * sb, sysv_zone_t nr)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tsysv_zone_t *blocks = sbi->s_bcache;\n\tunsigned count;\n\tunsigned block = fs32_to_cpu(sbi, nr);\n\n\t/*\n\t * This code does not work at all for AFS (it has a bitmap\n\t * free list).  As AFS is supposed to be read-only no one\n\t * should call this for an AFS filesystem anyway...\n\t */\n\tif (sbi->s_type == FSTYPE_AFS)\n\t\treturn;\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"sysv_free_block: trying to free block not in datazone\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_bcache_count);\n\n\tif (count > sbi->s_flc_size) {\n\t\tprintk(\"sysv_free_block: flc_count > flc_size\\n\");\n\t\tmutex_unlock(&sbi->s_lock);\n\t\treturn;\n\t}\n\t/* If the free list head in super-block is full, it is copied\n\t * into this block being freed, ditto if it's completely empty\n\t * (applies only on Coherent).\n\t */\n\tif (count == sbi->s_flc_size || count == 0) {\n\t\tblock += sbi->s_block_base;\n\t\tbh = sb_getblk(sb, block);\n\t\tif (!bh) {\n\t\t\tprintk(\"sysv_free_block: getblk() failed\\n\");\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn;\n\t\t}\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\t*(__fs16*)bh->b_data = cpu_to_fs16(sbi, count);\n\t\tmemcpy(get_chunk(sb,bh), blocks, count * sizeof(sysv_zone_t));\n\t\tmark_buffer_dirty(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tbrelse(bh);\n\t\tcount = 0;\n\t}\n\tsbi->s_bcache[count++] = nr;\n\n\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\tfs32_add(sbi, sbi->s_free_blocks, 1);\n\tdirty_sb(sb);\n\tmutex_unlock(&sbi->s_lock);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nvoid sysv_free_block(struct super_block * sb, sysv_zone_t nr)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tsysv_zone_t *blocks = sbi->s_bcache;\n\tunsigned count;\n\tunsigned block = fs32_to_cpu(sbi, nr);\n\n\t/*\n\t * This code does not work at all for AFS (it has a bitmap\n\t * free list).  As AFS is supposed to be read-only no one\n\t * should call this for an AFS filesystem anyway...\n\t */\n\tif (sbi->s_type == FSTYPE_AFS)\n\t\treturn;\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"sysv_free_block: trying to free block not in datazone\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_bcache_count);\n\n\tif (count > sbi->s_flc_size) {\n\t\tprintk(\"sysv_free_block: flc_count > flc_size\\n\");\n\t\tmutex_unlock(&sbi->s_lock);\n\t\treturn;\n\t}\n\t/* If the free list head in super-block is full, it is copied\n\t * into this block being freed, ditto if it's completely empty\n\t * (applies only on Coherent).\n\t */\n\tif (count == sbi->s_flc_size || count == 0) {\n\t\tblock += sbi->s_block_base;\n\t\tbh = sb_getblk(sb, block);\n\t\tif (!bh) {\n\t\t\tprintk(\"sysv_free_block: getblk() failed\\n\");\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn;\n\t\t}\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\t*(__fs16*)bh->b_data = cpu_to_fs16(sbi, count);\n\t\tmemcpy(get_chunk(sb,bh), blocks, count * sizeof(sysv_zone_t));\n\t\tmark_buffer_dirty(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tbrelse(bh);\n\t\tcount = 0;\n\t}\n\tsbi->s_bcache[count++] = nr;\n\n\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\tfs32_add(sbi, sbi->s_free_blocks, 1);\n\tdirty_sb(sb);\n\tmutex_unlock(&sbi->s_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "bh"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_branches",
          "args": [
            "inode",
            "(sysv_zone_t*)bh->b_data",
            "block_end(bh)",
            "depth"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "free_branches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "337-361",
          "snippet": "static void free_branches(struct inode *inode, sysv_zone_t *p, sysv_zone_t *q, int depth)\n{\n\tstruct buffer_head * bh;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (depth--) {\n\t\tfor ( ; p < q ; p++) {\n\t\t\tint block;\n\t\t\tsysv_zone_t nr = *p;\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\n\t\t\t*p = 0;\n\t\t\tblock = block_to_cpu(SYSV_SB(sb), nr);\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh)\n\t\t\t\tcontinue;\n\t\t\tfree_branches(inode, (sysv_zone_t*)bh->b_data,\n\t\t\t\t\tblock_end(bh), depth);\n\t\t\tbforget(bh);\n\t\t\tsysv_free_block(sb, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else\n\t\tfree_data(inode, p, q);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "block_end",
          "args": [
            "bh"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "block_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "79-82",
          "snippet": "static inline sysv_zone_t *block_end(struct buffer_head *bh)\n{\n\treturn (sysv_zone_t*)((char*)bh->b_data + bh->b_size);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline sysv_zone_t *block_end(struct buffer_head *bh)\n{\n\treturn (sysv_zone_t*)((char*)bh->b_data + bh->b_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_to_cpu",
          "args": [
            "SYSV_SB(sb)",
            "nr"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "block_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "53-56",
          "snippet": "static inline int block_to_cpu(struct sysv_sb_info *sbi, sysv_zone_t nr)\n{\n\treturn sbi->s_block_base + fs32_to_cpu(sbi, nr);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline int block_to_cpu(struct sysv_sb_info *sbi, sysv_zone_t nr)\n{\n\treturn sbi->s_block_base + fs32_to_cpu(sbi, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSV_SB",
          "args": [
            "sb"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "SYSV_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "79-82",
          "snippet": "static inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic void free_branches(struct inode *inode, sysv_zone_t *p, sysv_zone_t *q, int depth)\n{\n\tstruct buffer_head * bh;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (depth--) {\n\t\tfor ( ; p < q ; p++) {\n\t\t\tint block;\n\t\t\tsysv_zone_t nr = *p;\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\n\t\t\t*p = 0;\n\t\t\tblock = block_to_cpu(SYSV_SB(sb), nr);\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh)\n\t\t\t\tcontinue;\n\t\t\tfree_branches(inode, (sysv_zone_t*)bh->b_data,\n\t\t\t\t\tblock_end(bh), depth);\n\t\t\tbforget(bh);\n\t\t\tsysv_free_block(sb, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else\n\t\tfree_data(inode, p, q);\n}"
  },
  {
    "function_name": "free_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "325-335",
    "snippet": "static inline void free_data(struct inode *inode, sysv_zone_t *p, sysv_zone_t *q)\n{\n\tfor ( ; p < q ; p++) {\n\t\tsysv_zone_t nr = *p;\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\tsysv_free_block(inode->i_sb, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_free_block",
          "args": [
            "inode->i_sb",
            "nr"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/balloc.c",
          "lines": "42-97",
          "snippet": "void sysv_free_block(struct super_block * sb, sysv_zone_t nr)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tsysv_zone_t *blocks = sbi->s_bcache;\n\tunsigned count;\n\tunsigned block = fs32_to_cpu(sbi, nr);\n\n\t/*\n\t * This code does not work at all for AFS (it has a bitmap\n\t * free list).  As AFS is supposed to be read-only no one\n\t * should call this for an AFS filesystem anyway...\n\t */\n\tif (sbi->s_type == FSTYPE_AFS)\n\t\treturn;\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"sysv_free_block: trying to free block not in datazone\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_bcache_count);\n\n\tif (count > sbi->s_flc_size) {\n\t\tprintk(\"sysv_free_block: flc_count > flc_size\\n\");\n\t\tmutex_unlock(&sbi->s_lock);\n\t\treturn;\n\t}\n\t/* If the free list head in super-block is full, it is copied\n\t * into this block being freed, ditto if it's completely empty\n\t * (applies only on Coherent).\n\t */\n\tif (count == sbi->s_flc_size || count == 0) {\n\t\tblock += sbi->s_block_base;\n\t\tbh = sb_getblk(sb, block);\n\t\tif (!bh) {\n\t\t\tprintk(\"sysv_free_block: getblk() failed\\n\");\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn;\n\t\t}\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\t*(__fs16*)bh->b_data = cpu_to_fs16(sbi, count);\n\t\tmemcpy(get_chunk(sb,bh), blocks, count * sizeof(sysv_zone_t));\n\t\tmark_buffer_dirty(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tbrelse(bh);\n\t\tcount = 0;\n\t}\n\tsbi->s_bcache[count++] = nr;\n\n\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\tfs32_add(sbi, sbi->s_free_blocks, 1);\n\tdirty_sb(sb);\n\tmutex_unlock(&sbi->s_lock);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nvoid sysv_free_block(struct super_block * sb, sysv_zone_t nr)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tsysv_zone_t *blocks = sbi->s_bcache;\n\tunsigned count;\n\tunsigned block = fs32_to_cpu(sbi, nr);\n\n\t/*\n\t * This code does not work at all for AFS (it has a bitmap\n\t * free list).  As AFS is supposed to be read-only no one\n\t * should call this for an AFS filesystem anyway...\n\t */\n\tif (sbi->s_type == FSTYPE_AFS)\n\t\treturn;\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"sysv_free_block: trying to free block not in datazone\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_bcache_count);\n\n\tif (count > sbi->s_flc_size) {\n\t\tprintk(\"sysv_free_block: flc_count > flc_size\\n\");\n\t\tmutex_unlock(&sbi->s_lock);\n\t\treturn;\n\t}\n\t/* If the free list head in super-block is full, it is copied\n\t * into this block being freed, ditto if it's completely empty\n\t * (applies only on Coherent).\n\t */\n\tif (count == sbi->s_flc_size || count == 0) {\n\t\tblock += sbi->s_block_base;\n\t\tbh = sb_getblk(sb, block);\n\t\tif (!bh) {\n\t\t\tprintk(\"sysv_free_block: getblk() failed\\n\");\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn;\n\t\t}\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\t*(__fs16*)bh->b_data = cpu_to_fs16(sbi, count);\n\t\tmemcpy(get_chunk(sb,bh), blocks, count * sizeof(sysv_zone_t));\n\t\tmark_buffer_dirty(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tbrelse(bh);\n\t\tcount = 0;\n\t}\n\tsbi->s_bcache[count++] = nr;\n\n\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\tfs32_add(sbi, sbi->s_free_blocks, 1);\n\tdirty_sb(sb);\n\tmutex_unlock(&sbi->s_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline void free_data(struct inode *inode, sysv_zone_t *p, sysv_zone_t *q)\n{\n\tfor ( ; p < q ; p++) {\n\t\tsysv_zone_t nr = *p;\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\tsysv_free_block(inode->i_sb, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "find_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "276-323",
    "snippet": "static Indirect *find_shared(struct inode *inode,\n\t\t\t\tint depth,\n\t\t\t\tint offsets[],\n\t\t\t\tIndirect chain[],\n\t\t\t\tsysv_zone_t *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\n\twrite_lock(&pointers_lock);\n\tpartial = get_branch(inode, k, offsets, chain, &err);\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p) {\n\t\twrite_unlock(&pointers_lock);\n\t\tgoto no_top;\n\t}\n\tfor (p=partial; p>chain && all_zeroes((sysv_zone_t*)p->bh->b_data,p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t*p->p = 0;\n\t}\n\twrite_unlock(&pointers_lock);\n\n\twhile (partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(pointers_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "partial->bh"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&pointers_lock"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "all_zeroes",
          "args": [
            "(sysv_zone_t*)p->bh->b_data",
            "p->p"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "all_zeroes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "268-274",
          "snippet": "static inline int all_zeroes(sysv_zone_t *p, sysv_zone_t *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline int all_zeroes(sysv_zone_t *p, sysv_zone_t *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_branch",
          "args": [
            "inode",
            "k",
            "offsets",
            "chain",
            "&err"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "get_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "87-122",
          "snippet": "static Indirect *get_branch(struct inode *inode,\n\t\t\t    int depth,\n\t\t\t    int offsets[],\n\t\t\t    Indirect chain[],\n\t\t\t    int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\tadd_chain(chain, NULL, SYSV_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tint block = block_to_cpu(SYSV_SB(sb), p->key);\n\t\tbh = sb_bread(sb, block);\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (sysv_zone_t*)bh->b_data + *++offsets);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic Indirect *get_branch(struct inode *inode,\n\t\t\t    int depth,\n\t\t\t    int offsets[],\n\t\t\t    Indirect chain[],\n\t\t\t    int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\tadd_chain(chain, NULL, SYSV_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tint block = block_to_cpu(SYSV_SB(sb), p->key);\n\t\tbh = sb_bread(sb, block);\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (sysv_zone_t*)bh->b_data + *++offsets);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&pointers_lock"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic DEFINE_RWLOCK(pointers_lock);\n\nstatic Indirect *find_shared(struct inode *inode,\n\t\t\t\tint depth,\n\t\t\t\tint offsets[],\n\t\t\t\tIndirect chain[],\n\t\t\t\tsysv_zone_t *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\n\twrite_lock(&pointers_lock);\n\tpartial = get_branch(inode, k, offsets, chain, &err);\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p) {\n\t\twrite_unlock(&pointers_lock);\n\t\tgoto no_top;\n\t}\n\tfor (p=partial; p>chain && all_zeroes((sysv_zone_t*)p->bh->b_data,p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t*p->p = 0;\n\t}\n\twrite_unlock(&pointers_lock);\n\n\twhile (partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}"
  },
  {
    "function_name": "all_zeroes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "268-274",
    "snippet": "static inline int all_zeroes(sysv_zone_t *p, sysv_zone_t *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline int all_zeroes(sysv_zone_t *p, sysv_zone_t *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "202-266",
    "snippet": "static int get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create)\n{\n\tint err = -EIO;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *partial;\n\tint left;\n\tint depth = block_to_path(inode, iblock, offsets);\n\n\tif (depth == 0)\n\t\tgoto out;\n\nreread:\n\tread_lock(&pointers_lock);\n\tpartial = get_branch(inode, depth, offsets, chain, &err);\n\tread_unlock(&pointers_lock);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\ngot_it:\n\t\tmap_bh(bh_result, sb, block_to_cpu(SYSV_SB(sb),\n\t\t\t\t\tchain[depth-1].key));\n\t\t/* Clean up and exit */\n\t\tpartial = chain+depth-1; /* the whole chain */\n\t\tgoto cleanup;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO) {\ncleanup:\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\nout:\n\t\treturn err;\n\t}\n\n\t/*\n\t * Indirect block might be removed by truncate while we were\n\t * reading it. Handling of that case (forget what we've got and\n\t * reread) is taken out of the main path.\n\t */\n\tif (err == -EAGAIN)\n\t\tgoto changed;\n\n\tleft = (chain + depth) - partial;\n\terr = alloc_branch(inode, left, offsets+(partial-chain), partial);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (splice_branch(inode, chain, partial, left) < 0)\n\t\tgoto changed;\n\n\tset_buffer_new(bh_result);\n\tgoto got_it;\n\nchanged:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tgoto reread;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(pointers_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "partial->bh"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splice_branch",
          "args": [
            "inode",
            "chain",
            "partial",
            "left"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "splice_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "167-200",
          "snippet": "static inline int splice_branch(struct inode *inode,\n\t\t\t\tIndirect chain[],\n\t\t\t\tIndirect *where,\n\t\t\t\tint num)\n{\n\tint i;\n\n\t/* Verify that place we are splicing to is still there and vacant */\n\twrite_lock(&pointers_lock);\n\tif (!verify_chain(chain, where-1) || *where->p)\n\t\tgoto changed;\n\t*where->p = where->key;\n\twrite_unlock(&pointers_lock);\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh)\n\t\tdirty_indirect(where->bh, inode);\n\n\tif (IS_SYNC(inode))\n\t\tsysv_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n\nchanged:\n\twrite_unlock(&pointers_lock);\n\tfor (i = 1; i < num; i++)\n\t\tbforget(where[i].bh);\n\tfor (i = 0; i < num; i++)\n\t\tsysv_free_block(inode->i_sb, where[i].key);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(pointers_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic DEFINE_RWLOCK(pointers_lock);\n\nstatic inline int splice_branch(struct inode *inode,\n\t\t\t\tIndirect chain[],\n\t\t\t\tIndirect *where,\n\t\t\t\tint num)\n{\n\tint i;\n\n\t/* Verify that place we are splicing to is still there and vacant */\n\twrite_lock(&pointers_lock);\n\tif (!verify_chain(chain, where-1) || *where->p)\n\t\tgoto changed;\n\t*where->p = where->key;\n\twrite_unlock(&pointers_lock);\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh)\n\t\tdirty_indirect(where->bh, inode);\n\n\tif (IS_SYNC(inode))\n\t\tsysv_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n\nchanged:\n\twrite_unlock(&pointers_lock);\n\tfor (i = 1; i < num; i++)\n\t\tbforget(where[i].bh);\n\tfor (i = 0; i < num; i++)\n\t\tsysv_free_block(inode->i_sb, where[i].key);\n\treturn -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_branch",
          "args": [
            "inode",
            "left",
            "offsets+(partial-chain)",
            "partial"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "124-165",
          "snippet": "static int alloc_branch(struct inode *inode,\n\t\t\tint num,\n\t\t\tint *offsets,\n\t\t\tIndirect *branch)\n{\n\tint blocksize = inode->i_sb->s_blocksize;\n\tint n = 0;\n\tint i;\n\n\tbranch[0].key = sysv_new_block(inode->i_sb);\n\tif (branch[0].key) for (n = 1; n < num; n++) {\n\t\tstruct buffer_head *bh;\n\t\tint parent;\n\t\t/* Allocate the next block */\n\t\tbranch[n].key = sysv_new_block(inode->i_sb);\n\t\tif (!branch[n].key)\n\t\t\tbreak;\n\t\t/*\n\t\t * Get buffer_head for parent block, zero it out and set \n\t\t * the pointer to new one, then send parent to disk.\n\t\t */\n\t\tparent = block_to_cpu(SYSV_SB(inode->i_sb), branch[n-1].key);\n\t\tbh = sb_getblk(inode->i_sb, parent);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, blocksize);\n\t\tbranch[n].bh = bh;\n\t\tbranch[n].p = (sysv_zone_t*) bh->b_data + offsets[n];\n\t\t*branch[n].p = branch[n].key;\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tdirty_indirect(bh, inode);\n\t}\n\tif (n == num)\n\t\treturn 0;\n\n\t/* Allocation failed, free what we already allocated */\n\tfor (i = 1; i < n; i++)\n\t\tbforget(branch[i].bh);\n\tfor (i = 0; i < n; i++)\n\t\tsysv_free_block(inode->i_sb, branch[i].key);\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic int alloc_branch(struct inode *inode,\n\t\t\tint num,\n\t\t\tint *offsets,\n\t\t\tIndirect *branch)\n{\n\tint blocksize = inode->i_sb->s_blocksize;\n\tint n = 0;\n\tint i;\n\n\tbranch[0].key = sysv_new_block(inode->i_sb);\n\tif (branch[0].key) for (n = 1; n < num; n++) {\n\t\tstruct buffer_head *bh;\n\t\tint parent;\n\t\t/* Allocate the next block */\n\t\tbranch[n].key = sysv_new_block(inode->i_sb);\n\t\tif (!branch[n].key)\n\t\t\tbreak;\n\t\t/*\n\t\t * Get buffer_head for parent block, zero it out and set \n\t\t * the pointer to new one, then send parent to disk.\n\t\t */\n\t\tparent = block_to_cpu(SYSV_SB(inode->i_sb), branch[n-1].key);\n\t\tbh = sb_getblk(inode->i_sb, parent);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, blocksize);\n\t\tbranch[n].bh = bh;\n\t\tbranch[n].p = (sysv_zone_t*) bh->b_data + offsets[n];\n\t\t*branch[n].p = branch[n].key;\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tdirty_indirect(bh, inode);\n\t}\n\tif (n == num)\n\t\treturn 0;\n\n\t/* Allocation failed, free what we already allocated */\n\tfor (i = 1; i < n; i++)\n\t\tbforget(branch[i].bh);\n\tfor (i = 0; i < n; i++)\n\t\tsysv_free_block(inode->i_sb, branch[i].key);\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "sb",
            "block_to_cpu(SYSV_SB(sb),\n\t\t\t\t\tchain[depth-1].key)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_to_cpu",
          "args": [
            "SYSV_SB(sb)",
            "chain[depth-1].key"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "block_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "53-56",
          "snippet": "static inline int block_to_cpu(struct sysv_sb_info *sbi, sysv_zone_t nr)\n{\n\treturn sbi->s_block_base + fs32_to_cpu(sbi, nr);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline int block_to_cpu(struct sysv_sb_info *sbi, sysv_zone_t nr)\n{\n\treturn sbi->s_block_base + fs32_to_cpu(sbi, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSV_SB",
          "args": [
            "sb"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "SYSV_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "79-82",
          "snippet": "static inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&pointers_lock"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_branch",
          "args": [
            "inode",
            "depth",
            "offsets",
            "chain",
            "&err"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "get_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "87-122",
          "snippet": "static Indirect *get_branch(struct inode *inode,\n\t\t\t    int depth,\n\t\t\t    int offsets[],\n\t\t\t    Indirect chain[],\n\t\t\t    int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\tadd_chain(chain, NULL, SYSV_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tint block = block_to_cpu(SYSV_SB(sb), p->key);\n\t\tbh = sb_bread(sb, block);\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (sysv_zone_t*)bh->b_data + *++offsets);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic Indirect *get_branch(struct inode *inode,\n\t\t\t    int depth,\n\t\t\t    int offsets[],\n\t\t\t    Indirect chain[],\n\t\t\t    int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\tadd_chain(chain, NULL, SYSV_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tint block = block_to_cpu(SYSV_SB(sb), p->key);\n\t\tbh = sb_bread(sb, block);\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (sysv_zone_t*)bh->b_data + *++offsets);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&pointers_lock"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_to_path",
          "args": [
            "inode",
            "iblock",
            "offsets"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "block_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "22-51",
          "snippet": "static int block_to_path(struct inode *inode, long block, int offsets[DEPTH])\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tint ptrs_bits = sbi->s_ind_per_block_bits;\n\tunsigned long\tindirect_blocks = sbi->s_ind_per_block,\n\t\t\tdouble_blocks = sbi->s_ind_per_block_2;\n\tint n = 0;\n\n\tif (block < 0) {\n\t\tprintk(\"sysv_block_map: block < 0\\n\");\n\t} else if (block < DIRECT) {\n\t\toffsets[n++] = block;\n\t} else if ( (block -= DIRECT) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT;\n\t\toffsets[n++] = block;\n\t} else if ((block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = DIRECT+1;\n\t\toffsets[n++] = block >> ptrs_bits;\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else if (((block -= double_blocks) >> (ptrs_bits * 2)) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT+2;\n\t\toffsets[n++] = block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (block >> ptrs_bits) & (indirect_blocks - 1);\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else {\n\t\t/* nothing */;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic int block_to_path(struct inode *inode, long block, int offsets[DEPTH])\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tint ptrs_bits = sbi->s_ind_per_block_bits;\n\tunsigned long\tindirect_blocks = sbi->s_ind_per_block,\n\t\t\tdouble_blocks = sbi->s_ind_per_block_2;\n\tint n = 0;\n\n\tif (block < 0) {\n\t\tprintk(\"sysv_block_map: block < 0\\n\");\n\t} else if (block < DIRECT) {\n\t\toffsets[n++] = block;\n\t} else if ( (block -= DIRECT) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT;\n\t\toffsets[n++] = block;\n\t} else if ((block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = DIRECT+1;\n\t\toffsets[n++] = block >> ptrs_bits;\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else if (((block -= double_blocks) >> (ptrs_bits * 2)) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT+2;\n\t\toffsets[n++] = block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (block >> ptrs_bits) & (indirect_blocks - 1);\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else {\n\t\t/* nothing */;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic DEFINE_RWLOCK(pointers_lock);\n\nstatic int get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create)\n{\n\tint err = -EIO;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *partial;\n\tint left;\n\tint depth = block_to_path(inode, iblock, offsets);\n\n\tif (depth == 0)\n\t\tgoto out;\n\nreread:\n\tread_lock(&pointers_lock);\n\tpartial = get_branch(inode, depth, offsets, chain, &err);\n\tread_unlock(&pointers_lock);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\ngot_it:\n\t\tmap_bh(bh_result, sb, block_to_cpu(SYSV_SB(sb),\n\t\t\t\t\tchain[depth-1].key));\n\t\t/* Clean up and exit */\n\t\tpartial = chain+depth-1; /* the whole chain */\n\t\tgoto cleanup;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO) {\ncleanup:\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\nout:\n\t\treturn err;\n\t}\n\n\t/*\n\t * Indirect block might be removed by truncate while we were\n\t * reading it. Handling of that case (forget what we've got and\n\t * reread) is taken out of the main path.\n\t */\n\tif (err == -EAGAIN)\n\t\tgoto changed;\n\n\tleft = (chain + depth) - partial;\n\terr = alloc_branch(inode, left, offsets+(partial-chain), partial);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (splice_branch(inode, chain, partial, left) < 0)\n\t\tgoto changed;\n\n\tset_buffer_new(bh_result);\n\tgoto got_it;\n\nchanged:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tgoto reread;\n}"
  },
  {
    "function_name": "splice_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "167-200",
    "snippet": "static inline int splice_branch(struct inode *inode,\n\t\t\t\tIndirect chain[],\n\t\t\t\tIndirect *where,\n\t\t\t\tint num)\n{\n\tint i;\n\n\t/* Verify that place we are splicing to is still there and vacant */\n\twrite_lock(&pointers_lock);\n\tif (!verify_chain(chain, where-1) || *where->p)\n\t\tgoto changed;\n\t*where->p = where->key;\n\twrite_unlock(&pointers_lock);\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh)\n\t\tdirty_indirect(where->bh, inode);\n\n\tif (IS_SYNC(inode))\n\t\tsysv_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n\nchanged:\n\twrite_unlock(&pointers_lock);\n\tfor (i = 1; i < num; i++)\n\t\tbforget(where[i].bh);\n\tfor (i = 0; i < num; i++)\n\t\tsysv_free_block(inode->i_sb, where[i].key);\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(pointers_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysv_free_block",
          "args": [
            "inode->i_sb",
            "where[i].key"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/balloc.c",
          "lines": "42-97",
          "snippet": "void sysv_free_block(struct super_block * sb, sysv_zone_t nr)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tsysv_zone_t *blocks = sbi->s_bcache;\n\tunsigned count;\n\tunsigned block = fs32_to_cpu(sbi, nr);\n\n\t/*\n\t * This code does not work at all for AFS (it has a bitmap\n\t * free list).  As AFS is supposed to be read-only no one\n\t * should call this for an AFS filesystem anyway...\n\t */\n\tif (sbi->s_type == FSTYPE_AFS)\n\t\treturn;\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"sysv_free_block: trying to free block not in datazone\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_bcache_count);\n\n\tif (count > sbi->s_flc_size) {\n\t\tprintk(\"sysv_free_block: flc_count > flc_size\\n\");\n\t\tmutex_unlock(&sbi->s_lock);\n\t\treturn;\n\t}\n\t/* If the free list head in super-block is full, it is copied\n\t * into this block being freed, ditto if it's completely empty\n\t * (applies only on Coherent).\n\t */\n\tif (count == sbi->s_flc_size || count == 0) {\n\t\tblock += sbi->s_block_base;\n\t\tbh = sb_getblk(sb, block);\n\t\tif (!bh) {\n\t\t\tprintk(\"sysv_free_block: getblk() failed\\n\");\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn;\n\t\t}\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\t*(__fs16*)bh->b_data = cpu_to_fs16(sbi, count);\n\t\tmemcpy(get_chunk(sb,bh), blocks, count * sizeof(sysv_zone_t));\n\t\tmark_buffer_dirty(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tbrelse(bh);\n\t\tcount = 0;\n\t}\n\tsbi->s_bcache[count++] = nr;\n\n\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\tfs32_add(sbi, sbi->s_free_blocks, 1);\n\tdirty_sb(sb);\n\tmutex_unlock(&sbi->s_lock);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nvoid sysv_free_block(struct super_block * sb, sysv_zone_t nr)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tsysv_zone_t *blocks = sbi->s_bcache;\n\tunsigned count;\n\tunsigned block = fs32_to_cpu(sbi, nr);\n\n\t/*\n\t * This code does not work at all for AFS (it has a bitmap\n\t * free list).  As AFS is supposed to be read-only no one\n\t * should call this for an AFS filesystem anyway...\n\t */\n\tif (sbi->s_type == FSTYPE_AFS)\n\t\treturn;\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"sysv_free_block: trying to free block not in datazone\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_bcache_count);\n\n\tif (count > sbi->s_flc_size) {\n\t\tprintk(\"sysv_free_block: flc_count > flc_size\\n\");\n\t\tmutex_unlock(&sbi->s_lock);\n\t\treturn;\n\t}\n\t/* If the free list head in super-block is full, it is copied\n\t * into this block being freed, ditto if it's completely empty\n\t * (applies only on Coherent).\n\t */\n\tif (count == sbi->s_flc_size || count == 0) {\n\t\tblock += sbi->s_block_base;\n\t\tbh = sb_getblk(sb, block);\n\t\tif (!bh) {\n\t\t\tprintk(\"sysv_free_block: getblk() failed\\n\");\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn;\n\t\t}\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\t*(__fs16*)bh->b_data = cpu_to_fs16(sbi, count);\n\t\tmemcpy(get_chunk(sb,bh), blocks, count * sizeof(sysv_zone_t));\n\t\tmark_buffer_dirty(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tbrelse(bh);\n\t\tcount = 0;\n\t}\n\tsbi->s_bcache[count++] = nr;\n\n\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\tfs32_add(sbi, sbi->s_free_blocks, 1);\n\tdirty_sb(sb);\n\tmutex_unlock(&sbi->s_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "where[i].bh"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&pointers_lock"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_sync_inode",
          "args": [
            "inode"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_sync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/inode.c",
          "lines": "292-295",
          "snippet": "int sysv_sync_inode(struct inode *inode)\n{\n\treturn __sysv_write_inode(inode, 1);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/namei.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <asm/byteorder.h>\n#include <linux/namei.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/highuid.h>\n\nint sysv_sync_inode(struct inode *inode)\n{\n\treturn __sysv_write_inode(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirty_indirect",
          "args": [
            "where->bh",
            "inode"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "dirty_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "15-20",
          "snippet": "static inline void dirty_indirect(struct buffer_head *bh, struct inode *inode)\n{\n\tmark_buffer_dirty_inode(bh, inode);\n\tif (IS_SYNC(inode))\n\t\tsync_dirty_buffer(bh);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline void dirty_indirect(struct buffer_head *bh, struct inode *inode)\n{\n\tmark_buffer_dirty_inode(bh, inode);\n\tif (IS_SYNC(inode))\n\t\tsync_dirty_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_chain",
          "args": [
            "chain",
            "where-1"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "verify_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "72-77",
          "snippet": "static inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&pointers_lock"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic DEFINE_RWLOCK(pointers_lock);\n\nstatic inline int splice_branch(struct inode *inode,\n\t\t\t\tIndirect chain[],\n\t\t\t\tIndirect *where,\n\t\t\t\tint num)\n{\n\tint i;\n\n\t/* Verify that place we are splicing to is still there and vacant */\n\twrite_lock(&pointers_lock);\n\tif (!verify_chain(chain, where-1) || *where->p)\n\t\tgoto changed;\n\t*where->p = where->key;\n\twrite_unlock(&pointers_lock);\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh)\n\t\tdirty_indirect(where->bh, inode);\n\n\tif (IS_SYNC(inode))\n\t\tsysv_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n\nchanged:\n\twrite_unlock(&pointers_lock);\n\tfor (i = 1; i < num; i++)\n\t\tbforget(where[i].bh);\n\tfor (i = 0; i < num; i++)\n\t\tsysv_free_block(inode->i_sb, where[i].key);\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "alloc_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "124-165",
    "snippet": "static int alloc_branch(struct inode *inode,\n\t\t\tint num,\n\t\t\tint *offsets,\n\t\t\tIndirect *branch)\n{\n\tint blocksize = inode->i_sb->s_blocksize;\n\tint n = 0;\n\tint i;\n\n\tbranch[0].key = sysv_new_block(inode->i_sb);\n\tif (branch[0].key) for (n = 1; n < num; n++) {\n\t\tstruct buffer_head *bh;\n\t\tint parent;\n\t\t/* Allocate the next block */\n\t\tbranch[n].key = sysv_new_block(inode->i_sb);\n\t\tif (!branch[n].key)\n\t\t\tbreak;\n\t\t/*\n\t\t * Get buffer_head for parent block, zero it out and set \n\t\t * the pointer to new one, then send parent to disk.\n\t\t */\n\t\tparent = block_to_cpu(SYSV_SB(inode->i_sb), branch[n-1].key);\n\t\tbh = sb_getblk(inode->i_sb, parent);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, blocksize);\n\t\tbranch[n].bh = bh;\n\t\tbranch[n].p = (sysv_zone_t*) bh->b_data + offsets[n];\n\t\t*branch[n].p = branch[n].key;\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tdirty_indirect(bh, inode);\n\t}\n\tif (n == num)\n\t\treturn 0;\n\n\t/* Allocation failed, free what we already allocated */\n\tfor (i = 1; i < n; i++)\n\t\tbforget(branch[i].bh);\n\tfor (i = 0; i < n; i++)\n\t\tsysv_free_block(inode->i_sb, branch[i].key);\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysv_free_block",
          "args": [
            "inode->i_sb",
            "branch[i].key"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/balloc.c",
          "lines": "42-97",
          "snippet": "void sysv_free_block(struct super_block * sb, sysv_zone_t nr)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tsysv_zone_t *blocks = sbi->s_bcache;\n\tunsigned count;\n\tunsigned block = fs32_to_cpu(sbi, nr);\n\n\t/*\n\t * This code does not work at all for AFS (it has a bitmap\n\t * free list).  As AFS is supposed to be read-only no one\n\t * should call this for an AFS filesystem anyway...\n\t */\n\tif (sbi->s_type == FSTYPE_AFS)\n\t\treturn;\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"sysv_free_block: trying to free block not in datazone\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_bcache_count);\n\n\tif (count > sbi->s_flc_size) {\n\t\tprintk(\"sysv_free_block: flc_count > flc_size\\n\");\n\t\tmutex_unlock(&sbi->s_lock);\n\t\treturn;\n\t}\n\t/* If the free list head in super-block is full, it is copied\n\t * into this block being freed, ditto if it's completely empty\n\t * (applies only on Coherent).\n\t */\n\tif (count == sbi->s_flc_size || count == 0) {\n\t\tblock += sbi->s_block_base;\n\t\tbh = sb_getblk(sb, block);\n\t\tif (!bh) {\n\t\t\tprintk(\"sysv_free_block: getblk() failed\\n\");\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn;\n\t\t}\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\t*(__fs16*)bh->b_data = cpu_to_fs16(sbi, count);\n\t\tmemcpy(get_chunk(sb,bh), blocks, count * sizeof(sysv_zone_t));\n\t\tmark_buffer_dirty(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tbrelse(bh);\n\t\tcount = 0;\n\t}\n\tsbi->s_bcache[count++] = nr;\n\n\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\tfs32_add(sbi, sbi->s_free_blocks, 1);\n\tdirty_sb(sb);\n\tmutex_unlock(&sbi->s_lock);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nvoid sysv_free_block(struct super_block * sb, sysv_zone_t nr)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tsysv_zone_t *blocks = sbi->s_bcache;\n\tunsigned count;\n\tunsigned block = fs32_to_cpu(sbi, nr);\n\n\t/*\n\t * This code does not work at all for AFS (it has a bitmap\n\t * free list).  As AFS is supposed to be read-only no one\n\t * should call this for an AFS filesystem anyway...\n\t */\n\tif (sbi->s_type == FSTYPE_AFS)\n\t\treturn;\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"sysv_free_block: trying to free block not in datazone\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_bcache_count);\n\n\tif (count > sbi->s_flc_size) {\n\t\tprintk(\"sysv_free_block: flc_count > flc_size\\n\");\n\t\tmutex_unlock(&sbi->s_lock);\n\t\treturn;\n\t}\n\t/* If the free list head in super-block is full, it is copied\n\t * into this block being freed, ditto if it's completely empty\n\t * (applies only on Coherent).\n\t */\n\tif (count == sbi->s_flc_size || count == 0) {\n\t\tblock += sbi->s_block_base;\n\t\tbh = sb_getblk(sb, block);\n\t\tif (!bh) {\n\t\t\tprintk(\"sysv_free_block: getblk() failed\\n\");\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn;\n\t\t}\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\t*(__fs16*)bh->b_data = cpu_to_fs16(sbi, count);\n\t\tmemcpy(get_chunk(sb,bh), blocks, count * sizeof(sysv_zone_t));\n\t\tmark_buffer_dirty(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tbrelse(bh);\n\t\tcount = 0;\n\t}\n\tsbi->s_bcache[count++] = nr;\n\n\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\tfs32_add(sbi, sbi->s_free_blocks, 1);\n\tdirty_sb(sb);\n\tmutex_unlock(&sbi->s_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "branch[i].bh"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirty_indirect",
          "args": [
            "bh",
            "inode"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "dirty_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "15-20",
          "snippet": "static inline void dirty_indirect(struct buffer_head *bh, struct inode *inode)\n{\n\tmark_buffer_dirty_inode(bh, inode);\n\tif (IS_SYNC(inode))\n\t\tsync_dirty_buffer(bh);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline void dirty_indirect(struct buffer_head *bh, struct inode *inode)\n{\n\tmark_buffer_dirty_inode(bh, inode);\n\tif (IS_SYNC(inode))\n\t\tsync_dirty_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "blocksize"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "inode->i_sb",
            "parent"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_to_cpu",
          "args": [
            "SYSV_SB(inode->i_sb)",
            "branch[n-1].key"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "block_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "53-56",
          "snippet": "static inline int block_to_cpu(struct sysv_sb_info *sbi, sysv_zone_t nr)\n{\n\treturn sbi->s_block_base + fs32_to_cpu(sbi, nr);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline int block_to_cpu(struct sysv_sb_info *sbi, sysv_zone_t nr)\n{\n\treturn sbi->s_block_base + fs32_to_cpu(sbi, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSV_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "SYSV_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "79-82",
          "snippet": "static inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_new_block",
          "args": [
            "inode->i_sb"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_new_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/balloc.c",
          "lines": "99-156",
          "snippet": "sysv_zone_t sysv_new_block(struct super_block * sb)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tunsigned int block;\n\tsysv_zone_t nr;\n\tstruct buffer_head * bh;\n\tunsigned count;\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_bcache_count);\n\n\tif (count == 0) /* Applies only to Coherent FS */\n\t\tgoto Enospc;\n\tnr = sbi->s_bcache[--count];\n\tif (nr == 0)  /* Applies only to Xenix FS, SystemV FS */\n\t\tgoto Enospc;\n\n\tblock = fs32_to_cpu(sbi, nr);\n\n\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"sysv_new_block: new block %d is not in data zone\\n\",\n\t\t\tblock);\n\t\tgoto Enospc;\n\t}\n\n\tif (count == 0) { /* the last block continues the free list */\n\t\tunsigned count;\n\n\t\tblock += sbi->s_block_base;\n\t\tif (!(bh = sb_bread(sb, block))) {\n\t\t\tprintk(\"sysv_new_block: cannot read free-list block\\n\");\n\t\t\t/* retry this same block next time */\n\t\t\t*sbi->s_bcache_count = cpu_to_fs16(sbi, 1);\n\t\t\tgoto Enospc;\n\t\t}\n\t\tcount = fs16_to_cpu(sbi, *(__fs16*)bh->b_data);\n\t\tif (count > sbi->s_flc_size) {\n\t\t\tprintk(\"sysv_new_block: free-list block with >flc_size entries\\n\");\n\t\t\tbrelse(bh);\n\t\t\tgoto Enospc;\n\t\t}\n\t\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\t\tmemcpy(sbi->s_bcache, get_chunk(sb, bh),\n\t\t\t\tcount * sizeof(sysv_zone_t));\n\t\tbrelse(bh);\n\t}\n\t/* Now the free list head in the superblock is valid again. */\n\tfs32_add(sbi, sbi->s_free_blocks, -1);\n\tdirty_sb(sb);\n\tmutex_unlock(&sbi->s_lock);\n\treturn nr;\n\nEnospc:\n\tmutex_unlock(&sbi->s_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nsysv_zone_t sysv_new_block(struct super_block * sb)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tunsigned int block;\n\tsysv_zone_t nr;\n\tstruct buffer_head * bh;\n\tunsigned count;\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_bcache_count);\n\n\tif (count == 0) /* Applies only to Coherent FS */\n\t\tgoto Enospc;\n\tnr = sbi->s_bcache[--count];\n\tif (nr == 0)  /* Applies only to Xenix FS, SystemV FS */\n\t\tgoto Enospc;\n\n\tblock = fs32_to_cpu(sbi, nr);\n\n\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"sysv_new_block: new block %d is not in data zone\\n\",\n\t\t\tblock);\n\t\tgoto Enospc;\n\t}\n\n\tif (count == 0) { /* the last block continues the free list */\n\t\tunsigned count;\n\n\t\tblock += sbi->s_block_base;\n\t\tif (!(bh = sb_bread(sb, block))) {\n\t\t\tprintk(\"sysv_new_block: cannot read free-list block\\n\");\n\t\t\t/* retry this same block next time */\n\t\t\t*sbi->s_bcache_count = cpu_to_fs16(sbi, 1);\n\t\t\tgoto Enospc;\n\t\t}\n\t\tcount = fs16_to_cpu(sbi, *(__fs16*)bh->b_data);\n\t\tif (count > sbi->s_flc_size) {\n\t\t\tprintk(\"sysv_new_block: free-list block with >flc_size entries\\n\");\n\t\t\tbrelse(bh);\n\t\t\tgoto Enospc;\n\t\t}\n\t\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\t\tmemcpy(sbi->s_bcache, get_chunk(sb, bh),\n\t\t\t\tcount * sizeof(sysv_zone_t));\n\t\tbrelse(bh);\n\t}\n\t/* Now the free list head in the superblock is valid again. */\n\tfs32_add(sbi, sbi->s_free_blocks, -1);\n\tdirty_sb(sb);\n\tmutex_unlock(&sbi->s_lock);\n\treturn nr;\n\nEnospc:\n\tmutex_unlock(&sbi->s_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic int alloc_branch(struct inode *inode,\n\t\t\tint num,\n\t\t\tint *offsets,\n\t\t\tIndirect *branch)\n{\n\tint blocksize = inode->i_sb->s_blocksize;\n\tint n = 0;\n\tint i;\n\n\tbranch[0].key = sysv_new_block(inode->i_sb);\n\tif (branch[0].key) for (n = 1; n < num; n++) {\n\t\tstruct buffer_head *bh;\n\t\tint parent;\n\t\t/* Allocate the next block */\n\t\tbranch[n].key = sysv_new_block(inode->i_sb);\n\t\tif (!branch[n].key)\n\t\t\tbreak;\n\t\t/*\n\t\t * Get buffer_head for parent block, zero it out and set \n\t\t * the pointer to new one, then send parent to disk.\n\t\t */\n\t\tparent = block_to_cpu(SYSV_SB(inode->i_sb), branch[n-1].key);\n\t\tbh = sb_getblk(inode->i_sb, parent);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, blocksize);\n\t\tbranch[n].bh = bh;\n\t\tbranch[n].p = (sysv_zone_t*) bh->b_data + offsets[n];\n\t\t*branch[n].p = branch[n].key;\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tdirty_indirect(bh, inode);\n\t}\n\tif (n == num)\n\t\treturn 0;\n\n\t/* Allocation failed, free what we already allocated */\n\tfor (i = 1; i < n; i++)\n\t\tbforget(branch[i].bh);\n\tfor (i = 0; i < n; i++)\n\t\tsysv_free_block(inode->i_sb, branch[i].key);\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "get_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "87-122",
    "snippet": "static Indirect *get_branch(struct inode *inode,\n\t\t\t    int depth,\n\t\t\t    int offsets[],\n\t\t\t    Indirect chain[],\n\t\t\t    int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\tadd_chain(chain, NULL, SYSV_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tint block = block_to_cpu(SYSV_SB(sb), p->key);\n\t\tbh = sb_bread(sb, block);\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (sysv_zone_t*)bh->b_data + *++offsets);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_chain",
          "args": [
            "++p",
            "bh",
            "(sysv_zone_t*)bh->b_data + *++offsets"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "add_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "66-70",
          "snippet": "static inline void add_chain(Indirect *p, struct buffer_head *bh, sysv_zone_t *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline void add_chain(Indirect *p, struct buffer_head *bh, sysv_zone_t *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_chain",
          "args": [
            "chain",
            "p"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "verify_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "72-77",
          "snippet": "static inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_to_cpu",
          "args": [
            "SYSV_SB(sb)",
            "p->key"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "block_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
          "lines": "53-56",
          "snippet": "static inline int block_to_cpu(struct sysv_sb_info *sbi, sysv_zone_t nr)\n{\n\treturn sbi->s_block_base + fs32_to_cpu(sbi, nr);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/string.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline int block_to_cpu(struct sysv_sb_info *sbi, sysv_zone_t nr)\n{\n\treturn sbi->s_block_base + fs32_to_cpu(sbi, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSV_SB",
          "args": [
            "sb"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "SYSV_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "79-82",
          "snippet": "static inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSV_I",
          "args": [
            "inode"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "SYSV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "74-77",
          "snippet": "static inline struct sysv_inode_info *SYSV_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct sysv_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct sysv_inode_info *SYSV_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct sysv_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic Indirect *get_branch(struct inode *inode,\n\t\t\t    int depth,\n\t\t\t    int offsets[],\n\t\t\t    Indirect chain[],\n\t\t\t    int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\tadd_chain(chain, NULL, SYSV_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tint block = block_to_cpu(SYSV_SB(sb), p->key);\n\t\tbh = sb_bread(sb, block);\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (sysv_zone_t*)bh->b_data + *++offsets);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}"
  },
  {
    "function_name": "block_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "79-82",
    "snippet": "static inline sysv_zone_t *block_end(struct buffer_head *bh)\n{\n\treturn (sysv_zone_t*)((char*)bh->b_data + bh->b_size);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline sysv_zone_t *block_end(struct buffer_head *bh)\n{\n\treturn (sysv_zone_t*)((char*)bh->b_data + bh->b_size);\n}"
  },
  {
    "function_name": "verify_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "72-77",
    "snippet": "static inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}"
  },
  {
    "function_name": "add_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "66-70",
    "snippet": "static inline void add_chain(Indirect *p, struct buffer_head *bh, sysv_zone_t *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline void add_chain(Indirect *p, struct buffer_head *bh, sysv_zone_t *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}"
  },
  {
    "function_name": "block_to_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "53-56",
    "snippet": "static inline int block_to_cpu(struct sysv_sb_info *sbi, sysv_zone_t nr)\n{\n\treturn sbi->s_block_base + fs32_to_cpu(sbi, nr);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "nr"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "191-199",
          "snippet": "static inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline int block_to_cpu(struct sysv_sb_info *sbi, sysv_zone_t nr)\n{\n\treturn sbi->s_block_base + fs32_to_cpu(sbi, nr);\n}"
  },
  {
    "function_name": "block_to_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "22-51",
    "snippet": "static int block_to_path(struct inode *inode, long block, int offsets[DEPTH])\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tint ptrs_bits = sbi->s_ind_per_block_bits;\n\tunsigned long\tindirect_blocks = sbi->s_ind_per_block,\n\t\t\tdouble_blocks = sbi->s_ind_per_block_2;\n\tint n = 0;\n\n\tif (block < 0) {\n\t\tprintk(\"sysv_block_map: block < 0\\n\");\n\t} else if (block < DIRECT) {\n\t\toffsets[n++] = block;\n\t} else if ( (block -= DIRECT) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT;\n\t\toffsets[n++] = block;\n\t} else if ((block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = DIRECT+1;\n\t\toffsets[n++] = block >> ptrs_bits;\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else if (((block -= double_blocks) >> (ptrs_bits * 2)) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT+2;\n\t\toffsets[n++] = block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (block >> ptrs_bits) & (indirect_blocks - 1);\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else {\n\t\t/* nothing */;\n\t}\n\treturn n;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"sysv_block_map: block < 0\\n\""
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSV_SB",
          "args": [
            "sb"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "SYSV_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "79-82",
          "snippet": "static inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic int block_to_path(struct inode *inode, long block, int offsets[DEPTH])\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tint ptrs_bits = sbi->s_ind_per_block_bits;\n\tunsigned long\tindirect_blocks = sbi->s_ind_per_block,\n\t\t\tdouble_blocks = sbi->s_ind_per_block_2;\n\tint n = 0;\n\n\tif (block < 0) {\n\t\tprintk(\"sysv_block_map: block < 0\\n\");\n\t} else if (block < DIRECT) {\n\t\toffsets[n++] = block;\n\t} else if ( (block -= DIRECT) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT;\n\t\toffsets[n++] = block;\n\t} else if ((block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = DIRECT+1;\n\t\toffsets[n++] = block >> ptrs_bits;\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else if (((block -= double_blocks) >> (ptrs_bits * 2)) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT+2;\n\t\toffsets[n++] = block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (block >> ptrs_bits) & (indirect_blocks - 1);\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else {\n\t\t/* nothing */;\n\t}\n\treturn n;\n}"
  },
  {
    "function_name": "dirty_indirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/itree.c",
    "lines": "15-20",
    "snippet": "static inline void dirty_indirect(struct buffer_head *bh, struct inode *inode)\n{\n\tmark_buffer_dirty_inode(bh, inode);\n\tif (IS_SYNC(inode))\n\t\tsync_dirty_buffer(bh);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/string.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "inode"
          ],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n\nstatic inline void dirty_indirect(struct buffer_head *bh, struct inode *inode)\n{\n\tmark_buffer_dirty_inode(bh, inode);\n\tif (IS_SYNC(inode))\n\t\tsync_dirty_buffer(bh);\n}"
  }
]