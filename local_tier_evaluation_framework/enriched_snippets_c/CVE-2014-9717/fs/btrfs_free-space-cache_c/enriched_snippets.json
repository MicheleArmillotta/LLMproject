[
  {
    "function_name": "test_check_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "3439-3517",
    "snippet": "int test_check_exists(struct btrfs_block_group_cache *cache,\n\t\t      u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info)\n\t\t\tgoto out;\n\t}\n\nhave_info:\n\tif (info->bitmap) {\n\t\tu64 bit_off, bit_bytes;\n\t\tstruct rb_node *n;\n\t\tstruct btrfs_free_space *tmp;\n\n\t\tbit_off = offset;\n\t\tbit_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, info, &bit_off, &bit_bytes);\n\t\tif (!ret) {\n\t\t\tif (bit_off == offset) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (bit_off > offset &&\n\t\t\t\t   offset + bytes > bit_off) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tn = rb_prev(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (tmp->offset + tmp->bytes < offset)\n\t\t\t\tbreak;\n\t\t\tif (offset + bytes < tmp->offset) {\n\t\t\t\tn = rb_prev(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tn = rb_next(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (offset + bytes < tmp->offset)\n\t\t\t\tbreak;\n\t\t\tif (tmp->offset + tmp->bytes < offset) {\n\t\t\t\tn = rb_next(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (info->offset == offset) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (offset > info->offset && offset < info->offset + info->bytes)\n\t\tret = 1;\nout:\n\tspin_unlock(&ctl->tree_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 3515
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&info->offset_index"
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&info->offset_index"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&info->offset_index"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&info->offset_index"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_bitmap",
          "args": [
            "ctl",
            "info",
            "&bit_off",
            "&bit_bytes"
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "search_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1608-1643",
          "snippet": "static int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_search_offset",
          "args": [
            "ctl",
            "offset_to_bitmap(ctl, offset)",
            "1",
            "0"
          ],
          "line": 3449
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1370-1484",
          "snippet": "static struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_bitmap",
          "args": [
            "ctl",
            "offset"
          ],
          "line": 3449
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1297-1310",
          "snippet": "static inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 3446
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint test_check_exists(struct btrfs_block_group_cache *cache,\n\t\t      u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info)\n\t\t\tgoto out;\n\t}\n\nhave_info:\n\tif (info->bitmap) {\n\t\tu64 bit_off, bit_bytes;\n\t\tstruct rb_node *n;\n\t\tstruct btrfs_free_space *tmp;\n\n\t\tbit_off = offset;\n\t\tbit_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, info, &bit_off, &bit_bytes);\n\t\tif (!ret) {\n\t\t\tif (bit_off == offset) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (bit_off > offset &&\n\t\t\t\t   offset + bytes > bit_off) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tn = rb_prev(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (tmp->offset + tmp->bytes < offset)\n\t\t\t\tbreak;\n\t\t\tif (offset + bytes < tmp->offset) {\n\t\t\t\tn = rb_prev(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tn = rb_next(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (offset + bytes < tmp->offset)\n\t\t\t\tbreak;\n\t\t\tif (tmp->offset + tmp->bytes < offset) {\n\t\t\t\tn = rb_next(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (info->offset == offset) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (offset > info->offset && offset < info->offset + info->bytes)\n\t\tret = 1;\nout:\n\tspin_unlock(&ctl->tree_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "test_add_free_space_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "3373-3432",
    "snippet": "int test_add_free_space_entry(struct btrfs_block_group_cache *cache,\n\t\t\t      u64 offset, u64 bytes, bool bitmap)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info = NULL, *bitmap_info;\n\tvoid *map = NULL;\n\tu64 bytes_added;\n\tint ret;\n\nagain:\n\tif (!info) {\n\t\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!bitmap) {\n\t\tspin_lock(&ctl->tree_lock);\n\t\tinfo->offset = offset;\n\t\tinfo->bytes = bytes;\n\t\tret = link_free_space(ctl, info);\n\t\tspin_unlock(&ctl->tree_lock);\n\t\tif (ret)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\treturn ret;\n\t}\n\n\tif (!map) {\n\t\tmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\tif (!map) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&ctl->tree_lock);\n\tbitmap_info = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t 1, 0);\n\tif (!bitmap_info) {\n\t\tinfo->bitmap = map;\n\t\tmap = NULL;\n\t\tadd_new_bitmap(ctl, info, offset);\n\t\tbitmap_info = info;\n\t\tinfo = NULL;\n\t}\n\n\tbytes_added = add_bytes_to_bitmap(ctl, bitmap_info, offset, bytes);\n\tbytes -= bytes_added;\n\toffset += bytes_added;\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (bytes)\n\t\tgoto again;\n\n\tif (info)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\tif (map)\n\t\tkfree(map);\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "map"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "info"
          ],
          "line": 3428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 3422
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_bytes_to_bitmap",
          "args": [
            "ctl",
            "bitmap_info",
            "offset",
            "bytes"
          ],
          "line": 3419
        },
        "resolved": true,
        "details": {
          "function_name": "add_bytes_to_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1810-1825",
          "snippet": "static u64 add_bytes_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t       struct btrfs_free_space *info, u64 offset,\n\t\t\t       u64 bytes)\n{\n\tu64 bytes_to_set = 0;\n\tu64 end;\n\n\tend = info->offset + (u64)(BITS_PER_BITMAP * ctl->unit);\n\n\tbytes_to_set = min(end - offset, bytes);\n\n\tbitmap_set_bits(ctl, info, offset, bytes_to_set);\n\n\treturn bytes_to_set;\n\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic u64 add_bytes_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t       struct btrfs_free_space *info, u64 offset,\n\t\t\t       u64 bytes)\n{\n\tu64 bytes_to_set = 0;\n\tu64 end;\n\n\tend = info->offset + (u64)(BITS_PER_BITMAP * ctl->unit);\n\n\tbytes_to_set = min(end - offset, bytes);\n\n\tbitmap_set_bits(ctl, info, offset, bytes_to_set);\n\n\treturn bytes_to_set;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_new_bitmap",
          "args": [
            "ctl",
            "info",
            "offset"
          ],
          "line": 3414
        },
        "resolved": true,
        "details": {
          "function_name": "add_new_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1712-1722",
          "snippet": "static void add_new_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info, u64 offset)\n{\n\tinfo->offset = offset_to_bitmap(ctl, offset);\n\tinfo->bytes = 0;\n\tINIT_LIST_HEAD(&info->list);\n\tlink_free_space(ctl, info);\n\tctl->total_bitmaps++;\n\n\tctl->op->recalc_thresholds(ctl);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void add_new_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info, u64 offset)\n{\n\tinfo->offset = offset_to_bitmap(ctl, offset);\n\tinfo->bytes = 0;\n\tINIT_LIST_HEAD(&info->list);\n\tlink_free_space(ctl, info);\n\tctl->total_bitmaps++;\n\n\tctl->op->recalc_thresholds(ctl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_search_offset",
          "args": [
            "ctl",
            "offset_to_bitmap(ctl, offset)",
            "1",
            "0"
          ],
          "line": 3409
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1370-1484",
          "snippet": "static struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_bitmap",
          "args": [
            "ctl",
            "offset"
          ],
          "line": 3409
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1297-1310",
          "snippet": "static inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 3408
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "info"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "PAGE_CACHE_SIZE",
            "GFP_NOFS"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "info"
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_free_space",
          "args": [
            "ctl",
            "info"
          ],
          "line": 3393
        },
        "resolved": true,
        "details": {
          "function_name": "link_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1501-1515",
          "snippet": "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "btrfs_free_space_cachep",
            "GFP_NOFS"
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint test_add_free_space_entry(struct btrfs_block_group_cache *cache,\n\t\t\t      u64 offset, u64 bytes, bool bitmap)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info = NULL, *bitmap_info;\n\tvoid *map = NULL;\n\tu64 bytes_added;\n\tint ret;\n\nagain:\n\tif (!info) {\n\t\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!bitmap) {\n\t\tspin_lock(&ctl->tree_lock);\n\t\tinfo->offset = offset;\n\t\tinfo->bytes = bytes;\n\t\tret = link_free_space(ctl, info);\n\t\tspin_unlock(&ctl->tree_lock);\n\t\tif (ret)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\treturn ret;\n\t}\n\n\tif (!map) {\n\t\tmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\tif (!map) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&ctl->tree_lock);\n\tbitmap_info = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t 1, 0);\n\tif (!bitmap_info) {\n\t\tinfo->bitmap = map;\n\t\tmap = NULL;\n\t\tadd_new_bitmap(ctl, info, offset);\n\t\tbitmap_info = info;\n\t\tinfo = NULL;\n\t}\n\n\tbytes_added = add_bytes_to_bitmap(ctl, bitmap_info, offset, bytes);\n\tbytes -= bytes_added;\n\toffset += bytes_added;\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (bytes)\n\t\tgoto again;\n\n\tif (info)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\tif (map)\n\t\tkfree(map);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_write_out_ino_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "3342-3364",
    "snippet": "int btrfs_write_out_ino_cache(struct btrfs_root *root,\n\t\t\t      struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      struct inode *inode)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tint ret;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\tret = __btrfs_write_out_cache(root, inode, ctl, NULL, trans, path, 0);\n\tif (ret) {\n\t\tbtrfs_delalloc_release_metadata(inode, inode->i_size);\n#ifdef DEBUG\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"failed to write free ino cache for root %llu\",\n\t\t\troot->root_key.objectid);\n#endif\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"failed to write free ino cache for root %llu\"",
            "root->root_key.objectid"
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delalloc_release_metadata",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 3355
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delalloc_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5272-5300",
          "snippet": "void btrfs_delalloc_release_metadata(struct inode *inode, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 to_free = 0;\n\tunsigned dropped;\n\n\tnum_bytes = ALIGN(num_bytes, root->sectorsize);\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tdropped = drop_outstanding_extent(inode, num_bytes);\n\n\tif (num_bytes)\n\t\tto_free = calc_csum_metadata_size(inode, num_bytes, 0);\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\tif (dropped > 0)\n\t\tto_free += btrfs_calc_trans_metadata_size(root, dropped);\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn;\n\n\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t      btrfs_ino(inode), to_free, 0);\n\tif (root->fs_info->quota_enabled) {\n\t\tbtrfs_qgroup_free(root, num_bytes +\n\t\t\t\t\tdropped * root->nodesize);\n\t}\n\n\tbtrfs_block_rsv_release(root, &root->fs_info->delalloc_block_rsv,\n\t\t\t\tto_free);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_update_reserved_bytes(struct btrfs_block_group_cache *cache,\n\t\t\t\t       u64 num_bytes, int reserve,\n\t\t\t\t       int delalloc);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int btrfs_update_reserved_bytes(struct btrfs_block_group_cache *cache,\n\t\t\t\t       u64 num_bytes, int reserve,\n\t\t\t\t       int delalloc);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_delalloc_release_metadata(struct inode *inode, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 to_free = 0;\n\tunsigned dropped;\n\n\tnum_bytes = ALIGN(num_bytes, root->sectorsize);\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tdropped = drop_outstanding_extent(inode, num_bytes);\n\n\tif (num_bytes)\n\t\tto_free = calc_csum_metadata_size(inode, num_bytes, 0);\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\tif (dropped > 0)\n\t\tto_free += btrfs_calc_trans_metadata_size(root, dropped);\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn;\n\n\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t      btrfs_ino(inode), to_free, 0);\n\tif (root->fs_info->quota_enabled) {\n\t\tbtrfs_qgroup_free(root, num_bytes +\n\t\t\t\t\tdropped * root->nodesize);\n\t}\n\n\tbtrfs_block_rsv_release(root, &root->fs_info->delalloc_block_rsv,\n\t\t\t\tto_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_write_out_cache",
          "args": [
            "root",
            "inode",
            "ctl",
            "NULL",
            "trans",
            "path",
            "0"
          ],
          "line": 3353
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_write_out_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1117-1234",
          "snippet": "static int __btrfs_write_out_cache(struct btrfs_root *root, struct inode *inode,\n\t\t\t\t   struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   struct btrfs_block_group_cache *block_group,\n\t\t\t\t   struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path, u64 offset)\n{\n\tstruct extent_state *cached_state = NULL;\n\tstruct io_ctl io_ctl;\n\tLIST_HEAD(bitmap_list);\n\tint entries = 0;\n\tint bitmaps = 0;\n\tint ret;\n\n\tif (!i_size_read(inode))\n\t\treturn -1;\n\n\tret = io_ctl_init(&io_ctl, inode, root, 1);\n\tif (ret)\n\t\treturn -1;\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA)) {\n\t\tdown_write(&block_group->data_rwsem);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->delalloc_bytes) {\n\t\t\tblock_group->disk_cache_state = BTRFS_DC_WRITTEN;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tup_write(&block_group->data_rwsem);\n\t\t\tBTRFS_I(inode)->generation = 0;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\t/* Lock all pages first so we can lock the extent safely. */\n\tio_ctl_prepare_pages(&io_ctl, inode, 0);\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree, 0, i_size_read(inode) - 1,\n\t\t\t 0, &cached_state);\n\n\tio_ctl_set_generation(&io_ctl, trans->transid);\n\n\tmutex_lock(&ctl->cache_writeout_mutex);\n\t/* Write out the extent entries in the free space cache */\n\tret = write_cache_extent_entries(&io_ctl, ctl,\n\t\t\t\t\t block_group, &entries, &bitmaps,\n\t\t\t\t\t &bitmap_list);\n\tif (ret) {\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\tgoto out_nospc;\n\t}\n\n\t/*\n\t * Some spaces that are freed in the current transaction are pinned,\n\t * they will be added into free space cache after the transaction is\n\t * committed, we shouldn't lose them.\n\t */\n\tret = write_pinned_extent_entries(root, block_group, &io_ctl, &entries);\n\tif (ret) {\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\tgoto out_nospc;\n\t}\n\n\t/*\n\t * At last, we write out all the bitmaps and keep cache_writeout_mutex\n\t * locked while doing it because a concurrent trim can be manipulating\n\t * or freeing the bitmap.\n\t */\n\tret = write_bitmap_entries(&io_ctl, &bitmap_list);\n\tmutex_unlock(&ctl->cache_writeout_mutex);\n\tif (ret)\n\t\tgoto out_nospc;\n\n\t/* Zero out the rest of the pages just to make sure */\n\tio_ctl_zero_remaining_pages(&io_ctl);\n\n\t/* Everything is written out, now we dirty the pages in the file. */\n\tret = btrfs_dirty_pages(root, inode, io_ctl.pages, io_ctl.num_pages,\n\t\t\t\t0, i_size_read(inode), &cached_state);\n\tif (ret)\n\t\tgoto out_nospc;\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\tup_write(&block_group->data_rwsem);\n\t/*\n\t * Release the pages and unlock the extent, we will flush\n\t * them out later\n\t */\n\tio_ctl_drop_pages(&io_ctl);\n\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t     i_size_read(inode) - 1, &cached_state, GFP_NOFS);\n\n\t/* Flush the dirty pages in the cache file. */\n\tret = flush_dirty_cache(inode);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Update the cache item to tell everyone this cache file is valid. */\n\tret = update_cache_item(trans, root, inode, path, offset,\n\t\t\t\tentries, bitmaps);\nout:\n\tio_ctl_free(&io_ctl);\n\tif (ret) {\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t\tBTRFS_I(inode)->generation = 0;\n\t}\n\tbtrfs_update_inode(trans, root, inode);\n\treturn ret;\n\nout_nospc:\n\tcleanup_write_cache_enospc(inode, &io_ctl, &cached_state, &bitmap_list);\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\tup_write(&block_group->data_rwsem);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int __btrfs_write_out_cache(struct btrfs_root *root, struct inode *inode,\n\t\t\t\t   struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   struct btrfs_block_group_cache *block_group,\n\t\t\t\t   struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path, u64 offset)\n{\n\tstruct extent_state *cached_state = NULL;\n\tstruct io_ctl io_ctl;\n\tLIST_HEAD(bitmap_list);\n\tint entries = 0;\n\tint bitmaps = 0;\n\tint ret;\n\n\tif (!i_size_read(inode))\n\t\treturn -1;\n\n\tret = io_ctl_init(&io_ctl, inode, root, 1);\n\tif (ret)\n\t\treturn -1;\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA)) {\n\t\tdown_write(&block_group->data_rwsem);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->delalloc_bytes) {\n\t\t\tblock_group->disk_cache_state = BTRFS_DC_WRITTEN;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tup_write(&block_group->data_rwsem);\n\t\t\tBTRFS_I(inode)->generation = 0;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\t/* Lock all pages first so we can lock the extent safely. */\n\tio_ctl_prepare_pages(&io_ctl, inode, 0);\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree, 0, i_size_read(inode) - 1,\n\t\t\t 0, &cached_state);\n\n\tio_ctl_set_generation(&io_ctl, trans->transid);\n\n\tmutex_lock(&ctl->cache_writeout_mutex);\n\t/* Write out the extent entries in the free space cache */\n\tret = write_cache_extent_entries(&io_ctl, ctl,\n\t\t\t\t\t block_group, &entries, &bitmaps,\n\t\t\t\t\t &bitmap_list);\n\tif (ret) {\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\tgoto out_nospc;\n\t}\n\n\t/*\n\t * Some spaces that are freed in the current transaction are pinned,\n\t * they will be added into free space cache after the transaction is\n\t * committed, we shouldn't lose them.\n\t */\n\tret = write_pinned_extent_entries(root, block_group, &io_ctl, &entries);\n\tif (ret) {\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\tgoto out_nospc;\n\t}\n\n\t/*\n\t * At last, we write out all the bitmaps and keep cache_writeout_mutex\n\t * locked while doing it because a concurrent trim can be manipulating\n\t * or freeing the bitmap.\n\t */\n\tret = write_bitmap_entries(&io_ctl, &bitmap_list);\n\tmutex_unlock(&ctl->cache_writeout_mutex);\n\tif (ret)\n\t\tgoto out_nospc;\n\n\t/* Zero out the rest of the pages just to make sure */\n\tio_ctl_zero_remaining_pages(&io_ctl);\n\n\t/* Everything is written out, now we dirty the pages in the file. */\n\tret = btrfs_dirty_pages(root, inode, io_ctl.pages, io_ctl.num_pages,\n\t\t\t\t0, i_size_read(inode), &cached_state);\n\tif (ret)\n\t\tgoto out_nospc;\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\tup_write(&block_group->data_rwsem);\n\t/*\n\t * Release the pages and unlock the extent, we will flush\n\t * them out later\n\t */\n\tio_ctl_drop_pages(&io_ctl);\n\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t     i_size_read(inode) - 1, &cached_state, GFP_NOFS);\n\n\t/* Flush the dirty pages in the cache file. */\n\tret = flush_dirty_cache(inode);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Update the cache item to tell everyone this cache file is valid. */\n\tret = update_cache_item(trans, root, inode, path, offset,\n\t\t\t\tentries, bitmaps);\nout:\n\tio_ctl_free(&io_ctl);\n\tif (ret) {\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t\tBTRFS_I(inode)->generation = 0;\n\t}\n\tbtrfs_update_inode(trans, root, inode);\n\treturn ret;\n\nout_nospc:\n\tcleanup_write_cache_enospc(inode, &io_ctl, &cached_state, &bitmap_list);\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\tup_write(&block_group->data_rwsem);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "INODE_MAP_CACHE"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint btrfs_write_out_ino_cache(struct btrfs_root *root,\n\t\t\t      struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      struct inode *inode)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tint ret;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\tret = __btrfs_write_out_cache(root, inode, ctl, NULL, trans, path, 0);\n\tif (ret) {\n\t\tbtrfs_delalloc_release_metadata(inode, inode->i_size);\n#ifdef DEBUG\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"failed to write free ino cache for root %llu\",\n\t\t\troot->root_key.objectid);\n#endif\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "load_free_ino_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "3300-3340",
    "snippet": "int load_free_ino_cache(struct btrfs_fs_info *fs_info, struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_path *path;\n\tstruct inode *inode;\n\tint ret = 0;\n\tu64 root_gen = btrfs_root_generation(&root->root_item);\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\t/*\n\t * If we're unmounting then just return, since this does a search on the\n\t * normal root and not the commit root and we could deadlock.\n\t */\n\tif (btrfs_fs_closing(fs_info))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn 0;\n\n\tinode = lookup_free_ino_inode(root, path);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\n\tif (root_gen != BTRFS_I(inode)->generation)\n\t\tgoto out_put;\n\n\tret = __load_free_space_cache(root, inode, ctl, path, 0);\n\n\tif (ret < 0)\n\t\tbtrfs_err(fs_info,\n\t\t\t\"failed to load free ino cache for root %llu\",\n\t\t\troot->root_key.objectid);\nout_put:\n\tiput(inode);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 3338
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 3336
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"failed to load free ino cache for root %llu\"",
            "root->root_key.objectid"
          ],
          "line": 3332
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__load_free_space_cache",
          "args": [
            "root",
            "inode",
            "ctl",
            "path",
            "0"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "__load_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "645-801",
          "snippet": "static int __load_free_space_cache(struct btrfs_root *root, struct inode *inode,\n\t\t\t\t   struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   struct btrfs_path *path, u64 offset)\n{\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tstruct io_ctl io_ctl;\n\tstruct btrfs_key key;\n\tstruct btrfs_free_space *e, *n;\n\tLIST_HEAD(bitmaps);\n\tu64 num_entries;\n\tu64 num_bitmaps;\n\tu64 generation;\n\tu8 type;\n\tint ret = 0;\n\n\t/* Nothing in the space cache, goodbye */\n\tif (!i_size_read(inode))\n\t\treturn 0;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn 0;\n\telse if (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn 0;\n\t}\n\n\tret = -1;\n\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tnum_entries = btrfs_free_space_entries(leaf, header);\n\tnum_bitmaps = btrfs_free_space_bitmaps(leaf, header);\n\tgeneration = btrfs_free_space_generation(leaf, header);\n\tbtrfs_release_path(path);\n\n\tif (!BTRFS_I(inode)->generation) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t   \"The free space cache file (%llu) is invalid. skip it\\n\",\n\t\t\t   offset);\n\t\treturn 0;\n\t}\n\n\tif (BTRFS_I(inode)->generation != generation) {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"free space inode generation (%llu) \"\n\t\t\t\"did not match free space cache generation (%llu)\",\n\t\t\tBTRFS_I(inode)->generation, generation);\n\t\treturn 0;\n\t}\n\n\tif (!num_entries)\n\t\treturn 0;\n\n\tret = io_ctl_init(&io_ctl, inode, root, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = readahead_cache(inode);\n\tif (ret)\n\t\tgoto out;\n\n\tret = io_ctl_prepare_pages(&io_ctl, inode, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tret = io_ctl_check_crc(&io_ctl, 0);\n\tif (ret)\n\t\tgoto free_cache;\n\n\tret = io_ctl_check_generation(&io_ctl, generation);\n\tif (ret)\n\t\tgoto free_cache;\n\n\twhile (num_entries) {\n\t\te = kmem_cache_zalloc(btrfs_free_space_cachep,\n\t\t\t\t      GFP_NOFS);\n\t\tif (!e)\n\t\t\tgoto free_cache;\n\n\t\tret = io_ctl_read_entry(&io_ctl, e, &type);\n\t\tif (ret) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tgoto free_cache;\n\t\t}\n\n\t\tif (!e->bytes) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tgoto free_cache;\n\t\t}\n\n\t\tif (type == BTRFS_FREE_SPACE_EXTENT) {\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\tret = link_free_space(ctl, e);\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\t\"Duplicate entries in free space cache, dumping\");\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(num_bitmaps);\n\t\t\tnum_bitmaps--;\n\t\t\te->bitmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\t\tif (!e->bitmap) {\n\t\t\t\tkmem_cache_free(\n\t\t\t\t\tbtrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\tret = link_free_space(ctl, e);\n\t\t\tctl->total_bitmaps++;\n\t\t\tctl->op->recalc_thresholds(ctl);\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\t\"Duplicate entries in free space cache, dumping\");\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t\tlist_add_tail(&e->list, &bitmaps);\n\t\t}\n\n\t\tnum_entries--;\n\t}\n\n\tio_ctl_unmap_page(&io_ctl);\n\n\t/*\n\t * We add the bitmaps at the end of the entries in order that\n\t * the bitmap entries are added to the cache.\n\t */\n\tlist_for_each_entry_safe(e, n, &bitmaps, list) {\n\t\tlist_del_init(&e->list);\n\t\tret = io_ctl_read_bitmap(&io_ctl, e);\n\t\tif (ret)\n\t\t\tgoto free_cache;\n\t}\n\n\tio_ctl_drop_pages(&io_ctl);\n\tmerge_space_tree(ctl);\n\tret = 1;\nout:\n\tio_ctl_free(&io_ctl);\n\treturn ret;\nfree_cache:\n\tio_ctl_drop_pages(&io_ctl);\n\t__btrfs_remove_free_space_cache(ctl);\n\tgoto out;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int __load_free_space_cache(struct btrfs_root *root, struct inode *inode,\n\t\t\t\t   struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   struct btrfs_path *path, u64 offset)\n{\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tstruct io_ctl io_ctl;\n\tstruct btrfs_key key;\n\tstruct btrfs_free_space *e, *n;\n\tLIST_HEAD(bitmaps);\n\tu64 num_entries;\n\tu64 num_bitmaps;\n\tu64 generation;\n\tu8 type;\n\tint ret = 0;\n\n\t/* Nothing in the space cache, goodbye */\n\tif (!i_size_read(inode))\n\t\treturn 0;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn 0;\n\telse if (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn 0;\n\t}\n\n\tret = -1;\n\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tnum_entries = btrfs_free_space_entries(leaf, header);\n\tnum_bitmaps = btrfs_free_space_bitmaps(leaf, header);\n\tgeneration = btrfs_free_space_generation(leaf, header);\n\tbtrfs_release_path(path);\n\n\tif (!BTRFS_I(inode)->generation) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t   \"The free space cache file (%llu) is invalid. skip it\\n\",\n\t\t\t   offset);\n\t\treturn 0;\n\t}\n\n\tif (BTRFS_I(inode)->generation != generation) {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"free space inode generation (%llu) \"\n\t\t\t\"did not match free space cache generation (%llu)\",\n\t\t\tBTRFS_I(inode)->generation, generation);\n\t\treturn 0;\n\t}\n\n\tif (!num_entries)\n\t\treturn 0;\n\n\tret = io_ctl_init(&io_ctl, inode, root, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = readahead_cache(inode);\n\tif (ret)\n\t\tgoto out;\n\n\tret = io_ctl_prepare_pages(&io_ctl, inode, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tret = io_ctl_check_crc(&io_ctl, 0);\n\tif (ret)\n\t\tgoto free_cache;\n\n\tret = io_ctl_check_generation(&io_ctl, generation);\n\tif (ret)\n\t\tgoto free_cache;\n\n\twhile (num_entries) {\n\t\te = kmem_cache_zalloc(btrfs_free_space_cachep,\n\t\t\t\t      GFP_NOFS);\n\t\tif (!e)\n\t\t\tgoto free_cache;\n\n\t\tret = io_ctl_read_entry(&io_ctl, e, &type);\n\t\tif (ret) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tgoto free_cache;\n\t\t}\n\n\t\tif (!e->bytes) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tgoto free_cache;\n\t\t}\n\n\t\tif (type == BTRFS_FREE_SPACE_EXTENT) {\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\tret = link_free_space(ctl, e);\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\t\"Duplicate entries in free space cache, dumping\");\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(num_bitmaps);\n\t\t\tnum_bitmaps--;\n\t\t\te->bitmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\t\tif (!e->bitmap) {\n\t\t\t\tkmem_cache_free(\n\t\t\t\t\tbtrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\tret = link_free_space(ctl, e);\n\t\t\tctl->total_bitmaps++;\n\t\t\tctl->op->recalc_thresholds(ctl);\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\t\"Duplicate entries in free space cache, dumping\");\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t\tlist_add_tail(&e->list, &bitmaps);\n\t\t}\n\n\t\tnum_entries--;\n\t}\n\n\tio_ctl_unmap_page(&io_ctl);\n\n\t/*\n\t * We add the bitmaps at the end of the entries in order that\n\t * the bitmap entries are added to the cache.\n\t */\n\tlist_for_each_entry_safe(e, n, &bitmaps, list) {\n\t\tlist_del_init(&e->list);\n\t\tret = io_ctl_read_bitmap(&io_ctl, e);\n\t\tif (ret)\n\t\t\tgoto free_cache;\n\t}\n\n\tio_ctl_drop_pages(&io_ctl);\n\tmerge_space_tree(ctl);\n\tret = 1;\nout:\n\tio_ctl_free(&io_ctl);\n\treturn ret;\nfree_cache:\n\tio_ctl_drop_pages(&io_ctl);\n\t__btrfs_remove_free_space_cache(ctl);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3326
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_free_ino_inode",
          "args": [
            "root",
            "path"
          ],
          "line": 3322
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_free_ino_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3268-3290",
          "snippet": "struct inode *lookup_free_ino_inode(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_inode)\n\t\tinode = igrab(root->ino_cache_inode);\n\tspin_unlock(&root->ino_cache_lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path, 0);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (!btrfs_fs_closing(root->fs_info))\n\t\troot->ino_cache_inode = igrab(inode);\n\tspin_unlock(&root->ino_cache_lock);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstruct inode *lookup_free_ino_inode(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_inode)\n\t\tinode = igrab(root->ino_cache_inode);\n\tspin_unlock(&root->ino_cache_lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path, 0);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (!btrfs_fs_closing(root->fs_info))\n\t\troot->ino_cache_inode = igrab(inode);\n\tspin_unlock(&root->ino_cache_lock);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 3318
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_fs_closing",
          "args": [
            "fs_info"
          ],
          "line": 3315
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_fs_closing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3612-3619",
          "snippet": "static inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "INODE_MAP_CACHE"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_generation",
          "args": [
            "&root->root_item"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint load_free_ino_cache(struct btrfs_fs_info *fs_info, struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_path *path;\n\tstruct inode *inode;\n\tint ret = 0;\n\tu64 root_gen = btrfs_root_generation(&root->root_item);\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\t/*\n\t * If we're unmounting then just return, since this does a search on the\n\t * normal root and not the commit root and we could deadlock.\n\t */\n\tif (btrfs_fs_closing(fs_info))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn 0;\n\n\tinode = lookup_free_ino_inode(root, path);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\n\tif (root_gen != BTRFS_I(inode)->generation)\n\t\tgoto out_put;\n\n\tret = __load_free_space_cache(root, inode, ctl, path, 0);\n\n\tif (ret < 0)\n\t\tbtrfs_err(fs_info,\n\t\t\t\"failed to load free ino cache for root %llu\",\n\t\t\troot->root_key.objectid);\nout_put:\n\tiput(inode);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "create_free_ino_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "3292-3298",
    "snippet": "int create_free_ino_inode(struct btrfs_root *root,\n\t\t\t  struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_path *path)\n{\n\treturn __create_free_space_inode(root, trans, path,\n\t\t\t\t\t BTRFS_FREE_INO_OBJECTID, 0);\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__create_free_space_inode",
          "args": [
            "root",
            "trans",
            "path",
            "BTRFS_FREE_INO_OBJECTID",
            "0"
          ],
          "line": 3296
        },
        "resolved": true,
        "details": {
          "function_name": "__create_free_space_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "130-189",
          "snippet": "static int __create_free_space_inode(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     u64 ino, u64 offset)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_free_space_header *header;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tu64 flags = BTRFS_INODE_NOCOMPRESS | BTRFS_INODE_PREALLOC;\n\tint ret;\n\n\tret = btrfs_insert_empty_inode(trans, root, path, ino);\n\tif (ret)\n\t\treturn ret;\n\n\t/* We inline crc's for the free disk space cache */\n\tif (ino != BTRFS_FREE_INO_OBJECTID)\n\t\tflags |= BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tleaf = path->nodes[0];\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\tbtrfs_item_key(leaf, &disk_key, path->slots[0]);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)inode_item,\n\t\t\t     sizeof(*inode_item));\n\tbtrfs_set_inode_generation(leaf, inode_item, trans->transid);\n\tbtrfs_set_inode_size(leaf, inode_item, 0);\n\tbtrfs_set_inode_nbytes(leaf, inode_item, 0);\n\tbtrfs_set_inode_uid(leaf, inode_item, 0);\n\tbtrfs_set_inode_gid(leaf, inode_item, 0);\n\tbtrfs_set_inode_mode(leaf, inode_item, S_IFREG | 0600);\n\tbtrfs_set_inode_flags(leaf, inode_item, flags);\n\tbtrfs_set_inode_nlink(leaf, inode_item, 1);\n\tbtrfs_set_inode_transid(leaf, inode_item, trans->transid);\n\tbtrfs_set_inode_block_group(leaf, inode_item, offset);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(struct btrfs_free_space_header));\n\tif (ret < 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn ret;\n\t}\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)header, sizeof(*header));\n\tbtrfs_set_free_space_key(leaf, header, &disk_key);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int __create_free_space_inode(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     u64 ino, u64 offset)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_free_space_header *header;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tu64 flags = BTRFS_INODE_NOCOMPRESS | BTRFS_INODE_PREALLOC;\n\tint ret;\n\n\tret = btrfs_insert_empty_inode(trans, root, path, ino);\n\tif (ret)\n\t\treturn ret;\n\n\t/* We inline crc's for the free disk space cache */\n\tif (ino != BTRFS_FREE_INO_OBJECTID)\n\t\tflags |= BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tleaf = path->nodes[0];\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\tbtrfs_item_key(leaf, &disk_key, path->slots[0]);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)inode_item,\n\t\t\t     sizeof(*inode_item));\n\tbtrfs_set_inode_generation(leaf, inode_item, trans->transid);\n\tbtrfs_set_inode_size(leaf, inode_item, 0);\n\tbtrfs_set_inode_nbytes(leaf, inode_item, 0);\n\tbtrfs_set_inode_uid(leaf, inode_item, 0);\n\tbtrfs_set_inode_gid(leaf, inode_item, 0);\n\tbtrfs_set_inode_mode(leaf, inode_item, S_IFREG | 0600);\n\tbtrfs_set_inode_flags(leaf, inode_item, flags);\n\tbtrfs_set_inode_nlink(leaf, inode_item, 1);\n\tbtrfs_set_inode_transid(leaf, inode_item, trans->transid);\n\tbtrfs_set_inode_block_group(leaf, inode_item, offset);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(struct btrfs_free_space_header));\n\tif (ret < 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn ret;\n\t}\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)header, sizeof(*header));\n\tbtrfs_set_free_space_key(leaf, header, &disk_key);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint create_free_ino_inode(struct btrfs_root *root,\n\t\t\t  struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_path *path)\n{\n\treturn __create_free_space_inode(root, trans, path,\n\t\t\t\t\t BTRFS_FREE_INO_OBJECTID, 0);\n}"
  },
  {
    "function_name": "lookup_free_ino_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "3268-3290",
    "snippet": "struct inode *lookup_free_ino_inode(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_inode)\n\t\tinode = igrab(root->ino_cache_inode);\n\tspin_unlock(&root->ino_cache_lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path, 0);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (!btrfs_fs_closing(root->fs_info))\n\t\troot->ino_cache_inode = igrab(inode);\n\tspin_unlock(&root->ino_cache_lock);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->ino_cache_lock"
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 3286
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_fs_closing",
          "args": [
            "root->fs_info"
          ],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_fs_closing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3612-3619",
          "snippet": "static inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->ino_cache_lock"
          ],
          "line": 3284
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lookup_free_space_inode",
          "args": [
            "root",
            "path",
            "0"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_free_space_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "46-91",
          "snippet": "static struct inode *__lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t\t       u64 offset)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key location;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tstruct inode *inode = NULL;\n\tint ret;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tbtrfs_free_space_key(leaf, header, &disk_key);\n\tbtrfs_disk_key_to_cpu(&location, &disk_key);\n\tbtrfs_release_path(path);\n\n\tinode = btrfs_iget(root->fs_info->sb, &location, root, NULL);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\tmapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic struct inode *__lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t\t       u64 offset)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key location;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tstruct inode *inode = NULL;\n\tint ret;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tbtrfs_free_space_key(leaf, header, &disk_key);\n\tbtrfs_disk_key_to_cpu(&location, &disk_key);\n\tbtrfs_release_path(path);\n\n\tinode = btrfs_iget(root->fs_info->sb, &location, root, NULL);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\tmapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstruct inode *lookup_free_ino_inode(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_inode)\n\t\tinode = igrab(root->ino_cache_inode);\n\tspin_unlock(&root->ino_cache_lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path, 0);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (!btrfs_fs_closing(root->fs_info))\n\t\troot->ino_cache_inode = igrab(inode);\n\tspin_unlock(&root->ino_cache_lock);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "btrfs_find_ino_for_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "3224-3266",
    "snippet": "u64 btrfs_find_ino_for_alloc(struct btrfs_root *fs_root)\n{\n\tstruct btrfs_free_space_ctl *ctl = fs_root->free_ino_ctl;\n\tstruct btrfs_free_space *entry = NULL;\n\tu64 ino = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (RB_EMPTY_ROOT(&ctl->free_space_offset))\n\t\tgoto out;\n\n\tentry = rb_entry(rb_first(&ctl->free_space_offset),\n\t\t\t struct btrfs_free_space, offset_index);\n\n\tif (!entry->bitmap) {\n\t\tino = entry->offset;\n\n\t\tunlink_free_space(ctl, entry);\n\t\tentry->offset++;\n\t\tentry->bytes--;\n\t\tif (!entry->bytes)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\t\telse\n\t\t\tlink_free_space(ctl, entry);\n\t} else {\n\t\tu64 offset = 0;\n\t\tu64 count = 1;\n\t\tint ret;\n\n\t\tret = search_bitmap(ctl, entry, &offset, &count);\n\t\t/* Logic error; Should be empty if it can't find anything */\n\t\tASSERT(!ret);\n\n\t\tino = offset;\n\t\tbitmap_clear_bits(ctl, entry, offset, 1);\n\t\tif (entry->bytes == 0)\n\t\t\tfree_bitmap(ctl, entry);\n\t}\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\treturn ino;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_bitmap",
          "args": [
            "ctl",
            "entry"
          ],
          "line": 3260
        },
        "resolved": true,
        "details": {
          "function_name": "free_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1724-1732",
          "snippet": "static void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_clear_bits",
          "args": [
            "ctl",
            "entry",
            "offset",
            "1"
          ],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1580-1586",
          "snippet": "static void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!ret"
          ],
          "line": 3255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_bitmap",
          "args": [
            "ctl",
            "entry",
            "&offset",
            "&count"
          ],
          "line": 3253
        },
        "resolved": true,
        "details": {
          "function_name": "search_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1608-1643",
          "snippet": "static int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_free_space",
          "args": [
            "ctl",
            "entry"
          ],
          "line": 3247
        },
        "resolved": true,
        "details": {
          "function_name": "link_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1501-1515",
          "snippet": "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "entry"
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink_free_space",
          "args": [
            "ctl",
            "entry"
          ],
          "line": 3241
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1494-1499",
          "snippet": "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_first(&ctl->free_space_offset)",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ctl->free_space_offset"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&ctl->free_space_offset"
          ],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 3230
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nu64 btrfs_find_ino_for_alloc(struct btrfs_root *fs_root)\n{\n\tstruct btrfs_free_space_ctl *ctl = fs_root->free_ino_ctl;\n\tstruct btrfs_free_space *entry = NULL;\n\tu64 ino = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (RB_EMPTY_ROOT(&ctl->free_space_offset))\n\t\tgoto out;\n\n\tentry = rb_entry(rb_first(&ctl->free_space_offset),\n\t\t\t struct btrfs_free_space, offset_index);\n\n\tif (!entry->bitmap) {\n\t\tino = entry->offset;\n\n\t\tunlink_free_space(ctl, entry);\n\t\tentry->offset++;\n\t\tentry->bytes--;\n\t\tif (!entry->bytes)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\t\telse\n\t\t\tlink_free_space(ctl, entry);\n\t} else {\n\t\tu64 offset = 0;\n\t\tu64 count = 1;\n\t\tint ret;\n\n\t\tret = search_bitmap(ctl, entry, &offset, &count);\n\t\t/* Logic error; Should be empty if it can't find anything */\n\t\tASSERT(!ret);\n\n\t\tino = offset;\n\t\tbitmap_clear_bits(ctl, entry, offset, 1);\n\t\tif (entry->bytes == 0)\n\t\t\tfree_bitmap(ctl, entry);\n\t}\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\treturn ino;\n}"
  },
  {
    "function_name": "btrfs_trim_block_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "3158-3215",
    "snippet": "int btrfs_trim_block_group(struct btrfs_block_group_cache *block_group,\n\t\t\t   u64 *trimmed, u64 start, u64 end, u64 minlen)\n{\n\tint ret;\n\n\t*trimmed = 0;\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->removed) {\n\t\tspin_unlock(&block_group->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&block_group->trimming);\n\tspin_unlock(&block_group->lock);\n\n\tret = trim_no_bitmap(block_group, trimmed, start, end, minlen);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trim_bitmaps(block_group, trimmed, start, end, minlen);\nout:\n\tspin_lock(&block_group->lock);\n\tif (atomic_dec_and_test(&block_group->trimming) &&\n\t    block_group->removed) {\n\t\tstruct extent_map_tree *em_tree;\n\t\tstruct extent_map *em;\n\n\t\tspin_unlock(&block_group->lock);\n\n\t\tlock_chunks(block_group->fs_info->chunk_root);\n\t\tem_tree = &block_group->fs_info->mapping_tree.map_tree;\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, block_group->key.objectid,\n\t\t\t\t\t   1);\n\t\tBUG_ON(!em); /* logic error, can't happen */\n\t\t/*\n\t\t * remove_extent_mapping() will delete us from the pinned_chunks\n\t\t * list, which is protected by the chunk mutex.\n\t\t */\n\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\t\tunlock_chunks(block_group->fs_info->chunk_root);\n\n\t\t/* once for us and once for the tree */\n\t\tfree_extent_map(em);\n\t\tfree_extent_map(em);\n\n\t\t/*\n\t\t * We've left one free space entry and other tasks trimming\n\t\t * this block group have left 1 entry each one. Free them.\n\t\t */\n\t\t__btrfs_remove_free_space_cache(block_group->free_space_ctl);\n\t} else {\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&block_group->lock"
          ],
          "line": 3211
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_remove_free_space_cache",
          "args": [
            "block_group->free_space_ctl"
          ],
          "line": 3209
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_remove_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2413-2418",
          "snippet": "void __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nvoid __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 3203
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_chunks",
          "args": [
            "block_group->fs_info->chunk_root"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "536-539",
          "snippet": "static inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 3198
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_extent_mapping",
          "args": [
            "em_tree",
            "em"
          ],
          "line": 3197
        },
        "resolved": true,
        "details": {
          "function_name": "remove_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "430-440",
          "snippet": "int remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tint ret = 0;\n\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &em->flags));\n\trb_erase(&em->rb_node, &tree->map);\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &em->flags))\n\t\tlist_del_init(&em->list);\n\tRB_CLEAR_NODE(&em->rb_node);\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tint ret = 0;\n\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &em->flags));\n\trb_erase(&em->rb_node, &tree->map);\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &em->flags))\n\t\tlist_del_init(&em->list);\n\tRB_CLEAR_NODE(&em->rb_node);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!em"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "block_group->key.objectid",
            "1"
          ],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 3189
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&block_group->trimming"
          ],
          "line": 3180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&block_group->lock"
          ],
          "line": 3179
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trim_bitmaps",
          "args": [
            "block_group",
            "trimmed",
            "start",
            "end",
            "minlen"
          ],
          "line": 3177
        },
        "resolved": true,
        "details": {
          "function_name": "trim_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3077-3156",
          "snippet": "static int trim_bitmaps(struct btrfs_block_group_cache *block_group,\n\t\t\tu64 *total_trimmed, u64 start, u64 end, u64 minlen)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tint ret = 0;\n\tint ret2;\n\tu64 bytes;\n\tu64 offset = offset_to_bitmap(ctl, start);\n\n\twhile (offset < end) {\n\t\tbool next_bitmap = false;\n\t\tstruct btrfs_trim_range trim_entry;\n\n\t\tmutex_lock(&ctl->cache_writeout_mutex);\n\t\tspin_lock(&ctl->tree_lock);\n\n\t\tif (ctl->free_space < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = tree_search_offset(ctl, offset, 1, 0);\n\t\tif (!entry) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tnext_bitmap = true;\n\t\t\tgoto next;\n\t\t}\n\n\t\tbytes = minlen;\n\t\tret2 = search_bitmap(ctl, entry, &start, &bytes);\n\t\tif (ret2 || start >= end) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tnext_bitmap = true;\n\t\t\tgoto next;\n\t\t}\n\n\t\tbytes = min(bytes, end - start);\n\t\tif (bytes < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tgoto next;\n\t\t}\n\n\t\tbitmap_clear_bits(ctl, entry, start, bytes);\n\t\tif (entry->bytes == 0)\n\t\t\tfree_bitmap(ctl, entry);\n\n\t\tspin_unlock(&ctl->tree_lock);\n\t\ttrim_entry.start = start;\n\t\ttrim_entry.bytes = bytes;\n\t\tlist_add_tail(&trim_entry.list, &ctl->trimming_ranges);\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\t\tret = do_trimming(block_group, total_trimmed, start, bytes,\n\t\t\t\t  start, bytes, &trim_entry);\n\t\tif (ret)\n\t\t\tbreak;\nnext:\n\t\tif (next_bitmap) {\n\t\t\toffset += BITS_PER_BITMAP * ctl->unit;\n\t\t} else {\n\t\t\tstart += bytes;\n\t\t\tif (start >= offset + BITS_PER_BITMAP * ctl->unit)\n\t\t\t\toffset += BITS_PER_BITMAP * ctl->unit;\n\t\t}\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int trim_bitmaps(struct btrfs_block_group_cache *block_group,\n\t\t\tu64 *total_trimmed, u64 start, u64 end, u64 minlen)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tint ret = 0;\n\tint ret2;\n\tu64 bytes;\n\tu64 offset = offset_to_bitmap(ctl, start);\n\n\twhile (offset < end) {\n\t\tbool next_bitmap = false;\n\t\tstruct btrfs_trim_range trim_entry;\n\n\t\tmutex_lock(&ctl->cache_writeout_mutex);\n\t\tspin_lock(&ctl->tree_lock);\n\n\t\tif (ctl->free_space < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = tree_search_offset(ctl, offset, 1, 0);\n\t\tif (!entry) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tnext_bitmap = true;\n\t\t\tgoto next;\n\t\t}\n\n\t\tbytes = minlen;\n\t\tret2 = search_bitmap(ctl, entry, &start, &bytes);\n\t\tif (ret2 || start >= end) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tnext_bitmap = true;\n\t\t\tgoto next;\n\t\t}\n\n\t\tbytes = min(bytes, end - start);\n\t\tif (bytes < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tgoto next;\n\t\t}\n\n\t\tbitmap_clear_bits(ctl, entry, start, bytes);\n\t\tif (entry->bytes == 0)\n\t\t\tfree_bitmap(ctl, entry);\n\n\t\tspin_unlock(&ctl->tree_lock);\n\t\ttrim_entry.start = start;\n\t\ttrim_entry.bytes = bytes;\n\t\tlist_add_tail(&trim_entry.list, &ctl->trimming_ranges);\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\t\tret = do_trimming(block_group, total_trimmed, start, bytes,\n\t\t\t\t  start, bytes, &trim_entry);\n\t\tif (ret)\n\t\t\tbreak;\nnext:\n\t\tif (next_bitmap) {\n\t\t\toffset += BITS_PER_BITMAP * ctl->unit;\n\t\t} else {\n\t\t\tstart += bytes;\n\t\t\tif (start >= offset + BITS_PER_BITMAP * ctl->unit)\n\t\t\t\toffset += BITS_PER_BITMAP * ctl->unit;\n\t\t}\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trim_no_bitmap",
          "args": [
            "block_group",
            "trimmed",
            "start",
            "end",
            "minlen"
          ],
          "line": 3173
        },
        "resolved": true,
        "details": {
          "function_name": "trim_no_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2992-3075",
          "snippet": "static int trim_no_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t\t  u64 *total_trimmed, u64 start, u64 end, u64 minlen)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\tint ret = 0;\n\tu64 extent_start;\n\tu64 extent_bytes;\n\tu64 bytes;\n\n\twhile (start < end) {\n\t\tstruct btrfs_trim_range trim_entry;\n\n\t\tmutex_lock(&ctl->cache_writeout_mutex);\n\t\tspin_lock(&ctl->tree_lock);\n\n\t\tif (ctl->free_space < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = tree_search_offset(ctl, start, 0, 1);\n\t\tif (!entry) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* skip bitmaps */\n\t\twhile (entry->bitmap) {\n\t\t\tnode = rb_next(&entry->offset_index);\n\t\t\tif (!node) {\n\t\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tentry = rb_entry(node, struct btrfs_free_space,\n\t\t\t\t\t offset_index);\n\t\t}\n\n\t\tif (entry->offset >= end) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\textent_start = entry->offset;\n\t\textent_bytes = entry->bytes;\n\t\tstart = max(start, extent_start);\n\t\tbytes = min(extent_start + extent_bytes, end) - start;\n\t\tif (bytes < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tgoto next;\n\t\t}\n\n\t\tunlink_free_space(ctl, entry);\n\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\n\t\tspin_unlock(&ctl->tree_lock);\n\t\ttrim_entry.start = extent_start;\n\t\ttrim_entry.bytes = extent_bytes;\n\t\tlist_add_tail(&trim_entry.list, &ctl->trimming_ranges);\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\t\tret = do_trimming(block_group, total_trimmed, start, bytes,\n\t\t\t\t  extent_start, extent_bytes, &trim_entry);\n\t\tif (ret)\n\t\t\tbreak;\nnext:\n\t\tstart += bytes;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int trim_no_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t\t  u64 *total_trimmed, u64 start, u64 end, u64 minlen)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\tint ret = 0;\n\tu64 extent_start;\n\tu64 extent_bytes;\n\tu64 bytes;\n\n\twhile (start < end) {\n\t\tstruct btrfs_trim_range trim_entry;\n\n\t\tmutex_lock(&ctl->cache_writeout_mutex);\n\t\tspin_lock(&ctl->tree_lock);\n\n\t\tif (ctl->free_space < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = tree_search_offset(ctl, start, 0, 1);\n\t\tif (!entry) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* skip bitmaps */\n\t\twhile (entry->bitmap) {\n\t\t\tnode = rb_next(&entry->offset_index);\n\t\t\tif (!node) {\n\t\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tentry = rb_entry(node, struct btrfs_free_space,\n\t\t\t\t\t offset_index);\n\t\t}\n\n\t\tif (entry->offset >= end) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\textent_start = entry->offset;\n\t\textent_bytes = entry->bytes;\n\t\tstart = max(start, extent_start);\n\t\tbytes = min(extent_start + extent_bytes, end) - start;\n\t\tif (bytes < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tgoto next;\n\t\t}\n\n\t\tunlink_free_space(ctl, entry);\n\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\n\t\tspin_unlock(&ctl->tree_lock);\n\t\ttrim_entry.start = extent_start;\n\t\ttrim_entry.bytes = extent_bytes;\n\t\tlist_add_tail(&trim_entry.list, &ctl->trimming_ranges);\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\t\tret = do_trimming(block_group, total_trimmed, start, bytes,\n\t\t\t\t  extent_start, extent_bytes, &trim_entry);\n\t\tif (ret)\n\t\t\tbreak;\nnext:\n\t\tstart += bytes;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&block_group->trimming"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint btrfs_trim_block_group(struct btrfs_block_group_cache *block_group,\n\t\t\t   u64 *trimmed, u64 start, u64 end, u64 minlen)\n{\n\tint ret;\n\n\t*trimmed = 0;\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->removed) {\n\t\tspin_unlock(&block_group->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&block_group->trimming);\n\tspin_unlock(&block_group->lock);\n\n\tret = trim_no_bitmap(block_group, trimmed, start, end, minlen);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trim_bitmaps(block_group, trimmed, start, end, minlen);\nout:\n\tspin_lock(&block_group->lock);\n\tif (atomic_dec_and_test(&block_group->trimming) &&\n\t    block_group->removed) {\n\t\tstruct extent_map_tree *em_tree;\n\t\tstruct extent_map *em;\n\n\t\tspin_unlock(&block_group->lock);\n\n\t\tlock_chunks(block_group->fs_info->chunk_root);\n\t\tem_tree = &block_group->fs_info->mapping_tree.map_tree;\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, block_group->key.objectid,\n\t\t\t\t\t   1);\n\t\tBUG_ON(!em); /* logic error, can't happen */\n\t\t/*\n\t\t * remove_extent_mapping() will delete us from the pinned_chunks\n\t\t * list, which is protected by the chunk mutex.\n\t\t */\n\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\t\tunlock_chunks(block_group->fs_info->chunk_root);\n\n\t\t/* once for us and once for the tree */\n\t\tfree_extent_map(em);\n\t\tfree_extent_map(em);\n\n\t\t/*\n\t\t * We've left one free space entry and other tasks trimming\n\t\t * this block group have left 1 entry each one. Free them.\n\t\t */\n\t\t__btrfs_remove_free_space_cache(block_group->free_space_ctl);\n\t} else {\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trim_bitmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "3077-3156",
    "snippet": "static int trim_bitmaps(struct btrfs_block_group_cache *block_group,\n\t\t\tu64 *total_trimmed, u64 start, u64 end, u64 minlen)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tint ret = 0;\n\tint ret2;\n\tu64 bytes;\n\tu64 offset = offset_to_bitmap(ctl, start);\n\n\twhile (offset < end) {\n\t\tbool next_bitmap = false;\n\t\tstruct btrfs_trim_range trim_entry;\n\n\t\tmutex_lock(&ctl->cache_writeout_mutex);\n\t\tspin_lock(&ctl->tree_lock);\n\n\t\tif (ctl->free_space < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = tree_search_offset(ctl, offset, 1, 0);\n\t\tif (!entry) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tnext_bitmap = true;\n\t\t\tgoto next;\n\t\t}\n\n\t\tbytes = minlen;\n\t\tret2 = search_bitmap(ctl, entry, &start, &bytes);\n\t\tif (ret2 || start >= end) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tnext_bitmap = true;\n\t\t\tgoto next;\n\t\t}\n\n\t\tbytes = min(bytes, end - start);\n\t\tif (bytes < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tgoto next;\n\t\t}\n\n\t\tbitmap_clear_bits(ctl, entry, start, bytes);\n\t\tif (entry->bytes == 0)\n\t\t\tfree_bitmap(ctl, entry);\n\n\t\tspin_unlock(&ctl->tree_lock);\n\t\ttrim_entry.start = start;\n\t\ttrim_entry.bytes = bytes;\n\t\tlist_add_tail(&trim_entry.list, &ctl->trimming_ranges);\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\t\tret = do_trimming(block_group, total_trimmed, start, bytes,\n\t\t\t\t  start, bytes, &trim_entry);\n\t\tif (ret)\n\t\t\tbreak;\nnext:\n\t\tif (next_bitmap) {\n\t\t\toffset += BITS_PER_BITMAP * ctl->unit;\n\t\t} else {\n\t\t\tstart += bytes;\n\t\t\tif (start >= offset + BITS_PER_BITMAP * ctl->unit)\n\t\t\t\toffset += BITS_PER_BITMAP * ctl->unit;\n\t\t}\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_trimming",
          "args": [
            "block_group",
            "total_trimmed",
            "start",
            "bytes",
            "start",
            "bytes",
            "&trim_entry"
          ],
          "line": 3134
        },
        "resolved": true,
        "details": {
          "function_name": "do_trimming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2946-2990",
          "snippet": "static int do_trimming(struct btrfs_block_group_cache *block_group,\n\t\t       u64 *total_trimmed, u64 start, u64 bytes,\n\t\t       u64 reserved_start, u64 reserved_bytes,\n\t\t       struct btrfs_trim_range *trim_entry)\n{\n\tstruct btrfs_space_info *space_info = block_group->space_info;\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tint ret;\n\tint update = 0;\n\tu64 trimmed = 0;\n\n\tspin_lock(&space_info->lock);\n\tspin_lock(&block_group->lock);\n\tif (!block_group->ro) {\n\t\tblock_group->reserved += reserved_bytes;\n\t\tspace_info->bytes_reserved += reserved_bytes;\n\t\tupdate = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\tspin_unlock(&space_info->lock);\n\n\tret = btrfs_discard_extent(fs_info->extent_root,\n\t\t\t\t   start, bytes, &trimmed);\n\tif (!ret)\n\t\t*total_trimmed += trimmed;\n\n\tmutex_lock(&ctl->cache_writeout_mutex);\n\tbtrfs_add_free_space(block_group, reserved_start, reserved_bytes);\n\tlist_del(&trim_entry->list);\n\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\tif (update) {\n\t\tspin_lock(&space_info->lock);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->ro)\n\t\t\tspace_info->bytes_readonly += reserved_bytes;\n\t\tblock_group->reserved -= reserved_bytes;\n\t\tspace_info->bytes_reserved -= reserved_bytes;\n\t\tspin_unlock(&space_info->lock);\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int do_trimming(struct btrfs_block_group_cache *block_group,\n\t\t       u64 *total_trimmed, u64 start, u64 bytes,\n\t\t       u64 reserved_start, u64 reserved_bytes,\n\t\t       struct btrfs_trim_range *trim_entry)\n{\n\tstruct btrfs_space_info *space_info = block_group->space_info;\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tint ret;\n\tint update = 0;\n\tu64 trimmed = 0;\n\n\tspin_lock(&space_info->lock);\n\tspin_lock(&block_group->lock);\n\tif (!block_group->ro) {\n\t\tblock_group->reserved += reserved_bytes;\n\t\tspace_info->bytes_reserved += reserved_bytes;\n\t\tupdate = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\tspin_unlock(&space_info->lock);\n\n\tret = btrfs_discard_extent(fs_info->extent_root,\n\t\t\t\t   start, bytes, &trimmed);\n\tif (!ret)\n\t\t*total_trimmed += trimmed;\n\n\tmutex_lock(&ctl->cache_writeout_mutex);\n\tbtrfs_add_free_space(block_group, reserved_start, reserved_bytes);\n\tlist_del(&trim_entry->list);\n\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\tif (update) {\n\t\tspin_lock(&space_info->lock);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->ro)\n\t\t\tspace_info->bytes_readonly += reserved_bytes;\n\t\tblock_group->reserved -= reserved_bytes;\n\t\tspace_info->bytes_reserved -= reserved_bytes;\n\t\tspin_unlock(&space_info->lock);\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&trim_entry.list",
            "&ctl->trimming_ranges"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 3128
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_bitmap",
          "args": [
            "ctl",
            "entry"
          ],
          "line": 3126
        },
        "resolved": true,
        "details": {
          "function_name": "free_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1724-1732",
          "snippet": "static void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_clear_bits",
          "args": [
            "ctl",
            "entry",
            "start",
            "bytes"
          ],
          "line": 3124
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1580-1586",
          "snippet": "static void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 3120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes",
            "end - start"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_bitmap",
          "args": [
            "ctl",
            "entry",
            "&start",
            "&bytes"
          ],
          "line": 3109
        },
        "resolved": true,
        "details": {
          "function_name": "search_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1608-1643",
          "snippet": "static int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search_offset",
          "args": [
            "ctl",
            "offset",
            "1",
            "0"
          ],
          "line": 3100
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1370-1484",
          "snippet": "static struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 3091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_to_bitmap",
          "args": [
            "ctl",
            "start"
          ],
          "line": 3085
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1297-1310",
          "snippet": "static inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int trim_bitmaps(struct btrfs_block_group_cache *block_group,\n\t\t\tu64 *total_trimmed, u64 start, u64 end, u64 minlen)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tint ret = 0;\n\tint ret2;\n\tu64 bytes;\n\tu64 offset = offset_to_bitmap(ctl, start);\n\n\twhile (offset < end) {\n\t\tbool next_bitmap = false;\n\t\tstruct btrfs_trim_range trim_entry;\n\n\t\tmutex_lock(&ctl->cache_writeout_mutex);\n\t\tspin_lock(&ctl->tree_lock);\n\n\t\tif (ctl->free_space < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = tree_search_offset(ctl, offset, 1, 0);\n\t\tif (!entry) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tnext_bitmap = true;\n\t\t\tgoto next;\n\t\t}\n\n\t\tbytes = minlen;\n\t\tret2 = search_bitmap(ctl, entry, &start, &bytes);\n\t\tif (ret2 || start >= end) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tnext_bitmap = true;\n\t\t\tgoto next;\n\t\t}\n\n\t\tbytes = min(bytes, end - start);\n\t\tif (bytes < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tgoto next;\n\t\t}\n\n\t\tbitmap_clear_bits(ctl, entry, start, bytes);\n\t\tif (entry->bytes == 0)\n\t\t\tfree_bitmap(ctl, entry);\n\n\t\tspin_unlock(&ctl->tree_lock);\n\t\ttrim_entry.start = start;\n\t\ttrim_entry.bytes = bytes;\n\t\tlist_add_tail(&trim_entry.list, &ctl->trimming_ranges);\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\t\tret = do_trimming(block_group, total_trimmed, start, bytes,\n\t\t\t\t  start, bytes, &trim_entry);\n\t\tif (ret)\n\t\t\tbreak;\nnext:\n\t\tif (next_bitmap) {\n\t\t\toffset += BITS_PER_BITMAP * ctl->unit;\n\t\t} else {\n\t\t\tstart += bytes;\n\t\t\tif (start >= offset + BITS_PER_BITMAP * ctl->unit)\n\t\t\t\toffset += BITS_PER_BITMAP * ctl->unit;\n\t\t}\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trim_no_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2992-3075",
    "snippet": "static int trim_no_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t\t  u64 *total_trimmed, u64 start, u64 end, u64 minlen)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\tint ret = 0;\n\tu64 extent_start;\n\tu64 extent_bytes;\n\tu64 bytes;\n\n\twhile (start < end) {\n\t\tstruct btrfs_trim_range trim_entry;\n\n\t\tmutex_lock(&ctl->cache_writeout_mutex);\n\t\tspin_lock(&ctl->tree_lock);\n\n\t\tif (ctl->free_space < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = tree_search_offset(ctl, start, 0, 1);\n\t\tif (!entry) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* skip bitmaps */\n\t\twhile (entry->bitmap) {\n\t\t\tnode = rb_next(&entry->offset_index);\n\t\t\tif (!node) {\n\t\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tentry = rb_entry(node, struct btrfs_free_space,\n\t\t\t\t\t offset_index);\n\t\t}\n\n\t\tif (entry->offset >= end) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\textent_start = entry->offset;\n\t\textent_bytes = entry->bytes;\n\t\tstart = max(start, extent_start);\n\t\tbytes = min(extent_start + extent_bytes, end) - start;\n\t\tif (bytes < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tgoto next;\n\t\t}\n\n\t\tunlink_free_space(ctl, entry);\n\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\n\t\tspin_unlock(&ctl->tree_lock);\n\t\ttrim_entry.start = extent_start;\n\t\ttrim_entry.bytes = extent_bytes;\n\t\tlist_add_tail(&trim_entry.list, &ctl->trimming_ranges);\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\t\tret = do_trimming(block_group, total_trimmed, start, bytes,\n\t\t\t\t  extent_start, extent_bytes, &trim_entry);\n\t\tif (ret)\n\t\t\tbreak;\nnext:\n\t\tstart += bytes;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_trimming",
          "args": [
            "block_group",
            "total_trimmed",
            "start",
            "bytes",
            "extent_start",
            "extent_bytes",
            "&trim_entry"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "do_trimming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2946-2990",
          "snippet": "static int do_trimming(struct btrfs_block_group_cache *block_group,\n\t\t       u64 *total_trimmed, u64 start, u64 bytes,\n\t\t       u64 reserved_start, u64 reserved_bytes,\n\t\t       struct btrfs_trim_range *trim_entry)\n{\n\tstruct btrfs_space_info *space_info = block_group->space_info;\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tint ret;\n\tint update = 0;\n\tu64 trimmed = 0;\n\n\tspin_lock(&space_info->lock);\n\tspin_lock(&block_group->lock);\n\tif (!block_group->ro) {\n\t\tblock_group->reserved += reserved_bytes;\n\t\tspace_info->bytes_reserved += reserved_bytes;\n\t\tupdate = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\tspin_unlock(&space_info->lock);\n\n\tret = btrfs_discard_extent(fs_info->extent_root,\n\t\t\t\t   start, bytes, &trimmed);\n\tif (!ret)\n\t\t*total_trimmed += trimmed;\n\n\tmutex_lock(&ctl->cache_writeout_mutex);\n\tbtrfs_add_free_space(block_group, reserved_start, reserved_bytes);\n\tlist_del(&trim_entry->list);\n\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\tif (update) {\n\t\tspin_lock(&space_info->lock);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->ro)\n\t\t\tspace_info->bytes_readonly += reserved_bytes;\n\t\tblock_group->reserved -= reserved_bytes;\n\t\tspace_info->bytes_reserved -= reserved_bytes;\n\t\tspin_unlock(&space_info->lock);\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int do_trimming(struct btrfs_block_group_cache *block_group,\n\t\t       u64 *total_trimmed, u64 start, u64 bytes,\n\t\t       u64 reserved_start, u64 reserved_bytes,\n\t\t       struct btrfs_trim_range *trim_entry)\n{\n\tstruct btrfs_space_info *space_info = block_group->space_info;\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tint ret;\n\tint update = 0;\n\tu64 trimmed = 0;\n\n\tspin_lock(&space_info->lock);\n\tspin_lock(&block_group->lock);\n\tif (!block_group->ro) {\n\t\tblock_group->reserved += reserved_bytes;\n\t\tspace_info->bytes_reserved += reserved_bytes;\n\t\tupdate = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\tspin_unlock(&space_info->lock);\n\n\tret = btrfs_discard_extent(fs_info->extent_root,\n\t\t\t\t   start, bytes, &trimmed);\n\tif (!ret)\n\t\t*total_trimmed += trimmed;\n\n\tmutex_lock(&ctl->cache_writeout_mutex);\n\tbtrfs_add_free_space(block_group, reserved_start, reserved_bytes);\n\tlist_del(&trim_entry->list);\n\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\tif (update) {\n\t\tspin_lock(&space_info->lock);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->ro)\n\t\t\tspace_info->bytes_readonly += reserved_bytes;\n\t\tblock_group->reserved -= reserved_bytes;\n\t\tspace_info->bytes_reserved -= reserved_bytes;\n\t\tspin_unlock(&space_info->lock);\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&trim_entry.list",
            "&ctl->trimming_ranges"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "entry"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink_free_space",
          "args": [
            "ctl",
            "entry"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1494-1499",
          "snippet": "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "extent_start + extent_bytes",
            "end"
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "start",
            "extent_start"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 3030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&entry->offset_index"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search_offset",
          "args": [
            "ctl",
            "start",
            "0",
            "1"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1370-1484",
          "snippet": "static struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int trim_no_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t\t  u64 *total_trimmed, u64 start, u64 end, u64 minlen)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\tint ret = 0;\n\tu64 extent_start;\n\tu64 extent_bytes;\n\tu64 bytes;\n\n\twhile (start < end) {\n\t\tstruct btrfs_trim_range trim_entry;\n\n\t\tmutex_lock(&ctl->cache_writeout_mutex);\n\t\tspin_lock(&ctl->tree_lock);\n\n\t\tif (ctl->free_space < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = tree_search_offset(ctl, start, 0, 1);\n\t\tif (!entry) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* skip bitmaps */\n\t\twhile (entry->bitmap) {\n\t\t\tnode = rb_next(&entry->offset_index);\n\t\t\tif (!node) {\n\t\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tentry = rb_entry(node, struct btrfs_free_space,\n\t\t\t\t\t offset_index);\n\t\t}\n\n\t\tif (entry->offset >= end) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\textent_start = entry->offset;\n\t\textent_bytes = entry->bytes;\n\t\tstart = max(start, extent_start);\n\t\tbytes = min(extent_start + extent_bytes, end) - start;\n\t\tif (bytes < minlen) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\t\tgoto next;\n\t\t}\n\n\t\tunlink_free_space(ctl, entry);\n\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\n\t\tspin_unlock(&ctl->tree_lock);\n\t\ttrim_entry.start = extent_start;\n\t\ttrim_entry.bytes = extent_bytes;\n\t\tlist_add_tail(&trim_entry.list, &ctl->trimming_ranges);\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\t\tret = do_trimming(block_group, total_trimmed, start, bytes,\n\t\t\t\t  extent_start, extent_bytes, &trim_entry);\n\t\tif (ret)\n\t\t\tbreak;\nnext:\n\t\tstart += bytes;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "do_trimming",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2946-2990",
    "snippet": "static int do_trimming(struct btrfs_block_group_cache *block_group,\n\t\t       u64 *total_trimmed, u64 start, u64 bytes,\n\t\t       u64 reserved_start, u64 reserved_bytes,\n\t\t       struct btrfs_trim_range *trim_entry)\n{\n\tstruct btrfs_space_info *space_info = block_group->space_info;\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tint ret;\n\tint update = 0;\n\tu64 trimmed = 0;\n\n\tspin_lock(&space_info->lock);\n\tspin_lock(&block_group->lock);\n\tif (!block_group->ro) {\n\t\tblock_group->reserved += reserved_bytes;\n\t\tspace_info->bytes_reserved += reserved_bytes;\n\t\tupdate = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\tspin_unlock(&space_info->lock);\n\n\tret = btrfs_discard_extent(fs_info->extent_root,\n\t\t\t\t   start, bytes, &trimmed);\n\tif (!ret)\n\t\t*total_trimmed += trimmed;\n\n\tmutex_lock(&ctl->cache_writeout_mutex);\n\tbtrfs_add_free_space(block_group, reserved_start, reserved_bytes);\n\tlist_del(&trim_entry->list);\n\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\tif (update) {\n\t\tspin_lock(&space_info->lock);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->ro)\n\t\t\tspace_info->bytes_readonly += reserved_bytes;\n\t\tblock_group->reserved -= reserved_bytes;\n\t\tspace_info->bytes_reserved -= reserved_bytes;\n\t\tspin_unlock(&space_info->lock);\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&block_group->lock"
          ],
          "line": 2986
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&block_group->lock"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&trim_entry->list"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_add_free_space",
          "args": [
            "block_group",
            "reserved_start",
            "reserved_bytes"
          ],
          "line": 2974
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2155-2207",
          "snippet": "int __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_discard_extent",
          "args": [
            "fs_info->extent_root",
            "start",
            "bytes",
            "&trimmed"
          ],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_discard_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "1893-1939",
          "snippet": "int btrfs_discard_extent(struct btrfs_root *root, u64 bytenr,\n\t\t\t u64 num_bytes, u64 *actual_bytes)\n{\n\tint ret;\n\tu64 discarded_bytes = 0;\n\tstruct btrfs_bio *bbio = NULL;\n\n\n\t/* Tell the block device(s) that the sectors can be discarded */\n\tret = btrfs_map_block(root->fs_info, REQ_DISCARD,\n\t\t\t      bytenr, &num_bytes, &bbio, 0);\n\t/* Error condition is -ENOMEM */\n\tif (!ret) {\n\t\tstruct btrfs_bio_stripe *stripe = bbio->stripes;\n\t\tint i;\n\n\n\t\tfor (i = 0; i < bbio->num_stripes; i++, stripe++) {\n\t\t\tif (!stripe->dev->can_discard)\n\t\t\t\tcontinue;\n\n\t\t\tret = btrfs_issue_discard(stripe->dev->bdev,\n\t\t\t\t\t\t  stripe->physical,\n\t\t\t\t\t\t  stripe->length);\n\t\t\tif (!ret)\n\t\t\t\tdiscarded_bytes += stripe->length;\n\t\t\telse if (ret != -EOPNOTSUPP)\n\t\t\t\tbreak; /* Logic errors or -ENOMEM, or -EIO but I don't know how that could happen JDM */\n\n\t\t\t/*\n\t\t\t * Just in case we get back EOPNOTSUPP for some reason,\n\t\t\t * just ignore the return value so we don't screw up\n\t\t\t * people calling discard_extent.\n\t\t\t */\n\t\t\tret = 0;\n\t\t}\n\t\tbtrfs_put_bbio(bbio);\n\t}\n\n\tif (actual_bytes)\n\t\t*actual_bytes = discarded_bytes;\n\n\n\tif (ret == -EOPNOTSUPP)\n\t\tret = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_discard_extent(struct btrfs_root *root, u64 bytenr,\n\t\t\t u64 num_bytes, u64 *actual_bytes)\n{\n\tint ret;\n\tu64 discarded_bytes = 0;\n\tstruct btrfs_bio *bbio = NULL;\n\n\n\t/* Tell the block device(s) that the sectors can be discarded */\n\tret = btrfs_map_block(root->fs_info, REQ_DISCARD,\n\t\t\t      bytenr, &num_bytes, &bbio, 0);\n\t/* Error condition is -ENOMEM */\n\tif (!ret) {\n\t\tstruct btrfs_bio_stripe *stripe = bbio->stripes;\n\t\tint i;\n\n\n\t\tfor (i = 0; i < bbio->num_stripes; i++, stripe++) {\n\t\t\tif (!stripe->dev->can_discard)\n\t\t\t\tcontinue;\n\n\t\t\tret = btrfs_issue_discard(stripe->dev->bdev,\n\t\t\t\t\t\t  stripe->physical,\n\t\t\t\t\t\t  stripe->length);\n\t\t\tif (!ret)\n\t\t\t\tdiscarded_bytes += stripe->length;\n\t\t\telse if (ret != -EOPNOTSUPP)\n\t\t\t\tbreak; /* Logic errors or -ENOMEM, or -EIO but I don't know how that could happen JDM */\n\n\t\t\t/*\n\t\t\t * Just in case we get back EOPNOTSUPP for some reason,\n\t\t\t * just ignore the return value so we don't screw up\n\t\t\t * people calling discard_extent.\n\t\t\t */\n\t\t\tret = 0;\n\t\t}\n\t\tbtrfs_put_bbio(bbio);\n\t}\n\n\tif (actual_bytes)\n\t\t*actual_bytes = discarded_bytes;\n\n\n\tif (ret == -EOPNOTSUPP)\n\t\tret = 0;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int do_trimming(struct btrfs_block_group_cache *block_group,\n\t\t       u64 *total_trimmed, u64 start, u64 bytes,\n\t\t       u64 reserved_start, u64 reserved_bytes,\n\t\t       struct btrfs_trim_range *trim_entry)\n{\n\tstruct btrfs_space_info *space_info = block_group->space_info;\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tint ret;\n\tint update = 0;\n\tu64 trimmed = 0;\n\n\tspin_lock(&space_info->lock);\n\tspin_lock(&block_group->lock);\n\tif (!block_group->ro) {\n\t\tblock_group->reserved += reserved_bytes;\n\t\tspace_info->bytes_reserved += reserved_bytes;\n\t\tupdate = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\tspin_unlock(&space_info->lock);\n\n\tret = btrfs_discard_extent(fs_info->extent_root,\n\t\t\t\t   start, bytes, &trimmed);\n\tif (!ret)\n\t\t*total_trimmed += trimmed;\n\n\tmutex_lock(&ctl->cache_writeout_mutex);\n\tbtrfs_add_free_space(block_group, reserved_start, reserved_bytes);\n\tlist_del(&trim_entry->list);\n\tmutex_unlock(&ctl->cache_writeout_mutex);\n\n\tif (update) {\n\t\tspin_lock(&space_info->lock);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->ro)\n\t\t\tspace_info->bytes_readonly += reserved_bytes;\n\t\tblock_group->reserved -= reserved_bytes;\n\t\tspace_info->bytes_reserved -= reserved_bytes;\n\t\tspin_unlock(&space_info->lock);\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_init_free_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2936-2944",
    "snippet": "void btrfs_init_free_cluster(struct btrfs_free_cluster *cluster)\n{\n\tspin_lock_init(&cluster->lock);\n\tspin_lock_init(&cluster->refill_lock);\n\tcluster->root = RB_ROOT;\n\tcluster->max_size = 0;\n\tINIT_LIST_HEAD(&cluster->block_group_list);\n\tcluster->block_group = NULL;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cluster->block_group_list"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cluster->refill_lock"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cluster->lock"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nvoid btrfs_init_free_cluster(struct btrfs_free_cluster *cluster)\n{\n\tspin_lock_init(&cluster->lock);\n\tspin_lock_init(&cluster->refill_lock);\n\tcluster->root = RB_ROOT;\n\tcluster->max_size = 0;\n\tINIT_LIST_HEAD(&cluster->block_group_list);\n\tcluster->block_group = NULL;\n}"
  },
  {
    "function_name": "btrfs_find_space_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2856-2931",
    "snippet": "int btrfs_find_space_cluster(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_group_cache *block_group,\n\t\t\t     struct btrfs_free_cluster *cluster,\n\t\t\t     u64 offset, u64 bytes, u64 empty_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry, *tmp;\n\tLIST_HEAD(bitmaps);\n\tu64 min_bytes;\n\tu64 cont1_bytes;\n\tint ret;\n\n\t/*\n\t * Choose the minimum extent size we'll require for this\n\t * cluster.  For SSD_SPREAD, don't allow any fragmentation.\n\t * For metadata, allow allocates with smaller extents.  For\n\t * data, keep it dense.\n\t */\n\tif (btrfs_test_opt(root, SSD_SPREAD)) {\n\t\tcont1_bytes = min_bytes = bytes + empty_size;\n\t} else if (block_group->flags & BTRFS_BLOCK_GROUP_METADATA) {\n\t\tcont1_bytes = bytes;\n\t\tmin_bytes = block_group->sectorsize;\n\t} else {\n\t\tcont1_bytes = max(bytes, (bytes + empty_size) >> 2);\n\t\tmin_bytes = block_group->sectorsize;\n\t}\n\n\tspin_lock(&ctl->tree_lock);\n\n\t/*\n\t * If we know we don't have enough space to make a cluster don't even\n\t * bother doing all the work to try and find one.\n\t */\n\tif (ctl->free_space < bytes) {\n\t\tspin_unlock(&ctl->tree_lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tspin_lock(&cluster->lock);\n\n\t/* someone already found a cluster, hooray */\n\tif (cluster->block_group) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\ttrace_btrfs_find_cluster(block_group, offset, bytes, empty_size,\n\t\t\t\t min_bytes);\n\n\tret = setup_cluster_no_bitmap(block_group, cluster, &bitmaps, offset,\n\t\t\t\t      bytes + empty_size,\n\t\t\t\t      cont1_bytes, min_bytes);\n\tif (ret)\n\t\tret = setup_cluster_bitmap(block_group, cluster, &bitmaps,\n\t\t\t\t\t   offset, bytes + empty_size,\n\t\t\t\t\t   cont1_bytes, min_bytes);\n\n\t/* Clear our temporary list */\n\tlist_for_each_entry_safe(entry, tmp, &bitmaps, list)\n\t\tlist_del_init(&entry->list);\n\n\tif (!ret) {\n\t\tatomic_inc(&block_group->count);\n\t\tlist_add_tail(&cluster->block_group_list,\n\t\t\t      &block_group->cluster_list);\n\t\tcluster->block_group = block_group;\n\t} else {\n\t\ttrace_btrfs_failed_cluster_setup(block_group);\n\t}\nout:\n\tspin_unlock(&cluster->lock);\n\tspin_unlock(&ctl->tree_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2928
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_failed_cluster_setup",
          "args": [
            "block_group"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cluster->block_group_list",
            "&block_group->cluster_list"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&block_group->count"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&entry->list"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "entry",
            "tmp",
            "&bitmaps",
            "list"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_cluster_bitmap",
          "args": [
            "block_group",
            "cluster",
            "&bitmaps",
            "offset",
            "bytes + empty_size",
            "cont1_bytes",
            "min_bytes"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "setup_cluster_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2807-2846",
          "snippet": "static noinline int\nsetup_cluster_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t     struct btrfs_free_cluster *cluster,\n\t\t     struct list_head *bitmaps, u64 offset, u64 bytes,\n\t\t     u64 cont1_bytes, u64 min_bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tint ret = -ENOSPC;\n\tu64 bitmap_offset = offset_to_bitmap(ctl, offset);\n\n\tif (ctl->total_bitmaps == 0)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * The bitmap that covers offset won't be in the list unless offset\n\t * is just its start offset.\n\t */\n\tentry = list_first_entry(bitmaps, struct btrfs_free_space, list);\n\tif (entry->offset != bitmap_offset) {\n\t\tentry = tree_search_offset(ctl, bitmap_offset, 1, 0);\n\t\tif (entry && list_empty(&entry->list))\n\t\t\tlist_add(&entry->list, bitmaps);\n\t}\n\n\tlist_for_each_entry(entry, bitmaps, list) {\n\t\tif (entry->bytes < bytes)\n\t\t\tcontinue;\n\t\tret = btrfs_bitmap_cluster(block_group, entry, cluster, offset,\n\t\t\t\t\t   bytes, cont1_bytes, min_bytes);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * The bitmaps list has all the bitmaps that record free space\n\t * starting after offset, so no more search is required.\n\t */\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic noinline int\nsetup_cluster_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t     struct btrfs_free_cluster *cluster,\n\t\t     struct list_head *bitmaps, u64 offset, u64 bytes,\n\t\t     u64 cont1_bytes, u64 min_bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tint ret = -ENOSPC;\n\tu64 bitmap_offset = offset_to_bitmap(ctl, offset);\n\n\tif (ctl->total_bitmaps == 0)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * The bitmap that covers offset won't be in the list unless offset\n\t * is just its start offset.\n\t */\n\tentry = list_first_entry(bitmaps, struct btrfs_free_space, list);\n\tif (entry->offset != bitmap_offset) {\n\t\tentry = tree_search_offset(ctl, bitmap_offset, 1, 0);\n\t\tif (entry && list_empty(&entry->list))\n\t\t\tlist_add(&entry->list, bitmaps);\n\t}\n\n\tlist_for_each_entry(entry, bitmaps, list) {\n\t\tif (entry->bytes < bytes)\n\t\t\tcontinue;\n\t\tret = btrfs_bitmap_cluster(block_group, entry, cluster, offset,\n\t\t\t\t\t   bytes, cont1_bytes, min_bytes);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * The bitmaps list has all the bitmaps that record free space\n\t * starting after offset, so no more search is required.\n\t */\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_cluster_no_bitmap",
          "args": [
            "block_group",
            "cluster",
            "&bitmaps",
            "offset",
            "bytes + empty_size",
            "cont1_bytes",
            "min_bytes"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "setup_cluster_no_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2716-2801",
          "snippet": "static noinline int\nsetup_cluster_no_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t\tstruct btrfs_free_cluster *cluster,\n\t\t\tstruct list_head *bitmaps, u64 offset, u64 bytes,\n\t\t\tu64 cont1_bytes, u64 min_bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *first = NULL;\n\tstruct btrfs_free_space *entry = NULL;\n\tstruct btrfs_free_space *last;\n\tstruct rb_node *node;\n\tu64 window_free;\n\tu64 max_extent;\n\tu64 total_size = 0;\n\n\tentry = tree_search_offset(ctl, offset, 0, 1);\n\tif (!entry)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * We don't want bitmaps, so just move along until we find a normal\n\t * extent entry.\n\t */\n\twhile (entry->bitmap || entry->bytes < min_bytes) {\n\t\tif (entry->bitmap && list_empty(&entry->list))\n\t\t\tlist_add_tail(&entry->list, bitmaps);\n\t\tnode = rb_next(&entry->offset_index);\n\t\tif (!node)\n\t\t\treturn -ENOSPC;\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t}\n\n\twindow_free = entry->bytes;\n\tmax_extent = entry->bytes;\n\tfirst = entry;\n\tlast = entry;\n\n\tfor (node = rb_next(&entry->offset_index); node;\n\t     node = rb_next(&entry->offset_index)) {\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\n\t\tif (entry->bitmap) {\n\t\t\tif (list_empty(&entry->list))\n\t\t\t\tlist_add_tail(&entry->list, bitmaps);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->bytes < min_bytes)\n\t\t\tcontinue;\n\n\t\tlast = entry;\n\t\twindow_free += entry->bytes;\n\t\tif (entry->bytes > max_extent)\n\t\t\tmax_extent = entry->bytes;\n\t}\n\n\tif (window_free < bytes || max_extent < cont1_bytes)\n\t\treturn -ENOSPC;\n\n\tcluster->window_start = first->offset;\n\n\tnode = &first->offset_index;\n\n\t/*\n\t * now we've found our entries, pull them out of the free space\n\t * cache and put them into the cluster rbtree\n\t */\n\tdo {\n\t\tint ret;\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tnode = rb_next(&entry->offset_index);\n\t\tif (entry->bitmap || entry->bytes < min_bytes)\n\t\t\tcontinue;\n\n\t\trb_erase(&entry->offset_index, &ctl->free_space_offset);\n\t\tret = tree_insert_offset(&cluster->root, entry->offset,\n\t\t\t\t\t &entry->offset_index, 0);\n\t\ttotal_size += entry->bytes;\n\t\tASSERT(!ret); /* -EEXIST; Logic error */\n\t} while (node && entry != last);\n\n\tcluster->max_size = max_extent;\n\ttrace_btrfs_setup_cluster(block_group, cluster, total_size, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic noinline int\nsetup_cluster_no_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t\tstruct btrfs_free_cluster *cluster,\n\t\t\tstruct list_head *bitmaps, u64 offset, u64 bytes,\n\t\t\tu64 cont1_bytes, u64 min_bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *first = NULL;\n\tstruct btrfs_free_space *entry = NULL;\n\tstruct btrfs_free_space *last;\n\tstruct rb_node *node;\n\tu64 window_free;\n\tu64 max_extent;\n\tu64 total_size = 0;\n\n\tentry = tree_search_offset(ctl, offset, 0, 1);\n\tif (!entry)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * We don't want bitmaps, so just move along until we find a normal\n\t * extent entry.\n\t */\n\twhile (entry->bitmap || entry->bytes < min_bytes) {\n\t\tif (entry->bitmap && list_empty(&entry->list))\n\t\t\tlist_add_tail(&entry->list, bitmaps);\n\t\tnode = rb_next(&entry->offset_index);\n\t\tif (!node)\n\t\t\treturn -ENOSPC;\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t}\n\n\twindow_free = entry->bytes;\n\tmax_extent = entry->bytes;\n\tfirst = entry;\n\tlast = entry;\n\n\tfor (node = rb_next(&entry->offset_index); node;\n\t     node = rb_next(&entry->offset_index)) {\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\n\t\tif (entry->bitmap) {\n\t\t\tif (list_empty(&entry->list))\n\t\t\t\tlist_add_tail(&entry->list, bitmaps);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->bytes < min_bytes)\n\t\t\tcontinue;\n\n\t\tlast = entry;\n\t\twindow_free += entry->bytes;\n\t\tif (entry->bytes > max_extent)\n\t\t\tmax_extent = entry->bytes;\n\t}\n\n\tif (window_free < bytes || max_extent < cont1_bytes)\n\t\treturn -ENOSPC;\n\n\tcluster->window_start = first->offset;\n\n\tnode = &first->offset_index;\n\n\t/*\n\t * now we've found our entries, pull them out of the free space\n\t * cache and put them into the cluster rbtree\n\t */\n\tdo {\n\t\tint ret;\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tnode = rb_next(&entry->offset_index);\n\t\tif (entry->bitmap || entry->bytes < min_bytes)\n\t\t\tcontinue;\n\n\t\trb_erase(&entry->offset_index, &ctl->free_space_offset);\n\t\tret = tree_insert_offset(&cluster->root, entry->offset,\n\t\t\t\t\t &entry->offset_index, 0);\n\t\ttotal_size += entry->bytes;\n\t\tASSERT(!ret); /* -EEXIST; Logic error */\n\t} while (node && entry != last);\n\n\tcluster->max_size = max_extent;\n\ttrace_btrfs_setup_cluster(block_group, cluster, total_size, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_find_cluster",
          "args": [
            "block_group",
            "offset",
            "bytes",
            "empty_size",
            "min_bytes"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cluster->lock"
          ],
          "line": 2895
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "bytes",
            "(bytes + empty_size) >> 2"
          ],
          "line": 2880
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "SSD_SPREAD"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "bitmaps"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint btrfs_find_space_cluster(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_group_cache *block_group,\n\t\t\t     struct btrfs_free_cluster *cluster,\n\t\t\t     u64 offset, u64 bytes, u64 empty_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry, *tmp;\n\tLIST_HEAD(bitmaps);\n\tu64 min_bytes;\n\tu64 cont1_bytes;\n\tint ret;\n\n\t/*\n\t * Choose the minimum extent size we'll require for this\n\t * cluster.  For SSD_SPREAD, don't allow any fragmentation.\n\t * For metadata, allow allocates with smaller extents.  For\n\t * data, keep it dense.\n\t */\n\tif (btrfs_test_opt(root, SSD_SPREAD)) {\n\t\tcont1_bytes = min_bytes = bytes + empty_size;\n\t} else if (block_group->flags & BTRFS_BLOCK_GROUP_METADATA) {\n\t\tcont1_bytes = bytes;\n\t\tmin_bytes = block_group->sectorsize;\n\t} else {\n\t\tcont1_bytes = max(bytes, (bytes + empty_size) >> 2);\n\t\tmin_bytes = block_group->sectorsize;\n\t}\n\n\tspin_lock(&ctl->tree_lock);\n\n\t/*\n\t * If we know we don't have enough space to make a cluster don't even\n\t * bother doing all the work to try and find one.\n\t */\n\tif (ctl->free_space < bytes) {\n\t\tspin_unlock(&ctl->tree_lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tspin_lock(&cluster->lock);\n\n\t/* someone already found a cluster, hooray */\n\tif (cluster->block_group) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\ttrace_btrfs_find_cluster(block_group, offset, bytes, empty_size,\n\t\t\t\t min_bytes);\n\n\tret = setup_cluster_no_bitmap(block_group, cluster, &bitmaps, offset,\n\t\t\t\t      bytes + empty_size,\n\t\t\t\t      cont1_bytes, min_bytes);\n\tif (ret)\n\t\tret = setup_cluster_bitmap(block_group, cluster, &bitmaps,\n\t\t\t\t\t   offset, bytes + empty_size,\n\t\t\t\t\t   cont1_bytes, min_bytes);\n\n\t/* Clear our temporary list */\n\tlist_for_each_entry_safe(entry, tmp, &bitmaps, list)\n\t\tlist_del_init(&entry->list);\n\n\tif (!ret) {\n\t\tatomic_inc(&block_group->count);\n\t\tlist_add_tail(&cluster->block_group_list,\n\t\t\t      &block_group->cluster_list);\n\t\tcluster->block_group = block_group;\n\t} else {\n\t\ttrace_btrfs_failed_cluster_setup(block_group);\n\t}\nout:\n\tspin_unlock(&cluster->lock);\n\tspin_unlock(&ctl->tree_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "setup_cluster_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2807-2846",
    "snippet": "static noinline int\nsetup_cluster_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t     struct btrfs_free_cluster *cluster,\n\t\t     struct list_head *bitmaps, u64 offset, u64 bytes,\n\t\t     u64 cont1_bytes, u64 min_bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tint ret = -ENOSPC;\n\tu64 bitmap_offset = offset_to_bitmap(ctl, offset);\n\n\tif (ctl->total_bitmaps == 0)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * The bitmap that covers offset won't be in the list unless offset\n\t * is just its start offset.\n\t */\n\tentry = list_first_entry(bitmaps, struct btrfs_free_space, list);\n\tif (entry->offset != bitmap_offset) {\n\t\tentry = tree_search_offset(ctl, bitmap_offset, 1, 0);\n\t\tif (entry && list_empty(&entry->list))\n\t\t\tlist_add(&entry->list, bitmaps);\n\t}\n\n\tlist_for_each_entry(entry, bitmaps, list) {\n\t\tif (entry->bytes < bytes)\n\t\t\tcontinue;\n\t\tret = btrfs_bitmap_cluster(block_group, entry, cluster, offset,\n\t\t\t\t\t   bytes, cont1_bytes, min_bytes);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * The bitmaps list has all the bitmaps that record free space\n\t * starting after offset, so no more search is required.\n\t */\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_bitmap_cluster",
          "args": [
            "block_group",
            "entry",
            "cluster",
            "offset",
            "bytes",
            "cont1_bytes",
            "min_bytes"
          ],
          "line": 2835
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bitmap_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2649-2709",
          "snippet": "static int btrfs_bitmap_cluster(struct btrfs_block_group_cache *block_group,\n\t\t\t\tstruct btrfs_free_space *entry,\n\t\t\t\tstruct btrfs_free_cluster *cluster,\n\t\t\t\tu64 offset, u64 bytes,\n\t\t\t\tu64 cont1_bytes, u64 min_bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tunsigned long next_zero;\n\tunsigned long i;\n\tunsigned long want_bits;\n\tunsigned long min_bits;\n\tunsigned long found_bits;\n\tunsigned long start = 0;\n\tunsigned long total_found = 0;\n\tint ret;\n\n\ti = offset_to_bit(entry->offset, ctl->unit,\n\t\t\t  max_t(u64, offset, entry->offset));\n\twant_bits = bytes_to_bits(bytes, ctl->unit);\n\tmin_bits = bytes_to_bits(min_bytes, ctl->unit);\n\nagain:\n\tfound_bits = 0;\n\tfor_each_set_bit_from(i, entry->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(entry->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\tif (next_zero - i >= min_bits) {\n\t\t\tfound_bits = next_zero - i;\n\t\t\tbreak;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (!found_bits)\n\t\treturn -ENOSPC;\n\n\tif (!total_found) {\n\t\tstart = i;\n\t\tcluster->max_size = 0;\n\t}\n\n\ttotal_found += found_bits;\n\n\tif (cluster->max_size < found_bits * ctl->unit)\n\t\tcluster->max_size = found_bits * ctl->unit;\n\n\tif (total_found < want_bits || cluster->max_size < cont1_bytes) {\n\t\ti = next_zero + 1;\n\t\tgoto again;\n\t}\n\n\tcluster->window_start = start * ctl->unit + entry->offset;\n\trb_erase(&entry->offset_index, &ctl->free_space_offset);\n\tret = tree_insert_offset(&cluster->root, entry->offset,\n\t\t\t\t &entry->offset_index, 1);\n\tASSERT(!ret); /* -EEXIST; Logic error */\n\n\ttrace_btrfs_setup_cluster(block_group, cluster,\n\t\t\t\t  total_found * ctl->unit, 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int btrfs_bitmap_cluster(struct btrfs_block_group_cache *block_group,\n\t\t\t\tstruct btrfs_free_space *entry,\n\t\t\t\tstruct btrfs_free_cluster *cluster,\n\t\t\t\tu64 offset, u64 bytes,\n\t\t\t\tu64 cont1_bytes, u64 min_bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tunsigned long next_zero;\n\tunsigned long i;\n\tunsigned long want_bits;\n\tunsigned long min_bits;\n\tunsigned long found_bits;\n\tunsigned long start = 0;\n\tunsigned long total_found = 0;\n\tint ret;\n\n\ti = offset_to_bit(entry->offset, ctl->unit,\n\t\t\t  max_t(u64, offset, entry->offset));\n\twant_bits = bytes_to_bits(bytes, ctl->unit);\n\tmin_bits = bytes_to_bits(min_bytes, ctl->unit);\n\nagain:\n\tfound_bits = 0;\n\tfor_each_set_bit_from(i, entry->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(entry->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\tif (next_zero - i >= min_bits) {\n\t\t\tfound_bits = next_zero - i;\n\t\t\tbreak;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (!found_bits)\n\t\treturn -ENOSPC;\n\n\tif (!total_found) {\n\t\tstart = i;\n\t\tcluster->max_size = 0;\n\t}\n\n\ttotal_found += found_bits;\n\n\tif (cluster->max_size < found_bits * ctl->unit)\n\t\tcluster->max_size = found_bits * ctl->unit;\n\n\tif (total_found < want_bits || cluster->max_size < cont1_bytes) {\n\t\ti = next_zero + 1;\n\t\tgoto again;\n\t}\n\n\tcluster->window_start = start * ctl->unit + entry->offset;\n\trb_erase(&entry->offset_index, &ctl->free_space_offset);\n\tret = tree_insert_offset(&cluster->root, entry->offset,\n\t\t\t\t &entry->offset_index, 1);\n\tASSERT(!ret); /* -EEXIST; Logic error */\n\n\ttrace_btrfs_setup_cluster(block_group, cluster,\n\t\t\t\t  total_found * ctl->unit, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "bitmaps",
            "list"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&entry->list",
            "bitmaps"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&entry->list"
          ],
          "line": 2828
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_search_offset",
          "args": [
            "ctl",
            "bitmap_offset",
            "1",
            "0"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1370-1484",
          "snippet": "static struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "bitmaps",
            "structbtrfs_free_space",
            "list"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_to_bitmap",
          "args": [
            "ctl",
            "offset"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1297-1310",
          "snippet": "static inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic noinline int\nsetup_cluster_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t     struct btrfs_free_cluster *cluster,\n\t\t     struct list_head *bitmaps, u64 offset, u64 bytes,\n\t\t     u64 cont1_bytes, u64 min_bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tint ret = -ENOSPC;\n\tu64 bitmap_offset = offset_to_bitmap(ctl, offset);\n\n\tif (ctl->total_bitmaps == 0)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * The bitmap that covers offset won't be in the list unless offset\n\t * is just its start offset.\n\t */\n\tentry = list_first_entry(bitmaps, struct btrfs_free_space, list);\n\tif (entry->offset != bitmap_offset) {\n\t\tentry = tree_search_offset(ctl, bitmap_offset, 1, 0);\n\t\tif (entry && list_empty(&entry->list))\n\t\t\tlist_add(&entry->list, bitmaps);\n\t}\n\n\tlist_for_each_entry(entry, bitmaps, list) {\n\t\tif (entry->bytes < bytes)\n\t\t\tcontinue;\n\t\tret = btrfs_bitmap_cluster(block_group, entry, cluster, offset,\n\t\t\t\t\t   bytes, cont1_bytes, min_bytes);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * The bitmaps list has all the bitmaps that record free space\n\t * starting after offset, so no more search is required.\n\t */\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "setup_cluster_no_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2716-2801",
    "snippet": "static noinline int\nsetup_cluster_no_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t\tstruct btrfs_free_cluster *cluster,\n\t\t\tstruct list_head *bitmaps, u64 offset, u64 bytes,\n\t\t\tu64 cont1_bytes, u64 min_bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *first = NULL;\n\tstruct btrfs_free_space *entry = NULL;\n\tstruct btrfs_free_space *last;\n\tstruct rb_node *node;\n\tu64 window_free;\n\tu64 max_extent;\n\tu64 total_size = 0;\n\n\tentry = tree_search_offset(ctl, offset, 0, 1);\n\tif (!entry)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * We don't want bitmaps, so just move along until we find a normal\n\t * extent entry.\n\t */\n\twhile (entry->bitmap || entry->bytes < min_bytes) {\n\t\tif (entry->bitmap && list_empty(&entry->list))\n\t\t\tlist_add_tail(&entry->list, bitmaps);\n\t\tnode = rb_next(&entry->offset_index);\n\t\tif (!node)\n\t\t\treturn -ENOSPC;\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t}\n\n\twindow_free = entry->bytes;\n\tmax_extent = entry->bytes;\n\tfirst = entry;\n\tlast = entry;\n\n\tfor (node = rb_next(&entry->offset_index); node;\n\t     node = rb_next(&entry->offset_index)) {\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\n\t\tif (entry->bitmap) {\n\t\t\tif (list_empty(&entry->list))\n\t\t\t\tlist_add_tail(&entry->list, bitmaps);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->bytes < min_bytes)\n\t\t\tcontinue;\n\n\t\tlast = entry;\n\t\twindow_free += entry->bytes;\n\t\tif (entry->bytes > max_extent)\n\t\t\tmax_extent = entry->bytes;\n\t}\n\n\tif (window_free < bytes || max_extent < cont1_bytes)\n\t\treturn -ENOSPC;\n\n\tcluster->window_start = first->offset;\n\n\tnode = &first->offset_index;\n\n\t/*\n\t * now we've found our entries, pull them out of the free space\n\t * cache and put them into the cluster rbtree\n\t */\n\tdo {\n\t\tint ret;\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tnode = rb_next(&entry->offset_index);\n\t\tif (entry->bitmap || entry->bytes < min_bytes)\n\t\t\tcontinue;\n\n\t\trb_erase(&entry->offset_index, &ctl->free_space_offset);\n\t\tret = tree_insert_offset(&cluster->root, entry->offset,\n\t\t\t\t\t &entry->offset_index, 0);\n\t\ttotal_size += entry->bytes;\n\t\tASSERT(!ret); /* -EEXIST; Logic error */\n\t} while (node && entry != last);\n\n\tcluster->max_size = max_extent;\n\ttrace_btrfs_setup_cluster(block_group, cluster, total_size, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_btrfs_setup_cluster",
          "args": [
            "block_group",
            "cluster",
            "total_size",
            "0"
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!ret"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_insert_offset",
          "args": [
            "&cluster->root",
            "entry->offset",
            "&entry->offset_index",
            "0"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1312-1361",
          "snippet": "static int tree_insert_offset(struct rb_root *root, u64 offset,\n\t\t\t      struct rb_node *node, int bitmap)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_free_space *info;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tinfo = rb_entry(parent, struct btrfs_free_space, offset_index);\n\n\t\tif (offset < info->offset) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (offset > info->offset) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we could have a bitmap entry and an extent entry\n\t\t\t * share the same offset.  If this is the case, we want\n\t\t\t * the extent entry to always be found first if we do a\n\t\t\t * linear search through the tree, since we want to have\n\t\t\t * the quickest allocation time, and allocating from an\n\t\t\t * extent is faster than allocating from a bitmap.  So\n\t\t\t * if we're inserting a bitmap and we find an entry at\n\t\t\t * this offset, we want to go right, or after this entry\n\t\t\t * logically.  If we are inserting an extent and we've\n\t\t\t * found a bitmap, we want to go left, or before\n\t\t\t * logically.\n\t\t\t */\n\t\t\tif (bitmap) {\n\t\t\t\tif (info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\t} else {\n\t\t\t\tif (!info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\t}\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int tree_insert_offset(struct rb_root *root, u64 offset,\n\t\t\t      struct rb_node *node, int bitmap)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_free_space *info;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tinfo = rb_entry(parent, struct btrfs_free_space, offset_index);\n\n\t\tif (offset < info->offset) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (offset > info->offset) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we could have a bitmap entry and an extent entry\n\t\t\t * share the same offset.  If this is the case, we want\n\t\t\t * the extent entry to always be found first if we do a\n\t\t\t * linear search through the tree, since we want to have\n\t\t\t * the quickest allocation time, and allocating from an\n\t\t\t * extent is faster than allocating from a bitmap.  So\n\t\t\t * if we're inserting a bitmap and we find an entry at\n\t\t\t * this offset, we want to go right, or after this entry\n\t\t\t * logically.  If we are inserting an extent and we've\n\t\t\t * found a bitmap, we want to go left, or before\n\t\t\t * logically.\n\t\t\t */\n\t\t\tif (bitmap) {\n\t\t\t\tif (info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\t} else {\n\t\t\t\tif (!info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\t}\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&entry->offset_index",
            "&ctl->free_space_offset"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&entry->offset_index"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->list",
            "bitmaps"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&entry->list"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&entry->offset_index"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&entry->offset_index"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&entry->offset_index"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->list",
            "bitmaps"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search_offset",
          "args": [
            "ctl",
            "offset",
            "0",
            "1"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1370-1484",
          "snippet": "static struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic noinline int\nsetup_cluster_no_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t\tstruct btrfs_free_cluster *cluster,\n\t\t\tstruct list_head *bitmaps, u64 offset, u64 bytes,\n\t\t\tu64 cont1_bytes, u64 min_bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *first = NULL;\n\tstruct btrfs_free_space *entry = NULL;\n\tstruct btrfs_free_space *last;\n\tstruct rb_node *node;\n\tu64 window_free;\n\tu64 max_extent;\n\tu64 total_size = 0;\n\n\tentry = tree_search_offset(ctl, offset, 0, 1);\n\tif (!entry)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * We don't want bitmaps, so just move along until we find a normal\n\t * extent entry.\n\t */\n\twhile (entry->bitmap || entry->bytes < min_bytes) {\n\t\tif (entry->bitmap && list_empty(&entry->list))\n\t\t\tlist_add_tail(&entry->list, bitmaps);\n\t\tnode = rb_next(&entry->offset_index);\n\t\tif (!node)\n\t\t\treturn -ENOSPC;\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t}\n\n\twindow_free = entry->bytes;\n\tmax_extent = entry->bytes;\n\tfirst = entry;\n\tlast = entry;\n\n\tfor (node = rb_next(&entry->offset_index); node;\n\t     node = rb_next(&entry->offset_index)) {\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\n\t\tif (entry->bitmap) {\n\t\t\tif (list_empty(&entry->list))\n\t\t\t\tlist_add_tail(&entry->list, bitmaps);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->bytes < min_bytes)\n\t\t\tcontinue;\n\n\t\tlast = entry;\n\t\twindow_free += entry->bytes;\n\t\tif (entry->bytes > max_extent)\n\t\t\tmax_extent = entry->bytes;\n\t}\n\n\tif (window_free < bytes || max_extent < cont1_bytes)\n\t\treturn -ENOSPC;\n\n\tcluster->window_start = first->offset;\n\n\tnode = &first->offset_index;\n\n\t/*\n\t * now we've found our entries, pull them out of the free space\n\t * cache and put them into the cluster rbtree\n\t */\n\tdo {\n\t\tint ret;\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tnode = rb_next(&entry->offset_index);\n\t\tif (entry->bitmap || entry->bytes < min_bytes)\n\t\t\tcontinue;\n\n\t\trb_erase(&entry->offset_index, &ctl->free_space_offset);\n\t\tret = tree_insert_offset(&cluster->root, entry->offset,\n\t\t\t\t\t &entry->offset_index, 0);\n\t\ttotal_size += entry->bytes;\n\t\tASSERT(!ret); /* -EEXIST; Logic error */\n\t} while (node && entry != last);\n\n\tcluster->max_size = max_extent;\n\ttrace_btrfs_setup_cluster(block_group, cluster, total_size, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_bitmap_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2649-2709",
    "snippet": "static int btrfs_bitmap_cluster(struct btrfs_block_group_cache *block_group,\n\t\t\t\tstruct btrfs_free_space *entry,\n\t\t\t\tstruct btrfs_free_cluster *cluster,\n\t\t\t\tu64 offset, u64 bytes,\n\t\t\t\tu64 cont1_bytes, u64 min_bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tunsigned long next_zero;\n\tunsigned long i;\n\tunsigned long want_bits;\n\tunsigned long min_bits;\n\tunsigned long found_bits;\n\tunsigned long start = 0;\n\tunsigned long total_found = 0;\n\tint ret;\n\n\ti = offset_to_bit(entry->offset, ctl->unit,\n\t\t\t  max_t(u64, offset, entry->offset));\n\twant_bits = bytes_to_bits(bytes, ctl->unit);\n\tmin_bits = bytes_to_bits(min_bytes, ctl->unit);\n\nagain:\n\tfound_bits = 0;\n\tfor_each_set_bit_from(i, entry->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(entry->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\tif (next_zero - i >= min_bits) {\n\t\t\tfound_bits = next_zero - i;\n\t\t\tbreak;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (!found_bits)\n\t\treturn -ENOSPC;\n\n\tif (!total_found) {\n\t\tstart = i;\n\t\tcluster->max_size = 0;\n\t}\n\n\ttotal_found += found_bits;\n\n\tif (cluster->max_size < found_bits * ctl->unit)\n\t\tcluster->max_size = found_bits * ctl->unit;\n\n\tif (total_found < want_bits || cluster->max_size < cont1_bytes) {\n\t\ti = next_zero + 1;\n\t\tgoto again;\n\t}\n\n\tcluster->window_start = start * ctl->unit + entry->offset;\n\trb_erase(&entry->offset_index, &ctl->free_space_offset);\n\tret = tree_insert_offset(&cluster->root, entry->offset,\n\t\t\t\t &entry->offset_index, 1);\n\tASSERT(!ret); /* -EEXIST; Logic error */\n\n\ttrace_btrfs_setup_cluster(block_group, cluster,\n\t\t\t\t  total_found * ctl->unit, 1);\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_btrfs_setup_cluster",
          "args": [
            "block_group",
            "cluster",
            "total_found * ctl->unit",
            "1"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!ret"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_insert_offset",
          "args": [
            "&cluster->root",
            "entry->offset",
            "&entry->offset_index",
            "1"
          ],
          "line": 2702
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1312-1361",
          "snippet": "static int tree_insert_offset(struct rb_root *root, u64 offset,\n\t\t\t      struct rb_node *node, int bitmap)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_free_space *info;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tinfo = rb_entry(parent, struct btrfs_free_space, offset_index);\n\n\t\tif (offset < info->offset) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (offset > info->offset) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we could have a bitmap entry and an extent entry\n\t\t\t * share the same offset.  If this is the case, we want\n\t\t\t * the extent entry to always be found first if we do a\n\t\t\t * linear search through the tree, since we want to have\n\t\t\t * the quickest allocation time, and allocating from an\n\t\t\t * extent is faster than allocating from a bitmap.  So\n\t\t\t * if we're inserting a bitmap and we find an entry at\n\t\t\t * this offset, we want to go right, or after this entry\n\t\t\t * logically.  If we are inserting an extent and we've\n\t\t\t * found a bitmap, we want to go left, or before\n\t\t\t * logically.\n\t\t\t */\n\t\t\tif (bitmap) {\n\t\t\t\tif (info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\t} else {\n\t\t\t\tif (!info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\t}\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int tree_insert_offset(struct rb_root *root, u64 offset,\n\t\t\t      struct rb_node *node, int bitmap)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_free_space *info;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tinfo = rb_entry(parent, struct btrfs_free_space, offset_index);\n\n\t\tif (offset < info->offset) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (offset > info->offset) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we could have a bitmap entry and an extent entry\n\t\t\t * share the same offset.  If this is the case, we want\n\t\t\t * the extent entry to always be found first if we do a\n\t\t\t * linear search through the tree, since we want to have\n\t\t\t * the quickest allocation time, and allocating from an\n\t\t\t * extent is faster than allocating from a bitmap.  So\n\t\t\t * if we're inserting a bitmap and we find an entry at\n\t\t\t * this offset, we want to go right, or after this entry\n\t\t\t * logically.  If we are inserting an extent and we've\n\t\t\t * found a bitmap, we want to go left, or before\n\t\t\t * logically.\n\t\t\t */\n\t\t\tif (bitmap) {\n\t\t\t\tif (info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\t} else {\n\t\t\t\tif (!info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\t}\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&entry->offset_index",
            "&ctl->free_space_offset"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "entry->bitmap",
            "BITS_PER_BITMAP",
            "i"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "904-916",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit_from",
          "args": [
            "i",
            "entry->bitmap",
            "BITS_PER_BITMAP"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes_to_bits",
          "args": [
            "min_bytes",
            "ctl->unit"
          ],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "bytes_to_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1292-1295",
          "snippet": "static inline unsigned long bytes_to_bits(u64 bytes, u32 unit)\n{\n\treturn (unsigned long)(div_u64(bytes, unit));\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic inline unsigned long bytes_to_bits(u64 bytes, u32 unit)\n{\n\treturn (unsigned long)(div_u64(bytes, unit));\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_bit",
          "args": [
            "entry->offset",
            "ctl->unit",
            "max_t(u64, offset, entry->offset)"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1284-1290",
          "snippet": "static inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "offset",
            "entry->offset"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int btrfs_bitmap_cluster(struct btrfs_block_group_cache *block_group,\n\t\t\t\tstruct btrfs_free_space *entry,\n\t\t\t\tstruct btrfs_free_cluster *cluster,\n\t\t\t\tu64 offset, u64 bytes,\n\t\t\t\tu64 cont1_bytes, u64 min_bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tunsigned long next_zero;\n\tunsigned long i;\n\tunsigned long want_bits;\n\tunsigned long min_bits;\n\tunsigned long found_bits;\n\tunsigned long start = 0;\n\tunsigned long total_found = 0;\n\tint ret;\n\n\ti = offset_to_bit(entry->offset, ctl->unit,\n\t\t\t  max_t(u64, offset, entry->offset));\n\twant_bits = bytes_to_bits(bytes, ctl->unit);\n\tmin_bits = bytes_to_bits(min_bytes, ctl->unit);\n\nagain:\n\tfound_bits = 0;\n\tfor_each_set_bit_from(i, entry->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(entry->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\tif (next_zero - i >= min_bits) {\n\t\t\tfound_bits = next_zero - i;\n\t\t\tbreak;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (!found_bits)\n\t\treturn -ENOSPC;\n\n\tif (!total_found) {\n\t\tstart = i;\n\t\tcluster->max_size = 0;\n\t}\n\n\ttotal_found += found_bits;\n\n\tif (cluster->max_size < found_bits * ctl->unit)\n\t\tcluster->max_size = found_bits * ctl->unit;\n\n\tif (total_found < want_bits || cluster->max_size < cont1_bytes) {\n\t\ti = next_zero + 1;\n\t\tgoto again;\n\t}\n\n\tcluster->window_start = start * ctl->unit + entry->offset;\n\trb_erase(&entry->offset_index, &ctl->free_space_offset);\n\tret = tree_insert_offset(&cluster->root, entry->offset,\n\t\t\t\t &entry->offset_index, 1);\n\tASSERT(!ret); /* -EEXIST; Logic error */\n\n\ttrace_btrfs_setup_cluster(block_group, cluster,\n\t\t\t\t  total_found * ctl->unit, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_alloc_from_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2565-2647",
    "snippet": "u64 btrfs_alloc_from_cluster(struct btrfs_block_group_cache *block_group,\n\t\t\t     struct btrfs_free_cluster *cluster, u64 bytes,\n\t\t\t     u64 min_start, u64 *max_extent_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry = NULL;\n\tstruct rb_node *node;\n\tu64 ret = 0;\n\n\tspin_lock(&cluster->lock);\n\tif (bytes > cluster->max_size)\n\t\tgoto out;\n\n\tif (cluster->block_group != block_group)\n\t\tgoto out;\n\n\tnode = rb_first(&cluster->root);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\twhile (1) {\n\t\tif (entry->bytes < bytes && entry->bytes > *max_extent_size)\n\t\t\t*max_extent_size = entry->bytes;\n\n\t\tif (entry->bytes < bytes ||\n\t\t    (!entry->bitmap && entry->offset < min_start)) {\n\t\t\tnode = rb_next(&entry->offset_index);\n\t\t\tif (!node)\n\t\t\t\tbreak;\n\t\t\tentry = rb_entry(node, struct btrfs_free_space,\n\t\t\t\t\t offset_index);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->bitmap) {\n\t\t\tret = btrfs_alloc_from_bitmap(block_group,\n\t\t\t\t\t\t      cluster, entry, bytes,\n\t\t\t\t\t\t      cluster->window_start,\n\t\t\t\t\t\t      max_extent_size);\n\t\t\tif (ret == 0) {\n\t\t\t\tnode = rb_next(&entry->offset_index);\n\t\t\t\tif (!node)\n\t\t\t\t\tbreak;\n\t\t\t\tentry = rb_entry(node, struct btrfs_free_space,\n\t\t\t\t\t\t offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcluster->window_start += bytes;\n\t\t} else {\n\t\t\tret = entry->offset;\n\n\t\t\tentry->offset += bytes;\n\t\t\tentry->bytes -= bytes;\n\t\t}\n\n\t\tif (entry->bytes == 0)\n\t\t\trb_erase(&entry->offset_index, &cluster->root);\n\t\tbreak;\n\t}\nout:\n\tspin_unlock(&cluster->lock);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tspin_lock(&ctl->tree_lock);\n\n\tctl->free_space -= bytes;\n\tif (entry->bytes == 0) {\n\t\tctl->free_extents--;\n\t\tif (entry->bitmap) {\n\t\t\tkfree(entry->bitmap);\n\t\t\tctl->total_bitmaps--;\n\t\t\tctl->op->recalc_thresholds(ctl);\n\t\t}\n\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\t}\n\n\tspin_unlock(&ctl->tree_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "entry"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctl->op->recalc_thresholds",
          "args": [
            "ctl"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry->bitmap"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&entry->offset_index",
            "&cluster->root"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&entry->offset_index"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_from_bitmap",
          "args": [
            "block_group",
            "cluster",
            "entry",
            "bytes",
            "cluster->window_start",
            "max_extent_size"
          ],
          "line": 2601
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_from_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2532-2558",
          "snippet": "static u64 btrfs_alloc_from_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t\t\t   struct btrfs_free_cluster *cluster,\n\t\t\t\t   struct btrfs_free_space *entry,\n\t\t\t\t   u64 bytes, u64 min_start,\n\t\t\t\t   u64 *max_extent_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tint err;\n\tu64 search_start = cluster->window_start;\n\tu64 search_bytes = bytes;\n\tu64 ret = 0;\n\n\tsearch_start = min_start;\n\tsearch_bytes = bytes;\n\n\terr = search_bitmap(ctl, entry, &search_start, &search_bytes);\n\tif (err) {\n\t\tif (search_bytes > *max_extent_size)\n\t\t\t*max_extent_size = search_bytes;\n\t\treturn 0;\n\t}\n\n\tret = search_start;\n\t__bitmap_clear_bits(ctl, entry, ret, bytes);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic u64 btrfs_alloc_from_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t\t\t   struct btrfs_free_cluster *cluster,\n\t\t\t\t   struct btrfs_free_space *entry,\n\t\t\t\t   u64 bytes, u64 min_start,\n\t\t\t\t   u64 *max_extent_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tint err;\n\tu64 search_start = cluster->window_start;\n\tu64 search_bytes = bytes;\n\tu64 ret = 0;\n\n\tsearch_start = min_start;\n\tsearch_bytes = bytes;\n\n\terr = search_bitmap(ctl, entry, &search_start, &search_bytes);\n\tif (err) {\n\t\tif (search_bytes > *max_extent_size)\n\t\t\t*max_extent_size = search_bytes;\n\t\treturn 0;\n\t}\n\n\tret = search_start;\n\t__bitmap_clear_bits(ctl, entry, ret, bytes);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&entry->offset_index"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&cluster->root"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nu64 btrfs_alloc_from_cluster(struct btrfs_block_group_cache *block_group,\n\t\t\t     struct btrfs_free_cluster *cluster, u64 bytes,\n\t\t\t     u64 min_start, u64 *max_extent_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry = NULL;\n\tstruct rb_node *node;\n\tu64 ret = 0;\n\n\tspin_lock(&cluster->lock);\n\tif (bytes > cluster->max_size)\n\t\tgoto out;\n\n\tif (cluster->block_group != block_group)\n\t\tgoto out;\n\n\tnode = rb_first(&cluster->root);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\twhile (1) {\n\t\tif (entry->bytes < bytes && entry->bytes > *max_extent_size)\n\t\t\t*max_extent_size = entry->bytes;\n\n\t\tif (entry->bytes < bytes ||\n\t\t    (!entry->bitmap && entry->offset < min_start)) {\n\t\t\tnode = rb_next(&entry->offset_index);\n\t\t\tif (!node)\n\t\t\t\tbreak;\n\t\t\tentry = rb_entry(node, struct btrfs_free_space,\n\t\t\t\t\t offset_index);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->bitmap) {\n\t\t\tret = btrfs_alloc_from_bitmap(block_group,\n\t\t\t\t\t\t      cluster, entry, bytes,\n\t\t\t\t\t\t      cluster->window_start,\n\t\t\t\t\t\t      max_extent_size);\n\t\t\tif (ret == 0) {\n\t\t\t\tnode = rb_next(&entry->offset_index);\n\t\t\t\tif (!node)\n\t\t\t\t\tbreak;\n\t\t\t\tentry = rb_entry(node, struct btrfs_free_space,\n\t\t\t\t\t\t offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcluster->window_start += bytes;\n\t\t} else {\n\t\t\tret = entry->offset;\n\n\t\t\tentry->offset += bytes;\n\t\t\tentry->bytes -= bytes;\n\t\t}\n\n\t\tif (entry->bytes == 0)\n\t\t\trb_erase(&entry->offset_index, &cluster->root);\n\t\tbreak;\n\t}\nout:\n\tspin_unlock(&cluster->lock);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tspin_lock(&ctl->tree_lock);\n\n\tctl->free_space -= bytes;\n\tif (entry->bytes == 0) {\n\t\tctl->free_extents--;\n\t\tif (entry->bitmap) {\n\t\t\tkfree(entry->bitmap);\n\t\t\tctl->total_bitmaps--;\n\t\t\tctl->op->recalc_thresholds(ctl);\n\t\t}\n\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\t}\n\n\tspin_unlock(&ctl->tree_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_alloc_from_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2532-2558",
    "snippet": "static u64 btrfs_alloc_from_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t\t\t   struct btrfs_free_cluster *cluster,\n\t\t\t\t   struct btrfs_free_space *entry,\n\t\t\t\t   u64 bytes, u64 min_start,\n\t\t\t\t   u64 *max_extent_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tint err;\n\tu64 search_start = cluster->window_start;\n\tu64 search_bytes = bytes;\n\tu64 ret = 0;\n\n\tsearch_start = min_start;\n\tsearch_bytes = bytes;\n\n\terr = search_bitmap(ctl, entry, &search_start, &search_bytes);\n\tif (err) {\n\t\tif (search_bytes > *max_extent_size)\n\t\t\t*max_extent_size = search_bytes;\n\t\treturn 0;\n\t}\n\n\tret = search_start;\n\t__bitmap_clear_bits(ctl, entry, ret, bytes);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bitmap_clear_bits",
          "args": [
            "ctl",
            "entry",
            "ret",
            "bytes"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "__bitmap_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1565-1578",
          "snippet": "static inline void __bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       u64 offset, u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_clear(info->bitmap, start, count);\n\n\tinfo->bytes -= bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic inline void __bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       u64 offset, u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_clear(info->bitmap, start, count);\n\n\tinfo->bytes -= bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_bitmap",
          "args": [
            "ctl",
            "entry",
            "&search_start",
            "&search_bytes"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "search_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1608-1643",
          "snippet": "static int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic u64 btrfs_alloc_from_bitmap(struct btrfs_block_group_cache *block_group,\n\t\t\t\t   struct btrfs_free_cluster *cluster,\n\t\t\t\t   struct btrfs_free_space *entry,\n\t\t\t\t   u64 bytes, u64 min_start,\n\t\t\t\t   u64 *max_extent_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tint err;\n\tu64 search_start = cluster->window_start;\n\tu64 search_bytes = bytes;\n\tu64 ret = 0;\n\n\tsearch_start = min_start;\n\tsearch_bytes = bytes;\n\n\terr = search_bitmap(ctl, entry, &search_start, &search_bytes);\n\tif (err) {\n\t\tif (search_bytes > *max_extent_size)\n\t\t\t*max_extent_size = search_bytes;\n\t\treturn 0;\n\t}\n\n\tret = search_start;\n\t__bitmap_clear_bits(ctl, entry, ret, bytes);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_return_cluster_to_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2497-2530",
    "snippet": "int btrfs_return_cluster_to_free_space(\n\t\t\t       struct btrfs_block_group_cache *block_group,\n\t\t\t       struct btrfs_free_cluster *cluster)\n{\n\tstruct btrfs_free_space_ctl *ctl;\n\tint ret;\n\n\t/* first, get a safe pointer to the block group */\n\tspin_lock(&cluster->lock);\n\tif (!block_group) {\n\t\tblock_group = cluster->block_group;\n\t\tif (!block_group) {\n\t\t\tspin_unlock(&cluster->lock);\n\t\t\treturn 0;\n\t\t}\n\t} else if (cluster->block_group != block_group) {\n\t\t/* someone else has already freed it don't redo their work */\n\t\tspin_unlock(&cluster->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&block_group->count);\n\tspin_unlock(&cluster->lock);\n\n\tctl = block_group->free_space_ctl;\n\n\t/* now return any extents the cluster had on it */\n\tspin_lock(&ctl->tree_lock);\n\tret = __btrfs_return_cluster_to_free_space(block_group, cluster);\n\tspin_unlock(&ctl->tree_lock);\n\n\t/* finally drop our ref */\n\tbtrfs_put_block_group(block_group);\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_block_group",
          "args": [
            "block_group"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_block_group_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8797-8829",
          "snippet": "void btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nvoid btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_return_cluster_to_free_space",
          "args": [
            "block_group",
            "cluster"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_return_cluster_to_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2349-2389",
          "snippet": "static int\n__btrfs_return_cluster_to_free_space(\n\t\t\t     struct btrfs_block_group_cache *block_group,\n\t\t\t     struct btrfs_free_cluster *cluster)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\n\tspin_lock(&cluster->lock);\n\tif (cluster->block_group != block_group)\n\t\tgoto out;\n\n\tcluster->block_group = NULL;\n\tcluster->window_start = 0;\n\tlist_del_init(&cluster->block_group_list);\n\n\tnode = rb_first(&cluster->root);\n\twhile (node) {\n\t\tbool bitmap;\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tnode = rb_next(&entry->offset_index);\n\t\trb_erase(&entry->offset_index, &cluster->root);\n\t\tRB_CLEAR_NODE(&entry->offset_index);\n\n\t\tbitmap = (entry->bitmap != NULL);\n\t\tif (!bitmap) {\n\t\t\ttry_merge_free_space(ctl, entry, false);\n\t\t\tsteal_from_bitmap(ctl, entry, false);\n\t\t}\n\t\ttree_insert_offset(&ctl->free_space_offset,\n\t\t\t\t   entry->offset, &entry->offset_index, bitmap);\n\t}\n\tcluster->root = RB_ROOT;\n\nout:\n\tspin_unlock(&cluster->lock);\n\tbtrfs_put_block_group(block_group);\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int\n__btrfs_return_cluster_to_free_space(\n\t\t\t     struct btrfs_block_group_cache *block_group,\n\t\t\t     struct btrfs_free_cluster *cluster)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\n\tspin_lock(&cluster->lock);\n\tif (cluster->block_group != block_group)\n\t\tgoto out;\n\n\tcluster->block_group = NULL;\n\tcluster->window_start = 0;\n\tlist_del_init(&cluster->block_group_list);\n\n\tnode = rb_first(&cluster->root);\n\twhile (node) {\n\t\tbool bitmap;\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tnode = rb_next(&entry->offset_index);\n\t\trb_erase(&entry->offset_index, &cluster->root);\n\t\tRB_CLEAR_NODE(&entry->offset_index);\n\n\t\tbitmap = (entry->bitmap != NULL);\n\t\tif (!bitmap) {\n\t\t\ttry_merge_free_space(ctl, entry, false);\n\t\t\tsteal_from_bitmap(ctl, entry, false);\n\t\t}\n\t\ttree_insert_offset(&ctl->free_space_offset,\n\t\t\t\t   entry->offset, &entry->offset_index, bitmap);\n\t}\n\tcluster->root = RB_ROOT;\n\nout:\n\tspin_unlock(&cluster->lock);\n\tbtrfs_put_block_group(block_group);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&block_group->count"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint btrfs_return_cluster_to_free_space(\n\t\t\t       struct btrfs_block_group_cache *block_group,\n\t\t\t       struct btrfs_free_cluster *cluster)\n{\n\tstruct btrfs_free_space_ctl *ctl;\n\tint ret;\n\n\t/* first, get a safe pointer to the block group */\n\tspin_lock(&cluster->lock);\n\tif (!block_group) {\n\t\tblock_group = cluster->block_group;\n\t\tif (!block_group) {\n\t\t\tspin_unlock(&cluster->lock);\n\t\t\treturn 0;\n\t\t}\n\t} else if (cluster->block_group != block_group) {\n\t\t/* someone else has already freed it don't redo their work */\n\t\tspin_unlock(&cluster->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&block_group->count);\n\tspin_unlock(&cluster->lock);\n\n\tctl = block_group->free_space_ctl;\n\n\t/* now return any extents the cluster had on it */\n\tspin_lock(&ctl->tree_lock);\n\tret = __btrfs_return_cluster_to_free_space(block_group, cluster);\n\tspin_unlock(&ctl->tree_lock);\n\n\t/* finally drop our ref */\n\tbtrfs_put_block_group(block_group);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_find_space_for_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2445-2487",
    "snippet": "u64 btrfs_find_space_for_alloc(struct btrfs_block_group_cache *block_group,\n\t\t\t       u64 offset, u64 bytes, u64 empty_size,\n\t\t\t       u64 *max_extent_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry = NULL;\n\tu64 bytes_search = bytes + empty_size;\n\tu64 ret = 0;\n\tu64 align_gap = 0;\n\tu64 align_gap_len = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tentry = find_free_space(ctl, &offset, &bytes_search,\n\t\t\t\tblock_group->full_stripe_len, max_extent_size);\n\tif (!entry)\n\t\tgoto out;\n\n\tret = offset;\n\tif (entry->bitmap) {\n\t\tbitmap_clear_bits(ctl, entry, offset, bytes);\n\t\tif (!entry->bytes)\n\t\t\tfree_bitmap(ctl, entry);\n\t} else {\n\t\tunlink_free_space(ctl, entry);\n\t\talign_gap_len = offset - entry->offset;\n\t\talign_gap = entry->offset;\n\n\t\tentry->offset = offset + bytes;\n\t\tWARN_ON(entry->bytes < bytes + align_gap_len);\n\n\t\tentry->bytes -= bytes + align_gap_len;\n\t\tif (!entry->bytes)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\t\telse\n\t\t\tlink_free_space(ctl, entry);\n\t}\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (align_gap_len)\n\t\t__btrfs_add_free_space(ctl, align_gap, align_gap_len);\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_add_free_space",
          "args": [
            "ctl",
            "align_gap",
            "align_gap_len"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2155-2207",
          "snippet": "int __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_free_space",
          "args": [
            "ctl",
            "entry"
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "link_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1501-1515",
          "snippet": "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "entry"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "entry->bytes < bytes + align_gap_len"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink_free_space",
          "args": [
            "ctl",
            "entry"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1494-1499",
          "snippet": "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_bitmap",
          "args": [
            "ctl",
            "entry"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "free_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1724-1732",
          "snippet": "static void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_clear_bits",
          "args": [
            "ctl",
            "entry",
            "offset",
            "bytes"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1580-1586",
          "snippet": "static void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_free_space",
          "args": [
            "ctl",
            "&offset",
            "&bytes_search",
            "block_group->full_stripe_len",
            "max_extent_size"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "find_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1646-1710",
          "snippet": "static struct btrfs_free_space *\nfind_free_space(struct btrfs_free_space_ctl *ctl, u64 *offset, u64 *bytes,\n\t\tunsigned long align, u64 *max_extent_size)\n{\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\tu64 tmp;\n\tu64 align_off;\n\tint ret;\n\n\tif (!ctl->free_space_offset.rb_node)\n\t\tgoto out;\n\n\tentry = tree_search_offset(ctl, offset_to_bitmap(ctl, *offset), 0, 1);\n\tif (!entry)\n\t\tgoto out;\n\n\tfor (node = &entry->offset_index; node; node = rb_next(node)) {\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (entry->bytes < *bytes) {\n\t\t\tif (entry->bytes > *max_extent_size)\n\t\t\t\t*max_extent_size = entry->bytes;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* make sure the space returned is big enough\n\t\t * to match our requested alignment\n\t\t */\n\t\tif (*bytes >= align) {\n\t\t\ttmp = entry->offset - ctl->start + align - 1;\n\t\t\tdo_div(tmp, align);\n\t\t\ttmp = tmp * align + ctl->start;\n\t\t\talign_off = tmp - entry->offset;\n\t\t} else {\n\t\t\talign_off = 0;\n\t\t\ttmp = entry->offset;\n\t\t}\n\n\t\tif (entry->bytes < *bytes + align_off) {\n\t\t\tif (entry->bytes > *max_extent_size)\n\t\t\t\t*max_extent_size = entry->bytes;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->bitmap) {\n\t\t\tu64 size = *bytes;\n\n\t\t\tret = search_bitmap(ctl, entry, &tmp, &size);\n\t\t\tif (!ret) {\n\t\t\t\t*offset = tmp;\n\t\t\t\t*bytes = size;\n\t\t\t\treturn entry;\n\t\t\t} else if (size > *max_extent_size) {\n\t\t\t\t*max_extent_size = size;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t*offset = tmp;\n\t\t*bytes = entry->bytes - align_off;\n\t\treturn entry;\n\t}\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic struct btrfs_free_space *\nfind_free_space(struct btrfs_free_space_ctl *ctl, u64 *offset, u64 *bytes,\n\t\tunsigned long align, u64 *max_extent_size)\n{\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\tu64 tmp;\n\tu64 align_off;\n\tint ret;\n\n\tif (!ctl->free_space_offset.rb_node)\n\t\tgoto out;\n\n\tentry = tree_search_offset(ctl, offset_to_bitmap(ctl, *offset), 0, 1);\n\tif (!entry)\n\t\tgoto out;\n\n\tfor (node = &entry->offset_index; node; node = rb_next(node)) {\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (entry->bytes < *bytes) {\n\t\t\tif (entry->bytes > *max_extent_size)\n\t\t\t\t*max_extent_size = entry->bytes;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* make sure the space returned is big enough\n\t\t * to match our requested alignment\n\t\t */\n\t\tif (*bytes >= align) {\n\t\t\ttmp = entry->offset - ctl->start + align - 1;\n\t\t\tdo_div(tmp, align);\n\t\t\ttmp = tmp * align + ctl->start;\n\t\t\talign_off = tmp - entry->offset;\n\t\t} else {\n\t\t\talign_off = 0;\n\t\t\ttmp = entry->offset;\n\t\t}\n\n\t\tif (entry->bytes < *bytes + align_off) {\n\t\t\tif (entry->bytes > *max_extent_size)\n\t\t\t\t*max_extent_size = entry->bytes;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->bitmap) {\n\t\t\tu64 size = *bytes;\n\n\t\t\tret = search_bitmap(ctl, entry, &tmp, &size);\n\t\t\tif (!ret) {\n\t\t\t\t*offset = tmp;\n\t\t\t\t*bytes = size;\n\t\t\t\treturn entry;\n\t\t\t} else if (size > *max_extent_size) {\n\t\t\t\t*max_extent_size = size;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t*offset = tmp;\n\t\t*bytes = entry->bytes - align_off;\n\t\treturn entry;\n\t}\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nu64 btrfs_find_space_for_alloc(struct btrfs_block_group_cache *block_group,\n\t\t\t       u64 offset, u64 bytes, u64 empty_size,\n\t\t\t       u64 *max_extent_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry = NULL;\n\tu64 bytes_search = bytes + empty_size;\n\tu64 ret = 0;\n\tu64 align_gap = 0;\n\tu64 align_gap_len = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tentry = find_free_space(ctl, &offset, &bytes_search,\n\t\t\t\tblock_group->full_stripe_len, max_extent_size);\n\tif (!entry)\n\t\tgoto out;\n\n\tret = offset;\n\tif (entry->bitmap) {\n\t\tbitmap_clear_bits(ctl, entry, offset, bytes);\n\t\tif (!entry->bytes)\n\t\t\tfree_bitmap(ctl, entry);\n\t} else {\n\t\tunlink_free_space(ctl, entry);\n\t\talign_gap_len = offset - entry->offset;\n\t\talign_gap = entry->offset;\n\n\t\tentry->offset = offset + bytes;\n\t\tWARN_ON(entry->bytes < bytes + align_gap_len);\n\n\t\tentry->bytes -= bytes + align_gap_len;\n\t\tif (!entry->bytes)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\t\telse\n\t\t\tlink_free_space(ctl, entry);\n\t}\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (align_gap_len)\n\t\t__btrfs_add_free_space(ctl, align_gap, align_gap_len);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_remove_free_space_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2420-2443",
    "snippet": "void btrfs_remove_free_space_cache(struct btrfs_block_group_cache *block_group)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_cluster *cluster;\n\tstruct list_head *head;\n\n\tspin_lock(&ctl->tree_lock);\n\twhile ((head = block_group->cluster_list.next) !=\n\t       &block_group->cluster_list) {\n\t\tcluster = list_entry(head, struct btrfs_free_cluster,\n\t\t\t\t     block_group_list);\n\n\t\tWARN_ON(cluster->block_group != block_group);\n\t\t__btrfs_return_cluster_to_free_space(block_group, cluster);\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t}\n\t}\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_remove_free_space_cache_locked",
          "args": [
            "ctl"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_remove_free_space_cache_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2391-2411",
          "snippet": "static void __btrfs_remove_free_space_cache_locked(\n\t\t\t\tstruct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *node;\n\n\twhile ((node = rb_last(&ctl->free_space_offset)) != NULL) {\n\t\tinfo = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (!info->bitmap) {\n\t\t\tunlink_free_space(ctl, info);\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t} else {\n\t\t\tfree_bitmap(ctl, info);\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void __btrfs_remove_free_space_cache_locked(\n\t\t\t\tstruct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *node;\n\n\twhile ((node = rb_last(&ctl->free_space_offset)) != NULL) {\n\t\tinfo = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (!info->bitmap) {\n\t\t\tunlink_free_space(ctl, info);\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t} else {\n\t\t\tfree_bitmap(ctl, info);\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_return_cluster_to_free_space",
          "args": [
            "block_group",
            "cluster"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_return_cluster_to_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2349-2389",
          "snippet": "static int\n__btrfs_return_cluster_to_free_space(\n\t\t\t     struct btrfs_block_group_cache *block_group,\n\t\t\t     struct btrfs_free_cluster *cluster)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\n\tspin_lock(&cluster->lock);\n\tif (cluster->block_group != block_group)\n\t\tgoto out;\n\n\tcluster->block_group = NULL;\n\tcluster->window_start = 0;\n\tlist_del_init(&cluster->block_group_list);\n\n\tnode = rb_first(&cluster->root);\n\twhile (node) {\n\t\tbool bitmap;\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tnode = rb_next(&entry->offset_index);\n\t\trb_erase(&entry->offset_index, &cluster->root);\n\t\tRB_CLEAR_NODE(&entry->offset_index);\n\n\t\tbitmap = (entry->bitmap != NULL);\n\t\tif (!bitmap) {\n\t\t\ttry_merge_free_space(ctl, entry, false);\n\t\t\tsteal_from_bitmap(ctl, entry, false);\n\t\t}\n\t\ttree_insert_offset(&ctl->free_space_offset,\n\t\t\t\t   entry->offset, &entry->offset_index, bitmap);\n\t}\n\tcluster->root = RB_ROOT;\n\nout:\n\tspin_unlock(&cluster->lock);\n\tbtrfs_put_block_group(block_group);\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int\n__btrfs_return_cluster_to_free_space(\n\t\t\t     struct btrfs_block_group_cache *block_group,\n\t\t\t     struct btrfs_free_cluster *cluster)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\n\tspin_lock(&cluster->lock);\n\tif (cluster->block_group != block_group)\n\t\tgoto out;\n\n\tcluster->block_group = NULL;\n\tcluster->window_start = 0;\n\tlist_del_init(&cluster->block_group_list);\n\n\tnode = rb_first(&cluster->root);\n\twhile (node) {\n\t\tbool bitmap;\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tnode = rb_next(&entry->offset_index);\n\t\trb_erase(&entry->offset_index, &cluster->root);\n\t\tRB_CLEAR_NODE(&entry->offset_index);\n\n\t\tbitmap = (entry->bitmap != NULL);\n\t\tif (!bitmap) {\n\t\t\ttry_merge_free_space(ctl, entry, false);\n\t\t\tsteal_from_bitmap(ctl, entry, false);\n\t\t}\n\t\ttree_insert_offset(&ctl->free_space_offset,\n\t\t\t\t   entry->offset, &entry->offset_index, bitmap);\n\t}\n\tcluster->root = RB_ROOT;\n\nout:\n\tspin_unlock(&cluster->lock);\n\tbtrfs_put_block_group(block_group);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cluster->block_group != block_group"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head",
            "structbtrfs_free_cluster",
            "block_group_list"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nvoid btrfs_remove_free_space_cache(struct btrfs_block_group_cache *block_group)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_cluster *cluster;\n\tstruct list_head *head;\n\n\tspin_lock(&ctl->tree_lock);\n\twhile ((head = block_group->cluster_list.next) !=\n\t       &block_group->cluster_list) {\n\t\tcluster = list_entry(head, struct btrfs_free_cluster,\n\t\t\t\t     block_group_list);\n\n\t\tWARN_ON(cluster->block_group != block_group);\n\t\t__btrfs_return_cluster_to_free_space(block_group, cluster);\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t}\n\t}\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n\n}"
  },
  {
    "function_name": "__btrfs_remove_free_space_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2413-2418",
    "snippet": "void __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_remove_free_space_cache_locked",
          "args": [
            "ctl"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_remove_free_space_cache_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2391-2411",
          "snippet": "static void __btrfs_remove_free_space_cache_locked(\n\t\t\t\tstruct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *node;\n\n\twhile ((node = rb_last(&ctl->free_space_offset)) != NULL) {\n\t\tinfo = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (!info->bitmap) {\n\t\t\tunlink_free_space(ctl, info);\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t} else {\n\t\t\tfree_bitmap(ctl, info);\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void __btrfs_remove_free_space_cache_locked(\n\t\t\t\tstruct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *node;\n\n\twhile ((node = rb_last(&ctl->free_space_offset)) != NULL) {\n\t\tinfo = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (!info->bitmap) {\n\t\t\tunlink_free_space(ctl, info);\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t} else {\n\t\t\tfree_bitmap(ctl, info);\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nvoid __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}"
  },
  {
    "function_name": "__btrfs_remove_free_space_cache_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2391-2411",
    "snippet": "static void __btrfs_remove_free_space_cache_locked(\n\t\t\t\tstruct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *node;\n\n\twhile ((node = rb_last(&ctl->free_space_offset)) != NULL) {\n\t\tinfo = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (!info->bitmap) {\n\t\t\tunlink_free_space(ctl, info);\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t} else {\n\t\t\tfree_bitmap(ctl, info);\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_bitmap",
          "args": [
            "ctl",
            "info"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "free_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1724-1732",
          "snippet": "static void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "info"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink_free_space",
          "args": [
            "ctl",
            "info"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1494-1499",
          "snippet": "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_last",
          "args": [
            "&ctl->free_space_offset"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void __btrfs_remove_free_space_cache_locked(\n\t\t\t\tstruct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *node;\n\n\twhile ((node = rb_last(&ctl->free_space_offset)) != NULL) {\n\t\tinfo = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (!info->bitmap) {\n\t\t\tunlink_free_space(ctl, info);\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t} else {\n\t\t\tfree_bitmap(ctl, info);\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__btrfs_return_cluster_to_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2349-2389",
    "snippet": "static int\n__btrfs_return_cluster_to_free_space(\n\t\t\t     struct btrfs_block_group_cache *block_group,\n\t\t\t     struct btrfs_free_cluster *cluster)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\n\tspin_lock(&cluster->lock);\n\tif (cluster->block_group != block_group)\n\t\tgoto out;\n\n\tcluster->block_group = NULL;\n\tcluster->window_start = 0;\n\tlist_del_init(&cluster->block_group_list);\n\n\tnode = rb_first(&cluster->root);\n\twhile (node) {\n\t\tbool bitmap;\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tnode = rb_next(&entry->offset_index);\n\t\trb_erase(&entry->offset_index, &cluster->root);\n\t\tRB_CLEAR_NODE(&entry->offset_index);\n\n\t\tbitmap = (entry->bitmap != NULL);\n\t\tif (!bitmap) {\n\t\t\ttry_merge_free_space(ctl, entry, false);\n\t\t\tsteal_from_bitmap(ctl, entry, false);\n\t\t}\n\t\ttree_insert_offset(&ctl->free_space_offset,\n\t\t\t\t   entry->offset, &entry->offset_index, bitmap);\n\t}\n\tcluster->root = RB_ROOT;\n\nout:\n\tspin_unlock(&cluster->lock);\n\tbtrfs_put_block_group(block_group);\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_block_group",
          "args": [
            "block_group"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_block_group_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8797-8829",
          "snippet": "void btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nvoid btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cluster->lock"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_insert_offset",
          "args": [
            "&ctl->free_space_offset",
            "entry->offset",
            "&entry->offset_index",
            "bitmap"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1312-1361",
          "snippet": "static int tree_insert_offset(struct rb_root *root, u64 offset,\n\t\t\t      struct rb_node *node, int bitmap)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_free_space *info;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tinfo = rb_entry(parent, struct btrfs_free_space, offset_index);\n\n\t\tif (offset < info->offset) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (offset > info->offset) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we could have a bitmap entry and an extent entry\n\t\t\t * share the same offset.  If this is the case, we want\n\t\t\t * the extent entry to always be found first if we do a\n\t\t\t * linear search through the tree, since we want to have\n\t\t\t * the quickest allocation time, and allocating from an\n\t\t\t * extent is faster than allocating from a bitmap.  So\n\t\t\t * if we're inserting a bitmap and we find an entry at\n\t\t\t * this offset, we want to go right, or after this entry\n\t\t\t * logically.  If we are inserting an extent and we've\n\t\t\t * found a bitmap, we want to go left, or before\n\t\t\t * logically.\n\t\t\t */\n\t\t\tif (bitmap) {\n\t\t\t\tif (info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\t} else {\n\t\t\t\tif (!info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\t}\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int tree_insert_offset(struct rb_root *root, u64 offset,\n\t\t\t      struct rb_node *node, int bitmap)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_free_space *info;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tinfo = rb_entry(parent, struct btrfs_free_space, offset_index);\n\n\t\tif (offset < info->offset) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (offset > info->offset) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we could have a bitmap entry and an extent entry\n\t\t\t * share the same offset.  If this is the case, we want\n\t\t\t * the extent entry to always be found first if we do a\n\t\t\t * linear search through the tree, since we want to have\n\t\t\t * the quickest allocation time, and allocating from an\n\t\t\t * extent is faster than allocating from a bitmap.  So\n\t\t\t * if we're inserting a bitmap and we find an entry at\n\t\t\t * this offset, we want to go right, or after this entry\n\t\t\t * logically.  If we are inserting an extent and we've\n\t\t\t * found a bitmap, we want to go left, or before\n\t\t\t * logically.\n\t\t\t */\n\t\t\tif (bitmap) {\n\t\t\t\tif (info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\t} else {\n\t\t\t\tif (!info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\t}\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "steal_from_bitmap",
          "args": [
            "ctl",
            "entry",
            "false"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "steal_from_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2130-2153",
          "snippet": "static void steal_from_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info,\n\t\t\t      bool update_stat)\n{\n\t/*\n\t * Only work with disconnected entries, as we can change their offset,\n\t * and must be extent entries.\n\t */\n\tASSERT(!info->bitmap);\n\tASSERT(RB_EMPTY_NODE(&info->offset_index));\n\n\tif (ctl->total_bitmaps > 0) {\n\t\tbool stole_end;\n\t\tbool stole_front = false;\n\n\t\tstole_end = steal_from_bitmap_to_end(ctl, info, update_stat);\n\t\tif (ctl->total_bitmaps > 0)\n\t\t\tstole_front = steal_from_bitmap_to_front(ctl, info,\n\t\t\t\t\t\t\t\t update_stat);\n\n\t\tif (stole_end || stole_front)\n\t\t\ttry_merge_free_space(ctl, info, update_stat);\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void steal_from_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info,\n\t\t\t      bool update_stat)\n{\n\t/*\n\t * Only work with disconnected entries, as we can change their offset,\n\t * and must be extent entries.\n\t */\n\tASSERT(!info->bitmap);\n\tASSERT(RB_EMPTY_NODE(&info->offset_index));\n\n\tif (ctl->total_bitmaps > 0) {\n\t\tbool stole_end;\n\t\tbool stole_front = false;\n\n\t\tstole_end = steal_from_bitmap_to_end(ctl, info, update_stat);\n\t\tif (ctl->total_bitmaps > 0)\n\t\t\tstole_front = steal_from_bitmap_to_front(ctl, info,\n\t\t\t\t\t\t\t\t update_stat);\n\n\t\tif (stole_end || stole_front)\n\t\t\ttry_merge_free_space(ctl, info, update_stat);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_merge_free_space",
          "args": [
            "ctl",
            "entry",
            "false"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "try_merge_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1987-2031",
          "snippet": "static bool try_merge_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t  struct btrfs_free_space *info, bool update_stat)\n{\n\tstruct btrfs_free_space *left_info;\n\tstruct btrfs_free_space *right_info;\n\tbool merged = false;\n\tu64 offset = info->offset;\n\tu64 bytes = info->bytes;\n\n\t/*\n\t * first we want to see if there is free space adjacent to the range we\n\t * are adding, if there is remove that struct and add a new one to\n\t * cover the entire range\n\t */\n\tright_info = tree_search_offset(ctl, offset + bytes, 0, 0);\n\tif (right_info && rb_prev(&right_info->offset_index))\n\t\tleft_info = rb_entry(rb_prev(&right_info->offset_index),\n\t\t\t\t     struct btrfs_free_space, offset_index);\n\telse\n\t\tleft_info = tree_search_offset(ctl, offset - 1, 0, 0);\n\n\tif (right_info && !right_info->bitmap) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, right_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, right_info);\n\t\tinfo->bytes += right_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, right_info);\n\t\tmerged = true;\n\t}\n\n\tif (left_info && !left_info->bitmap &&\n\t    left_info->offset + left_info->bytes == offset) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, left_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, left_info);\n\t\tinfo->offset = left_info->offset;\n\t\tinfo->bytes += left_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, left_info);\n\t\tmerged = true;\n\t}\n\n\treturn merged;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic bool try_merge_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t  struct btrfs_free_space *info, bool update_stat)\n{\n\tstruct btrfs_free_space *left_info;\n\tstruct btrfs_free_space *right_info;\n\tbool merged = false;\n\tu64 offset = info->offset;\n\tu64 bytes = info->bytes;\n\n\t/*\n\t * first we want to see if there is free space adjacent to the range we\n\t * are adding, if there is remove that struct and add a new one to\n\t * cover the entire range\n\t */\n\tright_info = tree_search_offset(ctl, offset + bytes, 0, 0);\n\tif (right_info && rb_prev(&right_info->offset_index))\n\t\tleft_info = rb_entry(rb_prev(&right_info->offset_index),\n\t\t\t\t     struct btrfs_free_space, offset_index);\n\telse\n\t\tleft_info = tree_search_offset(ctl, offset - 1, 0, 0);\n\n\tif (right_info && !right_info->bitmap) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, right_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, right_info);\n\t\tinfo->bytes += right_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, right_info);\n\t\tmerged = true;\n\t}\n\n\tif (left_info && !left_info->bitmap &&\n\t    left_info->offset + left_info->bytes == offset) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, left_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, left_info);\n\t\tinfo->offset = left_info->offset;\n\t\tinfo->bytes += left_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, left_info);\n\t\tmerged = true;\n\t}\n\n\treturn merged;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&entry->offset_index"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&entry->offset_index",
            "&cluster->root"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&entry->offset_index"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&cluster->root"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cluster->block_group_list"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cluster->lock"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int\n__btrfs_return_cluster_to_free_space(\n\t\t\t     struct btrfs_block_group_cache *block_group,\n\t\t\t     struct btrfs_free_cluster *cluster)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\n\tspin_lock(&cluster->lock);\n\tif (cluster->block_group != block_group)\n\t\tgoto out;\n\n\tcluster->block_group = NULL;\n\tcluster->window_start = 0;\n\tlist_del_init(&cluster->block_group_list);\n\n\tnode = rb_first(&cluster->root);\n\twhile (node) {\n\t\tbool bitmap;\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tnode = rb_next(&entry->offset_index);\n\t\trb_erase(&entry->offset_index, &cluster->root);\n\t\tRB_CLEAR_NODE(&entry->offset_index);\n\n\t\tbitmap = (entry->bitmap != NULL);\n\t\tif (!bitmap) {\n\t\t\ttry_merge_free_space(ctl, entry, false);\n\t\t\tsteal_from_bitmap(ctl, entry, false);\n\t\t}\n\t\ttree_insert_offset(&ctl->free_space_offset,\n\t\t\t\t   entry->offset, &entry->offset_index, bitmap);\n\t}\n\tcluster->root = RB_ROOT;\n\nout:\n\tspin_unlock(&cluster->lock);\n\tbtrfs_put_block_group(block_group);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_init_free_space_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2322-2341",
    "snippet": "void btrfs_init_free_space_ctl(struct btrfs_block_group_cache *block_group)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\n\tspin_lock_init(&ctl->tree_lock);\n\tctl->unit = block_group->sectorsize;\n\tctl->start = block_group->key.objectid;\n\tctl->private = block_group;\n\tctl->op = &free_space_op;\n\tINIT_LIST_HEAD(&ctl->trimming_ranges);\n\tmutex_init(&ctl->cache_writeout_mutex);\n\n\t/*\n\t * we only want to have 32k of ram per block group for keeping\n\t * track of free space, and if we pass 1/2 of that we want to\n\t * start converting things over to using bitmaps\n\t */\n\tctl->extents_thresh = ((1024 * 32) / 2) /\n\t\t\t\tsizeof(struct btrfs_free_space);\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct btrfs_free_space_op free_space_op = {\n\t.recalc_thresholds\t= recalculate_thresholds,\n\t.use_bitmap\t\t= use_bitmap,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ctl->trimming_ranges"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic struct btrfs_free_space_op free_space_op = {\n\t.recalc_thresholds\t= recalculate_thresholds,\n\t.use_bitmap\t\t= use_bitmap,\n};\n\nvoid btrfs_init_free_space_ctl(struct btrfs_block_group_cache *block_group)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\n\tspin_lock_init(&ctl->tree_lock);\n\tctl->unit = block_group->sectorsize;\n\tctl->start = block_group->key.objectid;\n\tctl->private = block_group;\n\tctl->op = &free_space_op;\n\tINIT_LIST_HEAD(&ctl->trimming_ranges);\n\tmutex_init(&ctl->cache_writeout_mutex);\n\n\t/*\n\t * we only want to have 32k of ram per block group for keeping\n\t * track of free space, and if we pass 1/2 of that we want to\n\t * start converting things over to using bitmaps\n\t */\n\tctl->extents_thresh = ((1024 * 32) / 2) /\n\t\t\t\tsizeof(struct btrfs_free_space);\n}"
  },
  {
    "function_name": "btrfs_dump_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2299-2320",
    "snippet": "void btrfs_dump_free_space(struct btrfs_block_group_cache *block_group,\n\t\t\t   u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *n;\n\tint count = 0;\n\n\tfor (n = rb_first(&ctl->free_space_offset); n; n = rb_next(n)) {\n\t\tinfo = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (info->bytes >= bytes && !block_group->ro)\n\t\t\tcount++;\n\t\tbtrfs_crit(block_group->fs_info,\n\t\t\t   \"entry offset %llu, bytes %llu, bitmap %s\",\n\t\t\t   info->offset, info->bytes,\n\t\t       (info->bitmap) ? \"yes\" : \"no\");\n\t}\n\tbtrfs_info(block_group->fs_info, \"block group has cluster?: %s\",\n\t       list_empty(&block_group->cluster_list) ? \"no\" : \"yes\");\n\tbtrfs_info(block_group->fs_info,\n\t\t   \"%d blocks of free space at or bigger than bytes is\", count);\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "block_group->fs_info",
            "\"%d blocks of free space at or bigger than bytes is\"",
            "count"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "block_group->fs_info",
            "\"block group has cluster?: %s\"",
            "list_empty(&block_group->cluster_list) ? \"no\" : \"yes\""
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&block_group->cluster_list"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "block_group->fs_info",
            "\"entry offset %llu, bytes %llu, bitmap %s\"",
            "info->offset",
            "info->bytes",
            "(info->bitmap) ? \"yes\" : \"no\""
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ctl->free_space_offset"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nvoid btrfs_dump_free_space(struct btrfs_block_group_cache *block_group,\n\t\t\t   u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *n;\n\tint count = 0;\n\n\tfor (n = rb_first(&ctl->free_space_offset); n; n = rb_next(n)) {\n\t\tinfo = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (info->bytes >= bytes && !block_group->ro)\n\t\t\tcount++;\n\t\tbtrfs_crit(block_group->fs_info,\n\t\t\t   \"entry offset %llu, bytes %llu, bitmap %s\",\n\t\t\t   info->offset, info->bytes,\n\t\t       (info->bitmap) ? \"yes\" : \"no\");\n\t}\n\tbtrfs_info(block_group->fs_info, \"block group has cluster?: %s\",\n\t       list_empty(&block_group->cluster_list) ? \"no\" : \"yes\");\n\tbtrfs_info(block_group->fs_info,\n\t\t   \"%d blocks of free space at or bigger than bytes is\", count);\n}"
  },
  {
    "function_name": "btrfs_remove_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2209-2297",
    "snippet": "int btrfs_remove_free_space(struct btrfs_block_group_cache *block_group,\n\t\t\t    u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret;\n\tbool re_search = false;\n\n\tspin_lock(&ctl->tree_lock);\n\nagain:\n\tret = 0;\n\tif (!bytes)\n\t\tgoto out_lock;\n\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\t/*\n\t\t * oops didn't find an extent that matched the space we wanted\n\t\t * to remove, look for a bitmap instead\n\t\t */\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info) {\n\t\t\t/*\n\t\t\t * If we found a partial bit of our free space in a\n\t\t\t * bitmap but then couldn't find the other part this may\n\t\t\t * be a problem, so WARN about it.\n\t\t\t */\n\t\t\tWARN_ON(re_search);\n\t\t\tgoto out_lock;\n\t\t}\n\t}\n\n\tre_search = false;\n\tif (!info->bitmap) {\n\t\tunlink_free_space(ctl, info);\n\t\tif (offset == info->offset) {\n\t\t\tu64 to_free = min(bytes, info->bytes);\n\n\t\t\tinfo->bytes -= to_free;\n\t\t\tinfo->offset += to_free;\n\t\t\tif (info->bytes) {\n\t\t\t\tret = link_free_space(ctl, info);\n\t\t\t\tWARN_ON(ret);\n\t\t\t} else {\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\t}\n\n\t\t\toffset += to_free;\n\t\t\tbytes -= to_free;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tu64 old_end = info->bytes + info->offset;\n\n\t\t\tinfo->bytes = offset - info->offset;\n\t\t\tret = link_free_space(ctl, info);\n\t\t\tWARN_ON(ret);\n\t\t\tif (ret)\n\t\t\t\tgoto out_lock;\n\n\t\t\t/* Not enough bytes in this entry to satisfy us */\n\t\t\tif (old_end < offset + bytes) {\n\t\t\t\tbytes -= old_end - offset;\n\t\t\t\toffset = old_end;\n\t\t\t\tgoto again;\n\t\t\t} else if (old_end == offset + bytes) {\n\t\t\t\t/* all done */\n\t\t\t\tgoto out_lock;\n\t\t\t}\n\t\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t\tret = btrfs_add_free_space(block_group, offset + bytes,\n\t\t\t\t\t\t   old_end - (offset + bytes));\n\t\t\tWARN_ON(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = remove_from_bitmap(ctl, info, &offset, &bytes);\n\tif (ret == -EAGAIN) {\n\t\tre_search = true;\n\t\tgoto again;\n\t}\nout_lock:\n\tspin_unlock(&ctl->tree_lock);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_bitmap",
          "args": [
            "ctl",
            "info",
            "&offset",
            "&bytes"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1734-1808",
          "snippet": "static noinline int remove_from_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *bitmap_info,\n\t\t\t      u64 *offset, u64 *bytes)\n{\n\tu64 end;\n\tu64 search_start, search_bytes;\n\tint ret;\n\nagain:\n\tend = bitmap_info->offset + (u64)(BITS_PER_BITMAP * ctl->unit) - 1;\n\n\t/*\n\t * We need to search for bits in this bitmap.  We could only cover some\n\t * of the extent in this bitmap thanks to how we add space, so we need\n\t * to search for as much as it as we can and clear that amount, and then\n\t * go searching for the next bit.\n\t */\n\tsearch_start = *offset;\n\tsearch_bytes = ctl->unit;\n\tsearch_bytes = min(search_bytes, end - search_start + 1);\n\tret = search_bitmap(ctl, bitmap_info, &search_start, &search_bytes);\n\tif (ret < 0 || search_start != *offset)\n\t\treturn -EINVAL;\n\n\t/* We may have found more bits than what we need */\n\tsearch_bytes = min(search_bytes, *bytes);\n\n\t/* Cannot clear past the end of the bitmap */\n\tsearch_bytes = min(search_bytes, end - search_start + 1);\n\n\tbitmap_clear_bits(ctl, bitmap_info, search_start, search_bytes);\n\t*offset += search_bytes;\n\t*bytes -= search_bytes;\n\n\tif (*bytes) {\n\t\tstruct rb_node *next = rb_next(&bitmap_info->offset_index);\n\t\tif (!bitmap_info->bytes)\n\t\t\tfree_bitmap(ctl, bitmap_info);\n\n\t\t/*\n\t\t * no entry after this bitmap, but we still have bytes to\n\t\t * remove, so something has gone wrong.\n\t\t */\n\t\tif (!next)\n\t\t\treturn -EINVAL;\n\n\t\tbitmap_info = rb_entry(next, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\n\t\t/*\n\t\t * if the next entry isn't a bitmap we need to return to let the\n\t\t * extent stuff do its work.\n\t\t */\n\t\tif (!bitmap_info->bitmap)\n\t\t\treturn -EAGAIN;\n\n\t\t/*\n\t\t * Ok the next item is a bitmap, but it may not actually hold\n\t\t * the information for the rest of this free space stuff, so\n\t\t * look for it, and if we don't find it return so we can try\n\t\t * everything over again.\n\t\t */\n\t\tsearch_start = *offset;\n\t\tsearch_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, bitmap_info, &search_start,\n\t\t\t\t    &search_bytes);\n\t\tif (ret < 0 || search_start != *offset)\n\t\t\treturn -EAGAIN;\n\n\t\tgoto again;\n\t} else if (!bitmap_info->bytes)\n\t\tfree_bitmap(ctl, bitmap_info);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic noinline int remove_from_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *bitmap_info,\n\t\t\t      u64 *offset, u64 *bytes)\n{\n\tu64 end;\n\tu64 search_start, search_bytes;\n\tint ret;\n\nagain:\n\tend = bitmap_info->offset + (u64)(BITS_PER_BITMAP * ctl->unit) - 1;\n\n\t/*\n\t * We need to search for bits in this bitmap.  We could only cover some\n\t * of the extent in this bitmap thanks to how we add space, so we need\n\t * to search for as much as it as we can and clear that amount, and then\n\t * go searching for the next bit.\n\t */\n\tsearch_start = *offset;\n\tsearch_bytes = ctl->unit;\n\tsearch_bytes = min(search_bytes, end - search_start + 1);\n\tret = search_bitmap(ctl, bitmap_info, &search_start, &search_bytes);\n\tif (ret < 0 || search_start != *offset)\n\t\treturn -EINVAL;\n\n\t/* We may have found more bits than what we need */\n\tsearch_bytes = min(search_bytes, *bytes);\n\n\t/* Cannot clear past the end of the bitmap */\n\tsearch_bytes = min(search_bytes, end - search_start + 1);\n\n\tbitmap_clear_bits(ctl, bitmap_info, search_start, search_bytes);\n\t*offset += search_bytes;\n\t*bytes -= search_bytes;\n\n\tif (*bytes) {\n\t\tstruct rb_node *next = rb_next(&bitmap_info->offset_index);\n\t\tif (!bitmap_info->bytes)\n\t\t\tfree_bitmap(ctl, bitmap_info);\n\n\t\t/*\n\t\t * no entry after this bitmap, but we still have bytes to\n\t\t * remove, so something has gone wrong.\n\t\t */\n\t\tif (!next)\n\t\t\treturn -EINVAL;\n\n\t\tbitmap_info = rb_entry(next, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\n\t\t/*\n\t\t * if the next entry isn't a bitmap we need to return to let the\n\t\t * extent stuff do its work.\n\t\t */\n\t\tif (!bitmap_info->bitmap)\n\t\t\treturn -EAGAIN;\n\n\t\t/*\n\t\t * Ok the next item is a bitmap, but it may not actually hold\n\t\t * the information for the rest of this free space stuff, so\n\t\t * look for it, and if we don't find it return so we can try\n\t\t * everything over again.\n\t\t */\n\t\tsearch_start = *offset;\n\t\tsearch_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, bitmap_info, &search_start,\n\t\t\t\t    &search_bytes);\n\t\tif (ret < 0 || search_start != *offset)\n\t\t\treturn -EAGAIN;\n\n\t\tgoto again;\n\t} else if (!bitmap_info->bytes)\n\t\tfree_bitmap(ctl, bitmap_info);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_add_free_space",
          "args": [
            "block_group",
            "offset + bytes",
            "old_end - (offset + bytes)"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2155-2207",
          "snippet": "int __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_free_space",
          "args": [
            "ctl",
            "info"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "link_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1501-1515",
          "snippet": "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "info"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes",
            "info->bytes"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_free_space",
          "args": [
            "ctl",
            "info"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1494-1499",
          "snippet": "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "re_search"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search_offset",
          "args": [
            "ctl",
            "offset_to_bitmap(ctl, offset)",
            "1",
            "0"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1370-1484",
          "snippet": "static struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_bitmap",
          "args": [
            "ctl",
            "offset"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1297-1310",
          "snippet": "static inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint btrfs_remove_free_space(struct btrfs_block_group_cache *block_group,\n\t\t\t    u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret;\n\tbool re_search = false;\n\n\tspin_lock(&ctl->tree_lock);\n\nagain:\n\tret = 0;\n\tif (!bytes)\n\t\tgoto out_lock;\n\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\t/*\n\t\t * oops didn't find an extent that matched the space we wanted\n\t\t * to remove, look for a bitmap instead\n\t\t */\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info) {\n\t\t\t/*\n\t\t\t * If we found a partial bit of our free space in a\n\t\t\t * bitmap but then couldn't find the other part this may\n\t\t\t * be a problem, so WARN about it.\n\t\t\t */\n\t\t\tWARN_ON(re_search);\n\t\t\tgoto out_lock;\n\t\t}\n\t}\n\n\tre_search = false;\n\tif (!info->bitmap) {\n\t\tunlink_free_space(ctl, info);\n\t\tif (offset == info->offset) {\n\t\t\tu64 to_free = min(bytes, info->bytes);\n\n\t\t\tinfo->bytes -= to_free;\n\t\t\tinfo->offset += to_free;\n\t\t\tif (info->bytes) {\n\t\t\t\tret = link_free_space(ctl, info);\n\t\t\t\tWARN_ON(ret);\n\t\t\t} else {\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\t}\n\n\t\t\toffset += to_free;\n\t\t\tbytes -= to_free;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tu64 old_end = info->bytes + info->offset;\n\n\t\t\tinfo->bytes = offset - info->offset;\n\t\t\tret = link_free_space(ctl, info);\n\t\t\tWARN_ON(ret);\n\t\t\tif (ret)\n\t\t\t\tgoto out_lock;\n\n\t\t\t/* Not enough bytes in this entry to satisfy us */\n\t\t\tif (old_end < offset + bytes) {\n\t\t\t\tbytes -= old_end - offset;\n\t\t\t\toffset = old_end;\n\t\t\t\tgoto again;\n\t\t\t} else if (old_end == offset + bytes) {\n\t\t\t\t/* all done */\n\t\t\t\tgoto out_lock;\n\t\t\t}\n\t\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t\tret = btrfs_add_free_space(block_group, offset + bytes,\n\t\t\t\t\t\t   old_end - (offset + bytes));\n\t\t\tWARN_ON(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = remove_from_bitmap(ctl, info, &offset, &bytes);\n\tif (ret == -EAGAIN) {\n\t\tre_search = true;\n\t\tgoto again;\n\t}\nout_lock:\n\tspin_unlock(&ctl->tree_lock);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "__btrfs_add_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2155-2207",
    "snippet": "int __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ret != -EEXIST"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"BTRFS: unable to add free space :%d\\n\"",
            "ret"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "info"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_free_space",
          "args": [
            "ctl",
            "info"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "link_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1501-1515",
          "snippet": "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "steal_from_bitmap",
          "args": [
            "ctl",
            "info",
            "true"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "steal_from_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2130-2153",
          "snippet": "static void steal_from_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info,\n\t\t\t      bool update_stat)\n{\n\t/*\n\t * Only work with disconnected entries, as we can change their offset,\n\t * and must be extent entries.\n\t */\n\tASSERT(!info->bitmap);\n\tASSERT(RB_EMPTY_NODE(&info->offset_index));\n\n\tif (ctl->total_bitmaps > 0) {\n\t\tbool stole_end;\n\t\tbool stole_front = false;\n\n\t\tstole_end = steal_from_bitmap_to_end(ctl, info, update_stat);\n\t\tif (ctl->total_bitmaps > 0)\n\t\t\tstole_front = steal_from_bitmap_to_front(ctl, info,\n\t\t\t\t\t\t\t\t update_stat);\n\n\t\tif (stole_end || stole_front)\n\t\t\ttry_merge_free_space(ctl, info, update_stat);\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void steal_from_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info,\n\t\t\t      bool update_stat)\n{\n\t/*\n\t * Only work with disconnected entries, as we can change their offset,\n\t * and must be extent entries.\n\t */\n\tASSERT(!info->bitmap);\n\tASSERT(RB_EMPTY_NODE(&info->offset_index));\n\n\tif (ctl->total_bitmaps > 0) {\n\t\tbool stole_end;\n\t\tbool stole_front = false;\n\n\t\tstole_end = steal_from_bitmap_to_end(ctl, info, update_stat);\n\t\tif (ctl->total_bitmaps > 0)\n\t\t\tstole_front = steal_from_bitmap_to_front(ctl, info,\n\t\t\t\t\t\t\t\t update_stat);\n\n\t\tif (stole_end || stole_front)\n\t\t\ttry_merge_free_space(ctl, info, update_stat);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_into_bitmap",
          "args": [
            "ctl",
            "info"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "insert_into_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1871-1985",
          "snippet": "static int insert_into_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\tstruct btrfs_free_space *bitmap_info;\n\tstruct btrfs_block_group_cache *block_group = NULL;\n\tint added = 0;\n\tu64 bytes, offset, bytes_added;\n\tint ret;\n\n\tbytes = info->bytes;\n\toffset = info->offset;\n\n\tif (!ctl->op->use_bitmap(ctl, info))\n\t\treturn 0;\n\n\tif (ctl->op == &free_space_op)\n\t\tblock_group = ctl->private;\nagain:\n\t/*\n\t * Since we link bitmaps right into the cluster we need to see if we\n\t * have a cluster here, and if so and it has our bitmap we need to add\n\t * the free space to that bitmap.\n\t */\n\tif (block_group && !list_empty(&block_group->cluster_list)) {\n\t\tstruct btrfs_free_cluster *cluster;\n\t\tstruct rb_node *node;\n\t\tstruct btrfs_free_space *entry;\n\n\t\tcluster = list_entry(block_group->cluster_list.next,\n\t\t\t\t     struct btrfs_free_cluster,\n\t\t\t\t     block_group_list);\n\t\tspin_lock(&cluster->lock);\n\t\tnode = rb_first(&cluster->root);\n\t\tif (!node) {\n\t\t\tspin_unlock(&cluster->lock);\n\t\t\tgoto no_cluster_bitmap;\n\t\t}\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (!entry->bitmap) {\n\t\t\tspin_unlock(&cluster->lock);\n\t\t\tgoto no_cluster_bitmap;\n\t\t}\n\n\t\tif (entry->offset == offset_to_bitmap(ctl, offset)) {\n\t\t\tbytes_added = add_bytes_to_bitmap(ctl, entry,\n\t\t\t\t\t\t\t  offset, bytes);\n\t\t\tbytes -= bytes_added;\n\t\t\toffset += bytes_added;\n\t\t}\n\t\tspin_unlock(&cluster->lock);\n\t\tif (!bytes) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nno_cluster_bitmap:\n\tbitmap_info = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t 1, 0);\n\tif (!bitmap_info) {\n\t\tASSERT(added == 0);\n\t\tgoto new_bitmap;\n\t}\n\n\tbytes_added = add_bytes_to_bitmap(ctl, bitmap_info, offset, bytes);\n\tbytes -= bytes_added;\n\toffset += bytes_added;\n\tadded = 0;\n\n\tif (!bytes) {\n\t\tret = 1;\n\t\tgoto out;\n\t} else\n\t\tgoto again;\n\nnew_bitmap:\n\tif (info && info->bitmap) {\n\t\tadd_new_bitmap(ctl, info, offset);\n\t\tadded = 1;\n\t\tinfo = NULL;\n\t\tgoto again;\n\t} else {\n\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t/* no pre-allocated info, allocate a new one */\n\t\tif (!info) {\n\t\t\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep,\n\t\t\t\t\t\t GFP_NOFS);\n\t\t\tif (!info) {\n\t\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* allocate the bitmap */\n\t\tinfo->bitmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\tspin_lock(&ctl->tree_lock);\n\t\tif (!info->bitmap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\nout:\n\tif (info) {\n\t\tif (info->bitmap)\n\t\t\tkfree(info->bitmap);\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);",
            "static struct btrfs_free_space_op free_space_op = {\n\t.recalc_thresholds\t= recalculate_thresholds,\n\t.use_bitmap\t\t= use_bitmap,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\nstatic struct btrfs_free_space_op free_space_op = {\n\t.recalc_thresholds\t= recalculate_thresholds,\n\t.use_bitmap\t\t= use_bitmap,\n};\n\nstatic int insert_into_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\tstruct btrfs_free_space *bitmap_info;\n\tstruct btrfs_block_group_cache *block_group = NULL;\n\tint added = 0;\n\tu64 bytes, offset, bytes_added;\n\tint ret;\n\n\tbytes = info->bytes;\n\toffset = info->offset;\n\n\tif (!ctl->op->use_bitmap(ctl, info))\n\t\treturn 0;\n\n\tif (ctl->op == &free_space_op)\n\t\tblock_group = ctl->private;\nagain:\n\t/*\n\t * Since we link bitmaps right into the cluster we need to see if we\n\t * have a cluster here, and if so and it has our bitmap we need to add\n\t * the free space to that bitmap.\n\t */\n\tif (block_group && !list_empty(&block_group->cluster_list)) {\n\t\tstruct btrfs_free_cluster *cluster;\n\t\tstruct rb_node *node;\n\t\tstruct btrfs_free_space *entry;\n\n\t\tcluster = list_entry(block_group->cluster_list.next,\n\t\t\t\t     struct btrfs_free_cluster,\n\t\t\t\t     block_group_list);\n\t\tspin_lock(&cluster->lock);\n\t\tnode = rb_first(&cluster->root);\n\t\tif (!node) {\n\t\t\tspin_unlock(&cluster->lock);\n\t\t\tgoto no_cluster_bitmap;\n\t\t}\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (!entry->bitmap) {\n\t\t\tspin_unlock(&cluster->lock);\n\t\t\tgoto no_cluster_bitmap;\n\t\t}\n\n\t\tif (entry->offset == offset_to_bitmap(ctl, offset)) {\n\t\t\tbytes_added = add_bytes_to_bitmap(ctl, entry,\n\t\t\t\t\t\t\t  offset, bytes);\n\t\t\tbytes -= bytes_added;\n\t\t\toffset += bytes_added;\n\t\t}\n\t\tspin_unlock(&cluster->lock);\n\t\tif (!bytes) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nno_cluster_bitmap:\n\tbitmap_info = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t 1, 0);\n\tif (!bitmap_info) {\n\t\tASSERT(added == 0);\n\t\tgoto new_bitmap;\n\t}\n\n\tbytes_added = add_bytes_to_bitmap(ctl, bitmap_info, offset, bytes);\n\tbytes -= bytes_added;\n\toffset += bytes_added;\n\tadded = 0;\n\n\tif (!bytes) {\n\t\tret = 1;\n\t\tgoto out;\n\t} else\n\t\tgoto again;\n\nnew_bitmap:\n\tif (info && info->bitmap) {\n\t\tadd_new_bitmap(ctl, info, offset);\n\t\tadded = 1;\n\t\tinfo = NULL;\n\t\tgoto again;\n\t} else {\n\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t/* no pre-allocated info, allocate a new one */\n\t\tif (!info) {\n\t\t\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep,\n\t\t\t\t\t\t GFP_NOFS);\n\t\t\tif (!info) {\n\t\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* allocate the bitmap */\n\t\tinfo->bitmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\tspin_lock(&ctl->tree_lock);\n\t\tif (!info->bitmap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\nout:\n\tif (info) {\n\t\tif (info->bitmap)\n\t\t\tkfree(info->bitmap);\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_merge_free_space",
          "args": [
            "ctl",
            "info",
            "true"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "try_merge_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1987-2031",
          "snippet": "static bool try_merge_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t  struct btrfs_free_space *info, bool update_stat)\n{\n\tstruct btrfs_free_space *left_info;\n\tstruct btrfs_free_space *right_info;\n\tbool merged = false;\n\tu64 offset = info->offset;\n\tu64 bytes = info->bytes;\n\n\t/*\n\t * first we want to see if there is free space adjacent to the range we\n\t * are adding, if there is remove that struct and add a new one to\n\t * cover the entire range\n\t */\n\tright_info = tree_search_offset(ctl, offset + bytes, 0, 0);\n\tif (right_info && rb_prev(&right_info->offset_index))\n\t\tleft_info = rb_entry(rb_prev(&right_info->offset_index),\n\t\t\t\t     struct btrfs_free_space, offset_index);\n\telse\n\t\tleft_info = tree_search_offset(ctl, offset - 1, 0, 0);\n\n\tif (right_info && !right_info->bitmap) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, right_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, right_info);\n\t\tinfo->bytes += right_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, right_info);\n\t\tmerged = true;\n\t}\n\n\tif (left_info && !left_info->bitmap &&\n\t    left_info->offset + left_info->bytes == offset) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, left_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, left_info);\n\t\tinfo->offset = left_info->offset;\n\t\tinfo->bytes += left_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, left_info);\n\t\tmerged = true;\n\t}\n\n\treturn merged;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic bool try_merge_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t  struct btrfs_free_space *info, bool update_stat)\n{\n\tstruct btrfs_free_space *left_info;\n\tstruct btrfs_free_space *right_info;\n\tbool merged = false;\n\tu64 offset = info->offset;\n\tu64 bytes = info->bytes;\n\n\t/*\n\t * first we want to see if there is free space adjacent to the range we\n\t * are adding, if there is remove that struct and add a new one to\n\t * cover the entire range\n\t */\n\tright_info = tree_search_offset(ctl, offset + bytes, 0, 0);\n\tif (right_info && rb_prev(&right_info->offset_index))\n\t\tleft_info = rb_entry(rb_prev(&right_info->offset_index),\n\t\t\t\t     struct btrfs_free_space, offset_index);\n\telse\n\t\tleft_info = tree_search_offset(ctl, offset - 1, 0, 0);\n\n\tif (right_info && !right_info->bitmap) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, right_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, right_info);\n\t\tinfo->bytes += right_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, right_info);\n\t\tmerged = true;\n\t}\n\n\tif (left_info && !left_info->bitmap &&\n\t    left_info->offset + left_info->bytes == offset) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, left_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, left_info);\n\t\tinfo->offset = left_info->offset;\n\t\tinfo->bytes += left_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, left_info);\n\t\tmerged = true;\n\t}\n\n\treturn merged;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&info->offset_index"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "btrfs_free_space_cachep",
            "GFP_NOFS"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "steal_from_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2130-2153",
    "snippet": "static void steal_from_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info,\n\t\t\t      bool update_stat)\n{\n\t/*\n\t * Only work with disconnected entries, as we can change their offset,\n\t * and must be extent entries.\n\t */\n\tASSERT(!info->bitmap);\n\tASSERT(RB_EMPTY_NODE(&info->offset_index));\n\n\tif (ctl->total_bitmaps > 0) {\n\t\tbool stole_end;\n\t\tbool stole_front = false;\n\n\t\tstole_end = steal_from_bitmap_to_end(ctl, info, update_stat);\n\t\tif (ctl->total_bitmaps > 0)\n\t\t\tstole_front = steal_from_bitmap_to_front(ctl, info,\n\t\t\t\t\t\t\t\t update_stat);\n\n\t\tif (stole_end || stole_front)\n\t\t\ttry_merge_free_space(ctl, info, update_stat);\n\t}\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_merge_free_space",
          "args": [
            "ctl",
            "info",
            "update_stat"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "try_merge_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1987-2031",
          "snippet": "static bool try_merge_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t  struct btrfs_free_space *info, bool update_stat)\n{\n\tstruct btrfs_free_space *left_info;\n\tstruct btrfs_free_space *right_info;\n\tbool merged = false;\n\tu64 offset = info->offset;\n\tu64 bytes = info->bytes;\n\n\t/*\n\t * first we want to see if there is free space adjacent to the range we\n\t * are adding, if there is remove that struct and add a new one to\n\t * cover the entire range\n\t */\n\tright_info = tree_search_offset(ctl, offset + bytes, 0, 0);\n\tif (right_info && rb_prev(&right_info->offset_index))\n\t\tleft_info = rb_entry(rb_prev(&right_info->offset_index),\n\t\t\t\t     struct btrfs_free_space, offset_index);\n\telse\n\t\tleft_info = tree_search_offset(ctl, offset - 1, 0, 0);\n\n\tif (right_info && !right_info->bitmap) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, right_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, right_info);\n\t\tinfo->bytes += right_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, right_info);\n\t\tmerged = true;\n\t}\n\n\tif (left_info && !left_info->bitmap &&\n\t    left_info->offset + left_info->bytes == offset) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, left_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, left_info);\n\t\tinfo->offset = left_info->offset;\n\t\tinfo->bytes += left_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, left_info);\n\t\tmerged = true;\n\t}\n\n\treturn merged;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic bool try_merge_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t  struct btrfs_free_space *info, bool update_stat)\n{\n\tstruct btrfs_free_space *left_info;\n\tstruct btrfs_free_space *right_info;\n\tbool merged = false;\n\tu64 offset = info->offset;\n\tu64 bytes = info->bytes;\n\n\t/*\n\t * first we want to see if there is free space adjacent to the range we\n\t * are adding, if there is remove that struct and add a new one to\n\t * cover the entire range\n\t */\n\tright_info = tree_search_offset(ctl, offset + bytes, 0, 0);\n\tif (right_info && rb_prev(&right_info->offset_index))\n\t\tleft_info = rb_entry(rb_prev(&right_info->offset_index),\n\t\t\t\t     struct btrfs_free_space, offset_index);\n\telse\n\t\tleft_info = tree_search_offset(ctl, offset - 1, 0, 0);\n\n\tif (right_info && !right_info->bitmap) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, right_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, right_info);\n\t\tinfo->bytes += right_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, right_info);\n\t\tmerged = true;\n\t}\n\n\tif (left_info && !left_info->bitmap &&\n\t    left_info->offset + left_info->bytes == offset) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, left_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, left_info);\n\t\tinfo->offset = left_info->offset;\n\t\tinfo->bytes += left_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, left_info);\n\t\tmerged = true;\n\t}\n\n\treturn merged;\n}"
        }
      },
      {
        "call_info": {
          "callee": "steal_from_bitmap_to_front",
          "args": [
            "ctl",
            "info",
            "update_stat"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "steal_from_bitmap_to_front",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2066-2117",
          "snippet": "static bool steal_from_bitmap_to_front(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       bool update_stat)\n{\n\tstruct btrfs_free_space *bitmap;\n\tu64 bitmap_offset;\n\tunsigned long i;\n\tunsigned long j;\n\tunsigned long prev_j;\n\tu64 bytes;\n\n\tbitmap_offset = offset_to_bitmap(ctl, info->offset);\n\t/* If we're on a boundary, try the previous logical bitmap. */\n\tif (bitmap_offset == info->offset) {\n\t\tif (info->offset == 0)\n\t\t\treturn false;\n\t\tbitmap_offset = offset_to_bitmap(ctl, info->offset - 1);\n\t}\n\n\tbitmap = tree_search_offset(ctl, bitmap_offset, 1, 0);\n\tif (!bitmap)\n\t\treturn false;\n\n\ti = offset_to_bit(bitmap->offset, ctl->unit, info->offset) - 1;\n\tj = 0;\n\tprev_j = (unsigned long)-1;\n\tfor_each_clear_bit_from(j, bitmap->bitmap, BITS_PER_BITMAP) {\n\t\tif (j > i)\n\t\t\tbreak;\n\t\tprev_j = j;\n\t}\n\tif (prev_j == i)\n\t\treturn false;\n\n\tif (prev_j == (unsigned long)-1)\n\t\tbytes = (i + 1) * ctl->unit;\n\telse\n\t\tbytes = (i - prev_j) * ctl->unit;\n\n\tinfo->offset -= bytes;\n\tinfo->bytes += bytes;\n\n\tif (update_stat)\n\t\tbitmap_clear_bits(ctl, bitmap, info->offset, bytes);\n\telse\n\t\t__bitmap_clear_bits(ctl, bitmap, info->offset, bytes);\n\n\tif (!bitmap->bytes)\n\t\tfree_bitmap(ctl, bitmap);\n\n\treturn true;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic bool steal_from_bitmap_to_front(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       bool update_stat)\n{\n\tstruct btrfs_free_space *bitmap;\n\tu64 bitmap_offset;\n\tunsigned long i;\n\tunsigned long j;\n\tunsigned long prev_j;\n\tu64 bytes;\n\n\tbitmap_offset = offset_to_bitmap(ctl, info->offset);\n\t/* If we're on a boundary, try the previous logical bitmap. */\n\tif (bitmap_offset == info->offset) {\n\t\tif (info->offset == 0)\n\t\t\treturn false;\n\t\tbitmap_offset = offset_to_bitmap(ctl, info->offset - 1);\n\t}\n\n\tbitmap = tree_search_offset(ctl, bitmap_offset, 1, 0);\n\tif (!bitmap)\n\t\treturn false;\n\n\ti = offset_to_bit(bitmap->offset, ctl->unit, info->offset) - 1;\n\tj = 0;\n\tprev_j = (unsigned long)-1;\n\tfor_each_clear_bit_from(j, bitmap->bitmap, BITS_PER_BITMAP) {\n\t\tif (j > i)\n\t\t\tbreak;\n\t\tprev_j = j;\n\t}\n\tif (prev_j == i)\n\t\treturn false;\n\n\tif (prev_j == (unsigned long)-1)\n\t\tbytes = (i + 1) * ctl->unit;\n\telse\n\t\tbytes = (i - prev_j) * ctl->unit;\n\n\tinfo->offset -= bytes;\n\tinfo->bytes += bytes;\n\n\tif (update_stat)\n\t\tbitmap_clear_bits(ctl, bitmap, info->offset, bytes);\n\telse\n\t\t__bitmap_clear_bits(ctl, bitmap, info->offset, bytes);\n\n\tif (!bitmap->bytes)\n\t\tfree_bitmap(ctl, bitmap);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "steal_from_bitmap_to_end",
          "args": [
            "ctl",
            "info",
            "update_stat"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "steal_from_bitmap_to_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2033-2064",
          "snippet": "static bool steal_from_bitmap_to_end(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t     struct btrfs_free_space *info,\n\t\t\t\t     bool update_stat)\n{\n\tstruct btrfs_free_space *bitmap;\n\tunsigned long i;\n\tunsigned long j;\n\tconst u64 end = info->offset + info->bytes;\n\tconst u64 bitmap_offset = offset_to_bitmap(ctl, end);\n\tu64 bytes;\n\n\tbitmap = tree_search_offset(ctl, bitmap_offset, 1, 0);\n\tif (!bitmap)\n\t\treturn false;\n\n\ti = offset_to_bit(bitmap->offset, ctl->unit, end);\n\tj = find_next_zero_bit(bitmap->bitmap, BITS_PER_BITMAP, i);\n\tif (j == i)\n\t\treturn false;\n\tbytes = (j - i) * ctl->unit;\n\tinfo->bytes += bytes;\n\n\tif (update_stat)\n\t\tbitmap_clear_bits(ctl, bitmap, end, bytes);\n\telse\n\t\t__bitmap_clear_bits(ctl, bitmap, end, bytes);\n\n\tif (!bitmap->bytes)\n\t\tfree_bitmap(ctl, bitmap);\n\n\treturn true;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic bool steal_from_bitmap_to_end(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t     struct btrfs_free_space *info,\n\t\t\t\t     bool update_stat)\n{\n\tstruct btrfs_free_space *bitmap;\n\tunsigned long i;\n\tunsigned long j;\n\tconst u64 end = info->offset + info->bytes;\n\tconst u64 bitmap_offset = offset_to_bitmap(ctl, end);\n\tu64 bytes;\n\n\tbitmap = tree_search_offset(ctl, bitmap_offset, 1, 0);\n\tif (!bitmap)\n\t\treturn false;\n\n\ti = offset_to_bit(bitmap->offset, ctl->unit, end);\n\tj = find_next_zero_bit(bitmap->bitmap, BITS_PER_BITMAP, i);\n\tif (j == i)\n\t\treturn false;\n\tbytes = (j - i) * ctl->unit;\n\tinfo->bytes += bytes;\n\n\tif (update_stat)\n\t\tbitmap_clear_bits(ctl, bitmap, end, bytes);\n\telse\n\t\t__bitmap_clear_bits(ctl, bitmap, end, bytes);\n\n\tif (!bitmap->bytes)\n\t\tfree_bitmap(ctl, bitmap);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "RB_EMPTY_NODE(&info->offset_index)"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&info->offset_index"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!info->bitmap"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void steal_from_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info,\n\t\t\t      bool update_stat)\n{\n\t/*\n\t * Only work with disconnected entries, as we can change their offset,\n\t * and must be extent entries.\n\t */\n\tASSERT(!info->bitmap);\n\tASSERT(RB_EMPTY_NODE(&info->offset_index));\n\n\tif (ctl->total_bitmaps > 0) {\n\t\tbool stole_end;\n\t\tbool stole_front = false;\n\n\t\tstole_end = steal_from_bitmap_to_end(ctl, info, update_stat);\n\t\tif (ctl->total_bitmaps > 0)\n\t\t\tstole_front = steal_from_bitmap_to_front(ctl, info,\n\t\t\t\t\t\t\t\t update_stat);\n\n\t\tif (stole_end || stole_front)\n\t\t\ttry_merge_free_space(ctl, info, update_stat);\n\t}\n}"
  },
  {
    "function_name": "steal_from_bitmap_to_front",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2066-2117",
    "snippet": "static bool steal_from_bitmap_to_front(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       bool update_stat)\n{\n\tstruct btrfs_free_space *bitmap;\n\tu64 bitmap_offset;\n\tunsigned long i;\n\tunsigned long j;\n\tunsigned long prev_j;\n\tu64 bytes;\n\n\tbitmap_offset = offset_to_bitmap(ctl, info->offset);\n\t/* If we're on a boundary, try the previous logical bitmap. */\n\tif (bitmap_offset == info->offset) {\n\t\tif (info->offset == 0)\n\t\t\treturn false;\n\t\tbitmap_offset = offset_to_bitmap(ctl, info->offset - 1);\n\t}\n\n\tbitmap = tree_search_offset(ctl, bitmap_offset, 1, 0);\n\tif (!bitmap)\n\t\treturn false;\n\n\ti = offset_to_bit(bitmap->offset, ctl->unit, info->offset) - 1;\n\tj = 0;\n\tprev_j = (unsigned long)-1;\n\tfor_each_clear_bit_from(j, bitmap->bitmap, BITS_PER_BITMAP) {\n\t\tif (j > i)\n\t\t\tbreak;\n\t\tprev_j = j;\n\t}\n\tif (prev_j == i)\n\t\treturn false;\n\n\tif (prev_j == (unsigned long)-1)\n\t\tbytes = (i + 1) * ctl->unit;\n\telse\n\t\tbytes = (i - prev_j) * ctl->unit;\n\n\tinfo->offset -= bytes;\n\tinfo->bytes += bytes;\n\n\tif (update_stat)\n\t\tbitmap_clear_bits(ctl, bitmap, info->offset, bytes);\n\telse\n\t\t__bitmap_clear_bits(ctl, bitmap, info->offset, bytes);\n\n\tif (!bitmap->bytes)\n\t\tfree_bitmap(ctl, bitmap);\n\n\treturn true;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_bitmap",
          "args": [
            "ctl",
            "bitmap"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "free_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1724-1732",
          "snippet": "static void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bitmap_clear_bits",
          "args": [
            "ctl",
            "bitmap",
            "info->offset",
            "bytes"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "__bitmap_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1565-1578",
          "snippet": "static inline void __bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       u64 offset, u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_clear(info->bitmap, start, count);\n\n\tinfo->bytes -= bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic inline void __bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       u64 offset, u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_clear(info->bitmap, start, count);\n\n\tinfo->bytes -= bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_clear_bits",
          "args": [
            "ctl",
            "bitmap",
            "info->offset",
            "bytes"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1580-1586",
          "snippet": "static void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_clear_bit_from",
          "args": [
            "j",
            "bitmap->bitmap",
            "BITS_PER_BITMAP"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_to_bit",
          "args": [
            "bitmap->offset",
            "ctl->unit",
            "info->offset"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1284-1290",
          "snippet": "static inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_search_offset",
          "args": [
            "ctl",
            "bitmap_offset",
            "1",
            "0"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1370-1484",
          "snippet": "static struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_bitmap",
          "args": [
            "ctl",
            "info->offset - 1"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1297-1310",
          "snippet": "static inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic bool steal_from_bitmap_to_front(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       bool update_stat)\n{\n\tstruct btrfs_free_space *bitmap;\n\tu64 bitmap_offset;\n\tunsigned long i;\n\tunsigned long j;\n\tunsigned long prev_j;\n\tu64 bytes;\n\n\tbitmap_offset = offset_to_bitmap(ctl, info->offset);\n\t/* If we're on a boundary, try the previous logical bitmap. */\n\tif (bitmap_offset == info->offset) {\n\t\tif (info->offset == 0)\n\t\t\treturn false;\n\t\tbitmap_offset = offset_to_bitmap(ctl, info->offset - 1);\n\t}\n\n\tbitmap = tree_search_offset(ctl, bitmap_offset, 1, 0);\n\tif (!bitmap)\n\t\treturn false;\n\n\ti = offset_to_bit(bitmap->offset, ctl->unit, info->offset) - 1;\n\tj = 0;\n\tprev_j = (unsigned long)-1;\n\tfor_each_clear_bit_from(j, bitmap->bitmap, BITS_PER_BITMAP) {\n\t\tif (j > i)\n\t\t\tbreak;\n\t\tprev_j = j;\n\t}\n\tif (prev_j == i)\n\t\treturn false;\n\n\tif (prev_j == (unsigned long)-1)\n\t\tbytes = (i + 1) * ctl->unit;\n\telse\n\t\tbytes = (i - prev_j) * ctl->unit;\n\n\tinfo->offset -= bytes;\n\tinfo->bytes += bytes;\n\n\tif (update_stat)\n\t\tbitmap_clear_bits(ctl, bitmap, info->offset, bytes);\n\telse\n\t\t__bitmap_clear_bits(ctl, bitmap, info->offset, bytes);\n\n\tif (!bitmap->bytes)\n\t\tfree_bitmap(ctl, bitmap);\n\n\treturn true;\n}"
  },
  {
    "function_name": "steal_from_bitmap_to_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "2033-2064",
    "snippet": "static bool steal_from_bitmap_to_end(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t     struct btrfs_free_space *info,\n\t\t\t\t     bool update_stat)\n{\n\tstruct btrfs_free_space *bitmap;\n\tunsigned long i;\n\tunsigned long j;\n\tconst u64 end = info->offset + info->bytes;\n\tconst u64 bitmap_offset = offset_to_bitmap(ctl, end);\n\tu64 bytes;\n\n\tbitmap = tree_search_offset(ctl, bitmap_offset, 1, 0);\n\tif (!bitmap)\n\t\treturn false;\n\n\ti = offset_to_bit(bitmap->offset, ctl->unit, end);\n\tj = find_next_zero_bit(bitmap->bitmap, BITS_PER_BITMAP, i);\n\tif (j == i)\n\t\treturn false;\n\tbytes = (j - i) * ctl->unit;\n\tinfo->bytes += bytes;\n\n\tif (update_stat)\n\t\tbitmap_clear_bits(ctl, bitmap, end, bytes);\n\telse\n\t\t__bitmap_clear_bits(ctl, bitmap, end, bytes);\n\n\tif (!bitmap->bytes)\n\t\tfree_bitmap(ctl, bitmap);\n\n\treturn true;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_bitmap",
          "args": [
            "ctl",
            "bitmap"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "free_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1724-1732",
          "snippet": "static void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bitmap_clear_bits",
          "args": [
            "ctl",
            "bitmap",
            "end",
            "bytes"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "__bitmap_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1565-1578",
          "snippet": "static inline void __bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       u64 offset, u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_clear(info->bitmap, start, count);\n\n\tinfo->bytes -= bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic inline void __bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       u64 offset, u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_clear(info->bitmap, start, count);\n\n\tinfo->bytes -= bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_clear_bits",
          "args": [
            "ctl",
            "bitmap",
            "end",
            "bytes"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1580-1586",
          "snippet": "static void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "bitmap->bitmap",
            "BITS_PER_BITMAP",
            "i"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "904-916",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_bit",
          "args": [
            "bitmap->offset",
            "ctl->unit",
            "end"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1284-1290",
          "snippet": "static inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_search_offset",
          "args": [
            "ctl",
            "bitmap_offset",
            "1",
            "0"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1370-1484",
          "snippet": "static struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_bitmap",
          "args": [
            "ctl",
            "end"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1297-1310",
          "snippet": "static inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic bool steal_from_bitmap_to_end(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t     struct btrfs_free_space *info,\n\t\t\t\t     bool update_stat)\n{\n\tstruct btrfs_free_space *bitmap;\n\tunsigned long i;\n\tunsigned long j;\n\tconst u64 end = info->offset + info->bytes;\n\tconst u64 bitmap_offset = offset_to_bitmap(ctl, end);\n\tu64 bytes;\n\n\tbitmap = tree_search_offset(ctl, bitmap_offset, 1, 0);\n\tif (!bitmap)\n\t\treturn false;\n\n\ti = offset_to_bit(bitmap->offset, ctl->unit, end);\n\tj = find_next_zero_bit(bitmap->bitmap, BITS_PER_BITMAP, i);\n\tif (j == i)\n\t\treturn false;\n\tbytes = (j - i) * ctl->unit;\n\tinfo->bytes += bytes;\n\n\tif (update_stat)\n\t\tbitmap_clear_bits(ctl, bitmap, end, bytes);\n\telse\n\t\t__bitmap_clear_bits(ctl, bitmap, end, bytes);\n\n\tif (!bitmap->bytes)\n\t\tfree_bitmap(ctl, bitmap);\n\n\treturn true;\n}"
  },
  {
    "function_name": "try_merge_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1987-2031",
    "snippet": "static bool try_merge_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t  struct btrfs_free_space *info, bool update_stat)\n{\n\tstruct btrfs_free_space *left_info;\n\tstruct btrfs_free_space *right_info;\n\tbool merged = false;\n\tu64 offset = info->offset;\n\tu64 bytes = info->bytes;\n\n\t/*\n\t * first we want to see if there is free space adjacent to the range we\n\t * are adding, if there is remove that struct and add a new one to\n\t * cover the entire range\n\t */\n\tright_info = tree_search_offset(ctl, offset + bytes, 0, 0);\n\tif (right_info && rb_prev(&right_info->offset_index))\n\t\tleft_info = rb_entry(rb_prev(&right_info->offset_index),\n\t\t\t\t     struct btrfs_free_space, offset_index);\n\telse\n\t\tleft_info = tree_search_offset(ctl, offset - 1, 0, 0);\n\n\tif (right_info && !right_info->bitmap) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, right_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, right_info);\n\t\tinfo->bytes += right_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, right_info);\n\t\tmerged = true;\n\t}\n\n\tif (left_info && !left_info->bitmap &&\n\t    left_info->offset + left_info->bytes == offset) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, left_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, left_info);\n\t\tinfo->offset = left_info->offset;\n\t\tinfo->bytes += left_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, left_info);\n\t\tmerged = true;\n\t}\n\n\treturn merged;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "left_info"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unlink_free_space",
          "args": [
            "ctl",
            "left_info"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "__unlink_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1486-1492",
          "snippet": "static inline void\n__unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t    struct btrfs_free_space *info)\n{\n\trb_erase(&info->offset_index, &ctl->free_space_offset);\n\tctl->free_extents--;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic inline void\n__unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t    struct btrfs_free_space *info)\n{\n\trb_erase(&info->offset_index, &ctl->free_space_offset);\n\tctl->free_extents--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_free_space",
          "args": [
            "ctl",
            "left_info"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1494-1499",
          "snippet": "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "right_info"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search_offset",
          "args": [
            "ctl",
            "offset - 1",
            "0",
            "0"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1370-1484",
          "snippet": "static struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_prev(&right_info->offset_index)",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&right_info->offset_index"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&right_info->offset_index"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic bool try_merge_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t  struct btrfs_free_space *info, bool update_stat)\n{\n\tstruct btrfs_free_space *left_info;\n\tstruct btrfs_free_space *right_info;\n\tbool merged = false;\n\tu64 offset = info->offset;\n\tu64 bytes = info->bytes;\n\n\t/*\n\t * first we want to see if there is free space adjacent to the range we\n\t * are adding, if there is remove that struct and add a new one to\n\t * cover the entire range\n\t */\n\tright_info = tree_search_offset(ctl, offset + bytes, 0, 0);\n\tif (right_info && rb_prev(&right_info->offset_index))\n\t\tleft_info = rb_entry(rb_prev(&right_info->offset_index),\n\t\t\t\t     struct btrfs_free_space, offset_index);\n\telse\n\t\tleft_info = tree_search_offset(ctl, offset - 1, 0, 0);\n\n\tif (right_info && !right_info->bitmap) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, right_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, right_info);\n\t\tinfo->bytes += right_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, right_info);\n\t\tmerged = true;\n\t}\n\n\tif (left_info && !left_info->bitmap &&\n\t    left_info->offset + left_info->bytes == offset) {\n\t\tif (update_stat)\n\t\t\tunlink_free_space(ctl, left_info);\n\t\telse\n\t\t\t__unlink_free_space(ctl, left_info);\n\t\tinfo->offset = left_info->offset;\n\t\tinfo->bytes += left_info->bytes;\n\t\tkmem_cache_free(btrfs_free_space_cachep, left_info);\n\t\tmerged = true;\n\t}\n\n\treturn merged;\n}"
  },
  {
    "function_name": "insert_into_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1871-1985",
    "snippet": "static int insert_into_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\tstruct btrfs_free_space *bitmap_info;\n\tstruct btrfs_block_group_cache *block_group = NULL;\n\tint added = 0;\n\tu64 bytes, offset, bytes_added;\n\tint ret;\n\n\tbytes = info->bytes;\n\toffset = info->offset;\n\n\tif (!ctl->op->use_bitmap(ctl, info))\n\t\treturn 0;\n\n\tif (ctl->op == &free_space_op)\n\t\tblock_group = ctl->private;\nagain:\n\t/*\n\t * Since we link bitmaps right into the cluster we need to see if we\n\t * have a cluster here, and if so and it has our bitmap we need to add\n\t * the free space to that bitmap.\n\t */\n\tif (block_group && !list_empty(&block_group->cluster_list)) {\n\t\tstruct btrfs_free_cluster *cluster;\n\t\tstruct rb_node *node;\n\t\tstruct btrfs_free_space *entry;\n\n\t\tcluster = list_entry(block_group->cluster_list.next,\n\t\t\t\t     struct btrfs_free_cluster,\n\t\t\t\t     block_group_list);\n\t\tspin_lock(&cluster->lock);\n\t\tnode = rb_first(&cluster->root);\n\t\tif (!node) {\n\t\t\tspin_unlock(&cluster->lock);\n\t\t\tgoto no_cluster_bitmap;\n\t\t}\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (!entry->bitmap) {\n\t\t\tspin_unlock(&cluster->lock);\n\t\t\tgoto no_cluster_bitmap;\n\t\t}\n\n\t\tif (entry->offset == offset_to_bitmap(ctl, offset)) {\n\t\t\tbytes_added = add_bytes_to_bitmap(ctl, entry,\n\t\t\t\t\t\t\t  offset, bytes);\n\t\t\tbytes -= bytes_added;\n\t\t\toffset += bytes_added;\n\t\t}\n\t\tspin_unlock(&cluster->lock);\n\t\tif (!bytes) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nno_cluster_bitmap:\n\tbitmap_info = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t 1, 0);\n\tif (!bitmap_info) {\n\t\tASSERT(added == 0);\n\t\tgoto new_bitmap;\n\t}\n\n\tbytes_added = add_bytes_to_bitmap(ctl, bitmap_info, offset, bytes);\n\tbytes -= bytes_added;\n\toffset += bytes_added;\n\tadded = 0;\n\n\tif (!bytes) {\n\t\tret = 1;\n\t\tgoto out;\n\t} else\n\t\tgoto again;\n\nnew_bitmap:\n\tif (info && info->bitmap) {\n\t\tadd_new_bitmap(ctl, info, offset);\n\t\tadded = 1;\n\t\tinfo = NULL;\n\t\tgoto again;\n\t} else {\n\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t/* no pre-allocated info, allocate a new one */\n\t\tif (!info) {\n\t\t\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep,\n\t\t\t\t\t\t GFP_NOFS);\n\t\t\tif (!info) {\n\t\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* allocate the bitmap */\n\t\tinfo->bitmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\tspin_lock(&ctl->tree_lock);\n\t\tif (!info->bitmap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\nout:\n\tif (info) {\n\t\tif (info->bitmap)\n\t\t\tkfree(info->bitmap);\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);",
      "static struct btrfs_free_space_op free_space_op = {\n\t.recalc_thresholds\t= recalculate_thresholds,\n\t.use_bitmap\t\t= use_bitmap,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "info"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info->bitmap"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "PAGE_CACHE_SIZE",
            "GFP_NOFS"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "btrfs_free_space_cachep",
            "GFP_NOFS"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_new_bitmap",
          "args": [
            "ctl",
            "info",
            "offset"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "add_new_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1712-1722",
          "snippet": "static void add_new_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info, u64 offset)\n{\n\tinfo->offset = offset_to_bitmap(ctl, offset);\n\tinfo->bytes = 0;\n\tINIT_LIST_HEAD(&info->list);\n\tlink_free_space(ctl, info);\n\tctl->total_bitmaps++;\n\n\tctl->op->recalc_thresholds(ctl);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void add_new_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info, u64 offset)\n{\n\tinfo->offset = offset_to_bitmap(ctl, offset);\n\tinfo->bytes = 0;\n\tINIT_LIST_HEAD(&info->list);\n\tlink_free_space(ctl, info);\n\tctl->total_bitmaps++;\n\n\tctl->op->recalc_thresholds(ctl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_bytes_to_bitmap",
          "args": [
            "ctl",
            "bitmap_info",
            "offset",
            "bytes"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "add_bytes_to_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1810-1825",
          "snippet": "static u64 add_bytes_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t       struct btrfs_free_space *info, u64 offset,\n\t\t\t       u64 bytes)\n{\n\tu64 bytes_to_set = 0;\n\tu64 end;\n\n\tend = info->offset + (u64)(BITS_PER_BITMAP * ctl->unit);\n\n\tbytes_to_set = min(end - offset, bytes);\n\n\tbitmap_set_bits(ctl, info, offset, bytes_to_set);\n\n\treturn bytes_to_set;\n\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic u64 add_bytes_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t       struct btrfs_free_space *info, u64 offset,\n\t\t\t       u64 bytes)\n{\n\tu64 bytes_to_set = 0;\n\tu64 end;\n\n\tend = info->offset + (u64)(BITS_PER_BITMAP * ctl->unit);\n\n\tbytes_to_set = min(end - offset, bytes);\n\n\tbitmap_set_bits(ctl, info, offset, bytes_to_set);\n\n\treturn bytes_to_set;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "added == 0"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search_offset",
          "args": [
            "ctl",
            "offset_to_bitmap(ctl, offset)",
            "1",
            "0"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1370-1484",
          "snippet": "static struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_bitmap",
          "args": [
            "ctl",
            "offset"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1297-1310",
          "snippet": "static inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&cluster->root"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "block_group->cluster_list.next",
            "structbtrfs_free_cluster",
            "block_group_list"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&block_group->cluster_list"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctl->op->use_bitmap",
          "args": [
            "ctl",
            "info"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "use_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1827-1864",
          "snippet": "static bool use_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t      struct btrfs_free_space *info)\n{\n\tstruct btrfs_block_group_cache *block_group = ctl->private;\n\n\t/*\n\t * If we are below the extents threshold then we can add this as an\n\t * extent, and don't have to deal with the bitmap\n\t */\n\tif (ctl->free_extents < ctl->extents_thresh) {\n\t\t/*\n\t\t * If this block group has some small extents we don't want to\n\t\t * use up all of our free slots in the cache with them, we want\n\t\t * to reserve them to larger extents, however if we have plent\n\t\t * of cache left then go ahead an dadd them, no sense in adding\n\t\t * the overhead of a bitmap if we don't have to.\n\t\t */\n\t\tif (info->bytes <= block_group->sectorsize * 4) {\n\t\t\tif (ctl->free_extents * 2 <= ctl->extents_thresh)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * The original block groups from mkfs can be really small, like 8\n\t * megabytes, so don't bother with a bitmap for those entries.  However\n\t * some block groups can be smaller than what a bitmap would cover but\n\t * are still large enough that they could overflow the 32k memory limit,\n\t * so allow those block groups to still be allowed to have a bitmap\n\t * entry.\n\t */\n\tif (((BITS_PER_BITMAP * ctl->unit) >> 1) > block_group->key.offset)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic bool use_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t      struct btrfs_free_space *info)\n{\n\tstruct btrfs_block_group_cache *block_group = ctl->private;\n\n\t/*\n\t * If we are below the extents threshold then we can add this as an\n\t * extent, and don't have to deal with the bitmap\n\t */\n\tif (ctl->free_extents < ctl->extents_thresh) {\n\t\t/*\n\t\t * If this block group has some small extents we don't want to\n\t\t * use up all of our free slots in the cache with them, we want\n\t\t * to reserve them to larger extents, however if we have plent\n\t\t * of cache left then go ahead an dadd them, no sense in adding\n\t\t * the overhead of a bitmap if we don't have to.\n\t\t */\n\t\tif (info->bytes <= block_group->sectorsize * 4) {\n\t\t\tif (ctl->free_extents * 2 <= ctl->extents_thresh)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * The original block groups from mkfs can be really small, like 8\n\t * megabytes, so don't bother with a bitmap for those entries.  However\n\t * some block groups can be smaller than what a bitmap would cover but\n\t * are still large enough that they could overflow the 32k memory limit,\n\t * so allow those block groups to still be allowed to have a bitmap\n\t * entry.\n\t */\n\tif (((BITS_PER_BITMAP * ctl->unit) >> 1) > block_group->key.offset)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\nstatic struct btrfs_free_space_op free_space_op = {\n\t.recalc_thresholds\t= recalculate_thresholds,\n\t.use_bitmap\t\t= use_bitmap,\n};\n\nstatic int insert_into_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\tstruct btrfs_free_space *bitmap_info;\n\tstruct btrfs_block_group_cache *block_group = NULL;\n\tint added = 0;\n\tu64 bytes, offset, bytes_added;\n\tint ret;\n\n\tbytes = info->bytes;\n\toffset = info->offset;\n\n\tif (!ctl->op->use_bitmap(ctl, info))\n\t\treturn 0;\n\n\tif (ctl->op == &free_space_op)\n\t\tblock_group = ctl->private;\nagain:\n\t/*\n\t * Since we link bitmaps right into the cluster we need to see if we\n\t * have a cluster here, and if so and it has our bitmap we need to add\n\t * the free space to that bitmap.\n\t */\n\tif (block_group && !list_empty(&block_group->cluster_list)) {\n\t\tstruct btrfs_free_cluster *cluster;\n\t\tstruct rb_node *node;\n\t\tstruct btrfs_free_space *entry;\n\n\t\tcluster = list_entry(block_group->cluster_list.next,\n\t\t\t\t     struct btrfs_free_cluster,\n\t\t\t\t     block_group_list);\n\t\tspin_lock(&cluster->lock);\n\t\tnode = rb_first(&cluster->root);\n\t\tif (!node) {\n\t\t\tspin_unlock(&cluster->lock);\n\t\t\tgoto no_cluster_bitmap;\n\t\t}\n\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (!entry->bitmap) {\n\t\t\tspin_unlock(&cluster->lock);\n\t\t\tgoto no_cluster_bitmap;\n\t\t}\n\n\t\tif (entry->offset == offset_to_bitmap(ctl, offset)) {\n\t\t\tbytes_added = add_bytes_to_bitmap(ctl, entry,\n\t\t\t\t\t\t\t  offset, bytes);\n\t\t\tbytes -= bytes_added;\n\t\t\toffset += bytes_added;\n\t\t}\n\t\tspin_unlock(&cluster->lock);\n\t\tif (!bytes) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nno_cluster_bitmap:\n\tbitmap_info = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t 1, 0);\n\tif (!bitmap_info) {\n\t\tASSERT(added == 0);\n\t\tgoto new_bitmap;\n\t}\n\n\tbytes_added = add_bytes_to_bitmap(ctl, bitmap_info, offset, bytes);\n\tbytes -= bytes_added;\n\toffset += bytes_added;\n\tadded = 0;\n\n\tif (!bytes) {\n\t\tret = 1;\n\t\tgoto out;\n\t} else\n\t\tgoto again;\n\nnew_bitmap:\n\tif (info && info->bitmap) {\n\t\tadd_new_bitmap(ctl, info, offset);\n\t\tadded = 1;\n\t\tinfo = NULL;\n\t\tgoto again;\n\t} else {\n\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t/* no pre-allocated info, allocate a new one */\n\t\tif (!info) {\n\t\t\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep,\n\t\t\t\t\t\t GFP_NOFS);\n\t\t\tif (!info) {\n\t\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* allocate the bitmap */\n\t\tinfo->bitmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\tspin_lock(&ctl->tree_lock);\n\t\tif (!info->bitmap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\nout:\n\tif (info) {\n\t\tif (info->bitmap)\n\t\t\tkfree(info->bitmap);\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "use_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1827-1864",
    "snippet": "static bool use_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t      struct btrfs_free_space *info)\n{\n\tstruct btrfs_block_group_cache *block_group = ctl->private;\n\n\t/*\n\t * If we are below the extents threshold then we can add this as an\n\t * extent, and don't have to deal with the bitmap\n\t */\n\tif (ctl->free_extents < ctl->extents_thresh) {\n\t\t/*\n\t\t * If this block group has some small extents we don't want to\n\t\t * use up all of our free slots in the cache with them, we want\n\t\t * to reserve them to larger extents, however if we have plent\n\t\t * of cache left then go ahead an dadd them, no sense in adding\n\t\t * the overhead of a bitmap if we don't have to.\n\t\t */\n\t\tif (info->bytes <= block_group->sectorsize * 4) {\n\t\t\tif (ctl->free_extents * 2 <= ctl->extents_thresh)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * The original block groups from mkfs can be really small, like 8\n\t * megabytes, so don't bother with a bitmap for those entries.  However\n\t * some block groups can be smaller than what a bitmap would cover but\n\t * are still large enough that they could overflow the 32k memory limit,\n\t * so allow those block groups to still be allowed to have a bitmap\n\t * entry.\n\t */\n\tif (((BITS_PER_BITMAP * ctl->unit) >> 1) > block_group->key.offset)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic bool use_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t      struct btrfs_free_space *info)\n{\n\tstruct btrfs_block_group_cache *block_group = ctl->private;\n\n\t/*\n\t * If we are below the extents threshold then we can add this as an\n\t * extent, and don't have to deal with the bitmap\n\t */\n\tif (ctl->free_extents < ctl->extents_thresh) {\n\t\t/*\n\t\t * If this block group has some small extents we don't want to\n\t\t * use up all of our free slots in the cache with them, we want\n\t\t * to reserve them to larger extents, however if we have plent\n\t\t * of cache left then go ahead an dadd them, no sense in adding\n\t\t * the overhead of a bitmap if we don't have to.\n\t\t */\n\t\tif (info->bytes <= block_group->sectorsize * 4) {\n\t\t\tif (ctl->free_extents * 2 <= ctl->extents_thresh)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * The original block groups from mkfs can be really small, like 8\n\t * megabytes, so don't bother with a bitmap for those entries.  However\n\t * some block groups can be smaller than what a bitmap would cover but\n\t * are still large enough that they could overflow the 32k memory limit,\n\t * so allow those block groups to still be allowed to have a bitmap\n\t * entry.\n\t */\n\tif (((BITS_PER_BITMAP * ctl->unit) >> 1) > block_group->key.offset)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "add_bytes_to_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1810-1825",
    "snippet": "static u64 add_bytes_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t       struct btrfs_free_space *info, u64 offset,\n\t\t\t       u64 bytes)\n{\n\tu64 bytes_to_set = 0;\n\tu64 end;\n\n\tend = info->offset + (u64)(BITS_PER_BITMAP * ctl->unit);\n\n\tbytes_to_set = min(end - offset, bytes);\n\n\tbitmap_set_bits(ctl, info, offset, bytes_to_set);\n\n\treturn bytes_to_set;\n\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_set_bits",
          "args": [
            "ctl",
            "info",
            "offset",
            "bytes_to_set"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1588-1602",
          "snippet": "static void bitmap_set_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t    struct btrfs_free_space *info, u64 offset,\n\t\t\t    u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_set(info->bitmap, start, count);\n\n\tinfo->bytes += bytes;\n\tctl->free_space += bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void bitmap_set_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t    struct btrfs_free_space *info, u64 offset,\n\t\t\t    u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_set(info->bitmap, start, count);\n\n\tinfo->bytes += bytes;\n\tctl->free_space += bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end - offset",
            "bytes"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "BITS_PER_BITMAP * ctl->unit"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic u64 add_bytes_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t       struct btrfs_free_space *info, u64 offset,\n\t\t\t       u64 bytes)\n{\n\tu64 bytes_to_set = 0;\n\tu64 end;\n\n\tend = info->offset + (u64)(BITS_PER_BITMAP * ctl->unit);\n\n\tbytes_to_set = min(end - offset, bytes);\n\n\tbitmap_set_bits(ctl, info, offset, bytes_to_set);\n\n\treturn bytes_to_set;\n\n}"
  },
  {
    "function_name": "remove_from_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1734-1808",
    "snippet": "static noinline int remove_from_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *bitmap_info,\n\t\t\t      u64 *offset, u64 *bytes)\n{\n\tu64 end;\n\tu64 search_start, search_bytes;\n\tint ret;\n\nagain:\n\tend = bitmap_info->offset + (u64)(BITS_PER_BITMAP * ctl->unit) - 1;\n\n\t/*\n\t * We need to search for bits in this bitmap.  We could only cover some\n\t * of the extent in this bitmap thanks to how we add space, so we need\n\t * to search for as much as it as we can and clear that amount, and then\n\t * go searching for the next bit.\n\t */\n\tsearch_start = *offset;\n\tsearch_bytes = ctl->unit;\n\tsearch_bytes = min(search_bytes, end - search_start + 1);\n\tret = search_bitmap(ctl, bitmap_info, &search_start, &search_bytes);\n\tif (ret < 0 || search_start != *offset)\n\t\treturn -EINVAL;\n\n\t/* We may have found more bits than what we need */\n\tsearch_bytes = min(search_bytes, *bytes);\n\n\t/* Cannot clear past the end of the bitmap */\n\tsearch_bytes = min(search_bytes, end - search_start + 1);\n\n\tbitmap_clear_bits(ctl, bitmap_info, search_start, search_bytes);\n\t*offset += search_bytes;\n\t*bytes -= search_bytes;\n\n\tif (*bytes) {\n\t\tstruct rb_node *next = rb_next(&bitmap_info->offset_index);\n\t\tif (!bitmap_info->bytes)\n\t\t\tfree_bitmap(ctl, bitmap_info);\n\n\t\t/*\n\t\t * no entry after this bitmap, but we still have bytes to\n\t\t * remove, so something has gone wrong.\n\t\t */\n\t\tif (!next)\n\t\t\treturn -EINVAL;\n\n\t\tbitmap_info = rb_entry(next, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\n\t\t/*\n\t\t * if the next entry isn't a bitmap we need to return to let the\n\t\t * extent stuff do its work.\n\t\t */\n\t\tif (!bitmap_info->bitmap)\n\t\t\treturn -EAGAIN;\n\n\t\t/*\n\t\t * Ok the next item is a bitmap, but it may not actually hold\n\t\t * the information for the rest of this free space stuff, so\n\t\t * look for it, and if we don't find it return so we can try\n\t\t * everything over again.\n\t\t */\n\t\tsearch_start = *offset;\n\t\tsearch_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, bitmap_info, &search_start,\n\t\t\t\t    &search_bytes);\n\t\tif (ret < 0 || search_start != *offset)\n\t\t\treturn -EAGAIN;\n\n\t\tgoto again;\n\t} else if (!bitmap_info->bytes)\n\t\tfree_bitmap(ctl, bitmap_info);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_bitmap",
          "args": [
            "ctl",
            "bitmap_info"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "free_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1724-1732",
          "snippet": "static void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_bitmap",
          "args": [
            "ctl",
            "bitmap_info",
            "&search_start",
            "&search_bytes"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "search_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1608-1643",
          "snippet": "static int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&bitmap_info->offset_index"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_clear_bits",
          "args": [
            "ctl",
            "bitmap_info",
            "search_start",
            "search_bytes"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1580-1586",
          "snippet": "static void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "search_bytes",
            "end - search_start + 1"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "BITS_PER_BITMAP * ctl->unit"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic noinline int remove_from_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *bitmap_info,\n\t\t\t      u64 *offset, u64 *bytes)\n{\n\tu64 end;\n\tu64 search_start, search_bytes;\n\tint ret;\n\nagain:\n\tend = bitmap_info->offset + (u64)(BITS_PER_BITMAP * ctl->unit) - 1;\n\n\t/*\n\t * We need to search for bits in this bitmap.  We could only cover some\n\t * of the extent in this bitmap thanks to how we add space, so we need\n\t * to search for as much as it as we can and clear that amount, and then\n\t * go searching for the next bit.\n\t */\n\tsearch_start = *offset;\n\tsearch_bytes = ctl->unit;\n\tsearch_bytes = min(search_bytes, end - search_start + 1);\n\tret = search_bitmap(ctl, bitmap_info, &search_start, &search_bytes);\n\tif (ret < 0 || search_start != *offset)\n\t\treturn -EINVAL;\n\n\t/* We may have found more bits than what we need */\n\tsearch_bytes = min(search_bytes, *bytes);\n\n\t/* Cannot clear past the end of the bitmap */\n\tsearch_bytes = min(search_bytes, end - search_start + 1);\n\n\tbitmap_clear_bits(ctl, bitmap_info, search_start, search_bytes);\n\t*offset += search_bytes;\n\t*bytes -= search_bytes;\n\n\tif (*bytes) {\n\t\tstruct rb_node *next = rb_next(&bitmap_info->offset_index);\n\t\tif (!bitmap_info->bytes)\n\t\t\tfree_bitmap(ctl, bitmap_info);\n\n\t\t/*\n\t\t * no entry after this bitmap, but we still have bytes to\n\t\t * remove, so something has gone wrong.\n\t\t */\n\t\tif (!next)\n\t\t\treturn -EINVAL;\n\n\t\tbitmap_info = rb_entry(next, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\n\t\t/*\n\t\t * if the next entry isn't a bitmap we need to return to let the\n\t\t * extent stuff do its work.\n\t\t */\n\t\tif (!bitmap_info->bitmap)\n\t\t\treturn -EAGAIN;\n\n\t\t/*\n\t\t * Ok the next item is a bitmap, but it may not actually hold\n\t\t * the information for the rest of this free space stuff, so\n\t\t * look for it, and if we don't find it return so we can try\n\t\t * everything over again.\n\t\t */\n\t\tsearch_start = *offset;\n\t\tsearch_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, bitmap_info, &search_start,\n\t\t\t\t    &search_bytes);\n\t\tif (ret < 0 || search_start != *offset)\n\t\t\treturn -EAGAIN;\n\n\t\tgoto again;\n\t} else if (!bitmap_info->bytes)\n\t\tfree_bitmap(ctl, bitmap_info);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1724-1732",
    "snippet": "static void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctl->op->recalc_thresholds",
          "args": [
            "ctl"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "bitmap_info"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bitmap_info->bitmap"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink_free_space",
          "args": [
            "ctl",
            "bitmap_info"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1494-1499",
          "snippet": "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void free_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\tstruct btrfs_free_space *bitmap_info)\n{\n\tunlink_free_space(ctl, bitmap_info);\n\tkfree(bitmap_info->bitmap);\n\tkmem_cache_free(btrfs_free_space_cachep, bitmap_info);\n\tctl->total_bitmaps--;\n\tctl->op->recalc_thresholds(ctl);\n}"
  },
  {
    "function_name": "add_new_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1712-1722",
    "snippet": "static void add_new_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info, u64 offset)\n{\n\tinfo->offset = offset_to_bitmap(ctl, offset);\n\tinfo->bytes = 0;\n\tINIT_LIST_HEAD(&info->list);\n\tlink_free_space(ctl, info);\n\tctl->total_bitmaps++;\n\n\tctl->op->recalc_thresholds(ctl);\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctl->op->recalc_thresholds",
          "args": [
            "ctl"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_free_space",
          "args": [
            "ctl",
            "info"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "link_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1501-1515",
          "snippet": "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&info->list"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_to_bitmap",
          "args": [
            "ctl",
            "offset"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1297-1310",
          "snippet": "static inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void add_new_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info, u64 offset)\n{\n\tinfo->offset = offset_to_bitmap(ctl, offset);\n\tinfo->bytes = 0;\n\tINIT_LIST_HEAD(&info->list);\n\tlink_free_space(ctl, info);\n\tctl->total_bitmaps++;\n\n\tctl->op->recalc_thresholds(ctl);\n}"
  },
  {
    "function_name": "find_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1646-1710",
    "snippet": "static struct btrfs_free_space *\nfind_free_space(struct btrfs_free_space_ctl *ctl, u64 *offset, u64 *bytes,\n\t\tunsigned long align, u64 *max_extent_size)\n{\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\tu64 tmp;\n\tu64 align_off;\n\tint ret;\n\n\tif (!ctl->free_space_offset.rb_node)\n\t\tgoto out;\n\n\tentry = tree_search_offset(ctl, offset_to_bitmap(ctl, *offset), 0, 1);\n\tif (!entry)\n\t\tgoto out;\n\n\tfor (node = &entry->offset_index; node; node = rb_next(node)) {\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (entry->bytes < *bytes) {\n\t\t\tif (entry->bytes > *max_extent_size)\n\t\t\t\t*max_extent_size = entry->bytes;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* make sure the space returned is big enough\n\t\t * to match our requested alignment\n\t\t */\n\t\tif (*bytes >= align) {\n\t\t\ttmp = entry->offset - ctl->start + align - 1;\n\t\t\tdo_div(tmp, align);\n\t\t\ttmp = tmp * align + ctl->start;\n\t\t\talign_off = tmp - entry->offset;\n\t\t} else {\n\t\t\talign_off = 0;\n\t\t\ttmp = entry->offset;\n\t\t}\n\n\t\tif (entry->bytes < *bytes + align_off) {\n\t\t\tif (entry->bytes > *max_extent_size)\n\t\t\t\t*max_extent_size = entry->bytes;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->bitmap) {\n\t\t\tu64 size = *bytes;\n\n\t\t\tret = search_bitmap(ctl, entry, &tmp, &size);\n\t\t\tif (!ret) {\n\t\t\t\t*offset = tmp;\n\t\t\t\t*bytes = size;\n\t\t\t\treturn entry;\n\t\t\t} else if (size > *max_extent_size) {\n\t\t\t\t*max_extent_size = size;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t*offset = tmp;\n\t\t*bytes = entry->bytes - align_off;\n\t\treturn entry;\n\t}\nout:\n\treturn NULL;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "search_bitmap",
          "args": [
            "ctl",
            "entry",
            "&tmp",
            "&size"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "search_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1608-1643",
          "snippet": "static int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "align"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search_offset",
          "args": [
            "ctl",
            "offset_to_bitmap(ctl, *offset)",
            "0",
            "1"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1370-1484",
          "snippet": "static struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_bitmap",
          "args": [
            "ctl",
            "*offset"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1297-1310",
          "snippet": "static inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic struct btrfs_free_space *\nfind_free_space(struct btrfs_free_space_ctl *ctl, u64 *offset, u64 *bytes,\n\t\tunsigned long align, u64 *max_extent_size)\n{\n\tstruct btrfs_free_space *entry;\n\tstruct rb_node *node;\n\tu64 tmp;\n\tu64 align_off;\n\tint ret;\n\n\tif (!ctl->free_space_offset.rb_node)\n\t\tgoto out;\n\n\tentry = tree_search_offset(ctl, offset_to_bitmap(ctl, *offset), 0, 1);\n\tif (!entry)\n\t\tgoto out;\n\n\tfor (node = &entry->offset_index; node; node = rb_next(node)) {\n\t\tentry = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\tif (entry->bytes < *bytes) {\n\t\t\tif (entry->bytes > *max_extent_size)\n\t\t\t\t*max_extent_size = entry->bytes;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* make sure the space returned is big enough\n\t\t * to match our requested alignment\n\t\t */\n\t\tif (*bytes >= align) {\n\t\t\ttmp = entry->offset - ctl->start + align - 1;\n\t\t\tdo_div(tmp, align);\n\t\t\ttmp = tmp * align + ctl->start;\n\t\t\talign_off = tmp - entry->offset;\n\t\t} else {\n\t\t\talign_off = 0;\n\t\t\ttmp = entry->offset;\n\t\t}\n\n\t\tif (entry->bytes < *bytes + align_off) {\n\t\t\tif (entry->bytes > *max_extent_size)\n\t\t\t\t*max_extent_size = entry->bytes;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->bitmap) {\n\t\t\tu64 size = *bytes;\n\n\t\t\tret = search_bitmap(ctl, entry, &tmp, &size);\n\t\t\tif (!ret) {\n\t\t\t\t*offset = tmp;\n\t\t\t\t*bytes = size;\n\t\t\t\treturn entry;\n\t\t\t} else if (size > *max_extent_size) {\n\t\t\t\t*max_extent_size = size;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t*offset = tmp;\n\t\t*bytes = entry->bytes - align_off;\n\t\treturn entry;\n\t}\nout:\n\treturn NULL;\n}"
  },
  {
    "function_name": "search_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1608-1643",
    "snippet": "static int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "max_bits"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "found_bits"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "i * ctl->unit"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "bitmap_info->bitmap",
            "BITS_PER_BITMAP",
            "i"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "904-916",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit_from",
          "args": [
            "i",
            "bitmap_info->bitmap",
            "BITS_PER_BITMAP"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes_to_bits",
          "args": [
            "*bytes",
            "ctl->unit"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "bytes_to_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1292-1295",
          "snippet": "static inline unsigned long bytes_to_bits(u64 bytes, u32 unit)\n{\n\treturn (unsigned long)(div_u64(bytes, unit));\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic inline unsigned long bytes_to_bits(u64 bytes, u32 unit)\n{\n\treturn (unsigned long)(div_u64(bytes, unit));\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_bit",
          "args": [
            "bitmap_info->offset",
            "ctl->unit",
            "max_t(u64, *offset, bitmap_info->offset)"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1284-1290",
          "snippet": "static inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "*offset",
            "bitmap_info->offset"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int search_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t struct btrfs_free_space *bitmap_info, u64 *offset,\n\t\t\t u64 *bytes)\n{\n\tunsigned long found_bits = 0;\n\tunsigned long max_bits = 0;\n\tunsigned long bits, i;\n\tunsigned long next_zero;\n\tunsigned long extent_bits;\n\n\ti = offset_to_bit(bitmap_info->offset, ctl->unit,\n\t\t\t  max_t(u64, *offset, bitmap_info->offset));\n\tbits = bytes_to_bits(*bytes, ctl->unit);\n\n\tfor_each_set_bit_from(i, bitmap_info->bitmap, BITS_PER_BITMAP) {\n\t\tnext_zero = find_next_zero_bit(bitmap_info->bitmap,\n\t\t\t\t\t       BITS_PER_BITMAP, i);\n\t\textent_bits = next_zero - i;\n\t\tif (extent_bits >= bits) {\n\t\t\tfound_bits = extent_bits;\n\t\t\tbreak;\n\t\t} else if (extent_bits > max_bits) {\n\t\t\tmax_bits = extent_bits;\n\t\t}\n\t\ti = next_zero;\n\t}\n\n\tif (found_bits) {\n\t\t*offset = (u64)(i * ctl->unit) + bitmap_info->offset;\n\t\t*bytes = (u64)(found_bits) * ctl->unit;\n\t\treturn 0;\n\t}\n\n\t*bytes = (u64)(max_bits) * ctl->unit;\n\treturn -1;\n}"
  },
  {
    "function_name": "bitmap_set_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1588-1602",
    "snippet": "static void bitmap_set_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t    struct btrfs_free_space *info, u64 offset,\n\t\t\t    u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_set(info->bitmap, start, count);\n\n\tinfo->bytes += bytes;\n\tctl->free_space += bytes;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "info->bitmap",
            "start",
            "count"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_set_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "65-69",
          "snippet": "static inline int ntfs_bitmap_set_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 1);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_set_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "start + count <= BITS_PER_BITMAP"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes_to_bits",
          "args": [
            "bytes",
            "ctl->unit"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "bytes_to_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1292-1295",
          "snippet": "static inline unsigned long bytes_to_bits(u64 bytes, u32 unit)\n{\n\treturn (unsigned long)(div_u64(bytes, unit));\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic inline unsigned long bytes_to_bits(u64 bytes, u32 unit)\n{\n\treturn (unsigned long)(div_u64(bytes, unit));\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_bit",
          "args": [
            "info->offset",
            "ctl->unit",
            "offset"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1284-1290",
          "snippet": "static inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void bitmap_set_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t    struct btrfs_free_space *info, u64 offset,\n\t\t\t    u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_set(info->bitmap, start, count);\n\n\tinfo->bytes += bytes;\n\tctl->free_space += bytes;\n}"
  },
  {
    "function_name": "bitmap_clear_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1580-1586",
    "snippet": "static void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bitmap_clear_bits",
          "args": [
            "ctl",
            "info",
            "offset",
            "bytes"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "__bitmap_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1565-1578",
          "snippet": "static inline void __bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       u64 offset, u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_clear(info->bitmap, start, count);\n\n\tinfo->bytes -= bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic inline void __bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       u64 offset, u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_clear(info->bitmap, start, count);\n\n\tinfo->bytes -= bytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info, u64 offset,\n\t\t\t      u64 bytes)\n{\n\t__bitmap_clear_bits(ctl, info, offset, bytes);\n\tctl->free_space -= bytes;\n}"
  },
  {
    "function_name": "__bitmap_clear_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1565-1578",
    "snippet": "static inline void __bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       u64 offset, u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_clear(info->bitmap, start, count);\n\n\tinfo->bytes -= bytes;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_clear",
          "args": [
            "info->bitmap",
            "start",
            "count"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_clear_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "82-86",
          "snippet": "static inline int ntfs_bitmap_clear_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 0);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_clear_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "start + count <= BITS_PER_BITMAP"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes_to_bits",
          "args": [
            "bytes",
            "ctl->unit"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "bytes_to_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1292-1295",
          "snippet": "static inline unsigned long bytes_to_bits(u64 bytes, u32 unit)\n{\n\treturn (unsigned long)(div_u64(bytes, unit));\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic inline unsigned long bytes_to_bits(u64 bytes, u32 unit)\n{\n\treturn (unsigned long)(div_u64(bytes, unit));\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_bit",
          "args": [
            "info->offset",
            "ctl->unit",
            "offset"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1284-1290",
          "snippet": "static inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic inline void __bitmap_clear_bits(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t       struct btrfs_free_space *info,\n\t\t\t\t       u64 offset, u64 bytes)\n{\n\tunsigned long start, count;\n\n\tstart = offset_to_bit(info->offset, ctl->unit, offset);\n\tcount = bytes_to_bits(bytes, ctl->unit);\n\tASSERT(start + count <= BITS_PER_BITMAP);\n\n\tbitmap_clear(info->bitmap, start, count);\n\n\tinfo->bytes -= bytes;\n}"
  },
  {
    "function_name": "recalculate_thresholds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1517-1563",
    "snippet": "static void recalculate_thresholds(struct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_block_group_cache *block_group = ctl->private;\n\tu64 max_bytes;\n\tu64 bitmap_bytes;\n\tu64 extent_bytes;\n\tu64 size = block_group->key.offset;\n\tu64 bytes_per_bg = BITS_PER_BITMAP * ctl->unit;\n\tint max_bitmaps = div64_u64(size + bytes_per_bg - 1, bytes_per_bg);\n\n\tmax_bitmaps = max(max_bitmaps, 1);\n\n\tASSERT(ctl->total_bitmaps <= max_bitmaps);\n\n\t/*\n\t * The goal is to keep the total amount of memory used per 1gb of space\n\t * at or below 32k, so we need to adjust how much memory we allow to be\n\t * used by extent based free space tracking\n\t */\n\tif (size < 1024 * 1024 * 1024)\n\t\tmax_bytes = MAX_CACHE_BYTES_PER_GIG;\n\telse\n\t\tmax_bytes = MAX_CACHE_BYTES_PER_GIG *\n\t\t\tdiv64_u64(size, 1024 * 1024 * 1024);\n\n\t/*\n\t * we want to account for 1 more bitmap than what we have so we can make\n\t * sure we don't go over our overall goal of MAX_CACHE_BYTES_PER_GIG as\n\t * we add more bitmaps.\n\t */\n\tbitmap_bytes = (ctl->total_bitmaps + 1) * PAGE_CACHE_SIZE;\n\n\tif (bitmap_bytes >= max_bytes) {\n\t\tctl->extents_thresh = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * we want the extent entry threshold to always be at most 1/2 the maxw\n\t * bytes we can have, or whatever is less than that.\n\t */\n\textent_bytes = max_bytes - bitmap_bytes;\n\textent_bytes = min_t(u64, extent_bytes, div64_u64(max_bytes, 2));\n\n\tctl->extents_thresh =\n\t\tdiv64_u64(extent_bytes, (sizeof(struct btrfs_free_space)));\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define MAX_CACHE_BYTES_PER_GIG\t(32 * 1024)",
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "extent_bytes",
            "(sizeof(struct btrfs_free_space))"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "extent_bytes",
            "div64_u64(max_bytes, 2)"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "max_bytes",
            "2"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "size",
            "1024 * 1024 * 1024"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ctl->total_bitmaps <= max_bitmaps"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "max_bitmaps",
            "1"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "size + bytes_per_bg - 1",
            "bytes_per_bg"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define MAX_CACHE_BYTES_PER_GIG\t(32 * 1024)\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic void recalculate_thresholds(struct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_block_group_cache *block_group = ctl->private;\n\tu64 max_bytes;\n\tu64 bitmap_bytes;\n\tu64 extent_bytes;\n\tu64 size = block_group->key.offset;\n\tu64 bytes_per_bg = BITS_PER_BITMAP * ctl->unit;\n\tint max_bitmaps = div64_u64(size + bytes_per_bg - 1, bytes_per_bg);\n\n\tmax_bitmaps = max(max_bitmaps, 1);\n\n\tASSERT(ctl->total_bitmaps <= max_bitmaps);\n\n\t/*\n\t * The goal is to keep the total amount of memory used per 1gb of space\n\t * at or below 32k, so we need to adjust how much memory we allow to be\n\t * used by extent based free space tracking\n\t */\n\tif (size < 1024 * 1024 * 1024)\n\t\tmax_bytes = MAX_CACHE_BYTES_PER_GIG;\n\telse\n\t\tmax_bytes = MAX_CACHE_BYTES_PER_GIG *\n\t\t\tdiv64_u64(size, 1024 * 1024 * 1024);\n\n\t/*\n\t * we want to account for 1 more bitmap than what we have so we can make\n\t * sure we don't go over our overall goal of MAX_CACHE_BYTES_PER_GIG as\n\t * we add more bitmaps.\n\t */\n\tbitmap_bytes = (ctl->total_bitmaps + 1) * PAGE_CACHE_SIZE;\n\n\tif (bitmap_bytes >= max_bytes) {\n\t\tctl->extents_thresh = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * we want the extent entry threshold to always be at most 1/2 the maxw\n\t * bytes we can have, or whatever is less than that.\n\t */\n\textent_bytes = max_bytes - bitmap_bytes;\n\textent_bytes = min_t(u64, extent_bytes, div64_u64(max_bytes, 2));\n\n\tctl->extents_thresh =\n\t\tdiv64_u64(extent_bytes, (sizeof(struct btrfs_free_space)));\n}"
  },
  {
    "function_name": "link_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1501-1515",
    "snippet": "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_insert_offset",
          "args": [
            "&ctl->free_space_offset",
            "info->offset",
            "&info->offset_index",
            "(info->bitmap != NULL)"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1312-1361",
          "snippet": "static int tree_insert_offset(struct rb_root *root, u64 offset,\n\t\t\t      struct rb_node *node, int bitmap)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_free_space *info;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tinfo = rb_entry(parent, struct btrfs_free_space, offset_index);\n\n\t\tif (offset < info->offset) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (offset > info->offset) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we could have a bitmap entry and an extent entry\n\t\t\t * share the same offset.  If this is the case, we want\n\t\t\t * the extent entry to always be found first if we do a\n\t\t\t * linear search through the tree, since we want to have\n\t\t\t * the quickest allocation time, and allocating from an\n\t\t\t * extent is faster than allocating from a bitmap.  So\n\t\t\t * if we're inserting a bitmap and we find an entry at\n\t\t\t * this offset, we want to go right, or after this entry\n\t\t\t * logically.  If we are inserting an extent and we've\n\t\t\t * found a bitmap, we want to go left, or before\n\t\t\t * logically.\n\t\t\t */\n\t\t\tif (bitmap) {\n\t\t\t\tif (info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\t} else {\n\t\t\t\tif (!info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\t}\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int tree_insert_offset(struct rb_root *root, u64 offset,\n\t\t\t      struct rb_node *node, int bitmap)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_free_space *info;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tinfo = rb_entry(parent, struct btrfs_free_space, offset_index);\n\n\t\tif (offset < info->offset) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (offset > info->offset) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we could have a bitmap entry and an extent entry\n\t\t\t * share the same offset.  If this is the case, we want\n\t\t\t * the extent entry to always be found first if we do a\n\t\t\t * linear search through the tree, since we want to have\n\t\t\t * the quickest allocation time, and allocating from an\n\t\t\t * extent is faster than allocating from a bitmap.  So\n\t\t\t * if we're inserting a bitmap and we find an entry at\n\t\t\t * this offset, we want to go right, or after this entry\n\t\t\t * logically.  If we are inserting an extent and we've\n\t\t\t * found a bitmap, we want to go left, or before\n\t\t\t * logically.\n\t\t\t */\n\t\t\tif (bitmap) {\n\t\t\t\tif (info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\t} else {\n\t\t\t\tif (!info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\t}\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "info->bytes || info->bitmap"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}"
  },
  {
    "function_name": "unlink_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1494-1499",
    "snippet": "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__unlink_free_space",
          "args": [
            "ctl",
            "info"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "__unlink_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1486-1492",
          "snippet": "static inline void\n__unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t    struct btrfs_free_space *info)\n{\n\trb_erase(&info->offset_index, &ctl->free_space_offset);\n\tctl->free_extents--;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic inline void\n__unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t    struct btrfs_free_space *info)\n{\n\trb_erase(&info->offset_index, &ctl->free_space_offset);\n\tctl->free_extents--;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}"
  },
  {
    "function_name": "__unlink_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1486-1492",
    "snippet": "static inline void\n__unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t    struct btrfs_free_space *info)\n{\n\trb_erase(&info->offset_index, &ctl->free_space_offset);\n\tctl->free_extents--;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&info->offset_index",
            "&ctl->free_space_offset"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic inline void\n__unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t    struct btrfs_free_space *info)\n{\n\trb_erase(&info->offset_index, &ctl->free_space_offset);\n\tctl->free_extents--;\n}"
  },
  {
    "function_name": "tree_search_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1370-1484",
    "snippet": "static struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&entry->offset_index"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&entry->offset_index"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "entry->offset <= offset"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&entry->offset_index"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&entry->offset_index"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!entry->bitmap"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic struct btrfs_free_space *\ntree_search_offset(struct btrfs_free_space_ctl *ctl,\n\t\t   u64 offset, int bitmap_only, int fuzzy)\n{\n\tstruct rb_node *n = ctl->free_space_offset.rb_node;\n\tstruct btrfs_free_space *entry, *prev = NULL;\n\n\t/* find entry that is closest to the 'offset' */\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tprev = entry;\n\n\t\tif (offset < entry->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > entry->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (bitmap_only) {\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\tif (entry->bitmap)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * bitmap entry and extent entry may share same offset,\n\t\t * in that case, bitmap entry comes after extent entry.\n\t\t */\n\t\tn = rb_next(n);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (entry->offset != offset)\n\t\t\treturn NULL;\n\n\t\tWARN_ON(!entry->bitmap);\n\t\treturn entry;\n\t} else if (entry) {\n\t\tif (entry->bitmap) {\n\t\t\t/*\n\t\t\t * if previous extent entry covers the offset,\n\t\t\t * we should return it instead of the bitmap entry\n\t\t\t */\n\t\t\tn = rb_prev(&entry->offset_index);\n\t\t\tif (n) {\n\t\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\t\toffset_index);\n\t\t\t\tif (!prev->bitmap &&\n\t\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\t\tentry = prev;\n\t\t\t}\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (!prev)\n\t\treturn NULL;\n\n\t/* find last entry before the 'offset' */\n\tentry = prev;\n\tif (entry->offset > offset) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tentry = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tASSERT(entry->offset <= offset);\n\t\t} else {\n\t\t\tif (fuzzy)\n\t\t\t\treturn entry;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (entry->bitmap) {\n\t\tn = rb_prev(&entry->offset_index);\n\t\tif (n) {\n\t\t\tprev = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t\toffset_index);\n\t\t\tif (!prev->bitmap &&\n\t\t\t    prev->offset + prev->bytes > offset)\n\t\t\t\treturn prev;\n\t\t}\n\t\tif (entry->offset + BITS_PER_BITMAP * ctl->unit > offset)\n\t\t\treturn entry;\n\t} else if (entry->offset + entry->bytes > offset)\n\t\treturn entry;\n\n\tif (!fuzzy)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (entry->bitmap) {\n\t\t\tif (entry->offset + BITS_PER_BITMAP *\n\t\t\t    ctl->unit > offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (entry->offset + entry->bytes > offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(&entry->offset_index);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tentry = rb_entry(n, struct btrfs_free_space, offset_index);\n\t}\n\treturn entry;\n}"
  },
  {
    "function_name": "tree_insert_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1312-1361",
    "snippet": "static int tree_insert_offset(struct rb_root *root, u64 offset,\n\t\t\t      struct rb_node *node, int bitmap)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_free_space *info;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tinfo = rb_entry(parent, struct btrfs_free_space, offset_index);\n\n\t\tif (offset < info->offset) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (offset > info->offset) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we could have a bitmap entry and an extent entry\n\t\t\t * share the same offset.  If this is the case, we want\n\t\t\t * the extent entry to always be found first if we do a\n\t\t\t * linear search through the tree, since we want to have\n\t\t\t * the quickest allocation time, and allocating from an\n\t\t\t * extent is faster than allocating from a bitmap.  So\n\t\t\t * if we're inserting a bitmap and we find an entry at\n\t\t\t * this offset, we want to go right, or after this entry\n\t\t\t * logically.  If we are inserting an extent and we've\n\t\t\t * found a bitmap, we want to go left, or before\n\t\t\t * logically.\n\t\t\t */\n\t\t\tif (bitmap) {\n\t\t\t\tif (info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\t} else {\n\t\t\t\tif (!info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\t}\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
      "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "node",
            "root"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "node",
            "parent",
            "p"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int tree_insert_offset(struct rb_root *root, u64 offset,\n\t\t\t      struct rb_node *node, int bitmap)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_free_space *info;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tinfo = rb_entry(parent, struct btrfs_free_space, offset_index);\n\n\t\tif (offset < info->offset) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (offset > info->offset) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we could have a bitmap entry and an extent entry\n\t\t\t * share the same offset.  If this is the case, we want\n\t\t\t * the extent entry to always be found first if we do a\n\t\t\t * linear search through the tree, since we want to have\n\t\t\t * the quickest allocation time, and allocating from an\n\t\t\t * extent is faster than allocating from a bitmap.  So\n\t\t\t * if we're inserting a bitmap and we find an entry at\n\t\t\t * this offset, we want to go right, or after this entry\n\t\t\t * logically.  If we are inserting an extent and we've\n\t\t\t * found a bitmap, we want to go left, or before\n\t\t\t * logically.\n\t\t\t */\n\t\t\tif (bitmap) {\n\t\t\t\tif (info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\t} else {\n\t\t\t\tif (!info->bitmap) {\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\t}\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "offset_to_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1297-1310",
    "snippet": "static inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "bitmap_start",
            "bytes_per_bitmap"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   u64 offset)\n{\n\tu64 bitmap_start;\n\tu64 bytes_per_bitmap;\n\n\tbytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;\n\tbitmap_start = offset - ctl->start;\n\tbitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);\n\tbitmap_start *= bytes_per_bitmap;\n\tbitmap_start += ctl->start;\n\n\treturn bitmap_start;\n}"
  },
  {
    "function_name": "bytes_to_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1292-1295",
    "snippet": "static inline unsigned long bytes_to_bits(u64 bytes, u32 unit)\n{\n\treturn (unsigned long)(div_u64(bytes, unit));\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "bytes",
            "unit"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic inline unsigned long bytes_to_bits(u64 bytes, u32 unit)\n{\n\treturn (unsigned long)(div_u64(bytes, unit));\n}"
  },
  {
    "function_name": "offset_to_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1284-1290",
    "snippet": "static inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "offset",
            "unit"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset >= bitmap_start"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic inline unsigned long offset_to_bit(u64 bitmap_start, u32 unit,\n\t\t\t\t\t  u64 offset)\n{\n\tASSERT(offset >= bitmap_start);\n\toffset -= bitmap_start;\n\treturn (unsigned long)(div_u64(offset, unit));\n}"
  },
  {
    "function_name": "btrfs_write_out_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1236-1282",
    "snippet": "int btrfs_write_out_cache(struct btrfs_root *root,\n\t\t\t  struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_block_group_cache *block_group,\n\t\t\t  struct btrfs_path *path)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct inode *inode;\n\tint ret = 0;\n\tenum btrfs_disk_cache_state dcs = BTRFS_DC_WRITTEN;\n\n\troot = root->fs_info->tree_root;\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->disk_cache_state < BTRFS_DC_SETUP) {\n\t\tspin_unlock(&block_group->lock);\n\t\treturn 0;\n\t}\n\n\tif (block_group->delalloc_bytes) {\n\t\tblock_group->disk_cache_state = BTRFS_DC_WRITTEN;\n\t\tspin_unlock(&block_group->lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\tinode = lookup_free_space_inode(root, block_group, path);\n\tif (IS_ERR(inode))\n\t\treturn 0;\n\n\tret = __btrfs_write_out_cache(root, inode, ctl, block_group, trans,\n\t\t\t\t      path, block_group->key.objectid);\n\tif (ret) {\n\t\tdcs = BTRFS_DC_ERROR;\n\t\tret = 0;\n#ifdef DEBUG\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"failed to write free space cache for block group %llu\",\n\t\t\tblock_group->key.objectid);\n#endif\n\t}\n\n\tspin_lock(&block_group->lock);\n\tblock_group->disk_cache_state = dcs;\n\tspin_unlock(&block_group->lock);\n\tiput(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&block_group->lock"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&block_group->lock"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"failed to write free space cache for block group %llu\"",
            "block_group->key.objectid"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_write_out_cache",
          "args": [
            "root",
            "inode",
            "ctl",
            "block_group",
            "trans",
            "path",
            "block_group->key.objectid"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_write_out_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1117-1234",
          "snippet": "static int __btrfs_write_out_cache(struct btrfs_root *root, struct inode *inode,\n\t\t\t\t   struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   struct btrfs_block_group_cache *block_group,\n\t\t\t\t   struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path, u64 offset)\n{\n\tstruct extent_state *cached_state = NULL;\n\tstruct io_ctl io_ctl;\n\tLIST_HEAD(bitmap_list);\n\tint entries = 0;\n\tint bitmaps = 0;\n\tint ret;\n\n\tif (!i_size_read(inode))\n\t\treturn -1;\n\n\tret = io_ctl_init(&io_ctl, inode, root, 1);\n\tif (ret)\n\t\treturn -1;\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA)) {\n\t\tdown_write(&block_group->data_rwsem);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->delalloc_bytes) {\n\t\t\tblock_group->disk_cache_state = BTRFS_DC_WRITTEN;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tup_write(&block_group->data_rwsem);\n\t\t\tBTRFS_I(inode)->generation = 0;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\t/* Lock all pages first so we can lock the extent safely. */\n\tio_ctl_prepare_pages(&io_ctl, inode, 0);\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree, 0, i_size_read(inode) - 1,\n\t\t\t 0, &cached_state);\n\n\tio_ctl_set_generation(&io_ctl, trans->transid);\n\n\tmutex_lock(&ctl->cache_writeout_mutex);\n\t/* Write out the extent entries in the free space cache */\n\tret = write_cache_extent_entries(&io_ctl, ctl,\n\t\t\t\t\t block_group, &entries, &bitmaps,\n\t\t\t\t\t &bitmap_list);\n\tif (ret) {\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\tgoto out_nospc;\n\t}\n\n\t/*\n\t * Some spaces that are freed in the current transaction are pinned,\n\t * they will be added into free space cache after the transaction is\n\t * committed, we shouldn't lose them.\n\t */\n\tret = write_pinned_extent_entries(root, block_group, &io_ctl, &entries);\n\tif (ret) {\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\tgoto out_nospc;\n\t}\n\n\t/*\n\t * At last, we write out all the bitmaps and keep cache_writeout_mutex\n\t * locked while doing it because a concurrent trim can be manipulating\n\t * or freeing the bitmap.\n\t */\n\tret = write_bitmap_entries(&io_ctl, &bitmap_list);\n\tmutex_unlock(&ctl->cache_writeout_mutex);\n\tif (ret)\n\t\tgoto out_nospc;\n\n\t/* Zero out the rest of the pages just to make sure */\n\tio_ctl_zero_remaining_pages(&io_ctl);\n\n\t/* Everything is written out, now we dirty the pages in the file. */\n\tret = btrfs_dirty_pages(root, inode, io_ctl.pages, io_ctl.num_pages,\n\t\t\t\t0, i_size_read(inode), &cached_state);\n\tif (ret)\n\t\tgoto out_nospc;\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\tup_write(&block_group->data_rwsem);\n\t/*\n\t * Release the pages and unlock the extent, we will flush\n\t * them out later\n\t */\n\tio_ctl_drop_pages(&io_ctl);\n\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t     i_size_read(inode) - 1, &cached_state, GFP_NOFS);\n\n\t/* Flush the dirty pages in the cache file. */\n\tret = flush_dirty_cache(inode);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Update the cache item to tell everyone this cache file is valid. */\n\tret = update_cache_item(trans, root, inode, path, offset,\n\t\t\t\tentries, bitmaps);\nout:\n\tio_ctl_free(&io_ctl);\n\tif (ret) {\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t\tBTRFS_I(inode)->generation = 0;\n\t}\n\tbtrfs_update_inode(trans, root, inode);\n\treturn ret;\n\nout_nospc:\n\tcleanup_write_cache_enospc(inode, &io_ctl, &cached_state, &bitmap_list);\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\tup_write(&block_group->data_rwsem);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int __btrfs_write_out_cache(struct btrfs_root *root, struct inode *inode,\n\t\t\t\t   struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   struct btrfs_block_group_cache *block_group,\n\t\t\t\t   struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path, u64 offset)\n{\n\tstruct extent_state *cached_state = NULL;\n\tstruct io_ctl io_ctl;\n\tLIST_HEAD(bitmap_list);\n\tint entries = 0;\n\tint bitmaps = 0;\n\tint ret;\n\n\tif (!i_size_read(inode))\n\t\treturn -1;\n\n\tret = io_ctl_init(&io_ctl, inode, root, 1);\n\tif (ret)\n\t\treturn -1;\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA)) {\n\t\tdown_write(&block_group->data_rwsem);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->delalloc_bytes) {\n\t\t\tblock_group->disk_cache_state = BTRFS_DC_WRITTEN;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tup_write(&block_group->data_rwsem);\n\t\t\tBTRFS_I(inode)->generation = 0;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\t/* Lock all pages first so we can lock the extent safely. */\n\tio_ctl_prepare_pages(&io_ctl, inode, 0);\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree, 0, i_size_read(inode) - 1,\n\t\t\t 0, &cached_state);\n\n\tio_ctl_set_generation(&io_ctl, trans->transid);\n\n\tmutex_lock(&ctl->cache_writeout_mutex);\n\t/* Write out the extent entries in the free space cache */\n\tret = write_cache_extent_entries(&io_ctl, ctl,\n\t\t\t\t\t block_group, &entries, &bitmaps,\n\t\t\t\t\t &bitmap_list);\n\tif (ret) {\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\tgoto out_nospc;\n\t}\n\n\t/*\n\t * Some spaces that are freed in the current transaction are pinned,\n\t * they will be added into free space cache after the transaction is\n\t * committed, we shouldn't lose them.\n\t */\n\tret = write_pinned_extent_entries(root, block_group, &io_ctl, &entries);\n\tif (ret) {\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\tgoto out_nospc;\n\t}\n\n\t/*\n\t * At last, we write out all the bitmaps and keep cache_writeout_mutex\n\t * locked while doing it because a concurrent trim can be manipulating\n\t * or freeing the bitmap.\n\t */\n\tret = write_bitmap_entries(&io_ctl, &bitmap_list);\n\tmutex_unlock(&ctl->cache_writeout_mutex);\n\tif (ret)\n\t\tgoto out_nospc;\n\n\t/* Zero out the rest of the pages just to make sure */\n\tio_ctl_zero_remaining_pages(&io_ctl);\n\n\t/* Everything is written out, now we dirty the pages in the file. */\n\tret = btrfs_dirty_pages(root, inode, io_ctl.pages, io_ctl.num_pages,\n\t\t\t\t0, i_size_read(inode), &cached_state);\n\tif (ret)\n\t\tgoto out_nospc;\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\tup_write(&block_group->data_rwsem);\n\t/*\n\t * Release the pages and unlock the extent, we will flush\n\t * them out later\n\t */\n\tio_ctl_drop_pages(&io_ctl);\n\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t     i_size_read(inode) - 1, &cached_state, GFP_NOFS);\n\n\t/* Flush the dirty pages in the cache file. */\n\tret = flush_dirty_cache(inode);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Update the cache item to tell everyone this cache file is valid. */\n\tret = update_cache_item(trans, root, inode, path, offset,\n\t\t\t\tentries, bitmaps);\nout:\n\tio_ctl_free(&io_ctl);\n\tif (ret) {\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t\tBTRFS_I(inode)->generation = 0;\n\t}\n\tbtrfs_update_inode(trans, root, inode);\n\treturn ret;\n\nout_nospc:\n\tcleanup_write_cache_enospc(inode, &io_ctl, &cached_state, &bitmap_list);\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\tup_write(&block_group->data_rwsem);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_free_space_inode",
          "args": [
            "root",
            "block_group",
            "path"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_free_space_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "93-128",
          "snippet": "struct inode *lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_group_cache\n\t\t\t\t      *block_group, struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\tu32 flags = BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->inode)\n\t\tinode = igrab(block_group->inode);\n\tspin_unlock(&block_group->lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path,\n\t\t\t\t\t  block_group->key.objectid);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&block_group->lock);\n\tif (!((BTRFS_I(inode)->flags & flags) == flags)) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t\"Old style space inode found, converting.\");\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATASUM |\n\t\t\tBTRFS_INODE_NODATACOW;\n\t\tblock_group->disk_cache_state = BTRFS_DC_CLEAR;\n\t}\n\n\tif (!block_group->iref) {\n\t\tblock_group->inode = igrab(inode);\n\t\tblock_group->iref = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstruct inode *lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_group_cache\n\t\t\t\t      *block_group, struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\tu32 flags = BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->inode)\n\t\tinode = igrab(block_group->inode);\n\tspin_unlock(&block_group->lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path,\n\t\t\t\t\t  block_group->key.objectid);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&block_group->lock);\n\tif (!((BTRFS_I(inode)->flags & flags) == flags)) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t\"Old style space inode found, converting.\");\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATASUM |\n\t\t\tBTRFS_INODE_NODATACOW;\n\t\tblock_group->disk_cache_state = BTRFS_DC_CLEAR;\n\t}\n\n\tif (!block_group->iref) {\n\t\tblock_group->inode = igrab(inode);\n\t\tblock_group->iref = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint btrfs_write_out_cache(struct btrfs_root *root,\n\t\t\t  struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_block_group_cache *block_group,\n\t\t\t  struct btrfs_path *path)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct inode *inode;\n\tint ret = 0;\n\tenum btrfs_disk_cache_state dcs = BTRFS_DC_WRITTEN;\n\n\troot = root->fs_info->tree_root;\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->disk_cache_state < BTRFS_DC_SETUP) {\n\t\tspin_unlock(&block_group->lock);\n\t\treturn 0;\n\t}\n\n\tif (block_group->delalloc_bytes) {\n\t\tblock_group->disk_cache_state = BTRFS_DC_WRITTEN;\n\t\tspin_unlock(&block_group->lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\tinode = lookup_free_space_inode(root, block_group, path);\n\tif (IS_ERR(inode))\n\t\treturn 0;\n\n\tret = __btrfs_write_out_cache(root, inode, ctl, block_group, trans,\n\t\t\t\t      path, block_group->key.objectid);\n\tif (ret) {\n\t\tdcs = BTRFS_DC_ERROR;\n\t\tret = 0;\n#ifdef DEBUG\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"failed to write free space cache for block group %llu\",\n\t\t\tblock_group->key.objectid);\n#endif\n\t}\n\n\tspin_lock(&block_group->lock);\n\tblock_group->disk_cache_state = dcs;\n\tspin_unlock(&block_group->lock);\n\tiput(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "__btrfs_write_out_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1117-1234",
    "snippet": "static int __btrfs_write_out_cache(struct btrfs_root *root, struct inode *inode,\n\t\t\t\t   struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   struct btrfs_block_group_cache *block_group,\n\t\t\t\t   struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path, u64 offset)\n{\n\tstruct extent_state *cached_state = NULL;\n\tstruct io_ctl io_ctl;\n\tLIST_HEAD(bitmap_list);\n\tint entries = 0;\n\tint bitmaps = 0;\n\tint ret;\n\n\tif (!i_size_read(inode))\n\t\treturn -1;\n\n\tret = io_ctl_init(&io_ctl, inode, root, 1);\n\tif (ret)\n\t\treturn -1;\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA)) {\n\t\tdown_write(&block_group->data_rwsem);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->delalloc_bytes) {\n\t\t\tblock_group->disk_cache_state = BTRFS_DC_WRITTEN;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tup_write(&block_group->data_rwsem);\n\t\t\tBTRFS_I(inode)->generation = 0;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\t/* Lock all pages first so we can lock the extent safely. */\n\tio_ctl_prepare_pages(&io_ctl, inode, 0);\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree, 0, i_size_read(inode) - 1,\n\t\t\t 0, &cached_state);\n\n\tio_ctl_set_generation(&io_ctl, trans->transid);\n\n\tmutex_lock(&ctl->cache_writeout_mutex);\n\t/* Write out the extent entries in the free space cache */\n\tret = write_cache_extent_entries(&io_ctl, ctl,\n\t\t\t\t\t block_group, &entries, &bitmaps,\n\t\t\t\t\t &bitmap_list);\n\tif (ret) {\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\tgoto out_nospc;\n\t}\n\n\t/*\n\t * Some spaces that are freed in the current transaction are pinned,\n\t * they will be added into free space cache after the transaction is\n\t * committed, we shouldn't lose them.\n\t */\n\tret = write_pinned_extent_entries(root, block_group, &io_ctl, &entries);\n\tif (ret) {\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\tgoto out_nospc;\n\t}\n\n\t/*\n\t * At last, we write out all the bitmaps and keep cache_writeout_mutex\n\t * locked while doing it because a concurrent trim can be manipulating\n\t * or freeing the bitmap.\n\t */\n\tret = write_bitmap_entries(&io_ctl, &bitmap_list);\n\tmutex_unlock(&ctl->cache_writeout_mutex);\n\tif (ret)\n\t\tgoto out_nospc;\n\n\t/* Zero out the rest of the pages just to make sure */\n\tio_ctl_zero_remaining_pages(&io_ctl);\n\n\t/* Everything is written out, now we dirty the pages in the file. */\n\tret = btrfs_dirty_pages(root, inode, io_ctl.pages, io_ctl.num_pages,\n\t\t\t\t0, i_size_read(inode), &cached_state);\n\tif (ret)\n\t\tgoto out_nospc;\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\tup_write(&block_group->data_rwsem);\n\t/*\n\t * Release the pages and unlock the extent, we will flush\n\t * them out later\n\t */\n\tio_ctl_drop_pages(&io_ctl);\n\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t     i_size_read(inode) - 1, &cached_state, GFP_NOFS);\n\n\t/* Flush the dirty pages in the cache file. */\n\tret = flush_dirty_cache(inode);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Update the cache item to tell everyone this cache file is valid. */\n\tret = update_cache_item(trans, root, inode, path, offset,\n\t\t\t\tentries, bitmaps);\nout:\n\tio_ctl_free(&io_ctl);\n\tif (ret) {\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t\tBTRFS_I(inode)->generation = 0;\n\t}\n\tbtrfs_update_inode(trans, root, inode);\n\treturn ret;\n\nout_nospc:\n\tcleanup_write_cache_enospc(inode, &io_ctl, &cached_state, &bitmap_list);\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\tup_write(&block_group->data_rwsem);\n\n\tgoto out;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&block_group->data_rwsem"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanup_write_cache_enospc",
          "args": [
            "inode",
            "&io_ctl",
            "&cached_state",
            "&bitmap_list"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_write_cache_enospc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1085-1102",
          "snippet": "static void noinline_for_stack\ncleanup_write_cache_enospc(struct inode *inode,\n\t\t\t   struct io_ctl *io_ctl,\n\t\t\t   struct extent_state **cached_state,\n\t\t\t   struct list_head *bitmap_list)\n{\n\tstruct list_head *pos, *n;\n\n\tlist_for_each_safe(pos, n, bitmap_list) {\n\t\tstruct btrfs_free_space *entry =\n\t\t\tlist_entry(pos, struct btrfs_free_space, list);\n\t\tlist_del_init(&entry->list);\n\t}\n\tio_ctl_drop_pages(io_ctl);\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t     i_size_read(inode) - 1, cached_state,\n\t\t\t     GFP_NOFS);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void noinline_for_stack\ncleanup_write_cache_enospc(struct inode *inode,\n\t\t\t   struct io_ctl *io_ctl,\n\t\t\t   struct extent_state **cached_state,\n\t\t\t   struct list_head *bitmap_list)\n{\n\tstruct list_head *pos, *n;\n\n\tlist_for_each_safe(pos, n, bitmap_list) {\n\t\tstruct btrfs_free_space *entry =\n\t\t\tlist_entry(pos, struct btrfs_free_space, list);\n\t\tlist_del_init(&entry->list);\n\t}\n\tio_ctl_drop_pages(io_ctl);\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t     i_size_read(inode) - 1, cached_state,\n\t\t\t     GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode",
          "args": [
            "trans",
            "root",
            "inode"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_free",
          "args": [
            "&io_ctl"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "312-315",
          "snippet": "static void io_ctl_free(struct io_ctl *io_ctl)\n{\n\tkfree(io_ctl->pages);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_free(struct io_ctl *io_ctl)\n{\n\tkfree(io_ctl->pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_cache_item",
          "args": [
            "trans",
            "root",
            "inode",
            "path",
            "offset",
            "entries",
            "bitmaps"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "update_cache_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "945-998",
          "snippet": "static noinline_for_stack int\nupdate_cache_item(struct btrfs_trans_handle *trans,\n\t\t  struct btrfs_root *root,\n\t\t  struct inode *inode,\n\t\t  struct btrfs_path *path, u64 offset,\n\t\t  int entries, int bitmaps)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0) {\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0, inode->i_size - 1,\n\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC, 0, 0, NULL,\n\t\t\t\t GFP_NOFS);\n\t\tgoto fail;\n\t}\n\tleaf = path->nodes[0];\n\tif (ret > 0) {\n\t\tstruct btrfs_key found_key;\n\t\tASSERT(path->slots[0]);\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid != BTRFS_FREE_SPACE_OBJECTID ||\n\t\t    found_key.offset != offset) {\n\t\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t\t\t inode->i_size - 1,\n\t\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC, 0, 0,\n\t\t\t\t\t NULL, GFP_NOFS);\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tBTRFS_I(inode)->generation = trans->transid;\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tbtrfs_set_free_space_entries(leaf, header, entries);\n\tbtrfs_set_free_space_bitmaps(leaf, header, bitmaps);\n\tbtrfs_set_free_space_generation(leaf, header, trans->transid);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\treturn 0;\n\nfail:\n\treturn -1;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic noinline_for_stack int\nupdate_cache_item(struct btrfs_trans_handle *trans,\n\t\t  struct btrfs_root *root,\n\t\t  struct inode *inode,\n\t\t  struct btrfs_path *path, u64 offset,\n\t\t  int entries, int bitmaps)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0) {\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0, inode->i_size - 1,\n\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC, 0, 0, NULL,\n\t\t\t\t GFP_NOFS);\n\t\tgoto fail;\n\t}\n\tleaf = path->nodes[0];\n\tif (ret > 0) {\n\t\tstruct btrfs_key found_key;\n\t\tASSERT(path->slots[0]);\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid != BTRFS_FREE_SPACE_OBJECTID ||\n\t\t    found_key.offset != offset) {\n\t\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t\t\t inode->i_size - 1,\n\t\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC, 0, 0,\n\t\t\t\t\t NULL, GFP_NOFS);\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tBTRFS_I(inode)->generation = trans->transid;\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tbtrfs_set_free_space_entries(leaf, header, entries);\n\tbtrfs_set_free_space_bitmaps(leaf, header, bitmaps);\n\tbtrfs_set_free_space_generation(leaf, header, trans->transid);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\treturn 0;\n\nfail:\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dirty_cache",
          "args": [
            "inode"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dirty_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1072-1083",
          "snippet": "static int flush_dirty_cache(struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_wait_ordered_range(inode, 0, (u64)-1);\n\tif (ret)\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0, inode->i_size - 1,\n\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC, 0, 0, NULL,\n\t\t\t\t GFP_NOFS);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int flush_dirty_cache(struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_wait_ordered_range(inode, 0, (u64)-1);\n\tif (ret)\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0, inode->i_size - 1,\n\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC, 0, 0, NULL,\n\t\t\t\t GFP_NOFS);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "0",
            "i_size_read(inode) - 1",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_drop_pages",
          "args": [
            "&io_ctl"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_drop_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "337-350",
          "snippet": "static void io_ctl_drop_pages(struct io_ctl *io_ctl)\n{\n\tint i;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tif (io_ctl->pages[i]) {\n\t\t\tClearPageChecked(io_ctl->pages[i]);\n\t\t\tunlock_page(io_ctl->pages[i]);\n\t\t\tpage_cache_release(io_ctl->pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_drop_pages(struct io_ctl *io_ctl)\n{\n\tint i;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tif (io_ctl->pages[i]) {\n\t\t\tClearPageChecked(io_ctl->pages[i]);\n\t\t\tunlock_page(io_ctl->pages[i]);\n\t\t\tpage_cache_release(io_ctl->pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&block_group->data_rwsem"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dirty_pages",
          "args": [
            "root",
            "inode",
            "io_ctl.pages",
            "io_ctl.num_pages",
            "0",
            "i_size_read(inode)",
            "&cached_state"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "492-529",
          "snippet": "int btrfs_dirty_pages(struct btrfs_root *root, struct inode *inode,\n\t\t\t     struct page **pages, size_t num_pages,\n\t\t\t     loff_t pos, size_t write_bytes,\n\t\t\t     struct extent_state **cached)\n{\n\tint err = 0;\n\tint i;\n\tu64 num_bytes;\n\tu64 start_pos;\n\tu64 end_of_last_block;\n\tu64 end_pos = pos + write_bytes;\n\tloff_t isize = i_size_read(inode);\n\n\tstart_pos = pos & ~((u64)root->sectorsize - 1);\n\tnum_bytes = ALIGN(write_bytes + pos - start_pos, root->sectorsize);\n\n\tend_of_last_block = start_pos + num_bytes - 1;\n\terr = btrfs_set_extent_delalloc(inode, start_pos, end_of_last_block,\n\t\t\t\t\tcached);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = pages[i];\n\t\tSetPageUptodate(p);\n\t\tClearPageChecked(p);\n\t\tset_page_dirty(p);\n\t}\n\n\t/*\n\t * we've only changed i_size in ram, and we haven't updated\n\t * the disk i_size.  There is no need to log the inode\n\t * at this time.\n\t */\n\tif (end_pos > isize)\n\t\ti_size_write(inode, end_pos);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_dirty_pages(struct btrfs_root *root, struct inode *inode,\n\t\t\t     struct page **pages, size_t num_pages,\n\t\t\t     loff_t pos, size_t write_bytes,\n\t\t\t     struct extent_state **cached)\n{\n\tint err = 0;\n\tint i;\n\tu64 num_bytes;\n\tu64 start_pos;\n\tu64 end_of_last_block;\n\tu64 end_pos = pos + write_bytes;\n\tloff_t isize = i_size_read(inode);\n\n\tstart_pos = pos & ~((u64)root->sectorsize - 1);\n\tnum_bytes = ALIGN(write_bytes + pos - start_pos, root->sectorsize);\n\n\tend_of_last_block = start_pos + num_bytes - 1;\n\terr = btrfs_set_extent_delalloc(inode, start_pos, end_of_last_block,\n\t\t\t\t\tcached);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = pages[i];\n\t\tSetPageUptodate(p);\n\t\tClearPageChecked(p);\n\t\tset_page_dirty(p);\n\t}\n\n\t/*\n\t * we've only changed i_size in ram, and we haven't updated\n\t * the disk i_size.  There is no need to log the inode\n\t * at this time.\n\t */\n\tif (end_pos > isize)\n\t\ti_size_write(inode, end_pos);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_zero_remaining_pages",
          "args": [
            "&io_ctl"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_zero_remaining_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "548-563",
          "snippet": "static void io_ctl_zero_remaining_pages(struct io_ctl *io_ctl)\n{\n\t/*\n\t * If we're not on the boundary we know we've modified the page and we\n\t * need to crc the page.\n\t */\n\tif (io_ctl->cur != io_ctl->orig)\n\t\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\telse\n\t\tio_ctl_unmap_page(io_ctl);\n\n\twhile (io_ctl->index < io_ctl->num_pages) {\n\t\tio_ctl_map_page(io_ctl, 1);\n\t\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_zero_remaining_pages(struct io_ctl *io_ctl)\n{\n\t/*\n\t * If we're not on the boundary we know we've modified the page and we\n\t * need to crc the page.\n\t */\n\tif (io_ctl->cur != io_ctl->orig)\n\t\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\telse\n\t\tio_ctl_unmap_page(io_ctl);\n\n\twhile (io_ctl->index < io_ctl->num_pages) {\n\t\tio_ctl_map_page(io_ctl, 1);\n\t\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_bitmap_entries",
          "args": [
            "&io_ctl",
            "&bitmap_list"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "write_bitmap_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1052-1070",
          "snippet": "static noinline_for_stack int\nwrite_bitmap_entries(struct io_ctl *io_ctl, struct list_head *bitmap_list)\n{\n\tstruct list_head *pos, *n;\n\tint ret;\n\n\t/* Write out the bitmaps */\n\tlist_for_each_safe(pos, n, bitmap_list) {\n\t\tstruct btrfs_free_space *entry =\n\t\t\tlist_entry(pos, struct btrfs_free_space, list);\n\n\t\tret = io_ctl_add_bitmap(io_ctl, entry->bitmap);\n\t\tif (ret)\n\t\t\treturn -ENOSPC;\n\t\tlist_del_init(&entry->list);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic noinline_for_stack int\nwrite_bitmap_entries(struct io_ctl *io_ctl, struct list_head *bitmap_list)\n{\n\tstruct list_head *pos, *n;\n\tint ret;\n\n\t/* Write out the bitmaps */\n\tlist_for_each_safe(pos, n, bitmap_list) {\n\t\tstruct btrfs_free_space *entry =\n\t\t\tlist_entry(pos, struct btrfs_free_space, list);\n\n\t\tret = io_ctl_add_bitmap(io_ctl, entry->bitmap);\n\t\tif (ret)\n\t\t\treturn -ENOSPC;\n\t\tlist_del_init(&entry->list);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_pinned_extent_entries",
          "args": [
            "root",
            "block_group",
            "&io_ctl",
            "&entries"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "write_pinned_extent_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1000-1050",
          "snippet": "static noinline_for_stack int\nwrite_pinned_extent_entries(struct btrfs_root *root,\n\t\t\t    struct btrfs_block_group_cache *block_group,\n\t\t\t    struct io_ctl *io_ctl,\n\t\t\t    int *entries)\n{\n\tu64 start, extent_start, extent_end, len;\n\tstruct extent_io_tree *unpin = NULL;\n\tint ret;\n\n\tif (!block_group)\n\t\treturn 0;\n\n\t/*\n\t * We want to add any pinned extents to our free space cache\n\t * so we don't leak the space\n\t *\n\t * We shouldn't have switched the pinned extents yet so this is the\n\t * right one\n\t */\n\tunpin = root->fs_info->pinned_extents;\n\n\tstart = block_group->key.objectid;\n\n\twhile (start < block_group->key.objectid + block_group->key.offset) {\n\t\tret = find_first_extent_bit(unpin, start,\n\t\t\t\t\t    &extent_start, &extent_end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\t/* This pinned extent is out of our range */\n\t\tif (extent_start >= block_group->key.objectid +\n\t\t    block_group->key.offset)\n\t\t\treturn 0;\n\n\t\textent_start = max(extent_start, start);\n\t\textent_end = min(block_group->key.objectid +\n\t\t\t\t block_group->key.offset, extent_end + 1);\n\t\tlen = extent_end - extent_start;\n\n\t\t*entries += 1;\n\t\tret = io_ctl_add_entry(io_ctl, extent_start, len, NULL);\n\t\tif (ret)\n\t\t\treturn -ENOSPC;\n\n\t\tstart = extent_end;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic noinline_for_stack int\nwrite_pinned_extent_entries(struct btrfs_root *root,\n\t\t\t    struct btrfs_block_group_cache *block_group,\n\t\t\t    struct io_ctl *io_ctl,\n\t\t\t    int *entries)\n{\n\tu64 start, extent_start, extent_end, len;\n\tstruct extent_io_tree *unpin = NULL;\n\tint ret;\n\n\tif (!block_group)\n\t\treturn 0;\n\n\t/*\n\t * We want to add any pinned extents to our free space cache\n\t * so we don't leak the space\n\t *\n\t * We shouldn't have switched the pinned extents yet so this is the\n\t * right one\n\t */\n\tunpin = root->fs_info->pinned_extents;\n\n\tstart = block_group->key.objectid;\n\n\twhile (start < block_group->key.objectid + block_group->key.offset) {\n\t\tret = find_first_extent_bit(unpin, start,\n\t\t\t\t\t    &extent_start, &extent_end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\t/* This pinned extent is out of our range */\n\t\tif (extent_start >= block_group->key.objectid +\n\t\t    block_group->key.offset)\n\t\t\treturn 0;\n\n\t\textent_start = max(extent_start, start);\n\t\textent_end = min(block_group->key.objectid +\n\t\t\t\t block_group->key.offset, extent_end + 1);\n\t\tlen = extent_end - extent_start;\n\n\t\t*entries += 1;\n\t\tret = io_ctl_add_entry(io_ctl, extent_start, len, NULL);\n\t\tif (ret)\n\t\t\treturn -ENOSPC;\n\n\t\tstart = extent_end;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_cache_extent_entries",
          "args": [
            "&io_ctl",
            "ctl",
            "block_group",
            "&entries",
            "&bitmaps",
            "&bitmap_list"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "write_cache_extent_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "879-943",
          "snippet": "static noinline_for_stack\nint write_cache_extent_entries(struct io_ctl *io_ctl,\n\t\t\t      struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_block_group_cache *block_group,\n\t\t\t      int *entries, int *bitmaps,\n\t\t\t      struct list_head *bitmap_list)\n{\n\tint ret;\n\tstruct btrfs_free_cluster *cluster = NULL;\n\tstruct rb_node *node = rb_first(&ctl->free_space_offset);\n\tstruct btrfs_trim_range *trim_entry;\n\n\t/* Get the cluster for this block_group if it exists */\n\tif (block_group && !list_empty(&block_group->cluster_list)) {\n\t\tcluster = list_entry(block_group->cluster_list.next,\n\t\t\t\t     struct btrfs_free_cluster,\n\t\t\t\t     block_group_list);\n\t}\n\n\tif (!node && cluster) {\n\t\tnode = rb_first(&cluster->root);\n\t\tcluster = NULL;\n\t}\n\n\t/* Write out the extent entries */\n\twhile (node) {\n\t\tstruct btrfs_free_space *e;\n\n\t\te = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\t*entries += 1;\n\n\t\tret = io_ctl_add_entry(io_ctl, e->offset, e->bytes,\n\t\t\t\t       e->bitmap);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tif (e->bitmap) {\n\t\t\tlist_add_tail(&e->list, bitmap_list);\n\t\t\t*bitmaps += 1;\n\t\t}\n\t\tnode = rb_next(node);\n\t\tif (!node && cluster) {\n\t\t\tnode = rb_first(&cluster->root);\n\t\t\tcluster = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure we don't miss any range that was removed from our rbtree\n\t * because trimming is running. Otherwise after a umount+mount (or crash\n\t * after committing the transaction) we would leak free space and get\n\t * an inconsistent free space cache report from fsck.\n\t */\n\tlist_for_each_entry(trim_entry, &ctl->trimming_ranges, list) {\n\t\tret = io_ctl_add_entry(io_ctl, trim_entry->start,\n\t\t\t\t       trim_entry->bytes, NULL);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\t*entries += 1;\n\t}\n\n\treturn 0;\nfail:\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic noinline_for_stack\nint write_cache_extent_entries(struct io_ctl *io_ctl,\n\t\t\t      struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_block_group_cache *block_group,\n\t\t\t      int *entries, int *bitmaps,\n\t\t\t      struct list_head *bitmap_list)\n{\n\tint ret;\n\tstruct btrfs_free_cluster *cluster = NULL;\n\tstruct rb_node *node = rb_first(&ctl->free_space_offset);\n\tstruct btrfs_trim_range *trim_entry;\n\n\t/* Get the cluster for this block_group if it exists */\n\tif (block_group && !list_empty(&block_group->cluster_list)) {\n\t\tcluster = list_entry(block_group->cluster_list.next,\n\t\t\t\t     struct btrfs_free_cluster,\n\t\t\t\t     block_group_list);\n\t}\n\n\tif (!node && cluster) {\n\t\tnode = rb_first(&cluster->root);\n\t\tcluster = NULL;\n\t}\n\n\t/* Write out the extent entries */\n\twhile (node) {\n\t\tstruct btrfs_free_space *e;\n\n\t\te = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\t*entries += 1;\n\n\t\tret = io_ctl_add_entry(io_ctl, e->offset, e->bytes,\n\t\t\t\t       e->bitmap);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tif (e->bitmap) {\n\t\t\tlist_add_tail(&e->list, bitmap_list);\n\t\t\t*bitmaps += 1;\n\t\t}\n\t\tnode = rb_next(node);\n\t\tif (!node && cluster) {\n\t\t\tnode = rb_first(&cluster->root);\n\t\t\tcluster = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure we don't miss any range that was removed from our rbtree\n\t * because trimming is running. Otherwise after a umount+mount (or crash\n\t * after committing the transaction) we would leak free space and get\n\t * an inconsistent free space cache report from fsck.\n\t */\n\tlist_for_each_entry(trim_entry, &ctl->trimming_ranges, list) {\n\t\tret = io_ctl_add_entry(io_ctl, trim_entry->start,\n\t\t\t\t       trim_entry->bytes, NULL);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\t*entries += 1;\n\t}\n\n\treturn 0;\nfail:\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_set_generation",
          "args": [
            "&io_ctl",
            "trans->transid"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_set_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "386-407",
          "snippet": "static void io_ctl_set_generation(struct io_ctl *io_ctl, u64 generation)\n{\n\t__le64 *val;\n\n\tio_ctl_map_page(io_ctl, 1);\n\n\t/*\n\t * Skip the csum areas.  If we don't check crcs then we just have a\n\t * 64bit chunk at the front of the first page.\n\t */\n\tif (io_ctl->check_crcs) {\n\t\tio_ctl->cur += (sizeof(u32) * io_ctl->num_pages);\n\t\tio_ctl->size -= sizeof(u64) + (sizeof(u32) * io_ctl->num_pages);\n\t} else {\n\t\tio_ctl->cur += sizeof(u64);\n\t\tio_ctl->size -= sizeof(u64) * 2;\n\t}\n\n\tval = io_ctl->cur;\n\t*val = cpu_to_le64(generation);\n\tio_ctl->cur += sizeof(u64);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_set_generation(struct io_ctl *io_ctl, u64 generation)\n{\n\t__le64 *val;\n\n\tio_ctl_map_page(io_ctl, 1);\n\n\t/*\n\t * Skip the csum areas.  If we don't check crcs then we just have a\n\t * 64bit chunk at the front of the first page.\n\t */\n\tif (io_ctl->check_crcs) {\n\t\tio_ctl->cur += (sizeof(u32) * io_ctl->num_pages);\n\t\tio_ctl->size -= sizeof(u64) + (sizeof(u32) * io_ctl->num_pages);\n\t} else {\n\t\tio_ctl->cur += sizeof(u64);\n\t\tio_ctl->size -= sizeof(u64) * 2;\n\t}\n\n\tval = io_ctl->cur;\n\t*val = cpu_to_le64(generation);\n\tio_ctl->cur += sizeof(u64);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent_bits",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "0",
            "i_size_read(inode) - 1",
            "0",
            "&cached_state"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1332-1350",
          "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_prepare_pages",
          "args": [
            "&io_ctl",
            "inode",
            "0"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_prepare_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "352-384",
          "snippet": "static int io_ctl_prepare_pages(struct io_ctl *io_ctl, struct inode *inode,\n\t\t\t\tint uptodate)\n{\n\tstruct page *page;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint i;\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tpage = find_or_create_page(inode->i_mapping, i, mask);\n\t\tif (!page) {\n\t\t\tio_ctl_drop_pages(io_ctl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tio_ctl->pages[i] = page;\n\t\tif (uptodate && !PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tbtrfs_err(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t   \"error reading free space cache\");\n\t\t\t\tio_ctl_drop_pages(io_ctl);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tclear_page_dirty_for_io(io_ctl->pages[i]);\n\t\tset_page_extent_mapped(io_ctl->pages[i]);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_prepare_pages(struct io_ctl *io_ctl, struct inode *inode,\n\t\t\t\tint uptodate)\n{\n\tstruct page *page;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint i;\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tpage = find_or_create_page(inode->i_mapping, i, mask);\n\t\tif (!page) {\n\t\t\tio_ctl_drop_pages(io_ctl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tio_ctl->pages[i] = page;\n\t\tif (uptodate && !PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tbtrfs_err(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t   \"error reading free space cache\");\n\t\t\t\tio_ctl_drop_pages(io_ctl);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tclear_page_dirty_for_io(io_ctl->pages[i]);\n\t\tset_page_extent_mapped(io_ctl->pages[i]);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&block_group->lock"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&block_group->data_rwsem"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&block_group->lock"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&block_group->data_rwsem"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_init",
          "args": [
            "&io_ctl",
            "inode",
            "root",
            "1"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "283-310",
          "snippet": "static int io_ctl_init(struct io_ctl *io_ctl, struct inode *inode,\n\t\t       struct btrfs_root *root, int write)\n{\n\tint num_pages;\n\tint check_crcs = 0;\n\n\tnum_pages = DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE);\n\n\tif (btrfs_ino(inode) != BTRFS_FREE_INO_OBJECTID)\n\t\tcheck_crcs = 1;\n\n\t/* Make sure we can fit our crcs into the first page */\n\tif (write && check_crcs &&\n\t    (num_pages * sizeof(u32)) >= PAGE_CACHE_SIZE)\n\t\treturn -ENOSPC;\n\n\tmemset(io_ctl, 0, sizeof(struct io_ctl));\n\n\tio_ctl->pages = kzalloc(sizeof(struct page *) * num_pages, GFP_NOFS);\n\tif (!io_ctl->pages)\n\t\treturn -ENOMEM;\n\n\tio_ctl->num_pages = num_pages;\n\tio_ctl->root = root;\n\tio_ctl->check_crcs = check_crcs;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_init(struct io_ctl *io_ctl, struct inode *inode,\n\t\t       struct btrfs_root *root, int write)\n{\n\tint num_pages;\n\tint check_crcs = 0;\n\n\tnum_pages = DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE);\n\n\tif (btrfs_ino(inode) != BTRFS_FREE_INO_OBJECTID)\n\t\tcheck_crcs = 1;\n\n\t/* Make sure we can fit our crcs into the first page */\n\tif (write && check_crcs &&\n\t    (num_pages * sizeof(u32)) >= PAGE_CACHE_SIZE)\n\t\treturn -ENOSPC;\n\n\tmemset(io_ctl, 0, sizeof(struct io_ctl));\n\n\tio_ctl->pages = kzalloc(sizeof(struct page *) * num_pages, GFP_NOFS);\n\tif (!io_ctl->pages)\n\t\treturn -ENOMEM;\n\n\tio_ctl->num_pages = num_pages;\n\tio_ctl->root = root;\n\tio_ctl->check_crcs = check_crcs;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "bitmap_list"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int __btrfs_write_out_cache(struct btrfs_root *root, struct inode *inode,\n\t\t\t\t   struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   struct btrfs_block_group_cache *block_group,\n\t\t\t\t   struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path, u64 offset)\n{\n\tstruct extent_state *cached_state = NULL;\n\tstruct io_ctl io_ctl;\n\tLIST_HEAD(bitmap_list);\n\tint entries = 0;\n\tint bitmaps = 0;\n\tint ret;\n\n\tif (!i_size_read(inode))\n\t\treturn -1;\n\n\tret = io_ctl_init(&io_ctl, inode, root, 1);\n\tif (ret)\n\t\treturn -1;\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA)) {\n\t\tdown_write(&block_group->data_rwsem);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->delalloc_bytes) {\n\t\t\tblock_group->disk_cache_state = BTRFS_DC_WRITTEN;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tup_write(&block_group->data_rwsem);\n\t\t\tBTRFS_I(inode)->generation = 0;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&block_group->lock);\n\t}\n\n\t/* Lock all pages first so we can lock the extent safely. */\n\tio_ctl_prepare_pages(&io_ctl, inode, 0);\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree, 0, i_size_read(inode) - 1,\n\t\t\t 0, &cached_state);\n\n\tio_ctl_set_generation(&io_ctl, trans->transid);\n\n\tmutex_lock(&ctl->cache_writeout_mutex);\n\t/* Write out the extent entries in the free space cache */\n\tret = write_cache_extent_entries(&io_ctl, ctl,\n\t\t\t\t\t block_group, &entries, &bitmaps,\n\t\t\t\t\t &bitmap_list);\n\tif (ret) {\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\tgoto out_nospc;\n\t}\n\n\t/*\n\t * Some spaces that are freed in the current transaction are pinned,\n\t * they will be added into free space cache after the transaction is\n\t * committed, we shouldn't lose them.\n\t */\n\tret = write_pinned_extent_entries(root, block_group, &io_ctl, &entries);\n\tif (ret) {\n\t\tmutex_unlock(&ctl->cache_writeout_mutex);\n\t\tgoto out_nospc;\n\t}\n\n\t/*\n\t * At last, we write out all the bitmaps and keep cache_writeout_mutex\n\t * locked while doing it because a concurrent trim can be manipulating\n\t * or freeing the bitmap.\n\t */\n\tret = write_bitmap_entries(&io_ctl, &bitmap_list);\n\tmutex_unlock(&ctl->cache_writeout_mutex);\n\tif (ret)\n\t\tgoto out_nospc;\n\n\t/* Zero out the rest of the pages just to make sure */\n\tio_ctl_zero_remaining_pages(&io_ctl);\n\n\t/* Everything is written out, now we dirty the pages in the file. */\n\tret = btrfs_dirty_pages(root, inode, io_ctl.pages, io_ctl.num_pages,\n\t\t\t\t0, i_size_read(inode), &cached_state);\n\tif (ret)\n\t\tgoto out_nospc;\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\tup_write(&block_group->data_rwsem);\n\t/*\n\t * Release the pages and unlock the extent, we will flush\n\t * them out later\n\t */\n\tio_ctl_drop_pages(&io_ctl);\n\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t     i_size_read(inode) - 1, &cached_state, GFP_NOFS);\n\n\t/* Flush the dirty pages in the cache file. */\n\tret = flush_dirty_cache(inode);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Update the cache item to tell everyone this cache file is valid. */\n\tret = update_cache_item(trans, root, inode, path, offset,\n\t\t\t\tentries, bitmaps);\nout:\n\tio_ctl_free(&io_ctl);\n\tif (ret) {\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t\tBTRFS_I(inode)->generation = 0;\n\t}\n\tbtrfs_update_inode(trans, root, inode);\n\treturn ret;\n\nout_nospc:\n\tcleanup_write_cache_enospc(inode, &io_ctl, &cached_state, &bitmap_list);\n\n\tif (block_group && (block_group->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\tup_write(&block_group->data_rwsem);\n\n\tgoto out;\n}"
  },
  {
    "function_name": "cleanup_write_cache_enospc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1085-1102",
    "snippet": "static void noinline_for_stack\ncleanup_write_cache_enospc(struct inode *inode,\n\t\t\t   struct io_ctl *io_ctl,\n\t\t\t   struct extent_state **cached_state,\n\t\t\t   struct list_head *bitmap_list)\n{\n\tstruct list_head *pos, *n;\n\n\tlist_for_each_safe(pos, n, bitmap_list) {\n\t\tstruct btrfs_free_space *entry =\n\t\t\tlist_entry(pos, struct btrfs_free_space, list);\n\t\tlist_del_init(&entry->list);\n\t}\n\tio_ctl_drop_pages(io_ctl);\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t     i_size_read(inode) - 1, cached_state,\n\t\t\t     GFP_NOFS);\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "0",
            "i_size_read(inode) - 1",
            "cached_state",
            "GFP_NOFS"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_ctl_drop_pages",
          "args": [
            "io_ctl"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_drop_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "337-350",
          "snippet": "static void io_ctl_drop_pages(struct io_ctl *io_ctl)\n{\n\tint i;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tif (io_ctl->pages[i]) {\n\t\t\tClearPageChecked(io_ctl->pages[i]);\n\t\t\tunlock_page(io_ctl->pages[i]);\n\t\t\tpage_cache_release(io_ctl->pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_drop_pages(struct io_ctl *io_ctl)\n{\n\tint i;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tif (io_ctl->pages[i]) {\n\t\t\tClearPageChecked(io_ctl->pages[i]);\n\t\t\tunlock_page(io_ctl->pages[i]);\n\t\t\tpage_cache_release(io_ctl->pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&entry->list"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structbtrfs_free_space",
            "list"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "n",
            "bitmap_list"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void noinline_for_stack\ncleanup_write_cache_enospc(struct inode *inode,\n\t\t\t   struct io_ctl *io_ctl,\n\t\t\t   struct extent_state **cached_state,\n\t\t\t   struct list_head *bitmap_list)\n{\n\tstruct list_head *pos, *n;\n\n\tlist_for_each_safe(pos, n, bitmap_list) {\n\t\tstruct btrfs_free_space *entry =\n\t\t\tlist_entry(pos, struct btrfs_free_space, list);\n\t\tlist_del_init(&entry->list);\n\t}\n\tio_ctl_drop_pages(io_ctl);\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t     i_size_read(inode) - 1, cached_state,\n\t\t\t     GFP_NOFS);\n}"
  },
  {
    "function_name": "flush_dirty_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1072-1083",
    "snippet": "static int flush_dirty_cache(struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_wait_ordered_range(inode, 0, (u64)-1);\n\tif (ret)\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0, inode->i_size - 1,\n\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC, 0, 0, NULL,\n\t\t\t\t GFP_NOFS);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "0",
            "inode->i_size - 1",
            "EXTENT_DIRTY | EXTENT_DELALLOC",
            "0",
            "0",
            "NULL",
            "GFP_NOFS"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wait_ordered_range",
          "args": [
            "inode",
            "0",
            "(u64)-1"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_ordered_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "722-771",
          "snippet": "int btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int flush_dirty_cache(struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_wait_ordered_range(inode, 0, (u64)-1);\n\tif (ret)\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0, inode->i_size - 1,\n\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC, 0, 0, NULL,\n\t\t\t\t GFP_NOFS);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "write_bitmap_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1052-1070",
    "snippet": "static noinline_for_stack int\nwrite_bitmap_entries(struct io_ctl *io_ctl, struct list_head *bitmap_list)\n{\n\tstruct list_head *pos, *n;\n\tint ret;\n\n\t/* Write out the bitmaps */\n\tlist_for_each_safe(pos, n, bitmap_list) {\n\t\tstruct btrfs_free_space *entry =\n\t\t\tlist_entry(pos, struct btrfs_free_space, list);\n\n\t\tret = io_ctl_add_bitmap(io_ctl, entry->bitmap);\n\t\tif (ret)\n\t\t\treturn -ENOSPC;\n\t\tlist_del_init(&entry->list);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&entry->list"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_add_bitmap",
          "args": [
            "io_ctl",
            "entry->bitmap"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_add_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "525-546",
          "snippet": "static int io_ctl_add_bitmap(struct io_ctl *io_ctl, void *bitmap)\n{\n\tif (!io_ctl->cur)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * If we aren't at the start of the current page, unmap this one and\n\t * map the next one if there is any left.\n\t */\n\tif (io_ctl->cur != io_ctl->orig) {\n\t\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\t\tif (io_ctl->index >= io_ctl->num_pages)\n\t\t\treturn -ENOSPC;\n\t\tio_ctl_map_page(io_ctl, 0);\n\t}\n\n\tmemcpy(io_ctl->cur, bitmap, PAGE_CACHE_SIZE);\n\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\tif (io_ctl->index < io_ctl->num_pages)\n\t\tio_ctl_map_page(io_ctl, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_add_bitmap(struct io_ctl *io_ctl, void *bitmap)\n{\n\tif (!io_ctl->cur)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * If we aren't at the start of the current page, unmap this one and\n\t * map the next one if there is any left.\n\t */\n\tif (io_ctl->cur != io_ctl->orig) {\n\t\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\t\tif (io_ctl->index >= io_ctl->num_pages)\n\t\t\treturn -ENOSPC;\n\t\tio_ctl_map_page(io_ctl, 0);\n\t}\n\n\tmemcpy(io_ctl->cur, bitmap, PAGE_CACHE_SIZE);\n\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\tif (io_ctl->index < io_ctl->num_pages)\n\t\tio_ctl_map_page(io_ctl, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structbtrfs_free_space",
            "list"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "n",
            "bitmap_list"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic noinline_for_stack int\nwrite_bitmap_entries(struct io_ctl *io_ctl, struct list_head *bitmap_list)\n{\n\tstruct list_head *pos, *n;\n\tint ret;\n\n\t/* Write out the bitmaps */\n\tlist_for_each_safe(pos, n, bitmap_list) {\n\t\tstruct btrfs_free_space *entry =\n\t\t\tlist_entry(pos, struct btrfs_free_space, list);\n\n\t\tret = io_ctl_add_bitmap(io_ctl, entry->bitmap);\n\t\tif (ret)\n\t\t\treturn -ENOSPC;\n\t\tlist_del_init(&entry->list);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "write_pinned_extent_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "1000-1050",
    "snippet": "static noinline_for_stack int\nwrite_pinned_extent_entries(struct btrfs_root *root,\n\t\t\t    struct btrfs_block_group_cache *block_group,\n\t\t\t    struct io_ctl *io_ctl,\n\t\t\t    int *entries)\n{\n\tu64 start, extent_start, extent_end, len;\n\tstruct extent_io_tree *unpin = NULL;\n\tint ret;\n\n\tif (!block_group)\n\t\treturn 0;\n\n\t/*\n\t * We want to add any pinned extents to our free space cache\n\t * so we don't leak the space\n\t *\n\t * We shouldn't have switched the pinned extents yet so this is the\n\t * right one\n\t */\n\tunpin = root->fs_info->pinned_extents;\n\n\tstart = block_group->key.objectid;\n\n\twhile (start < block_group->key.objectid + block_group->key.offset) {\n\t\tret = find_first_extent_bit(unpin, start,\n\t\t\t\t\t    &extent_start, &extent_end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\t/* This pinned extent is out of our range */\n\t\tif (extent_start >= block_group->key.objectid +\n\t\t    block_group->key.offset)\n\t\t\treturn 0;\n\n\t\textent_start = max(extent_start, start);\n\t\textent_end = min(block_group->key.objectid +\n\t\t\t\t block_group->key.offset, extent_end + 1);\n\t\tlen = extent_end - extent_start;\n\n\t\t*entries += 1;\n\t\tret = io_ctl_add_entry(io_ctl, extent_start, len, NULL);\n\t\tif (ret)\n\t\t\treturn -ENOSPC;\n\n\t\tstart = extent_end;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_ctl_add_entry",
          "args": [
            "io_ctl",
            "extent_start",
            "len",
            "NULL"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "495-523",
          "snippet": "static int io_ctl_add_entry(struct io_ctl *io_ctl, u64 offset, u64 bytes,\n\t\t\t    void *bitmap)\n{\n\tstruct btrfs_free_space_entry *entry;\n\n\tif (!io_ctl->cur)\n\t\treturn -ENOSPC;\n\n\tentry = io_ctl->cur;\n\tentry->offset = cpu_to_le64(offset);\n\tentry->bytes = cpu_to_le64(bytes);\n\tentry->type = (bitmap) ? BTRFS_FREE_SPACE_BITMAP :\n\t\tBTRFS_FREE_SPACE_EXTENT;\n\tio_ctl->cur += sizeof(struct btrfs_free_space_entry);\n\tio_ctl->size -= sizeof(struct btrfs_free_space_entry);\n\n\tif (io_ctl->size >= sizeof(struct btrfs_free_space_entry))\n\t\treturn 0;\n\n\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\n\t/* No more pages to map */\n\tif (io_ctl->index >= io_ctl->num_pages)\n\t\treturn 0;\n\n\t/* map the next page */\n\tio_ctl_map_page(io_ctl, 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_add_entry(struct io_ctl *io_ctl, u64 offset, u64 bytes,\n\t\t\t    void *bitmap)\n{\n\tstruct btrfs_free_space_entry *entry;\n\n\tif (!io_ctl->cur)\n\t\treturn -ENOSPC;\n\n\tentry = io_ctl->cur;\n\tentry->offset = cpu_to_le64(offset);\n\tentry->bytes = cpu_to_le64(bytes);\n\tentry->type = (bitmap) ? BTRFS_FREE_SPACE_BITMAP :\n\t\tBTRFS_FREE_SPACE_EXTENT;\n\tio_ctl->cur += sizeof(struct btrfs_free_space_entry);\n\tio_ctl->size -= sizeof(struct btrfs_free_space_entry);\n\n\tif (io_ctl->size >= sizeof(struct btrfs_free_space_entry))\n\t\treturn 0;\n\n\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\n\t/* No more pages to map */\n\tif (io_ctl->index >= io_ctl->num_pages)\n\t\treturn 0;\n\n\t/* map the next page */\n\tio_ctl_map_page(io_ctl, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "block_group->key.objectid +\n\t\t\t\t block_group->key.offset",
            "extent_end + 1"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "extent_start",
            "start"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_extent_bit",
          "args": [
            "unpin",
            "start",
            "&extent_start",
            "&extent_end",
            "EXTENT_DIRTY",
            "NULL"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "find_first_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1477-1516",
          "snippet": "int find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic noinline_for_stack int\nwrite_pinned_extent_entries(struct btrfs_root *root,\n\t\t\t    struct btrfs_block_group_cache *block_group,\n\t\t\t    struct io_ctl *io_ctl,\n\t\t\t    int *entries)\n{\n\tu64 start, extent_start, extent_end, len;\n\tstruct extent_io_tree *unpin = NULL;\n\tint ret;\n\n\tif (!block_group)\n\t\treturn 0;\n\n\t/*\n\t * We want to add any pinned extents to our free space cache\n\t * so we don't leak the space\n\t *\n\t * We shouldn't have switched the pinned extents yet so this is the\n\t * right one\n\t */\n\tunpin = root->fs_info->pinned_extents;\n\n\tstart = block_group->key.objectid;\n\n\twhile (start < block_group->key.objectid + block_group->key.offset) {\n\t\tret = find_first_extent_bit(unpin, start,\n\t\t\t\t\t    &extent_start, &extent_end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\t/* This pinned extent is out of our range */\n\t\tif (extent_start >= block_group->key.objectid +\n\t\t    block_group->key.offset)\n\t\t\treturn 0;\n\n\t\textent_start = max(extent_start, start);\n\t\textent_end = min(block_group->key.objectid +\n\t\t\t\t block_group->key.offset, extent_end + 1);\n\t\tlen = extent_end - extent_start;\n\n\t\t*entries += 1;\n\t\tret = io_ctl_add_entry(io_ctl, extent_start, len, NULL);\n\t\tif (ret)\n\t\t\treturn -ENOSPC;\n\n\t\tstart = extent_end;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "update_cache_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "945-998",
    "snippet": "static noinline_for_stack int\nupdate_cache_item(struct btrfs_trans_handle *trans,\n\t\t  struct btrfs_root *root,\n\t\t  struct inode *inode,\n\t\t  struct btrfs_path *path, u64 offset,\n\t\t  int entries, int bitmaps)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0) {\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0, inode->i_size - 1,\n\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC, 0, 0, NULL,\n\t\t\t\t GFP_NOFS);\n\t\tgoto fail;\n\t}\n\tleaf = path->nodes[0];\n\tif (ret > 0) {\n\t\tstruct btrfs_key found_key;\n\t\tASSERT(path->slots[0]);\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid != BTRFS_FREE_SPACE_OBJECTID ||\n\t\t    found_key.offset != offset) {\n\t\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t\t\t inode->i_size - 1,\n\t\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC, 0, 0,\n\t\t\t\t\t NULL, GFP_NOFS);\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tBTRFS_I(inode)->generation = trans->transid;\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tbtrfs_set_free_space_entries(leaf, header, entries);\n\tbtrfs_set_free_space_bitmaps(leaf, header, bitmaps);\n\tbtrfs_set_free_space_generation(leaf, header, trans->transid);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\treturn 0;\n\nfail:\n\treturn -1;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_free_space_generation",
          "args": [
            "leaf",
            "header",
            "trans->transid"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_free_space_bitmaps",
          "args": [
            "leaf",
            "header",
            "bitmaps"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_free_space_entries",
          "args": [
            "leaf",
            "header",
            "entries"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_free_space_header"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "0",
            "inode->i_size - 1",
            "EXTENT_DIRTY | EXTENT_DELALLOC",
            "0",
            "0",
            "NULL",
            "GFP_NOFS"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "path->slots[0]"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "0",
            "1"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic noinline_for_stack int\nupdate_cache_item(struct btrfs_trans_handle *trans,\n\t\t  struct btrfs_root *root,\n\t\t  struct inode *inode,\n\t\t  struct btrfs_path *path, u64 offset,\n\t\t  int entries, int bitmaps)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0) {\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0, inode->i_size - 1,\n\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC, 0, 0, NULL,\n\t\t\t\t GFP_NOFS);\n\t\tgoto fail;\n\t}\n\tleaf = path->nodes[0];\n\tif (ret > 0) {\n\t\tstruct btrfs_key found_key;\n\t\tASSERT(path->slots[0]);\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid != BTRFS_FREE_SPACE_OBJECTID ||\n\t\t    found_key.offset != offset) {\n\t\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0,\n\t\t\t\t\t inode->i_size - 1,\n\t\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC, 0, 0,\n\t\t\t\t\t NULL, GFP_NOFS);\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tBTRFS_I(inode)->generation = trans->transid;\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tbtrfs_set_free_space_entries(leaf, header, entries);\n\tbtrfs_set_free_space_bitmaps(leaf, header, bitmaps);\n\tbtrfs_set_free_space_generation(leaf, header, trans->transid);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\treturn 0;\n\nfail:\n\treturn -1;\n}"
  },
  {
    "function_name": "write_cache_extent_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "879-943",
    "snippet": "static noinline_for_stack\nint write_cache_extent_entries(struct io_ctl *io_ctl,\n\t\t\t      struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_block_group_cache *block_group,\n\t\t\t      int *entries, int *bitmaps,\n\t\t\t      struct list_head *bitmap_list)\n{\n\tint ret;\n\tstruct btrfs_free_cluster *cluster = NULL;\n\tstruct rb_node *node = rb_first(&ctl->free_space_offset);\n\tstruct btrfs_trim_range *trim_entry;\n\n\t/* Get the cluster for this block_group if it exists */\n\tif (block_group && !list_empty(&block_group->cluster_list)) {\n\t\tcluster = list_entry(block_group->cluster_list.next,\n\t\t\t\t     struct btrfs_free_cluster,\n\t\t\t\t     block_group_list);\n\t}\n\n\tif (!node && cluster) {\n\t\tnode = rb_first(&cluster->root);\n\t\tcluster = NULL;\n\t}\n\n\t/* Write out the extent entries */\n\twhile (node) {\n\t\tstruct btrfs_free_space *e;\n\n\t\te = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\t*entries += 1;\n\n\t\tret = io_ctl_add_entry(io_ctl, e->offset, e->bytes,\n\t\t\t\t       e->bitmap);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tif (e->bitmap) {\n\t\t\tlist_add_tail(&e->list, bitmap_list);\n\t\t\t*bitmaps += 1;\n\t\t}\n\t\tnode = rb_next(node);\n\t\tif (!node && cluster) {\n\t\t\tnode = rb_first(&cluster->root);\n\t\t\tcluster = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure we don't miss any range that was removed from our rbtree\n\t * because trimming is running. Otherwise after a umount+mount (or crash\n\t * after committing the transaction) we would leak free space and get\n\t * an inconsistent free space cache report from fsck.\n\t */\n\tlist_for_each_entry(trim_entry, &ctl->trimming_ranges, list) {\n\t\tret = io_ctl_add_entry(io_ctl, trim_entry->start,\n\t\t\t\t       trim_entry->bytes, NULL);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\t*entries += 1;\n\t}\n\n\treturn 0;\nfail:\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_ctl_add_entry",
          "args": [
            "io_ctl",
            "trim_entry->start",
            "trim_entry->bytes",
            "NULL"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "495-523",
          "snippet": "static int io_ctl_add_entry(struct io_ctl *io_ctl, u64 offset, u64 bytes,\n\t\t\t    void *bitmap)\n{\n\tstruct btrfs_free_space_entry *entry;\n\n\tif (!io_ctl->cur)\n\t\treturn -ENOSPC;\n\n\tentry = io_ctl->cur;\n\tentry->offset = cpu_to_le64(offset);\n\tentry->bytes = cpu_to_le64(bytes);\n\tentry->type = (bitmap) ? BTRFS_FREE_SPACE_BITMAP :\n\t\tBTRFS_FREE_SPACE_EXTENT;\n\tio_ctl->cur += sizeof(struct btrfs_free_space_entry);\n\tio_ctl->size -= sizeof(struct btrfs_free_space_entry);\n\n\tif (io_ctl->size >= sizeof(struct btrfs_free_space_entry))\n\t\treturn 0;\n\n\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\n\t/* No more pages to map */\n\tif (io_ctl->index >= io_ctl->num_pages)\n\t\treturn 0;\n\n\t/* map the next page */\n\tio_ctl_map_page(io_ctl, 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_add_entry(struct io_ctl *io_ctl, u64 offset, u64 bytes,\n\t\t\t    void *bitmap)\n{\n\tstruct btrfs_free_space_entry *entry;\n\n\tif (!io_ctl->cur)\n\t\treturn -ENOSPC;\n\n\tentry = io_ctl->cur;\n\tentry->offset = cpu_to_le64(offset);\n\tentry->bytes = cpu_to_le64(bytes);\n\tentry->type = (bitmap) ? BTRFS_FREE_SPACE_BITMAP :\n\t\tBTRFS_FREE_SPACE_EXTENT;\n\tio_ctl->cur += sizeof(struct btrfs_free_space_entry);\n\tio_ctl->size -= sizeof(struct btrfs_free_space_entry);\n\n\tif (io_ctl->size >= sizeof(struct btrfs_free_space_entry))\n\t\treturn 0;\n\n\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\n\t/* No more pages to map */\n\tif (io_ctl->index >= io_ctl->num_pages)\n\t\treturn 0;\n\n\t/* map the next page */\n\tio_ctl_map_page(io_ctl, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "trim_entry",
            "&ctl->trimming_ranges",
            "list"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&cluster->root"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&e->list",
            "bitmap_list"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&cluster->root"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "block_group->cluster_list.next",
            "structbtrfs_free_cluster",
            "block_group_list"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&block_group->cluster_list"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ctl->free_space_offset"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic noinline_for_stack\nint write_cache_extent_entries(struct io_ctl *io_ctl,\n\t\t\t      struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_block_group_cache *block_group,\n\t\t\t      int *entries, int *bitmaps,\n\t\t\t      struct list_head *bitmap_list)\n{\n\tint ret;\n\tstruct btrfs_free_cluster *cluster = NULL;\n\tstruct rb_node *node = rb_first(&ctl->free_space_offset);\n\tstruct btrfs_trim_range *trim_entry;\n\n\t/* Get the cluster for this block_group if it exists */\n\tif (block_group && !list_empty(&block_group->cluster_list)) {\n\t\tcluster = list_entry(block_group->cluster_list.next,\n\t\t\t\t     struct btrfs_free_cluster,\n\t\t\t\t     block_group_list);\n\t}\n\n\tif (!node && cluster) {\n\t\tnode = rb_first(&cluster->root);\n\t\tcluster = NULL;\n\t}\n\n\t/* Write out the extent entries */\n\twhile (node) {\n\t\tstruct btrfs_free_space *e;\n\n\t\te = rb_entry(node, struct btrfs_free_space, offset_index);\n\t\t*entries += 1;\n\n\t\tret = io_ctl_add_entry(io_ctl, e->offset, e->bytes,\n\t\t\t\t       e->bitmap);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tif (e->bitmap) {\n\t\t\tlist_add_tail(&e->list, bitmap_list);\n\t\t\t*bitmaps += 1;\n\t\t}\n\t\tnode = rb_next(node);\n\t\tif (!node && cluster) {\n\t\t\tnode = rb_first(&cluster->root);\n\t\t\tcluster = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure we don't miss any range that was removed from our rbtree\n\t * because trimming is running. Otherwise after a umount+mount (or crash\n\t * after committing the transaction) we would leak free space and get\n\t * an inconsistent free space cache report from fsck.\n\t */\n\tlist_for_each_entry(trim_entry, &ctl->trimming_ranges, list) {\n\t\tret = io_ctl_add_entry(io_ctl, trim_entry->start,\n\t\t\t\t       trim_entry->bytes, NULL);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\t*entries += 1;\n\t}\n\n\treturn 0;\nfail:\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "load_free_space_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "803-877",
    "snippet": "int load_free_space_cache(struct btrfs_fs_info *fs_info,\n\t\t\t  struct btrfs_block_group_cache *block_group)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct inode *inode;\n\tstruct btrfs_path *path;\n\tint ret = 0;\n\tbool matched;\n\tu64 used = btrfs_block_group_used(&block_group->item);\n\n\t/*\n\t * If this block group has been marked to be cleared for one reason or\n\t * another then we can't trust the on disk cache, so just return.\n\t */\n\tspin_lock(&block_group->lock);\n\tif (block_group->disk_cache_state != BTRFS_DC_WRITTEN) {\n\t\tspin_unlock(&block_group->lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn 0;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tinode = lookup_free_space_inode(root, block_group, path);\n\tif (IS_ERR(inode)) {\n\t\tbtrfs_free_path(path);\n\t\treturn 0;\n\t}\n\n\t/* We may have converted the inode and made the cache invalid. */\n\tspin_lock(&block_group->lock);\n\tif (block_group->disk_cache_state != BTRFS_DC_WRITTEN) {\n\t\tspin_unlock(&block_group->lock);\n\t\tbtrfs_free_path(path);\n\t\tgoto out;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\tret = __load_free_space_cache(fs_info->tree_root, inode, ctl,\n\t\t\t\t      path, block_group->key.objectid);\n\tbtrfs_free_path(path);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tspin_lock(&ctl->tree_lock);\n\tmatched = (ctl->free_space == (block_group->key.offset - used -\n\t\t\t\t       block_group->bytes_super));\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (!matched) {\n\t\t__btrfs_remove_free_space_cache(ctl);\n\t\tbtrfs_warn(fs_info, \"block group %llu has wrong amount of free space\",\n\t\t\tblock_group->key.objectid);\n\t\tret = -1;\n\t}\nout:\n\tif (ret < 0) {\n\t\t/* This cache is bogus, make sure it gets cleared */\n\t\tspin_lock(&block_group->lock);\n\t\tblock_group->disk_cache_state = BTRFS_DC_CLEAR;\n\t\tspin_unlock(&block_group->lock);\n\t\tret = 0;\n\n\t\tbtrfs_warn(fs_info, \"failed to load free space cache for block group %llu, rebuild it now\",\n\t\t\tblock_group->key.objectid);\n\t}\n\n\tiput(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"failed to load free space cache for block group %llu, rebuild it now\"",
            "block_group->key.objectid"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&block_group->lock"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&block_group->lock"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"block group %llu has wrong amount of free space\"",
            "block_group->key.objectid"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_remove_free_space_cache",
          "args": [
            "ctl"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_remove_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2413-2418",
          "snippet": "void __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nvoid __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__load_free_space_cache",
          "args": [
            "fs_info->tree_root",
            "inode",
            "ctl",
            "path",
            "block_group->key.objectid"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "__load_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "645-801",
          "snippet": "static int __load_free_space_cache(struct btrfs_root *root, struct inode *inode,\n\t\t\t\t   struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   struct btrfs_path *path, u64 offset)\n{\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tstruct io_ctl io_ctl;\n\tstruct btrfs_key key;\n\tstruct btrfs_free_space *e, *n;\n\tLIST_HEAD(bitmaps);\n\tu64 num_entries;\n\tu64 num_bitmaps;\n\tu64 generation;\n\tu8 type;\n\tint ret = 0;\n\n\t/* Nothing in the space cache, goodbye */\n\tif (!i_size_read(inode))\n\t\treturn 0;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn 0;\n\telse if (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn 0;\n\t}\n\n\tret = -1;\n\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tnum_entries = btrfs_free_space_entries(leaf, header);\n\tnum_bitmaps = btrfs_free_space_bitmaps(leaf, header);\n\tgeneration = btrfs_free_space_generation(leaf, header);\n\tbtrfs_release_path(path);\n\n\tif (!BTRFS_I(inode)->generation) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t   \"The free space cache file (%llu) is invalid. skip it\\n\",\n\t\t\t   offset);\n\t\treturn 0;\n\t}\n\n\tif (BTRFS_I(inode)->generation != generation) {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"free space inode generation (%llu) \"\n\t\t\t\"did not match free space cache generation (%llu)\",\n\t\t\tBTRFS_I(inode)->generation, generation);\n\t\treturn 0;\n\t}\n\n\tif (!num_entries)\n\t\treturn 0;\n\n\tret = io_ctl_init(&io_ctl, inode, root, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = readahead_cache(inode);\n\tif (ret)\n\t\tgoto out;\n\n\tret = io_ctl_prepare_pages(&io_ctl, inode, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tret = io_ctl_check_crc(&io_ctl, 0);\n\tif (ret)\n\t\tgoto free_cache;\n\n\tret = io_ctl_check_generation(&io_ctl, generation);\n\tif (ret)\n\t\tgoto free_cache;\n\n\twhile (num_entries) {\n\t\te = kmem_cache_zalloc(btrfs_free_space_cachep,\n\t\t\t\t      GFP_NOFS);\n\t\tif (!e)\n\t\t\tgoto free_cache;\n\n\t\tret = io_ctl_read_entry(&io_ctl, e, &type);\n\t\tif (ret) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tgoto free_cache;\n\t\t}\n\n\t\tif (!e->bytes) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tgoto free_cache;\n\t\t}\n\n\t\tif (type == BTRFS_FREE_SPACE_EXTENT) {\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\tret = link_free_space(ctl, e);\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\t\"Duplicate entries in free space cache, dumping\");\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(num_bitmaps);\n\t\t\tnum_bitmaps--;\n\t\t\te->bitmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\t\tif (!e->bitmap) {\n\t\t\t\tkmem_cache_free(\n\t\t\t\t\tbtrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\tret = link_free_space(ctl, e);\n\t\t\tctl->total_bitmaps++;\n\t\t\tctl->op->recalc_thresholds(ctl);\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\t\"Duplicate entries in free space cache, dumping\");\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t\tlist_add_tail(&e->list, &bitmaps);\n\t\t}\n\n\t\tnum_entries--;\n\t}\n\n\tio_ctl_unmap_page(&io_ctl);\n\n\t/*\n\t * We add the bitmaps at the end of the entries in order that\n\t * the bitmap entries are added to the cache.\n\t */\n\tlist_for_each_entry_safe(e, n, &bitmaps, list) {\n\t\tlist_del_init(&e->list);\n\t\tret = io_ctl_read_bitmap(&io_ctl, e);\n\t\tif (ret)\n\t\t\tgoto free_cache;\n\t}\n\n\tio_ctl_drop_pages(&io_ctl);\n\tmerge_space_tree(ctl);\n\tret = 1;\nout:\n\tio_ctl_free(&io_ctl);\n\treturn ret;\nfree_cache:\n\tio_ctl_drop_pages(&io_ctl);\n\t__btrfs_remove_free_space_cache(ctl);\n\tgoto out;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int __load_free_space_cache(struct btrfs_root *root, struct inode *inode,\n\t\t\t\t   struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   struct btrfs_path *path, u64 offset)\n{\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tstruct io_ctl io_ctl;\n\tstruct btrfs_key key;\n\tstruct btrfs_free_space *e, *n;\n\tLIST_HEAD(bitmaps);\n\tu64 num_entries;\n\tu64 num_bitmaps;\n\tu64 generation;\n\tu8 type;\n\tint ret = 0;\n\n\t/* Nothing in the space cache, goodbye */\n\tif (!i_size_read(inode))\n\t\treturn 0;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn 0;\n\telse if (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn 0;\n\t}\n\n\tret = -1;\n\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tnum_entries = btrfs_free_space_entries(leaf, header);\n\tnum_bitmaps = btrfs_free_space_bitmaps(leaf, header);\n\tgeneration = btrfs_free_space_generation(leaf, header);\n\tbtrfs_release_path(path);\n\n\tif (!BTRFS_I(inode)->generation) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t   \"The free space cache file (%llu) is invalid. skip it\\n\",\n\t\t\t   offset);\n\t\treturn 0;\n\t}\n\n\tif (BTRFS_I(inode)->generation != generation) {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"free space inode generation (%llu) \"\n\t\t\t\"did not match free space cache generation (%llu)\",\n\t\t\tBTRFS_I(inode)->generation, generation);\n\t\treturn 0;\n\t}\n\n\tif (!num_entries)\n\t\treturn 0;\n\n\tret = io_ctl_init(&io_ctl, inode, root, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = readahead_cache(inode);\n\tif (ret)\n\t\tgoto out;\n\n\tret = io_ctl_prepare_pages(&io_ctl, inode, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tret = io_ctl_check_crc(&io_ctl, 0);\n\tif (ret)\n\t\tgoto free_cache;\n\n\tret = io_ctl_check_generation(&io_ctl, generation);\n\tif (ret)\n\t\tgoto free_cache;\n\n\twhile (num_entries) {\n\t\te = kmem_cache_zalloc(btrfs_free_space_cachep,\n\t\t\t\t      GFP_NOFS);\n\t\tif (!e)\n\t\t\tgoto free_cache;\n\n\t\tret = io_ctl_read_entry(&io_ctl, e, &type);\n\t\tif (ret) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tgoto free_cache;\n\t\t}\n\n\t\tif (!e->bytes) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tgoto free_cache;\n\t\t}\n\n\t\tif (type == BTRFS_FREE_SPACE_EXTENT) {\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\tret = link_free_space(ctl, e);\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\t\"Duplicate entries in free space cache, dumping\");\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(num_bitmaps);\n\t\t\tnum_bitmaps--;\n\t\t\te->bitmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\t\tif (!e->bitmap) {\n\t\t\t\tkmem_cache_free(\n\t\t\t\t\tbtrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\tret = link_free_space(ctl, e);\n\t\t\tctl->total_bitmaps++;\n\t\t\tctl->op->recalc_thresholds(ctl);\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\t\"Duplicate entries in free space cache, dumping\");\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t\tlist_add_tail(&e->list, &bitmaps);\n\t\t}\n\n\t\tnum_entries--;\n\t}\n\n\tio_ctl_unmap_page(&io_ctl);\n\n\t/*\n\t * We add the bitmaps at the end of the entries in order that\n\t * the bitmap entries are added to the cache.\n\t */\n\tlist_for_each_entry_safe(e, n, &bitmaps, list) {\n\t\tlist_del_init(&e->list);\n\t\tret = io_ctl_read_bitmap(&io_ctl, e);\n\t\tif (ret)\n\t\t\tgoto free_cache;\n\t}\n\n\tio_ctl_drop_pages(&io_ctl);\n\tmerge_space_tree(ctl);\n\tret = 1;\nout:\n\tio_ctl_free(&io_ctl);\n\treturn ret;\nfree_cache:\n\tio_ctl_drop_pages(&io_ctl);\n\t__btrfs_remove_free_space_cache(ctl);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_free_space_inode",
          "args": [
            "root",
            "block_group",
            "path"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_free_space_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "93-128",
          "snippet": "struct inode *lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_group_cache\n\t\t\t\t      *block_group, struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\tu32 flags = BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->inode)\n\t\tinode = igrab(block_group->inode);\n\tspin_unlock(&block_group->lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path,\n\t\t\t\t\t  block_group->key.objectid);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&block_group->lock);\n\tif (!((BTRFS_I(inode)->flags & flags) == flags)) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t\"Old style space inode found, converting.\");\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATASUM |\n\t\t\tBTRFS_INODE_NODATACOW;\n\t\tblock_group->disk_cache_state = BTRFS_DC_CLEAR;\n\t}\n\n\tif (!block_group->iref) {\n\t\tblock_group->inode = igrab(inode);\n\t\tblock_group->iref = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstruct inode *lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_group_cache\n\t\t\t\t      *block_group, struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\tu32 flags = BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->inode)\n\t\tinode = igrab(block_group->inode);\n\tspin_unlock(&block_group->lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path,\n\t\t\t\t\t  block_group->key.objectid);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&block_group->lock);\n\tif (!((BTRFS_I(inode)->flags & flags) == flags)) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t\"Old style space inode found, converting.\");\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATASUM |\n\t\t\tBTRFS_INODE_NODATACOW;\n\t\tblock_group->disk_cache_state = BTRFS_DC_CLEAR;\n\t}\n\n\tif (!block_group->iref) {\n\t\tblock_group->inode = igrab(inode);\n\t\tblock_group->iref = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_block_group_used",
          "args": [
            "&block_group->item"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint load_free_space_cache(struct btrfs_fs_info *fs_info,\n\t\t\t  struct btrfs_block_group_cache *block_group)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct inode *inode;\n\tstruct btrfs_path *path;\n\tint ret = 0;\n\tbool matched;\n\tu64 used = btrfs_block_group_used(&block_group->item);\n\n\t/*\n\t * If this block group has been marked to be cleared for one reason or\n\t * another then we can't trust the on disk cache, so just return.\n\t */\n\tspin_lock(&block_group->lock);\n\tif (block_group->disk_cache_state != BTRFS_DC_WRITTEN) {\n\t\tspin_unlock(&block_group->lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn 0;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tinode = lookup_free_space_inode(root, block_group, path);\n\tif (IS_ERR(inode)) {\n\t\tbtrfs_free_path(path);\n\t\treturn 0;\n\t}\n\n\t/* We may have converted the inode and made the cache invalid. */\n\tspin_lock(&block_group->lock);\n\tif (block_group->disk_cache_state != BTRFS_DC_WRITTEN) {\n\t\tspin_unlock(&block_group->lock);\n\t\tbtrfs_free_path(path);\n\t\tgoto out;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\tret = __load_free_space_cache(fs_info->tree_root, inode, ctl,\n\t\t\t\t      path, block_group->key.objectid);\n\tbtrfs_free_path(path);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tspin_lock(&ctl->tree_lock);\n\tmatched = (ctl->free_space == (block_group->key.offset - used -\n\t\t\t\t       block_group->bytes_super));\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (!matched) {\n\t\t__btrfs_remove_free_space_cache(ctl);\n\t\tbtrfs_warn(fs_info, \"block group %llu has wrong amount of free space\",\n\t\t\tblock_group->key.objectid);\n\t\tret = -1;\n\t}\nout:\n\tif (ret < 0) {\n\t\t/* This cache is bogus, make sure it gets cleared */\n\t\tspin_lock(&block_group->lock);\n\t\tblock_group->disk_cache_state = BTRFS_DC_CLEAR;\n\t\tspin_unlock(&block_group->lock);\n\t\tret = 0;\n\n\t\tbtrfs_warn(fs_info, \"failed to load free space cache for block group %llu, rebuild it now\",\n\t\t\tblock_group->key.objectid);\n\t}\n\n\tiput(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "__load_free_space_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "645-801",
    "snippet": "static int __load_free_space_cache(struct btrfs_root *root, struct inode *inode,\n\t\t\t\t   struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   struct btrfs_path *path, u64 offset)\n{\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tstruct io_ctl io_ctl;\n\tstruct btrfs_key key;\n\tstruct btrfs_free_space *e, *n;\n\tLIST_HEAD(bitmaps);\n\tu64 num_entries;\n\tu64 num_bitmaps;\n\tu64 generation;\n\tu8 type;\n\tint ret = 0;\n\n\t/* Nothing in the space cache, goodbye */\n\tif (!i_size_read(inode))\n\t\treturn 0;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn 0;\n\telse if (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn 0;\n\t}\n\n\tret = -1;\n\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tnum_entries = btrfs_free_space_entries(leaf, header);\n\tnum_bitmaps = btrfs_free_space_bitmaps(leaf, header);\n\tgeneration = btrfs_free_space_generation(leaf, header);\n\tbtrfs_release_path(path);\n\n\tif (!BTRFS_I(inode)->generation) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t   \"The free space cache file (%llu) is invalid. skip it\\n\",\n\t\t\t   offset);\n\t\treturn 0;\n\t}\n\n\tif (BTRFS_I(inode)->generation != generation) {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"free space inode generation (%llu) \"\n\t\t\t\"did not match free space cache generation (%llu)\",\n\t\t\tBTRFS_I(inode)->generation, generation);\n\t\treturn 0;\n\t}\n\n\tif (!num_entries)\n\t\treturn 0;\n\n\tret = io_ctl_init(&io_ctl, inode, root, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = readahead_cache(inode);\n\tif (ret)\n\t\tgoto out;\n\n\tret = io_ctl_prepare_pages(&io_ctl, inode, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tret = io_ctl_check_crc(&io_ctl, 0);\n\tif (ret)\n\t\tgoto free_cache;\n\n\tret = io_ctl_check_generation(&io_ctl, generation);\n\tif (ret)\n\t\tgoto free_cache;\n\n\twhile (num_entries) {\n\t\te = kmem_cache_zalloc(btrfs_free_space_cachep,\n\t\t\t\t      GFP_NOFS);\n\t\tif (!e)\n\t\t\tgoto free_cache;\n\n\t\tret = io_ctl_read_entry(&io_ctl, e, &type);\n\t\tif (ret) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tgoto free_cache;\n\t\t}\n\n\t\tif (!e->bytes) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tgoto free_cache;\n\t\t}\n\n\t\tif (type == BTRFS_FREE_SPACE_EXTENT) {\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\tret = link_free_space(ctl, e);\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\t\"Duplicate entries in free space cache, dumping\");\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(num_bitmaps);\n\t\t\tnum_bitmaps--;\n\t\t\te->bitmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\t\tif (!e->bitmap) {\n\t\t\t\tkmem_cache_free(\n\t\t\t\t\tbtrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\tret = link_free_space(ctl, e);\n\t\t\tctl->total_bitmaps++;\n\t\t\tctl->op->recalc_thresholds(ctl);\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\t\"Duplicate entries in free space cache, dumping\");\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t\tlist_add_tail(&e->list, &bitmaps);\n\t\t}\n\n\t\tnum_entries--;\n\t}\n\n\tio_ctl_unmap_page(&io_ctl);\n\n\t/*\n\t * We add the bitmaps at the end of the entries in order that\n\t * the bitmap entries are added to the cache.\n\t */\n\tlist_for_each_entry_safe(e, n, &bitmaps, list) {\n\t\tlist_del_init(&e->list);\n\t\tret = io_ctl_read_bitmap(&io_ctl, e);\n\t\tif (ret)\n\t\t\tgoto free_cache;\n\t}\n\n\tio_ctl_drop_pages(&io_ctl);\n\tmerge_space_tree(ctl);\n\tret = 1;\nout:\n\tio_ctl_free(&io_ctl);\n\treturn ret;\nfree_cache:\n\tio_ctl_drop_pages(&io_ctl);\n\t__btrfs_remove_free_space_cache(ctl);\n\tgoto out;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_remove_free_space_cache",
          "args": [
            "ctl"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_remove_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2413-2418",
          "snippet": "void __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nvoid __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_ctl_drop_pages",
          "args": [
            "&io_ctl"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_drop_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "337-350",
          "snippet": "static void io_ctl_drop_pages(struct io_ctl *io_ctl)\n{\n\tint i;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tif (io_ctl->pages[i]) {\n\t\t\tClearPageChecked(io_ctl->pages[i]);\n\t\t\tunlock_page(io_ctl->pages[i]);\n\t\t\tpage_cache_release(io_ctl->pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_drop_pages(struct io_ctl *io_ctl)\n{\n\tint i;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tif (io_ctl->pages[i]) {\n\t\t\tClearPageChecked(io_ctl->pages[i]);\n\t\t\tunlock_page(io_ctl->pages[i]);\n\t\t\tpage_cache_release(io_ctl->pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_ctl_free",
          "args": [
            "&io_ctl"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "312-315",
          "snippet": "static void io_ctl_free(struct io_ctl *io_ctl)\n{\n\tkfree(io_ctl->pages);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_free(struct io_ctl *io_ctl)\n{\n\tkfree(io_ctl->pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_space_tree",
          "args": [
            "ctl"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "merge_space_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "616-643",
          "snippet": "static void merge_space_tree(struct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_free_space *e, *prev = NULL;\n\tstruct rb_node *n;\n\nagain:\n\tspin_lock(&ctl->tree_lock);\n\tfor (n = rb_first(&ctl->free_space_offset); n; n = rb_next(n)) {\n\t\te = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (!prev)\n\t\t\tgoto next;\n\t\tif (e->bitmap || prev->bitmap)\n\t\t\tgoto next;\n\t\tif (prev->offset + prev->bytes == e->offset) {\n\t\t\tunlink_free_space(ctl, prev);\n\t\t\tunlink_free_space(ctl, e);\n\t\t\tprev->bytes += e->bytes;\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tlink_free_space(ctl, prev);\n\t\t\tprev = NULL;\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tgoto again;\n\t\t}\nnext:\n\t\tprev = e;\n\t}\n\tspin_unlock(&ctl->tree_lock);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void merge_space_tree(struct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_free_space *e, *prev = NULL;\n\tstruct rb_node *n;\n\nagain:\n\tspin_lock(&ctl->tree_lock);\n\tfor (n = rb_first(&ctl->free_space_offset); n; n = rb_next(n)) {\n\t\te = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (!prev)\n\t\t\tgoto next;\n\t\tif (e->bitmap || prev->bitmap)\n\t\t\tgoto next;\n\t\tif (prev->offset + prev->bytes == e->offset) {\n\t\t\tunlink_free_space(ctl, prev);\n\t\t\tunlink_free_space(ctl, e);\n\t\t\tprev->bytes += e->bytes;\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tlink_free_space(ctl, prev);\n\t\t\tprev = NULL;\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tgoto again;\n\t\t}\nnext:\n\t\tprev = e;\n\t}\n\tspin_unlock(&ctl->tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_ctl_read_bitmap",
          "args": [
            "&io_ctl",
            "e"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_read_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "592-605",
          "snippet": "static int io_ctl_read_bitmap(struct io_ctl *io_ctl,\n\t\t\t      struct btrfs_free_space *entry)\n{\n\tint ret;\n\n\tret = io_ctl_check_crc(io_ctl, io_ctl->index);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(entry->bitmap, io_ctl->cur, PAGE_CACHE_SIZE);\n\tio_ctl_unmap_page(io_ctl);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_read_bitmap(struct io_ctl *io_ctl,\n\t\t\t      struct btrfs_free_space *entry)\n{\n\tint ret;\n\n\tret = io_ctl_check_crc(io_ctl, io_ctl->index);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(entry->bitmap, io_ctl->cur, PAGE_CACHE_SIZE);\n\tio_ctl_unmap_page(io_ctl);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&e->list"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "e",
            "n",
            "&bitmaps",
            "list"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_unmap_page",
          "args": [
            "&io_ctl"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "317-324",
          "snippet": "static void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&e->list",
            "&bitmaps"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "e"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"Duplicate entries in free space cache, dumping\""
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctl->op->recalc_thresholds",
          "args": [
            "ctl"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_free_space",
          "args": [
            "ctl",
            "e"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "link_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1501-1515",
          "snippet": "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "e"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "PAGE_CACHE_SIZE",
            "GFP_NOFS"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "num_bitmaps"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "e"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"Duplicate entries in free space cache, dumping\""
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "e"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "e"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_read_entry",
          "args": [
            "&io_ctl",
            "e",
            "&type"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_read_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "565-590",
          "snippet": "static int io_ctl_read_entry(struct io_ctl *io_ctl,\n\t\t\t    struct btrfs_free_space *entry, u8 *type)\n{\n\tstruct btrfs_free_space_entry *e;\n\tint ret;\n\n\tif (!io_ctl->cur) {\n\t\tret = io_ctl_check_crc(io_ctl, io_ctl->index);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\te = io_ctl->cur;\n\tentry->offset = le64_to_cpu(e->offset);\n\tentry->bytes = le64_to_cpu(e->bytes);\n\t*type = e->type;\n\tio_ctl->cur += sizeof(struct btrfs_free_space_entry);\n\tio_ctl->size -= sizeof(struct btrfs_free_space_entry);\n\n\tif (io_ctl->size >= sizeof(struct btrfs_free_space_entry))\n\t\treturn 0;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_read_entry(struct io_ctl *io_ctl,\n\t\t\t    struct btrfs_free_space *entry, u8 *type)\n{\n\tstruct btrfs_free_space_entry *e;\n\tint ret;\n\n\tif (!io_ctl->cur) {\n\t\tret = io_ctl_check_crc(io_ctl, io_ctl->index);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\te = io_ctl->cur;\n\tentry->offset = le64_to_cpu(e->offset);\n\tentry->bytes = le64_to_cpu(e->bytes);\n\t*type = e->type;\n\tio_ctl->cur += sizeof(struct btrfs_free_space_entry);\n\tio_ctl->size -= sizeof(struct btrfs_free_space_entry);\n\n\tif (io_ctl->size >= sizeof(struct btrfs_free_space_entry))\n\t\treturn 0;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "btrfs_free_space_cachep",
            "GFP_NOFS"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_check_generation",
          "args": [
            "&io_ctl",
            "generation"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_check_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "409-436",
          "snippet": "static int io_ctl_check_generation(struct io_ctl *io_ctl, u64 generation)\n{\n\t__le64 *gen;\n\n\t/*\n\t * Skip the crc area.  If we don't check crcs then we just have a 64bit\n\t * chunk at the front of the first page.\n\t */\n\tif (io_ctl->check_crcs) {\n\t\tio_ctl->cur += sizeof(u32) * io_ctl->num_pages;\n\t\tio_ctl->size -= sizeof(u64) +\n\t\t\t(sizeof(u32) * io_ctl->num_pages);\n\t} else {\n\t\tio_ctl->cur += sizeof(u64);\n\t\tio_ctl->size -= sizeof(u64) * 2;\n\t}\n\n\tgen = io_ctl->cur;\n\tif (le64_to_cpu(*gen) != generation) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: space cache generation \"\n\t\t\t\t   \"(%Lu) does not match inode (%Lu)\\n\", *gen,\n\t\t\t\t   generation);\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn -EIO;\n\t}\n\tio_ctl->cur += sizeof(u64);\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_check_generation(struct io_ctl *io_ctl, u64 generation)\n{\n\t__le64 *gen;\n\n\t/*\n\t * Skip the crc area.  If we don't check crcs then we just have a 64bit\n\t * chunk at the front of the first page.\n\t */\n\tif (io_ctl->check_crcs) {\n\t\tio_ctl->cur += sizeof(u32) * io_ctl->num_pages;\n\t\tio_ctl->size -= sizeof(u64) +\n\t\t\t(sizeof(u32) * io_ctl->num_pages);\n\t} else {\n\t\tio_ctl->cur += sizeof(u64);\n\t\tio_ctl->size -= sizeof(u64) * 2;\n\t}\n\n\tgen = io_ctl->cur;\n\tif (le64_to_cpu(*gen) != generation) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: space cache generation \"\n\t\t\t\t   \"(%Lu) does not match inode (%Lu)\\n\", *gen,\n\t\t\t\t   generation);\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn -EIO;\n\t}\n\tio_ctl->cur += sizeof(u64);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_ctl_check_crc",
          "args": [
            "&io_ctl",
            "0"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_check_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "462-493",
          "snippet": "static int io_ctl_check_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp, val;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_map_page(io_ctl, 0);\n\t\treturn 0;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\tval = *tmp;\n\tkunmap(io_ctl->pages[0]);\n\n\tio_ctl_map_page(io_ctl, 0);\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tif (val != crc) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: csum mismatch on free \"\n\t\t\t\t   \"space cache\\n\");\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_check_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp, val;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_map_page(io_ctl, 0);\n\t\treturn 0;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\tval = *tmp;\n\tkunmap(io_ctl->pages[0]);\n\n\tio_ctl_map_page(io_ctl, 0);\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tif (val != crc) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: csum mismatch on free \"\n\t\t\t\t   \"space cache\\n\");\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_ctl_prepare_pages",
          "args": [
            "&io_ctl",
            "inode",
            "1"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_prepare_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "352-384",
          "snippet": "static int io_ctl_prepare_pages(struct io_ctl *io_ctl, struct inode *inode,\n\t\t\t\tint uptodate)\n{\n\tstruct page *page;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint i;\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tpage = find_or_create_page(inode->i_mapping, i, mask);\n\t\tif (!page) {\n\t\t\tio_ctl_drop_pages(io_ctl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tio_ctl->pages[i] = page;\n\t\tif (uptodate && !PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tbtrfs_err(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t   \"error reading free space cache\");\n\t\t\t\tio_ctl_drop_pages(io_ctl);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tclear_page_dirty_for_io(io_ctl->pages[i]);\n\t\tset_page_extent_mapped(io_ctl->pages[i]);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_prepare_pages(struct io_ctl *io_ctl, struct inode *inode,\n\t\t\t\tint uptodate)\n{\n\tstruct page *page;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint i;\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tpage = find_or_create_page(inode->i_mapping, i, mask);\n\t\tif (!page) {\n\t\t\tio_ctl_drop_pages(io_ctl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tio_ctl->pages[i] = page;\n\t\tif (uptodate && !PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tbtrfs_err(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t   \"error reading free space cache\");\n\t\t\t\tio_ctl_drop_pages(io_ctl);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tclear_page_dirty_for_io(io_ctl->pages[i]);\n\t\tset_page_extent_mapped(io_ctl->pages[i]);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "readahead_cache",
          "args": [
            "inode"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "readahead_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "253-270",
          "snippet": "static int readahead_cache(struct inode *inode)\n{\n\tstruct file_ra_state *ra;\n\tunsigned long last_index;\n\n\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\tif (!ra)\n\t\treturn -ENOMEM;\n\n\tfile_ra_state_init(ra, inode->i_mapping);\n\tlast_index = (i_size_read(inode) - 1) >> PAGE_CACHE_SHIFT;\n\n\tpage_cache_sync_readahead(inode->i_mapping, ra, NULL, 0, last_index);\n\n\tkfree(ra);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int readahead_cache(struct inode *inode)\n{\n\tstruct file_ra_state *ra;\n\tunsigned long last_index;\n\n\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\tif (!ra)\n\t\treturn -ENOMEM;\n\n\tfile_ra_state_init(ra, inode->i_mapping);\n\tlast_index = (i_size_read(inode) - 1) >> PAGE_CACHE_SHIFT;\n\n\tpage_cache_sync_readahead(inode->i_mapping, ra, NULL, 0, last_index);\n\n\tkfree(ra);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_ctl_init",
          "args": [
            "&io_ctl",
            "inode",
            "root",
            "0"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "283-310",
          "snippet": "static int io_ctl_init(struct io_ctl *io_ctl, struct inode *inode,\n\t\t       struct btrfs_root *root, int write)\n{\n\tint num_pages;\n\tint check_crcs = 0;\n\n\tnum_pages = DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE);\n\n\tif (btrfs_ino(inode) != BTRFS_FREE_INO_OBJECTID)\n\t\tcheck_crcs = 1;\n\n\t/* Make sure we can fit our crcs into the first page */\n\tif (write && check_crcs &&\n\t    (num_pages * sizeof(u32)) >= PAGE_CACHE_SIZE)\n\t\treturn -ENOSPC;\n\n\tmemset(io_ctl, 0, sizeof(struct io_ctl));\n\n\tio_ctl->pages = kzalloc(sizeof(struct page *) * num_pages, GFP_NOFS);\n\tif (!io_ctl->pages)\n\t\treturn -ENOMEM;\n\n\tio_ctl->num_pages = num_pages;\n\tio_ctl->root = root;\n\tio_ctl->check_crcs = check_crcs;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_init(struct io_ctl *io_ctl, struct inode *inode,\n\t\t       struct btrfs_root *root, int write)\n{\n\tint num_pages;\n\tint check_crcs = 0;\n\n\tnum_pages = DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE);\n\n\tif (btrfs_ino(inode) != BTRFS_FREE_INO_OBJECTID)\n\t\tcheck_crcs = 1;\n\n\t/* Make sure we can fit our crcs into the first page */\n\tif (write && check_crcs &&\n\t    (num_pages * sizeof(u32)) >= PAGE_CACHE_SIZE)\n\t\treturn -ENOSPC;\n\n\tmemset(io_ctl, 0, sizeof(struct io_ctl));\n\n\tio_ctl->pages = kzalloc(sizeof(struct page *) * num_pages, GFP_NOFS);\n\tif (!io_ctl->pages)\n\t\treturn -ENOMEM;\n\n\tio_ctl->num_pages = num_pages;\n\tio_ctl->root = root;\n\tio_ctl->check_crcs = check_crcs;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"free space inode generation (%llu) \"\n\t\t\t\"did not match free space cache generation (%llu)\"",
            "BTRFS_I(inode)->generation",
            "generation"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"The free space cache file (%llu) is invalid. skip it\\n\"",
            "offset"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_space_generation",
          "args": [
            "leaf",
            "header"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_space_bitmaps",
          "args": [
            "leaf",
            "header"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_space_entries",
          "args": [
            "leaf",
            "header"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_free_space_header"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "bitmaps"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int __load_free_space_cache(struct btrfs_root *root, struct inode *inode,\n\t\t\t\t   struct btrfs_free_space_ctl *ctl,\n\t\t\t\t   struct btrfs_path *path, u64 offset)\n{\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tstruct io_ctl io_ctl;\n\tstruct btrfs_key key;\n\tstruct btrfs_free_space *e, *n;\n\tLIST_HEAD(bitmaps);\n\tu64 num_entries;\n\tu64 num_bitmaps;\n\tu64 generation;\n\tu8 type;\n\tint ret = 0;\n\n\t/* Nothing in the space cache, goodbye */\n\tif (!i_size_read(inode))\n\t\treturn 0;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn 0;\n\telse if (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn 0;\n\t}\n\n\tret = -1;\n\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tnum_entries = btrfs_free_space_entries(leaf, header);\n\tnum_bitmaps = btrfs_free_space_bitmaps(leaf, header);\n\tgeneration = btrfs_free_space_generation(leaf, header);\n\tbtrfs_release_path(path);\n\n\tif (!BTRFS_I(inode)->generation) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t   \"The free space cache file (%llu) is invalid. skip it\\n\",\n\t\t\t   offset);\n\t\treturn 0;\n\t}\n\n\tif (BTRFS_I(inode)->generation != generation) {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"free space inode generation (%llu) \"\n\t\t\t\"did not match free space cache generation (%llu)\",\n\t\t\tBTRFS_I(inode)->generation, generation);\n\t\treturn 0;\n\t}\n\n\tif (!num_entries)\n\t\treturn 0;\n\n\tret = io_ctl_init(&io_ctl, inode, root, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = readahead_cache(inode);\n\tif (ret)\n\t\tgoto out;\n\n\tret = io_ctl_prepare_pages(&io_ctl, inode, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tret = io_ctl_check_crc(&io_ctl, 0);\n\tif (ret)\n\t\tgoto free_cache;\n\n\tret = io_ctl_check_generation(&io_ctl, generation);\n\tif (ret)\n\t\tgoto free_cache;\n\n\twhile (num_entries) {\n\t\te = kmem_cache_zalloc(btrfs_free_space_cachep,\n\t\t\t\t      GFP_NOFS);\n\t\tif (!e)\n\t\t\tgoto free_cache;\n\n\t\tret = io_ctl_read_entry(&io_ctl, e, &type);\n\t\tif (ret) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tgoto free_cache;\n\t\t}\n\n\t\tif (!e->bytes) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tgoto free_cache;\n\t\t}\n\n\t\tif (type == BTRFS_FREE_SPACE_EXTENT) {\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\tret = link_free_space(ctl, e);\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\t\"Duplicate entries in free space cache, dumping\");\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(num_bitmaps);\n\t\t\tnum_bitmaps--;\n\t\t\te->bitmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\t\tif (!e->bitmap) {\n\t\t\t\tkmem_cache_free(\n\t\t\t\t\tbtrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t\tspin_lock(&ctl->tree_lock);\n\t\t\tret = link_free_space(ctl, e);\n\t\t\tctl->total_bitmaps++;\n\t\t\tctl->op->recalc_thresholds(ctl);\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\t\"Duplicate entries in free space cache, dumping\");\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\t\tgoto free_cache;\n\t\t\t}\n\t\t\tlist_add_tail(&e->list, &bitmaps);\n\t\t}\n\n\t\tnum_entries--;\n\t}\n\n\tio_ctl_unmap_page(&io_ctl);\n\n\t/*\n\t * We add the bitmaps at the end of the entries in order that\n\t * the bitmap entries are added to the cache.\n\t */\n\tlist_for_each_entry_safe(e, n, &bitmaps, list) {\n\t\tlist_del_init(&e->list);\n\t\tret = io_ctl_read_bitmap(&io_ctl, e);\n\t\tif (ret)\n\t\t\tgoto free_cache;\n\t}\n\n\tio_ctl_drop_pages(&io_ctl);\n\tmerge_space_tree(ctl);\n\tret = 1;\nout:\n\tio_ctl_free(&io_ctl);\n\treturn ret;\nfree_cache:\n\tio_ctl_drop_pages(&io_ctl);\n\t__btrfs_remove_free_space_cache(ctl);\n\tgoto out;\n}"
  },
  {
    "function_name": "merge_space_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "616-643",
    "snippet": "static void merge_space_tree(struct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_free_space *e, *prev = NULL;\n\tstruct rb_node *n;\n\nagain:\n\tspin_lock(&ctl->tree_lock);\n\tfor (n = rb_first(&ctl->free_space_offset); n; n = rb_next(n)) {\n\t\te = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (!prev)\n\t\t\tgoto next;\n\t\tif (e->bitmap || prev->bitmap)\n\t\t\tgoto next;\n\t\tif (prev->offset + prev->bytes == e->offset) {\n\t\t\tunlink_free_space(ctl, prev);\n\t\t\tunlink_free_space(ctl, e);\n\t\t\tprev->bytes += e->bytes;\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tlink_free_space(ctl, prev);\n\t\t\tprev = NULL;\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tgoto again;\n\t\t}\nnext:\n\t\tprev = e;\n\t}\n\tspin_unlock(&ctl->tree_lock);\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_free_space",
          "args": [
            "ctl",
            "prev"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "link_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1501-1515",
          "snippet": "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info)\n{\n\tint ret = 0;\n\n\tASSERT(info->bytes || info->bitmap);\n\tret = tree_insert_offset(&ctl->free_space_offset, info->offset,\n\t\t\t\t &info->offset_index, (info->bitmap != NULL));\n\tif (ret)\n\t\treturn ret;\n\n\tctl->free_space += info->bytes;\n\tctl->free_extents++;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_free_space_cachep",
            "e"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink_free_space",
          "args": [
            "ctl",
            "e"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "1494-1499",
          "snippet": "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t__unlink_free_space(ctl, info);\n\tctl->free_space -= info->bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ctl->free_space_offset"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void merge_space_tree(struct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_free_space *e, *prev = NULL;\n\tstruct rb_node *n;\n\nagain:\n\tspin_lock(&ctl->tree_lock);\n\tfor (n = rb_first(&ctl->free_space_offset); n; n = rb_next(n)) {\n\t\te = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tif (!prev)\n\t\t\tgoto next;\n\t\tif (e->bitmap || prev->bitmap)\n\t\t\tgoto next;\n\t\tif (prev->offset + prev->bytes == e->offset) {\n\t\t\tunlink_free_space(ctl, prev);\n\t\t\tunlink_free_space(ctl, e);\n\t\t\tprev->bytes += e->bytes;\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, e);\n\t\t\tlink_free_space(ctl, prev);\n\t\t\tprev = NULL;\n\t\t\tspin_unlock(&ctl->tree_lock);\n\t\t\tgoto again;\n\t\t}\nnext:\n\t\tprev = e;\n\t}\n\tspin_unlock(&ctl->tree_lock);\n}"
  },
  {
    "function_name": "io_ctl_read_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "592-605",
    "snippet": "static int io_ctl_read_bitmap(struct io_ctl *io_ctl,\n\t\t\t      struct btrfs_free_space *entry)\n{\n\tint ret;\n\n\tret = io_ctl_check_crc(io_ctl, io_ctl->index);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(entry->bitmap, io_ctl->cur, PAGE_CACHE_SIZE);\n\tio_ctl_unmap_page(io_ctl);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_ctl_unmap_page",
          "args": [
            "io_ctl"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "317-324",
          "snippet": "static void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry->bitmap",
            "io_ctl->cur",
            "PAGE_CACHE_SIZE"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_check_crc",
          "args": [
            "io_ctl",
            "io_ctl->index"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_check_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "462-493",
          "snippet": "static int io_ctl_check_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp, val;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_map_page(io_ctl, 0);\n\t\treturn 0;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\tval = *tmp;\n\tkunmap(io_ctl->pages[0]);\n\n\tio_ctl_map_page(io_ctl, 0);\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tif (val != crc) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: csum mismatch on free \"\n\t\t\t\t   \"space cache\\n\");\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_check_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp, val;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_map_page(io_ctl, 0);\n\t\treturn 0;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\tval = *tmp;\n\tkunmap(io_ctl->pages[0]);\n\n\tio_ctl_map_page(io_ctl, 0);\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tif (val != crc) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: csum mismatch on free \"\n\t\t\t\t   \"space cache\\n\");\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_read_bitmap(struct io_ctl *io_ctl,\n\t\t\t      struct btrfs_free_space *entry)\n{\n\tint ret;\n\n\tret = io_ctl_check_crc(io_ctl, io_ctl->index);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(entry->bitmap, io_ctl->cur, PAGE_CACHE_SIZE);\n\tio_ctl_unmap_page(io_ctl);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "io_ctl_read_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "565-590",
    "snippet": "static int io_ctl_read_entry(struct io_ctl *io_ctl,\n\t\t\t    struct btrfs_free_space *entry, u8 *type)\n{\n\tstruct btrfs_free_space_entry *e;\n\tint ret;\n\n\tif (!io_ctl->cur) {\n\t\tret = io_ctl_check_crc(io_ctl, io_ctl->index);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\te = io_ctl->cur;\n\tentry->offset = le64_to_cpu(e->offset);\n\tentry->bytes = le64_to_cpu(e->bytes);\n\t*type = e->type;\n\tio_ctl->cur += sizeof(struct btrfs_free_space_entry);\n\tio_ctl->size -= sizeof(struct btrfs_free_space_entry);\n\n\tif (io_ctl->size >= sizeof(struct btrfs_free_space_entry))\n\t\treturn 0;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_ctl_unmap_page",
          "args": [
            "io_ctl"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "317-324",
          "snippet": "static void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "e->bytes"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_ctl_check_crc",
          "args": [
            "io_ctl",
            "io_ctl->index"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_check_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "462-493",
          "snippet": "static int io_ctl_check_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp, val;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_map_page(io_ctl, 0);\n\t\treturn 0;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\tval = *tmp;\n\tkunmap(io_ctl->pages[0]);\n\n\tio_ctl_map_page(io_ctl, 0);\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tif (val != crc) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: csum mismatch on free \"\n\t\t\t\t   \"space cache\\n\");\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_check_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp, val;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_map_page(io_ctl, 0);\n\t\treturn 0;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\tval = *tmp;\n\tkunmap(io_ctl->pages[0]);\n\n\tio_ctl_map_page(io_ctl, 0);\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tif (val != crc) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: csum mismatch on free \"\n\t\t\t\t   \"space cache\\n\");\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_read_entry(struct io_ctl *io_ctl,\n\t\t\t    struct btrfs_free_space *entry, u8 *type)\n{\n\tstruct btrfs_free_space_entry *e;\n\tint ret;\n\n\tif (!io_ctl->cur) {\n\t\tret = io_ctl_check_crc(io_ctl, io_ctl->index);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\te = io_ctl->cur;\n\tentry->offset = le64_to_cpu(e->offset);\n\tentry->bytes = le64_to_cpu(e->bytes);\n\t*type = e->type;\n\tio_ctl->cur += sizeof(struct btrfs_free_space_entry);\n\tio_ctl->size -= sizeof(struct btrfs_free_space_entry);\n\n\tif (io_ctl->size >= sizeof(struct btrfs_free_space_entry))\n\t\treturn 0;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "io_ctl_zero_remaining_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "548-563",
    "snippet": "static void io_ctl_zero_remaining_pages(struct io_ctl *io_ctl)\n{\n\t/*\n\t * If we're not on the boundary we know we've modified the page and we\n\t * need to crc the page.\n\t */\n\tif (io_ctl->cur != io_ctl->orig)\n\t\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\telse\n\t\tio_ctl_unmap_page(io_ctl);\n\n\twhile (io_ctl->index < io_ctl->num_pages) {\n\t\tio_ctl_map_page(io_ctl, 1);\n\t\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\t}\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_ctl_set_crc",
          "args": [
            "io_ctl",
            "io_ctl->index - 1"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_set_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "438-460",
          "snippet": "static void io_ctl_set_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tio_ctl_unmap_page(io_ctl);\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\t*tmp = crc;\n\tkunmap(io_ctl->pages[0]);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_set_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tio_ctl_unmap_page(io_ctl);\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\t*tmp = crc;\n\tkunmap(io_ctl->pages[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_ctl_map_page",
          "args": [
            "io_ctl",
            "1"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "326-335",
          "snippet": "static void io_ctl_map_page(struct io_ctl *io_ctl, int clear)\n{\n\tASSERT(io_ctl->index < io_ctl->num_pages);\n\tio_ctl->page = io_ctl->pages[io_ctl->index++];\n\tio_ctl->cur = kmap(io_ctl->page);\n\tio_ctl->orig = io_ctl->cur;\n\tio_ctl->size = PAGE_CACHE_SIZE;\n\tif (clear)\n\t\tmemset(io_ctl->cur, 0, PAGE_CACHE_SIZE);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_map_page(struct io_ctl *io_ctl, int clear)\n{\n\tASSERT(io_ctl->index < io_ctl->num_pages);\n\tio_ctl->page = io_ctl->pages[io_ctl->index++];\n\tio_ctl->cur = kmap(io_ctl->page);\n\tio_ctl->orig = io_ctl->cur;\n\tio_ctl->size = PAGE_CACHE_SIZE;\n\tif (clear)\n\t\tmemset(io_ctl->cur, 0, PAGE_CACHE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_ctl_unmap_page",
          "args": [
            "io_ctl"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "317-324",
          "snippet": "static void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_zero_remaining_pages(struct io_ctl *io_ctl)\n{\n\t/*\n\t * If we're not on the boundary we know we've modified the page and we\n\t * need to crc the page.\n\t */\n\tif (io_ctl->cur != io_ctl->orig)\n\t\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\telse\n\t\tio_ctl_unmap_page(io_ctl);\n\n\twhile (io_ctl->index < io_ctl->num_pages) {\n\t\tio_ctl_map_page(io_ctl, 1);\n\t\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\t}\n}"
  },
  {
    "function_name": "io_ctl_add_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "525-546",
    "snippet": "static int io_ctl_add_bitmap(struct io_ctl *io_ctl, void *bitmap)\n{\n\tif (!io_ctl->cur)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * If we aren't at the start of the current page, unmap this one and\n\t * map the next one if there is any left.\n\t */\n\tif (io_ctl->cur != io_ctl->orig) {\n\t\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\t\tif (io_ctl->index >= io_ctl->num_pages)\n\t\t\treturn -ENOSPC;\n\t\tio_ctl_map_page(io_ctl, 0);\n\t}\n\n\tmemcpy(io_ctl->cur, bitmap, PAGE_CACHE_SIZE);\n\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\tif (io_ctl->index < io_ctl->num_pages)\n\t\tio_ctl_map_page(io_ctl, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_ctl_map_page",
          "args": [
            "io_ctl",
            "0"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "326-335",
          "snippet": "static void io_ctl_map_page(struct io_ctl *io_ctl, int clear)\n{\n\tASSERT(io_ctl->index < io_ctl->num_pages);\n\tio_ctl->page = io_ctl->pages[io_ctl->index++];\n\tio_ctl->cur = kmap(io_ctl->page);\n\tio_ctl->orig = io_ctl->cur;\n\tio_ctl->size = PAGE_CACHE_SIZE;\n\tif (clear)\n\t\tmemset(io_ctl->cur, 0, PAGE_CACHE_SIZE);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_map_page(struct io_ctl *io_ctl, int clear)\n{\n\tASSERT(io_ctl->index < io_ctl->num_pages);\n\tio_ctl->page = io_ctl->pages[io_ctl->index++];\n\tio_ctl->cur = kmap(io_ctl->page);\n\tio_ctl->orig = io_ctl->cur;\n\tio_ctl->size = PAGE_CACHE_SIZE;\n\tif (clear)\n\t\tmemset(io_ctl->cur, 0, PAGE_CACHE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_ctl_set_crc",
          "args": [
            "io_ctl",
            "io_ctl->index - 1"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_set_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "438-460",
          "snippet": "static void io_ctl_set_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tio_ctl_unmap_page(io_ctl);\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\t*tmp = crc;\n\tkunmap(io_ctl->pages[0]);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_set_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tio_ctl_unmap_page(io_ctl);\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\t*tmp = crc;\n\tkunmap(io_ctl->pages[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "io_ctl->cur",
            "bitmap",
            "PAGE_CACHE_SIZE"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_add_bitmap(struct io_ctl *io_ctl, void *bitmap)\n{\n\tif (!io_ctl->cur)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * If we aren't at the start of the current page, unmap this one and\n\t * map the next one if there is any left.\n\t */\n\tif (io_ctl->cur != io_ctl->orig) {\n\t\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\t\tif (io_ctl->index >= io_ctl->num_pages)\n\t\t\treturn -ENOSPC;\n\t\tio_ctl_map_page(io_ctl, 0);\n\t}\n\n\tmemcpy(io_ctl->cur, bitmap, PAGE_CACHE_SIZE);\n\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\tif (io_ctl->index < io_ctl->num_pages)\n\t\tio_ctl_map_page(io_ctl, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "io_ctl_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "495-523",
    "snippet": "static int io_ctl_add_entry(struct io_ctl *io_ctl, u64 offset, u64 bytes,\n\t\t\t    void *bitmap)\n{\n\tstruct btrfs_free_space_entry *entry;\n\n\tif (!io_ctl->cur)\n\t\treturn -ENOSPC;\n\n\tentry = io_ctl->cur;\n\tentry->offset = cpu_to_le64(offset);\n\tentry->bytes = cpu_to_le64(bytes);\n\tentry->type = (bitmap) ? BTRFS_FREE_SPACE_BITMAP :\n\t\tBTRFS_FREE_SPACE_EXTENT;\n\tio_ctl->cur += sizeof(struct btrfs_free_space_entry);\n\tio_ctl->size -= sizeof(struct btrfs_free_space_entry);\n\n\tif (io_ctl->size >= sizeof(struct btrfs_free_space_entry))\n\t\treturn 0;\n\n\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\n\t/* No more pages to map */\n\tif (io_ctl->index >= io_ctl->num_pages)\n\t\treturn 0;\n\n\t/* map the next page */\n\tio_ctl_map_page(io_ctl, 1);\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_ctl_map_page",
          "args": [
            "io_ctl",
            "1"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "326-335",
          "snippet": "static void io_ctl_map_page(struct io_ctl *io_ctl, int clear)\n{\n\tASSERT(io_ctl->index < io_ctl->num_pages);\n\tio_ctl->page = io_ctl->pages[io_ctl->index++];\n\tio_ctl->cur = kmap(io_ctl->page);\n\tio_ctl->orig = io_ctl->cur;\n\tio_ctl->size = PAGE_CACHE_SIZE;\n\tif (clear)\n\t\tmemset(io_ctl->cur, 0, PAGE_CACHE_SIZE);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_map_page(struct io_ctl *io_ctl, int clear)\n{\n\tASSERT(io_ctl->index < io_ctl->num_pages);\n\tio_ctl->page = io_ctl->pages[io_ctl->index++];\n\tio_ctl->cur = kmap(io_ctl->page);\n\tio_ctl->orig = io_ctl->cur;\n\tio_ctl->size = PAGE_CACHE_SIZE;\n\tif (clear)\n\t\tmemset(io_ctl->cur, 0, PAGE_CACHE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_ctl_set_crc",
          "args": [
            "io_ctl",
            "io_ctl->index - 1"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_set_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "438-460",
          "snippet": "static void io_ctl_set_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tio_ctl_unmap_page(io_ctl);\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\t*tmp = crc;\n\tkunmap(io_ctl->pages[0]);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_set_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tio_ctl_unmap_page(io_ctl);\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\t*tmp = crc;\n\tkunmap(io_ctl->pages[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "bytes"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "offset"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_add_entry(struct io_ctl *io_ctl, u64 offset, u64 bytes,\n\t\t\t    void *bitmap)\n{\n\tstruct btrfs_free_space_entry *entry;\n\n\tif (!io_ctl->cur)\n\t\treturn -ENOSPC;\n\n\tentry = io_ctl->cur;\n\tentry->offset = cpu_to_le64(offset);\n\tentry->bytes = cpu_to_le64(bytes);\n\tentry->type = (bitmap) ? BTRFS_FREE_SPACE_BITMAP :\n\t\tBTRFS_FREE_SPACE_EXTENT;\n\tio_ctl->cur += sizeof(struct btrfs_free_space_entry);\n\tio_ctl->size -= sizeof(struct btrfs_free_space_entry);\n\n\tif (io_ctl->size >= sizeof(struct btrfs_free_space_entry))\n\t\treturn 0;\n\n\tio_ctl_set_crc(io_ctl, io_ctl->index - 1);\n\n\t/* No more pages to map */\n\tif (io_ctl->index >= io_ctl->num_pages)\n\t\treturn 0;\n\n\t/* map the next page */\n\tio_ctl_map_page(io_ctl, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "io_ctl_check_crc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "462-493",
    "snippet": "static int io_ctl_check_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp, val;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_map_page(io_ctl, 0);\n\t\treturn 0;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\tval = *tmp;\n\tkunmap(io_ctl->pages[0]);\n\n\tio_ctl_map_page(io_ctl, 0);\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tif (val != crc) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: csum mismatch on free \"\n\t\t\t\t   \"space cache\\n\");\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_ctl_unmap_page",
          "args": [
            "io_ctl"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "317-324",
          "snippet": "static void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_ERR \"BTRFS: csum mismatch on free \"\n\t\t\t\t   \"space cache\\n\""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_final",
          "args": [
            "crc",
            "(char *)&crc"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "268-271",
          "snippet": "void btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_csum_data",
          "args": [
            "io_ctl->orig + offset",
            "crc",
            "PAGE_CACHE_SIZE - offset"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "263-266",
          "snippet": "u32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nu32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_ctl_map_page",
          "args": [
            "io_ctl",
            "0"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "326-335",
          "snippet": "static void io_ctl_map_page(struct io_ctl *io_ctl, int clear)\n{\n\tASSERT(io_ctl->index < io_ctl->num_pages);\n\tio_ctl->page = io_ctl->pages[io_ctl->index++];\n\tio_ctl->cur = kmap(io_ctl->page);\n\tio_ctl->orig = io_ctl->cur;\n\tio_ctl->size = PAGE_CACHE_SIZE;\n\tif (clear)\n\t\tmemset(io_ctl->cur, 0, PAGE_CACHE_SIZE);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_map_page(struct io_ctl *io_ctl, int clear)\n{\n\tASSERT(io_ctl->index < io_ctl->num_pages);\n\tio_ctl->page = io_ctl->pages[io_ctl->index++];\n\tio_ctl->cur = kmap(io_ctl->page);\n\tio_ctl->orig = io_ctl->cur;\n\tio_ctl->size = PAGE_CACHE_SIZE;\n\tif (clear)\n\t\tmemset(io_ctl->cur, 0, PAGE_CACHE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "io_ctl->pages[0]"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "io_ctl->pages[0]"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_check_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp, val;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_map_page(io_ctl, 0);\n\t\treturn 0;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\tval = *tmp;\n\tkunmap(io_ctl->pages[0]);\n\n\tio_ctl_map_page(io_ctl, 0);\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tif (val != crc) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: csum mismatch on free \"\n\t\t\t\t   \"space cache\\n\");\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "io_ctl_set_crc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "438-460",
    "snippet": "static void io_ctl_set_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tio_ctl_unmap_page(io_ctl);\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\t*tmp = crc;\n\tkunmap(io_ctl->pages[0]);\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "io_ctl->pages[0]"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "io_ctl->pages[0]"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_unmap_page",
          "args": [
            "io_ctl"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "317-324",
          "snippet": "static void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_csum_final",
          "args": [
            "crc",
            "(char *)&crc"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "268-271",
          "snippet": "void btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_csum_data",
          "args": [
            "io_ctl->orig + offset",
            "crc",
            "PAGE_CACHE_SIZE - offset"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "263-266",
          "snippet": "u32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nu32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_set_crc(struct io_ctl *io_ctl, int index)\n{\n\tu32 *tmp;\n\tu32 crc = ~(u32)0;\n\tunsigned offset = 0;\n\n\tif (!io_ctl->check_crcs) {\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn;\n\t}\n\n\tif (index == 0)\n\t\toffset = sizeof(u32) * io_ctl->num_pages;\n\n\tcrc = btrfs_csum_data(io_ctl->orig + offset, crc,\n\t\t\t      PAGE_CACHE_SIZE - offset);\n\tbtrfs_csum_final(crc, (char *)&crc);\n\tio_ctl_unmap_page(io_ctl);\n\ttmp = kmap(io_ctl->pages[0]);\n\ttmp += index;\n\t*tmp = crc;\n\tkunmap(io_ctl->pages[0]);\n}"
  },
  {
    "function_name": "io_ctl_check_generation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "409-436",
    "snippet": "static int io_ctl_check_generation(struct io_ctl *io_ctl, u64 generation)\n{\n\t__le64 *gen;\n\n\t/*\n\t * Skip the crc area.  If we don't check crcs then we just have a 64bit\n\t * chunk at the front of the first page.\n\t */\n\tif (io_ctl->check_crcs) {\n\t\tio_ctl->cur += sizeof(u32) * io_ctl->num_pages;\n\t\tio_ctl->size -= sizeof(u64) +\n\t\t\t(sizeof(u32) * io_ctl->num_pages);\n\t} else {\n\t\tio_ctl->cur += sizeof(u64);\n\t\tio_ctl->size -= sizeof(u64) * 2;\n\t}\n\n\tgen = io_ctl->cur;\n\tif (le64_to_cpu(*gen) != generation) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: space cache generation \"\n\t\t\t\t   \"(%Lu) does not match inode (%Lu)\\n\", *gen,\n\t\t\t\t   generation);\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn -EIO;\n\t}\n\tio_ctl->cur += sizeof(u64);\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_ctl_unmap_page",
          "args": [
            "io_ctl"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "317-324",
          "snippet": "static void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_ERR \"BTRFS: space cache generation \"\n\t\t\t\t   \"(%Lu) does not match inode (%Lu)\\n\"",
            "*gen",
            "generation"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "*gen"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_check_generation(struct io_ctl *io_ctl, u64 generation)\n{\n\t__le64 *gen;\n\n\t/*\n\t * Skip the crc area.  If we don't check crcs then we just have a 64bit\n\t * chunk at the front of the first page.\n\t */\n\tif (io_ctl->check_crcs) {\n\t\tio_ctl->cur += sizeof(u32) * io_ctl->num_pages;\n\t\tio_ctl->size -= sizeof(u64) +\n\t\t\t(sizeof(u32) * io_ctl->num_pages);\n\t} else {\n\t\tio_ctl->cur += sizeof(u64);\n\t\tio_ctl->size -= sizeof(u64) * 2;\n\t}\n\n\tgen = io_ctl->cur;\n\tif (le64_to_cpu(*gen) != generation) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: space cache generation \"\n\t\t\t\t   \"(%Lu) does not match inode (%Lu)\\n\", *gen,\n\t\t\t\t   generation);\n\t\tio_ctl_unmap_page(io_ctl);\n\t\treturn -EIO;\n\t}\n\tio_ctl->cur += sizeof(u64);\n\treturn 0;\n}"
  },
  {
    "function_name": "io_ctl_set_generation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "386-407",
    "snippet": "static void io_ctl_set_generation(struct io_ctl *io_ctl, u64 generation)\n{\n\t__le64 *val;\n\n\tio_ctl_map_page(io_ctl, 1);\n\n\t/*\n\t * Skip the csum areas.  If we don't check crcs then we just have a\n\t * 64bit chunk at the front of the first page.\n\t */\n\tif (io_ctl->check_crcs) {\n\t\tio_ctl->cur += (sizeof(u32) * io_ctl->num_pages);\n\t\tio_ctl->size -= sizeof(u64) + (sizeof(u32) * io_ctl->num_pages);\n\t} else {\n\t\tio_ctl->cur += sizeof(u64);\n\t\tio_ctl->size -= sizeof(u64) * 2;\n\t}\n\n\tval = io_ctl->cur;\n\t*val = cpu_to_le64(generation);\n\tio_ctl->cur += sizeof(u64);\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "generation"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_map_page",
          "args": [
            "io_ctl",
            "1"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "326-335",
          "snippet": "static void io_ctl_map_page(struct io_ctl *io_ctl, int clear)\n{\n\tASSERT(io_ctl->index < io_ctl->num_pages);\n\tio_ctl->page = io_ctl->pages[io_ctl->index++];\n\tio_ctl->cur = kmap(io_ctl->page);\n\tio_ctl->orig = io_ctl->cur;\n\tio_ctl->size = PAGE_CACHE_SIZE;\n\tif (clear)\n\t\tmemset(io_ctl->cur, 0, PAGE_CACHE_SIZE);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_map_page(struct io_ctl *io_ctl, int clear)\n{\n\tASSERT(io_ctl->index < io_ctl->num_pages);\n\tio_ctl->page = io_ctl->pages[io_ctl->index++];\n\tio_ctl->cur = kmap(io_ctl->page);\n\tio_ctl->orig = io_ctl->cur;\n\tio_ctl->size = PAGE_CACHE_SIZE;\n\tif (clear)\n\t\tmemset(io_ctl->cur, 0, PAGE_CACHE_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_set_generation(struct io_ctl *io_ctl, u64 generation)\n{\n\t__le64 *val;\n\n\tio_ctl_map_page(io_ctl, 1);\n\n\t/*\n\t * Skip the csum areas.  If we don't check crcs then we just have a\n\t * 64bit chunk at the front of the first page.\n\t */\n\tif (io_ctl->check_crcs) {\n\t\tio_ctl->cur += (sizeof(u32) * io_ctl->num_pages);\n\t\tio_ctl->size -= sizeof(u64) + (sizeof(u32) * io_ctl->num_pages);\n\t} else {\n\t\tio_ctl->cur += sizeof(u64);\n\t\tio_ctl->size -= sizeof(u64) * 2;\n\t}\n\n\tval = io_ctl->cur;\n\t*val = cpu_to_le64(generation);\n\tio_ctl->cur += sizeof(u64);\n}"
  },
  {
    "function_name": "io_ctl_prepare_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "352-384",
    "snippet": "static int io_ctl_prepare_pages(struct io_ctl *io_ctl, struct inode *inode,\n\t\t\t\tint uptodate)\n{\n\tstruct page *page;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint i;\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tpage = find_or_create_page(inode->i_mapping, i, mask);\n\t\tif (!page) {\n\t\t\tio_ctl_drop_pages(io_ctl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tio_ctl->pages[i] = page;\n\t\tif (uptodate && !PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tbtrfs_err(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t   \"error reading free space cache\");\n\t\t\t\tio_ctl_drop_pages(io_ctl);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tclear_page_dirty_for_io(io_ctl->pages[i]);\n\t\tset_page_extent_mapped(io_ctl->pages[i]);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_extent_mapped",
          "args": [
            "io_ctl->pages[i]"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_extent_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2862-2869",
          "snippet": "void set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "io_ctl->pages[i]"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_drop_pages",
          "args": [
            "io_ctl"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_drop_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "337-350",
          "snippet": "static void io_ctl_drop_pages(struct io_ctl *io_ctl)\n{\n\tint i;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tif (io_ctl->pages[i]) {\n\t\t\tClearPageChecked(io_ctl->pages[i]);\n\t\t\tunlock_page(io_ctl->pages[i]);\n\t\t\tpage_cache_release(io_ctl->pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_drop_pages(struct io_ctl *io_ctl)\n{\n\tint i;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tif (io_ctl->pages[i]) {\n\t\t\tClearPageChecked(io_ctl->pages[i]);\n\t\t\tunlock_page(io_ctl->pages[i]);\n\t\t\tpage_cache_release(io_ctl->pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "BTRFS_I(inode)->root->fs_info",
            "\"error reading free space cache\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_readpage",
          "args": [
            "NULL",
            "page"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "8212-8217",
          "snippet": "int btrfs_readpage(struct file *file, struct page *page)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\treturn extent_read_full_page(tree, page, btrfs_get_extent, 0);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_readpage(struct file *file, struct page *page)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\treturn extent_read_full_page(tree, page, btrfs_get_extent, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "i",
            "mask"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_write_mask",
          "args": [
            "inode->i_mapping"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_write_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3292-3295",
          "snippet": "static inline gfp_t btrfs_alloc_write_mask(struct address_space *mapping)\n{\n\treturn mapping_gfp_mask(mapping) & ~__GFP_FS;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline gfp_t btrfs_alloc_write_mask(struct address_space *mapping)\n{\n\treturn mapping_gfp_mask(mapping) & ~__GFP_FS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_prepare_pages(struct io_ctl *io_ctl, struct inode *inode,\n\t\t\t\tint uptodate)\n{\n\tstruct page *page;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint i;\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tpage = find_or_create_page(inode->i_mapping, i, mask);\n\t\tif (!page) {\n\t\t\tio_ctl_drop_pages(io_ctl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tio_ctl->pages[i] = page;\n\t\tif (uptodate && !PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tbtrfs_err(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t   \"error reading free space cache\");\n\t\t\t\tio_ctl_drop_pages(io_ctl);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tclear_page_dirty_for_io(io_ctl->pages[i]);\n\t\tset_page_extent_mapped(io_ctl->pages[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "io_ctl_drop_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "337-350",
    "snippet": "static void io_ctl_drop_pages(struct io_ctl *io_ctl)\n{\n\tint i;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tif (io_ctl->pages[i]) {\n\t\t\tClearPageChecked(io_ctl->pages[i]);\n\t\t\tunlock_page(io_ctl->pages[i]);\n\t\t\tpage_cache_release(io_ctl->pages[i]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "io_ctl->pages[i]"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "io_ctl->pages[i]"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "io_ctl->pages[i]"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_ctl_unmap_page",
          "args": [
            "io_ctl"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "io_ctl_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "317-324",
          "snippet": "static void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_drop_pages(struct io_ctl *io_ctl)\n{\n\tint i;\n\n\tio_ctl_unmap_page(io_ctl);\n\n\tfor (i = 0; i < io_ctl->num_pages; i++) {\n\t\tif (io_ctl->pages[i]) {\n\t\t\tClearPageChecked(io_ctl->pages[i]);\n\t\t\tunlock_page(io_ctl->pages[i]);\n\t\t\tpage_cache_release(io_ctl->pages[i]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "io_ctl_map_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "326-335",
    "snippet": "static void io_ctl_map_page(struct io_ctl *io_ctl, int clear)\n{\n\tASSERT(io_ctl->index < io_ctl->num_pages);\n\tio_ctl->page = io_ctl->pages[io_ctl->index++];\n\tio_ctl->cur = kmap(io_ctl->page);\n\tio_ctl->orig = io_ctl->cur;\n\tio_ctl->size = PAGE_CACHE_SIZE;\n\tif (clear)\n\t\tmemset(io_ctl->cur, 0, PAGE_CACHE_SIZE);\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "io_ctl->cur",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "io_ctl->page"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "io_ctl->index < io_ctl->num_pages"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_map_page(struct io_ctl *io_ctl, int clear)\n{\n\tASSERT(io_ctl->index < io_ctl->num_pages);\n\tio_ctl->page = io_ctl->pages[io_ctl->index++];\n\tio_ctl->cur = kmap(io_ctl->page);\n\tio_ctl->orig = io_ctl->cur;\n\tio_ctl->size = PAGE_CACHE_SIZE;\n\tif (clear)\n\t\tmemset(io_ctl->cur, 0, PAGE_CACHE_SIZE);\n}"
  },
  {
    "function_name": "io_ctl_unmap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "317-324",
    "snippet": "static void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "io_ctl->page"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_unmap_page(struct io_ctl *io_ctl)\n{\n\tif (io_ctl->cur) {\n\t\tkunmap(io_ctl->page);\n\t\tio_ctl->cur = NULL;\n\t\tio_ctl->orig = NULL;\n\t}\n}"
  },
  {
    "function_name": "io_ctl_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "312-315",
    "snippet": "static void io_ctl_free(struct io_ctl *io_ctl)\n{\n\tkfree(io_ctl->pages);\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "io_ctl->pages"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic void io_ctl_free(struct io_ctl *io_ctl)\n{\n\tkfree(io_ctl->pages);\n}"
  },
  {
    "function_name": "io_ctl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "283-310",
    "snippet": "static int io_ctl_init(struct io_ctl *io_ctl, struct inode *inode,\n\t\t       struct btrfs_root *root, int write)\n{\n\tint num_pages;\n\tint check_crcs = 0;\n\n\tnum_pages = DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE);\n\n\tif (btrfs_ino(inode) != BTRFS_FREE_INO_OBJECTID)\n\t\tcheck_crcs = 1;\n\n\t/* Make sure we can fit our crcs into the first page */\n\tif (write && check_crcs &&\n\t    (num_pages * sizeof(u32)) >= PAGE_CACHE_SIZE)\n\t\treturn -ENOSPC;\n\n\tmemset(io_ctl, 0, sizeof(struct io_ctl));\n\n\tio_ctl->pages = kzalloc(sizeof(struct page *) * num_pages, GFP_NOFS);\n\tif (!io_ctl->pages)\n\t\treturn -ENOMEM;\n\n\tio_ctl->num_pages = num_pages;\n\tio_ctl->root = root;\n\tio_ctl->check_crcs = check_crcs;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct page *) * num_pages",
            "GFP_NOFS"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "io_ctl",
            "0",
            "sizeof(struct io_ctl)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "i_size_read(inode)",
            "PAGE_CACHE_SIZE"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int io_ctl_init(struct io_ctl *io_ctl, struct inode *inode,\n\t\t       struct btrfs_root *root, int write)\n{\n\tint num_pages;\n\tint check_crcs = 0;\n\n\tnum_pages = DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE);\n\n\tif (btrfs_ino(inode) != BTRFS_FREE_INO_OBJECTID)\n\t\tcheck_crcs = 1;\n\n\t/* Make sure we can fit our crcs into the first page */\n\tif (write && check_crcs &&\n\t    (num_pages * sizeof(u32)) >= PAGE_CACHE_SIZE)\n\t\treturn -ENOSPC;\n\n\tmemset(io_ctl, 0, sizeof(struct io_ctl));\n\n\tio_ctl->pages = kzalloc(sizeof(struct page *) * num_pages, GFP_NOFS);\n\tif (!io_ctl->pages)\n\t\treturn -ENOMEM;\n\n\tio_ctl->num_pages = num_pages;\n\tio_ctl->root = root;\n\tio_ctl->check_crcs = check_crcs;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "readahead_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "253-270",
    "snippet": "static int readahead_cache(struct inode *inode)\n{\n\tstruct file_ra_state *ra;\n\tunsigned long last_index;\n\n\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\tif (!ra)\n\t\treturn -ENOMEM;\n\n\tfile_ra_state_init(ra, inode->i_mapping);\n\tlast_index = (i_size_read(inode) - 1) >> PAGE_CACHE_SHIFT;\n\n\tpage_cache_sync_readahead(inode->i_mapping, ra, NULL, 0, last_index);\n\n\tkfree(ra);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ra"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_sync_readahead",
          "args": [
            "inode->i_mapping",
            "ra",
            "NULL",
            "0",
            "last_index"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_ra_state_init",
          "args": [
            "ra",
            "inode->i_mapping"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ra)",
            "GFP_NOFS"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int readahead_cache(struct inode *inode)\n{\n\tstruct file_ra_state *ra;\n\tunsigned long last_index;\n\n\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\tif (!ra)\n\t\treturn -ENOMEM;\n\n\tfile_ra_state_init(ra, inode->i_mapping);\n\tlast_index = (i_size_read(inode) - 1) >> PAGE_CACHE_SHIFT;\n\n\tpage_cache_sync_readahead(inode->i_mapping, ra, NULL, 0, last_index);\n\n\tkfree(ra);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_truncate_free_space_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "226-251",
    "snippet": "int btrfs_truncate_free_space_cache(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_trans_handle *trans,\n\t\t\t\t    struct inode *inode)\n{\n\tint ret = 0;\n\n\tbtrfs_i_size_write(inode, 0);\n\ttruncate_pagecache(inode, 0);\n\n\t/*\n\t * We don't need an orphan item because truncating the free space cache\n\t * will never be split across transactions.\n\t */\n\tret = btrfs_truncate_inode_items(trans, root, inode,\n\t\t\t\t\t 0, BTRFS_EXTENT_DATA_KEY);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode",
          "args": [
            "trans",
            "root",
            "inode"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_truncate_inode_items",
          "args": [
            "trans",
            "root",
            "inode",
            "0",
            "BTRFS_EXTENT_DATA_KEY"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_truncate_inode_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "4176-4420",
          "snippet": "int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct inode *inode,\n\t\t\t       u64 new_size, u32 min_type)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tu64 extent_start = 0;\n\tu64 extent_num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 item_end = 0;\n\tu64 last_size = (u64)-1;\n\tu32 found_type = (u8)-1;\n\tint found_extent;\n\tint del_item;\n\tint pending_del_nr = 0;\n\tint pending_del_slot = 0;\n\tint extent_type = -1;\n\tint ret;\n\tint err = 0;\n\tu64 ino = btrfs_ino(inode);\n\n\tBUG_ON(new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = -1;\n\n\t/*\n\t * We want to drop from the next block forward in case this new size is\n\t * not block aligned since we will be keeping the last block of the\n\t * extent just the way it is.\n\t */\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t    root == root->fs_info->tree_root)\n\t\tbtrfs_drop_extent_cache(inode, ALIGN(new_size,\n\t\t\t\t\troot->sectorsize), (u64)-1, 0);\n\n\t/*\n\t * This function is also used to drop the items in the log tree before\n\t * we relog the inode, so if root != BTRFS_I(inode)->root, it means\n\t * it is used to drop the loged items. So we shouldn't kill the delayed\n\t * items.\n\t */\n\tif (min_type == 0 && root == BTRFS_I(inode)->root)\n\t\tbtrfs_kill_delayed_inode_items(inode);\n\n\tkey.objectid = ino;\n\tkey.offset = (u64)-1;\n\tkey.type = (u8)-1;\n\nsearch_again:\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\tif (ret > 0) {\n\t\t/* there are no items in the tree for us to truncate, we're\n\t\t * done\n\t\t */\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\n\twhile (1) {\n\t\tfi = NULL;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tfound_type = found_key.type;\n\n\t\tif (found_key.objectid != ino)\n\t\t\tbreak;\n\n\t\tif (found_type < min_type)\n\t\t\tbreak;\n\n\t\titem_end = found_key.offset;\n\t\tif (found_type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\t\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\titem_end +=\n\t\t\t\t    btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\titem_end += btrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t\t path->slots[0], fi);\n\t\t\t}\n\t\t\titem_end--;\n\t\t}\n\t\tif (found_type > min_type) {\n\t\t\tdel_item = 1;\n\t\t} else {\n\t\t\tif (item_end < new_size)\n\t\t\t\tbreak;\n\t\t\tif (found_key.offset >= new_size)\n\t\t\t\tdel_item = 1;\n\t\t\telse\n\t\t\t\tdel_item = 0;\n\t\t}\n\t\tfound_extent = 0;\n\t\t/* FIXME, shrink the extent if the ref count is only 1 */\n\t\tif (found_type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto delete;\n\n\t\tif (del_item)\n\t\t\tlast_size = found_key.offset;\n\t\telse\n\t\t\tlast_size = new_size;\n\n\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tu64 num_dec;\n\t\t\textent_start = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tif (!del_item) {\n\t\t\t\tu64 orig_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\textent_num_bytes = ALIGN(new_size -\n\t\t\t\t\t\tfound_key.offset,\n\t\t\t\t\t\troot->sectorsize);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\t extent_num_bytes);\n\t\t\t\tnum_dec = (orig_num_bytes -\n\t\t\t\t\t   extent_num_bytes);\n\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t     &root->state) &&\n\t\t\t\t    extent_start != 0)\n\t\t\t\t\tinode_sub_bytes(inode, num_dec);\n\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t} else {\n\t\t\t\textent_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t\t fi);\n\t\t\t\textent_offset = found_key.offset -\n\t\t\t\t\tbtrfs_file_extent_offset(leaf, fi);\n\n\t\t\t\t/* FIXME blocksize != 4096 */\n\t\t\t\tnum_dec = btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\tif (extent_start != 0) {\n\t\t\t\t\tfound_extent = 1;\n\t\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t\t     &root->state))\n\t\t\t\t\t\tinode_sub_bytes(inode, num_dec);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t/*\n\t\t\t * we can't truncate inline items that have had\n\t\t\t * special encodings\n\t\t\t */\n\t\t\tif (!del_item &&\n\t\t\t    btrfs_file_extent_compression(leaf, fi) == 0 &&\n\t\t\t    btrfs_file_extent_encryption(leaf, fi) == 0 &&\n\t\t\t    btrfs_file_extent_other_encoding(leaf, fi) == 0) {\n\t\t\t\tu32 size = new_size - found_key.offset;\n\n\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\t\t\t\tinode_sub_bytes(inode, item_end + 1 -\n\t\t\t\t\t\t\tnew_size);\n\n\t\t\t\t/*\n\t\t\t\t * update the ram bytes to properly reflect\n\t\t\t\t * the new size of our item\n\t\t\t\t */\n\t\t\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\t\t\t\tsize =\n\t\t\t\t    btrfs_file_extent_calc_inline_size(size);\n\t\t\t\tbtrfs_truncate_item(root, path, size, 1);\n\t\t\t} else if (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t    &root->state)) {\n\t\t\t\tinode_sub_bytes(inode, item_end + 1 -\n\t\t\t\t\t\tfound_key.offset);\n\t\t\t}\n\t\t}\ndelete:\n\t\tif (del_item) {\n\t\t\tif (!pending_del_nr) {\n\t\t\t\t/* no pending yet, add ourselves */\n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t\tpending_del_nr = 1;\n\t\t\t} else if (pending_del_nr &&\n\t\t\t\t   path->slots[0] + 1 == pending_del_slot) {\n\t\t\t\t/* hop on the pending chunk */\n\t\t\t\tpending_del_nr++;\n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t} else {\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tif (found_extent &&\n\t\t    (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t     root == root->fs_info->tree_root)) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_free_extent(trans, root, extent_start,\n\t\t\t\t\t\textent_num_bytes, 0,\n\t\t\t\t\t\tbtrfs_header_owner(leaf),\n\t\t\t\t\t\tino, extent_offset, 0);\n\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tif (found_type == BTRFS_INODE_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tif (path->slots[0] == 0 ||\n\t\t    path->slots[0] != pending_del_slot) {\n\t\t\tif (pending_del_nr) {\n\t\t\t\tret = btrfs_del_items(trans, root, path,\n\t\t\t\t\t\tpending_del_slot,\n\t\t\t\t\t\tpending_del_nr);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tpending_del_nr = 0;\n\t\t\t}\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto search_again;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t}\nout:\n\tif (pending_del_nr) {\n\t\tret = btrfs_del_items(trans, root, path, pending_del_slot,\n\t\t\t\t      pending_del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\nerror:\n\tif (last_size != (u64)-1 &&\n\t    root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\tbtrfs_ordered_update_i_size(inode, last_size, NULL);\n\tbtrfs_free_path(path);\n\treturn err;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct inode *inode,\n\t\t\t       u64 new_size, u32 min_type)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tu64 extent_start = 0;\n\tu64 extent_num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 item_end = 0;\n\tu64 last_size = (u64)-1;\n\tu32 found_type = (u8)-1;\n\tint found_extent;\n\tint del_item;\n\tint pending_del_nr = 0;\n\tint pending_del_slot = 0;\n\tint extent_type = -1;\n\tint ret;\n\tint err = 0;\n\tu64 ino = btrfs_ino(inode);\n\n\tBUG_ON(new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = -1;\n\n\t/*\n\t * We want to drop from the next block forward in case this new size is\n\t * not block aligned since we will be keeping the last block of the\n\t * extent just the way it is.\n\t */\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t    root == root->fs_info->tree_root)\n\t\tbtrfs_drop_extent_cache(inode, ALIGN(new_size,\n\t\t\t\t\troot->sectorsize), (u64)-1, 0);\n\n\t/*\n\t * This function is also used to drop the items in the log tree before\n\t * we relog the inode, so if root != BTRFS_I(inode)->root, it means\n\t * it is used to drop the loged items. So we shouldn't kill the delayed\n\t * items.\n\t */\n\tif (min_type == 0 && root == BTRFS_I(inode)->root)\n\t\tbtrfs_kill_delayed_inode_items(inode);\n\n\tkey.objectid = ino;\n\tkey.offset = (u64)-1;\n\tkey.type = (u8)-1;\n\nsearch_again:\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\tif (ret > 0) {\n\t\t/* there are no items in the tree for us to truncate, we're\n\t\t * done\n\t\t */\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\n\twhile (1) {\n\t\tfi = NULL;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tfound_type = found_key.type;\n\n\t\tif (found_key.objectid != ino)\n\t\t\tbreak;\n\n\t\tif (found_type < min_type)\n\t\t\tbreak;\n\n\t\titem_end = found_key.offset;\n\t\tif (found_type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\t\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\titem_end +=\n\t\t\t\t    btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\titem_end += btrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t\t path->slots[0], fi);\n\t\t\t}\n\t\t\titem_end--;\n\t\t}\n\t\tif (found_type > min_type) {\n\t\t\tdel_item = 1;\n\t\t} else {\n\t\t\tif (item_end < new_size)\n\t\t\t\tbreak;\n\t\t\tif (found_key.offset >= new_size)\n\t\t\t\tdel_item = 1;\n\t\t\telse\n\t\t\t\tdel_item = 0;\n\t\t}\n\t\tfound_extent = 0;\n\t\t/* FIXME, shrink the extent if the ref count is only 1 */\n\t\tif (found_type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto delete;\n\n\t\tif (del_item)\n\t\t\tlast_size = found_key.offset;\n\t\telse\n\t\t\tlast_size = new_size;\n\n\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tu64 num_dec;\n\t\t\textent_start = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tif (!del_item) {\n\t\t\t\tu64 orig_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\textent_num_bytes = ALIGN(new_size -\n\t\t\t\t\t\tfound_key.offset,\n\t\t\t\t\t\troot->sectorsize);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\t extent_num_bytes);\n\t\t\t\tnum_dec = (orig_num_bytes -\n\t\t\t\t\t   extent_num_bytes);\n\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t     &root->state) &&\n\t\t\t\t    extent_start != 0)\n\t\t\t\t\tinode_sub_bytes(inode, num_dec);\n\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t} else {\n\t\t\t\textent_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t\t fi);\n\t\t\t\textent_offset = found_key.offset -\n\t\t\t\t\tbtrfs_file_extent_offset(leaf, fi);\n\n\t\t\t\t/* FIXME blocksize != 4096 */\n\t\t\t\tnum_dec = btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\tif (extent_start != 0) {\n\t\t\t\t\tfound_extent = 1;\n\t\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t\t     &root->state))\n\t\t\t\t\t\tinode_sub_bytes(inode, num_dec);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t/*\n\t\t\t * we can't truncate inline items that have had\n\t\t\t * special encodings\n\t\t\t */\n\t\t\tif (!del_item &&\n\t\t\t    btrfs_file_extent_compression(leaf, fi) == 0 &&\n\t\t\t    btrfs_file_extent_encryption(leaf, fi) == 0 &&\n\t\t\t    btrfs_file_extent_other_encoding(leaf, fi) == 0) {\n\t\t\t\tu32 size = new_size - found_key.offset;\n\n\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\t\t\t\tinode_sub_bytes(inode, item_end + 1 -\n\t\t\t\t\t\t\tnew_size);\n\n\t\t\t\t/*\n\t\t\t\t * update the ram bytes to properly reflect\n\t\t\t\t * the new size of our item\n\t\t\t\t */\n\t\t\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\t\t\t\tsize =\n\t\t\t\t    btrfs_file_extent_calc_inline_size(size);\n\t\t\t\tbtrfs_truncate_item(root, path, size, 1);\n\t\t\t} else if (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t    &root->state)) {\n\t\t\t\tinode_sub_bytes(inode, item_end + 1 -\n\t\t\t\t\t\tfound_key.offset);\n\t\t\t}\n\t\t}\ndelete:\n\t\tif (del_item) {\n\t\t\tif (!pending_del_nr) {\n\t\t\t\t/* no pending yet, add ourselves */\n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t\tpending_del_nr = 1;\n\t\t\t} else if (pending_del_nr &&\n\t\t\t\t   path->slots[0] + 1 == pending_del_slot) {\n\t\t\t\t/* hop on the pending chunk */\n\t\t\t\tpending_del_nr++;\n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t} else {\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tif (found_extent &&\n\t\t    (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t     root == root->fs_info->tree_root)) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_free_extent(trans, root, extent_start,\n\t\t\t\t\t\textent_num_bytes, 0,\n\t\t\t\t\t\tbtrfs_header_owner(leaf),\n\t\t\t\t\t\tino, extent_offset, 0);\n\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tif (found_type == BTRFS_INODE_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tif (path->slots[0] == 0 ||\n\t\t    path->slots[0] != pending_del_slot) {\n\t\t\tif (pending_del_nr) {\n\t\t\t\tret = btrfs_del_items(trans, root, path,\n\t\t\t\t\t\tpending_del_slot,\n\t\t\t\t\t\tpending_del_nr);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tpending_del_nr = 0;\n\t\t\t}\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto search_again;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t}\nout:\n\tif (pending_del_nr) {\n\t\tret = btrfs_del_items(trans, root, path, pending_del_slot,\n\t\t\t\t      pending_del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\nerror:\n\tif (last_size != (u64)-1 &&\n\t    root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\tbtrfs_ordered_update_i_size(inode, last_size, NULL);\n\tbtrfs_free_path(path);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "0"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_i_size_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint btrfs_truncate_free_space_cache(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_trans_handle *trans,\n\t\t\t\t    struct inode *inode)\n{\n\tint ret = 0;\n\n\tbtrfs_i_size_write(inode, 0);\n\ttruncate_pagecache(inode, 0);\n\n\t/*\n\t * We don't need an orphan item because truncating the free space cache\n\t * will never be split across transactions.\n\t */\n\tret = btrfs_truncate_inode_items(trans, root, inode,\n\t\t\t\t\t 0, BTRFS_EXTENT_DATA_KEY);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_check_trunc_cache_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "207-224",
    "snippet": "int btrfs_check_trunc_cache_free_space(struct btrfs_root *root,\n\t\t\t\t       struct btrfs_block_rsv *rsv)\n{\n\tu64 needed_bytes;\n\tint ret;\n\n\t/* 1 for slack space, 1 for updating the inode */\n\tneeded_bytes = btrfs_calc_trunc_metadata_size(root, 1) +\n\t\tbtrfs_calc_trans_metadata_size(root, 1);\n\n\tspin_lock(&rsv->lock);\n\tif (rsv->reserved < needed_bytes)\n\t\tret = -ENOSPC;\n\telse\n\t\tret = 0;\n\tspin_unlock(&rsv->lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rsv->lock"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rsv->lock"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_calc_trans_metadata_size",
          "args": [
            "root",
            "1"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_calc_trans_metadata_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3298-3303",
          "snippet": "static inline u64 btrfs_calc_trans_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn (root->nodesize + root->nodesize * (BTRFS_MAX_LEVEL - 1)) *\n\t\t2 * num_items;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_MAX_LEVEL 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_MAX_LEVEL 8\n\nstatic inline u64 btrfs_calc_trans_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn (root->nodesize + root->nodesize * (BTRFS_MAX_LEVEL - 1)) *\n\t\t2 * num_items;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_calc_trunc_metadata_size",
          "args": [
            "root",
            "1"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_calc_trunc_metadata_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3309-3313",
          "snippet": "static inline u64 btrfs_calc_trunc_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn root->nodesize * BTRFS_MAX_LEVEL * num_items;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_MAX_LEVEL 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_MAX_LEVEL 8\n\nstatic inline u64 btrfs_calc_trunc_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn root->nodesize * BTRFS_MAX_LEVEL * num_items;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint btrfs_check_trunc_cache_free_space(struct btrfs_root *root,\n\t\t\t\t       struct btrfs_block_rsv *rsv)\n{\n\tu64 needed_bytes;\n\tint ret;\n\n\t/* 1 for slack space, 1 for updating the inode */\n\tneeded_bytes = btrfs_calc_trunc_metadata_size(root, 1) +\n\t\tbtrfs_calc_trans_metadata_size(root, 1);\n\n\tspin_lock(&rsv->lock);\n\tif (rsv->reserved < needed_bytes)\n\t\tret = -ENOSPC;\n\telse\n\t\tret = 0;\n\tspin_unlock(&rsv->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "create_free_space_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "191-205",
    "snippet": "int create_free_space_inode(struct btrfs_root *root,\n\t\t\t    struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_block_group_cache *block_group,\n\t\t\t    struct btrfs_path *path)\n{\n\tint ret;\n\tu64 ino;\n\n\tret = btrfs_find_free_objectid(root, &ino);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn __create_free_space_inode(root, trans, path, ino,\n\t\t\t\t\t block_group->key.objectid);\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__create_free_space_inode",
          "args": [
            "root",
            "trans",
            "path",
            "ino",
            "block_group->key.objectid"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "__create_free_space_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "130-189",
          "snippet": "static int __create_free_space_inode(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     u64 ino, u64 offset)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_free_space_header *header;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tu64 flags = BTRFS_INODE_NOCOMPRESS | BTRFS_INODE_PREALLOC;\n\tint ret;\n\n\tret = btrfs_insert_empty_inode(trans, root, path, ino);\n\tif (ret)\n\t\treturn ret;\n\n\t/* We inline crc's for the free disk space cache */\n\tif (ino != BTRFS_FREE_INO_OBJECTID)\n\t\tflags |= BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tleaf = path->nodes[0];\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\tbtrfs_item_key(leaf, &disk_key, path->slots[0]);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)inode_item,\n\t\t\t     sizeof(*inode_item));\n\tbtrfs_set_inode_generation(leaf, inode_item, trans->transid);\n\tbtrfs_set_inode_size(leaf, inode_item, 0);\n\tbtrfs_set_inode_nbytes(leaf, inode_item, 0);\n\tbtrfs_set_inode_uid(leaf, inode_item, 0);\n\tbtrfs_set_inode_gid(leaf, inode_item, 0);\n\tbtrfs_set_inode_mode(leaf, inode_item, S_IFREG | 0600);\n\tbtrfs_set_inode_flags(leaf, inode_item, flags);\n\tbtrfs_set_inode_nlink(leaf, inode_item, 1);\n\tbtrfs_set_inode_transid(leaf, inode_item, trans->transid);\n\tbtrfs_set_inode_block_group(leaf, inode_item, offset);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(struct btrfs_free_space_header));\n\tif (ret < 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn ret;\n\t}\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)header, sizeof(*header));\n\tbtrfs_set_free_space_key(leaf, header, &disk_key);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int __create_free_space_inode(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     u64 ino, u64 offset)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_free_space_header *header;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tu64 flags = BTRFS_INODE_NOCOMPRESS | BTRFS_INODE_PREALLOC;\n\tint ret;\n\n\tret = btrfs_insert_empty_inode(trans, root, path, ino);\n\tif (ret)\n\t\treturn ret;\n\n\t/* We inline crc's for the free disk space cache */\n\tif (ino != BTRFS_FREE_INO_OBJECTID)\n\t\tflags |= BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tleaf = path->nodes[0];\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\tbtrfs_item_key(leaf, &disk_key, path->slots[0]);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)inode_item,\n\t\t\t     sizeof(*inode_item));\n\tbtrfs_set_inode_generation(leaf, inode_item, trans->transid);\n\tbtrfs_set_inode_size(leaf, inode_item, 0);\n\tbtrfs_set_inode_nbytes(leaf, inode_item, 0);\n\tbtrfs_set_inode_uid(leaf, inode_item, 0);\n\tbtrfs_set_inode_gid(leaf, inode_item, 0);\n\tbtrfs_set_inode_mode(leaf, inode_item, S_IFREG | 0600);\n\tbtrfs_set_inode_flags(leaf, inode_item, flags);\n\tbtrfs_set_inode_nlink(leaf, inode_item, 1);\n\tbtrfs_set_inode_transid(leaf, inode_item, trans->transid);\n\tbtrfs_set_inode_block_group(leaf, inode_item, offset);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(struct btrfs_free_space_header));\n\tif (ret < 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn ret;\n\t}\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)header, sizeof(*header));\n\tbtrfs_set_free_space_key(leaf, header, &disk_key);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_free_objectid",
          "args": [
            "root",
            "&ino"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_free_objectid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
          "lines": "546-568",
          "snippet": "int btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nint btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint create_free_space_inode(struct btrfs_root *root,\n\t\t\t    struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_block_group_cache *block_group,\n\t\t\t    struct btrfs_path *path)\n{\n\tint ret;\n\tu64 ino;\n\n\tret = btrfs_find_free_objectid(root, &ino);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn __create_free_space_inode(root, trans, path, ino,\n\t\t\t\t\t block_group->key.objectid);\n}"
  },
  {
    "function_name": "__create_free_space_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "130-189",
    "snippet": "static int __create_free_space_inode(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     u64 ino, u64 offset)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_free_space_header *header;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tu64 flags = BTRFS_INODE_NOCOMPRESS | BTRFS_INODE_PREALLOC;\n\tint ret;\n\n\tret = btrfs_insert_empty_inode(trans, root, path, ino);\n\tif (ret)\n\t\treturn ret;\n\n\t/* We inline crc's for the free disk space cache */\n\tif (ino != BTRFS_FREE_INO_OBJECTID)\n\t\tflags |= BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tleaf = path->nodes[0];\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\tbtrfs_item_key(leaf, &disk_key, path->slots[0]);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)inode_item,\n\t\t\t     sizeof(*inode_item));\n\tbtrfs_set_inode_generation(leaf, inode_item, trans->transid);\n\tbtrfs_set_inode_size(leaf, inode_item, 0);\n\tbtrfs_set_inode_nbytes(leaf, inode_item, 0);\n\tbtrfs_set_inode_uid(leaf, inode_item, 0);\n\tbtrfs_set_inode_gid(leaf, inode_item, 0);\n\tbtrfs_set_inode_mode(leaf, inode_item, S_IFREG | 0600);\n\tbtrfs_set_inode_flags(leaf, inode_item, flags);\n\tbtrfs_set_inode_nlink(leaf, inode_item, 1);\n\tbtrfs_set_inode_transid(leaf, inode_item, trans->transid);\n\tbtrfs_set_inode_block_group(leaf, inode_item, offset);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(struct btrfs_free_space_header));\n\tif (ret < 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn ret;\n\t}\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)header, sizeof(*header));\n\tbtrfs_set_free_space_key(leaf, header, &disk_key);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_free_space_key",
          "args": [
            "leaf",
            "header",
            "&disk_key"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_free_space_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2718-2723",
          "snippet": "static inline void btrfs_set_free_space_key(struct extent_buffer *eb,\n\t\t\t\t\t    struct btrfs_free_space_header *h,\n\t\t\t\t\t    struct btrfs_disk_key *key)\n{\n\twrite_eb_member(eb, h, struct btrfs_free_space_header, location, key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_free_space_key(struct extent_buffer *eb,\n\t\t\t\t\t    struct btrfs_free_space_header *h,\n\t\t\t\t\t    struct btrfs_disk_key *key)\n{\n\twrite_eb_member(eb, h, struct btrfs_free_space_header, location, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset_extent_buffer",
          "args": [
            "leaf",
            "0",
            "(unsigned long)header",
            "sizeof(*header)"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "memset_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5387-5414",
          "snippet": "void memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_free_space_header"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "root",
            "path",
            "&key",
            "sizeof(struct btrfs_free_space_header)"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_block_group",
          "args": [
            "leaf",
            "inode_item",
            "offset"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_transid",
          "args": [
            "leaf",
            "inode_item",
            "trans->transid"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_nlink",
          "args": [
            "leaf",
            "inode_item",
            "1"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_flags",
          "args": [
            "leaf",
            "inode_item",
            "flags"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_mode",
          "args": [
            "leaf",
            "inode_item",
            "S_IFREG | 0600"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_gid",
          "args": [
            "leaf",
            "inode_item",
            "0"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_uid",
          "args": [
            "leaf",
            "inode_item",
            "0"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_nbytes",
          "args": [
            "leaf",
            "inode_item",
            "0"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_size",
          "args": [
            "leaf",
            "inode_item",
            "0"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_generation",
          "args": [
            "leaf",
            "inode_item",
            "trans->transid"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key",
          "args": [
            "leaf",
            "&disk_key",
            "path->slots[0]"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_inode_item"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_inode",
          "args": [
            "trans",
            "root",
            "path",
            "ino"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-item.c",
          "lines": "401-414",
          "snippet": "int btrfs_insert_empty_inode(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(struct btrfs_inode_item));\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_insert_empty_inode(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(struct btrfs_inode_item));\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int __create_free_space_inode(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     u64 ino, u64 offset)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_free_space_header *header;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tu64 flags = BTRFS_INODE_NOCOMPRESS | BTRFS_INODE_PREALLOC;\n\tint ret;\n\n\tret = btrfs_insert_empty_inode(trans, root, path, ino);\n\tif (ret)\n\t\treturn ret;\n\n\t/* We inline crc's for the free disk space cache */\n\tif (ino != BTRFS_FREE_INO_OBJECTID)\n\t\tflags |= BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tleaf = path->nodes[0];\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\tbtrfs_item_key(leaf, &disk_key, path->slots[0]);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)inode_item,\n\t\t\t     sizeof(*inode_item));\n\tbtrfs_set_inode_generation(leaf, inode_item, trans->transid);\n\tbtrfs_set_inode_size(leaf, inode_item, 0);\n\tbtrfs_set_inode_nbytes(leaf, inode_item, 0);\n\tbtrfs_set_inode_uid(leaf, inode_item, 0);\n\tbtrfs_set_inode_gid(leaf, inode_item, 0);\n\tbtrfs_set_inode_mode(leaf, inode_item, S_IFREG | 0600);\n\tbtrfs_set_inode_flags(leaf, inode_item, flags);\n\tbtrfs_set_inode_nlink(leaf, inode_item, 1);\n\tbtrfs_set_inode_transid(leaf, inode_item, trans->transid);\n\tbtrfs_set_inode_block_group(leaf, inode_item, offset);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(struct btrfs_free_space_header));\n\tif (ret < 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn ret;\n\t}\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)header, sizeof(*header));\n\tbtrfs_set_free_space_key(leaf, header, &disk_key);\n\tbtrfs_mark_buffer_dirty(leaf);\n\tbtrfs_release_path(path);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lookup_free_space_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "93-128",
    "snippet": "struct inode *lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_group_cache\n\t\t\t\t      *block_group, struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\tu32 flags = BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->inode)\n\t\tinode = igrab(block_group->inode);\n\tspin_unlock(&block_group->lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path,\n\t\t\t\t\t  block_group->key.objectid);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&block_group->lock);\n\tif (!((BTRFS_I(inode)->flags & flags) == flags)) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t\"Old style space inode found, converting.\");\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATASUM |\n\t\t\tBTRFS_INODE_NODATACOW;\n\t\tblock_group->disk_cache_state = BTRFS_DC_CLEAR;\n\t}\n\n\tif (!block_group->iref) {\n\t\tblock_group->inode = igrab(inode);\n\t\tblock_group->iref = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&block_group->lock"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"Old style space inode found, converting.\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&block_group->lock"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lookup_free_space_inode",
          "args": [
            "root",
            "path",
            "block_group->key.objectid"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_free_space_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "46-91",
          "snippet": "static struct inode *__lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t\t       u64 offset)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key location;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tstruct inode *inode = NULL;\n\tint ret;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tbtrfs_free_space_key(leaf, header, &disk_key);\n\tbtrfs_disk_key_to_cpu(&location, &disk_key);\n\tbtrfs_release_path(path);\n\n\tinode = btrfs_iget(root->fs_info->sb, &location, root, NULL);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\tmapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic struct inode *__lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t\t       u64 offset)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key location;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tstruct inode *inode = NULL;\n\tint ret;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tbtrfs_free_space_key(leaf, header, &disk_key);\n\tbtrfs_disk_key_to_cpu(&location, &disk_key);\n\tbtrfs_release_path(path);\n\n\tinode = btrfs_iget(root->fs_info->sb, &location, root, NULL);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\tmapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstruct inode *lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_group_cache\n\t\t\t\t      *block_group, struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\tu32 flags = BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->inode)\n\t\tinode = igrab(block_group->inode);\n\tspin_unlock(&block_group->lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path,\n\t\t\t\t\t  block_group->key.objectid);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&block_group->lock);\n\tif (!((BTRFS_I(inode)->flags & flags) == flags)) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t\"Old style space inode found, converting.\");\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATASUM |\n\t\t\tBTRFS_INODE_NODATACOW;\n\t\tblock_group->disk_cache_state = BTRFS_DC_CLEAR;\n\t}\n\n\tif (!block_group->iref) {\n\t\tblock_group->inode = igrab(inode);\n\t\tblock_group->iref = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "__lookup_free_space_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
    "lines": "46-91",
    "snippet": "static struct inode *__lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t\t       u64 offset)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key location;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tstruct inode *inode = NULL;\n\tint ret;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tbtrfs_free_space_key(leaf, header, &disk_key);\n\tbtrfs_disk_key_to_cpu(&location, &disk_key);\n\tbtrfs_release_path(path);\n\n\tinode = btrfs_iget(root->fs_info->sb, &location, root, NULL);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\tmapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"extent_io.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"ctree.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/math64.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "inode->i_mapping",
            "mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "inode->i_mapping"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_iget",
          "args": [
            "root->fs_info->sb",
            "&location",
            "root",
            "NULL"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5312-5336",
          "snippet": "struct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_to_cpu",
          "args": [
            "&location",
            "&disk_key"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_disk_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2731-2737",
          "snippet": "static inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_space_key",
          "args": [
            "leaf",
            "header",
            "&disk_key"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_space_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2711-2716",
          "snippet": "static inline void btrfs_free_space_key(struct extent_buffer *eb,\n\t\t\t\t\tstruct btrfs_free_space_header *h,\n\t\t\t\t\tstruct btrfs_disk_key *key)\n{\n\tread_eb_member(eb, h, struct btrfs_free_space_header, location, key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_free_space_key(struct extent_buffer *eb,\n\t\t\t\t\tstruct btrfs_free_space_header *h,\n\t\t\t\t\tstruct btrfs_disk_key *key)\n{\n\tread_eb_member(eb, h, struct btrfs_free_space_header, location, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_free_space_header"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic struct inode *__lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t\t       u64 offset)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key location;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_free_space_header *header;\n\tstruct extent_buffer *leaf;\n\tstruct inode *inode = NULL;\n\tint ret;\n\n\tkey.objectid = BTRFS_FREE_SPACE_OBJECTID;\n\tkey.offset = offset;\n\tkey.type = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tleaf = path->nodes[0];\n\theader = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\tstruct btrfs_free_space_header);\n\tbtrfs_free_space_key(leaf, header, &disk_key);\n\tbtrfs_disk_key_to_cpu(&location, &disk_key);\n\tbtrfs_release_path(path);\n\n\tinode = btrfs_iget(root->fs_info->sb, &location, root, NULL);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\tmapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n\n\treturn inode;\n}"
  }
]