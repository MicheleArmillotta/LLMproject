[
  {
    "function_name": "cachefiles_cook_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/key.c",
    "lines": "37-159",
    "snippet": "char *cachefiles_cook_key(const u8 *raw, int keylen, uint8_t type)\n{\n\tunsigned char csum, ch;\n\tunsigned int acc;\n\tchar *key;\n\tint loop, len, max, seg, mark, print;\n\n\t_enter(\",%d\", keylen);\n\n\tBUG_ON(keylen < 2 || keylen > 514);\n\n\tcsum = raw[0] + raw[1];\n\tprint = 1;\n\tfor (loop = 2; loop < keylen; loop++) {\n\t\tch = raw[loop];\n\t\tcsum += ch;\n\t\tprint &= cachefiles_filecharmap[ch];\n\t}\n\n\tif (print) {\n\t\t/* if the path is usable ASCII, then we render it directly */\n\t\tmax = keylen - 2;\n\t\tmax += 2;\t/* two base64'd length chars on the front */\n\t\tmax += 5;\t/* @checksum/M */\n\t\tmax += 3 * 2;\t/* maximum number of segment dividers (\".../M\")\n\t\t\t\t * is ((514 + 251) / 252) = 3\n\t\t\t\t */\n\t\tmax += 1;\t/* NUL on end */\n\t} else {\n\t\t/* calculate the maximum length of the cooked key */\n\t\tkeylen = (keylen + 2) / 3;\n\n\t\tmax = keylen * 4;\n\t\tmax += 5;\t/* @checksum/M */\n\t\tmax += 3 * 2;\t/* maximum number of segment dividers (\".../M\")\n\t\t\t\t * is ((514 + 188) / 189) = 3\n\t\t\t\t */\n\t\tmax += 1;\t/* NUL on end */\n\t}\n\n\tmax += 1;\t/* 2nd NUL on end */\n\n\t_debug(\"max: %d\", max);\n\n\tkey = kmalloc(max, cachefiles_gfp);\n\tif (!key)\n\t\treturn NULL;\n\n\tlen = 0;\n\n\t/* build the cooked key */\n\tsprintf(key, \"@%02x%c+\", (unsigned) csum, 0);\n\tlen = 5;\n\tmark = len - 1;\n\n\tif (print) {\n\t\tacc = *(uint16_t *) raw;\n\t\traw += 2;\n\n\t\tkey[len + 1] = cachefiles_charmap[acc & 63];\n\t\tacc >>= 6;\n\t\tkey[len] = cachefiles_charmap[acc & 63];\n\t\tlen += 2;\n\n\t\tseg = 250;\n\t\tfor (loop = keylen; loop > 0; loop--) {\n\t\t\tif (seg <= 0) {\n\t\t\t\tkey[len++] = '\\0';\n\t\t\t\tmark = len;\n\t\t\t\tkey[len++] = '+';\n\t\t\t\tseg = 252;\n\t\t\t}\n\n\t\t\tkey[len++] = *raw++;\n\t\t\tASSERT(len < max);\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase FSCACHE_COOKIE_TYPE_INDEX:\t\ttype = 'I';\tbreak;\n\t\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\ttype = 'D';\tbreak;\n\t\tdefault:\t\t\t\ttype = 'S';\tbreak;\n\t\t}\n\t} else {\n\t\tseg = 252;\n\t\tfor (loop = keylen; loop > 0; loop--) {\n\t\t\tif (seg <= 0) {\n\t\t\t\tkey[len++] = '\\0';\n\t\t\t\tmark = len;\n\t\t\t\tkey[len++] = '+';\n\t\t\t\tseg = 252;\n\t\t\t}\n\n\t\t\tacc = *raw++;\n\t\t\tacc |= *raw++ << 8;\n\t\t\tacc |= *raw++ << 16;\n\n\t\t\t_debug(\"acc: %06x\", acc);\n\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\t\t\tacc >>= 6;\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\t\t\tacc >>= 6;\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\t\t\tacc >>= 6;\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\n\t\t\tASSERT(len < max);\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase FSCACHE_COOKIE_TYPE_INDEX:\t\ttype = 'J';\tbreak;\n\t\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\ttype = 'E';\tbreak;\n\t\tdefault:\t\t\t\ttype = 'T';\tbreak;\n\t\t}\n\t}\n\n\tkey[mark] = type;\n\tkey[len++] = 0;\n\tkey[len] = 0;\n\n\t_leave(\" = %p %d\", key, len);\n\treturn key;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char cachefiles_charmap[64] =\n\t\"0123456789\"\t\t\t/* 0 - 9 */\n\t\"abcdefghijklmnopqrstuvwxyz\"\t/* 10 - 35 */\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\t/* 36 - 61 */\n\t\"_-\"\t\t\t\t/* 62 - 63 */\n\t;",
      "static const char cachefiles_filecharmap[256] = {\n\t/* we skip space and tab and control chars */\n\t[33 ... 46] = 1,\t\t/* '!' -> '.' */\n\t/* we skip '/' as it's significant to pathwalk */\n\t[48 ... 127] = 1,\t\t/* '0' -> '~' */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %p %d\"",
            "key",
            "len"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len < max"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"acc: %06x\"",
            "acc"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "602-619",
          "snippet": "static int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len < max"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "key",
            "\"@%02x%c+\"",
            "(unsigned) csum",
            "0"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1609-1628",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "max",
            "cachefiles_gfp"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "keylen < 2 || keylen > 514"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%d\"",
            "keylen"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n\nstatic const char cachefiles_charmap[64] =\n\t\"0123456789\"\t\t\t/* 0 - 9 */\n\t\"abcdefghijklmnopqrstuvwxyz\"\t/* 10 - 35 */\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\t/* 36 - 61 */\n\t\"_-\"\t\t\t\t/* 62 - 63 */\n\t;\nstatic const char cachefiles_filecharmap[256] = {\n\t/* we skip space and tab and control chars */\n\t[33 ... 46] = 1,\t\t/* '!' -> '.' */\n\t/* we skip '/' as it's significant to pathwalk */\n\t[48 ... 127] = 1,\t\t/* '0' -> '~' */\n};\n\nchar *cachefiles_cook_key(const u8 *raw, int keylen, uint8_t type)\n{\n\tunsigned char csum, ch;\n\tunsigned int acc;\n\tchar *key;\n\tint loop, len, max, seg, mark, print;\n\n\t_enter(\",%d\", keylen);\n\n\tBUG_ON(keylen < 2 || keylen > 514);\n\n\tcsum = raw[0] + raw[1];\n\tprint = 1;\n\tfor (loop = 2; loop < keylen; loop++) {\n\t\tch = raw[loop];\n\t\tcsum += ch;\n\t\tprint &= cachefiles_filecharmap[ch];\n\t}\n\n\tif (print) {\n\t\t/* if the path is usable ASCII, then we render it directly */\n\t\tmax = keylen - 2;\n\t\tmax += 2;\t/* two base64'd length chars on the front */\n\t\tmax += 5;\t/* @checksum/M */\n\t\tmax += 3 * 2;\t/* maximum number of segment dividers (\".../M\")\n\t\t\t\t * is ((514 + 251) / 252) = 3\n\t\t\t\t */\n\t\tmax += 1;\t/* NUL on end */\n\t} else {\n\t\t/* calculate the maximum length of the cooked key */\n\t\tkeylen = (keylen + 2) / 3;\n\n\t\tmax = keylen * 4;\n\t\tmax += 5;\t/* @checksum/M */\n\t\tmax += 3 * 2;\t/* maximum number of segment dividers (\".../M\")\n\t\t\t\t * is ((514 + 188) / 189) = 3\n\t\t\t\t */\n\t\tmax += 1;\t/* NUL on end */\n\t}\n\n\tmax += 1;\t/* 2nd NUL on end */\n\n\t_debug(\"max: %d\", max);\n\n\tkey = kmalloc(max, cachefiles_gfp);\n\tif (!key)\n\t\treturn NULL;\n\n\tlen = 0;\n\n\t/* build the cooked key */\n\tsprintf(key, \"@%02x%c+\", (unsigned) csum, 0);\n\tlen = 5;\n\tmark = len - 1;\n\n\tif (print) {\n\t\tacc = *(uint16_t *) raw;\n\t\traw += 2;\n\n\t\tkey[len + 1] = cachefiles_charmap[acc & 63];\n\t\tacc >>= 6;\n\t\tkey[len] = cachefiles_charmap[acc & 63];\n\t\tlen += 2;\n\n\t\tseg = 250;\n\t\tfor (loop = keylen; loop > 0; loop--) {\n\t\t\tif (seg <= 0) {\n\t\t\t\tkey[len++] = '\\0';\n\t\t\t\tmark = len;\n\t\t\t\tkey[len++] = '+';\n\t\t\t\tseg = 252;\n\t\t\t}\n\n\t\t\tkey[len++] = *raw++;\n\t\t\tASSERT(len < max);\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase FSCACHE_COOKIE_TYPE_INDEX:\t\ttype = 'I';\tbreak;\n\t\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\ttype = 'D';\tbreak;\n\t\tdefault:\t\t\t\ttype = 'S';\tbreak;\n\t\t}\n\t} else {\n\t\tseg = 252;\n\t\tfor (loop = keylen; loop > 0; loop--) {\n\t\t\tif (seg <= 0) {\n\t\t\t\tkey[len++] = '\\0';\n\t\t\t\tmark = len;\n\t\t\t\tkey[len++] = '+';\n\t\t\t\tseg = 252;\n\t\t\t}\n\n\t\t\tacc = *raw++;\n\t\t\tacc |= *raw++ << 8;\n\t\t\tacc |= *raw++ << 16;\n\n\t\t\t_debug(\"acc: %06x\", acc);\n\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\t\t\tacc >>= 6;\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\t\t\tacc >>= 6;\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\t\t\tacc >>= 6;\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\n\t\t\tASSERT(len < max);\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase FSCACHE_COOKIE_TYPE_INDEX:\t\ttype = 'J';\tbreak;\n\t\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\ttype = 'E';\tbreak;\n\t\tdefault:\t\t\t\ttype = 'T';\tbreak;\n\t\t}\n\t}\n\n\tkey[mark] = type;\n\tkey[len++] = 0;\n\tkey[len] = 0;\n\n\t_leave(\" = %p %d\", key, len);\n\treturn key;\n}"
  }
]