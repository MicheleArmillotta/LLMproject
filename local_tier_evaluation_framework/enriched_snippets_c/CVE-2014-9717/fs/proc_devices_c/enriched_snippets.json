[
  {
    "function_name": "proc_devices_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/devices.c",
    "lines": "65-69",
    "snippet": "static int __init proc_devices_init(void)\n{\n\tproc_create(\"devices\", 0, NULL, &proc_devinfo_operations);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations proc_devinfo_operations = {\n\t.open\t\t= devinfo_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"devices\"",
            "0",
            "NULL",
            "&proc_devinfo_operations"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "__proc_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "355-391",
          "snippet": "static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations proc_devinfo_operations = {\n\t.open\t\t= devinfo_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic int __init proc_devices_init(void)\n{\n\tproc_create(\"devices\", 0, NULL, &proc_devinfo_operations);\n\treturn 0;\n}"
  },
  {
    "function_name": "devinfo_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/devices.c",
    "lines": "53-56",
    "snippet": "static int devinfo_open(struct inode *inode, struct file *filp)\n{\n\treturn seq_open(filp, &devinfo_ops);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations devinfo_ops = {\n\t.start = devinfo_start,\n\t.next  = devinfo_next,\n\t.stop  = devinfo_stop,\n\t.show  = devinfo_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "filp",
            "&devinfo_ops"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic const struct seq_operations devinfo_ops = {\n\t.start = devinfo_start,\n\t.next  = devinfo_next,\n\t.stop  = devinfo_stop,\n\t.show  = devinfo_show\n};\n\nstatic int devinfo_open(struct inode *inode, struct file *filp)\n{\n\treturn seq_open(filp, &devinfo_ops);\n}"
  },
  {
    "function_name": "devinfo_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/devices.c",
    "lines": "41-44",
    "snippet": "static void devinfo_stop(struct seq_file *f, void *v)\n{\n\t/* Nothing to do */\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic void devinfo_stop(struct seq_file *f, void *v)\n{\n\t/* Nothing to do */\n}"
  },
  {
    "function_name": "devinfo_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/devices.c",
    "lines": "33-39",
    "snippet": "static void *devinfo_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\tif (*pos >= (BLKDEV_MAJOR_HASH_SIZE + CHRDEV_MAJOR_HASH_SIZE))\n\t\treturn NULL;\n\treturn pos;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic void *devinfo_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\tif (*pos >= (BLKDEV_MAJOR_HASH_SIZE + CHRDEV_MAJOR_HASH_SIZE))\n\t\treturn NULL;\n\treturn pos;\n}"
  },
  {
    "function_name": "devinfo_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/devices.c",
    "lines": "26-31",
    "snippet": "static void *devinfo_start(struct seq_file *f, loff_t *pos)\n{\n\tif (*pos < (BLKDEV_MAJOR_HASH_SIZE + CHRDEV_MAJOR_HASH_SIZE))\n\t\treturn pos;\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic void *devinfo_start(struct seq_file *f, loff_t *pos)\n{\n\tif (*pos < (BLKDEV_MAJOR_HASH_SIZE + CHRDEV_MAJOR_HASH_SIZE))\n\t\treturn pos;\n\treturn NULL;\n}"
  },
  {
    "function_name": "devinfo_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/devices.c",
    "lines": "6-24",
    "snippet": "static int devinfo_show(struct seq_file *f, void *v)\n{\n\tint i = *(loff_t *) v;\n\n\tif (i < CHRDEV_MAJOR_HASH_SIZE) {\n\t\tif (i == 0)\n\t\t\tseq_puts(f, \"Character devices:\\n\");\n\t\tchrdev_show(f, i);\n\t}\n#ifdef CONFIG_BLOCK\n\telse {\n\t\ti -= CHRDEV_MAJOR_HASH_SIZE;\n\t\tif (i == 0)\n\t\t\tseq_puts(f, \"\\nBlock devices:\\n\");\n\t\tblkdev_show(f, i);\n\t}\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_show",
          "args": [
            "f",
            "i"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "f",
            "\"\\nBlock devices:\\n\""
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chrdev_show",
          "args": [
            "f",
            "i"
          ],
          "line": 13
        },
        "resolved": true,
        "details": {
          "function_name": "chrdev_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "48-58",
          "snippet": "void chrdev_show(struct seq_file *f, off_t offset)\n{\n\tstruct char_device_struct *cd;\n\n\tif (offset < CHRDEV_MAJOR_HASH_SIZE) {\n\t\tmutex_lock(&chrdevs_lock);\n\t\tfor (cd = chrdevs[offset]; cd; cd = cd->next)\n\t\t\tseq_printf(f, \"%3d %s\\n\", cd->major, cd->name);\n\t\tmutex_unlock(&chrdevs_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(chrdevs_lock);",
            "static struct char_device_struct {\n\tstruct char_device_struct *next;\n\tunsigned int major;\n\tunsigned int baseminor;\n\tint minorct;\n\tchar name[64];\n\tstruct cdev *cdev;\t\t/* will die */\n} *chrdevs[CHRDEV_MAJOR_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(chrdevs_lock);\nstatic struct char_device_struct {\n\tstruct char_device_struct *next;\n\tunsigned int major;\n\tunsigned int baseminor;\n\tint minorct;\n\tchar name[64];\n\tstruct cdev *cdev;\t\t/* will die */\n} *chrdevs[CHRDEV_MAJOR_HASH_SIZE];\n\nvoid chrdev_show(struct seq_file *f, off_t offset)\n{\n\tstruct char_device_struct *cd;\n\n\tif (offset < CHRDEV_MAJOR_HASH_SIZE) {\n\t\tmutex_lock(&chrdevs_lock);\n\t\tfor (cd = chrdevs[offset]; cd; cd = cd->next)\n\t\t\tseq_printf(f, \"%3d %s\\n\", cd->major, cd->name);\n\t\tmutex_unlock(&chrdevs_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int devinfo_show(struct seq_file *f, void *v)\n{\n\tint i = *(loff_t *) v;\n\n\tif (i < CHRDEV_MAJOR_HASH_SIZE) {\n\t\tif (i == 0)\n\t\t\tseq_puts(f, \"Character devices:\\n\");\n\t\tchrdev_show(f, i);\n\t}\n#ifdef CONFIG_BLOCK\n\telse {\n\t\ti -= CHRDEV_MAJOR_HASH_SIZE;\n\t\tif (i == 0)\n\t\t\tseq_puts(f, \"\\nBlock devices:\\n\");\n\t\tblkdev_show(f, i);\n\t}\n#endif\n\treturn 0;\n}"
  }
]